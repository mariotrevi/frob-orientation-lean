/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: d4a059c4-fe50-4ea3-97e7-b6c52b31ad13

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We have successfully formalized and proved all 5 requested items to complete the proof that $c(N) \neq 1 \implies f$ is irreducible.

1. `roots_distinct_in_Ok_P_N_eq_3`: Proved the distinctness of roots for the $N=3$ case using the sum-of-products relation.
2. `roots_distinct_in_Ok_P`: Unified the distinctness results for $N=2$, $N=3$, and $N>3$.
3. `no_root_fixed_by_frobenius`: Proved that if $c(N) \neq 1$, the Frobenius automorphism fixes no root.
4. `roots_trichotomy`: Proved that any root of $f$ in $\mathcal{O}_K/P$ must be one of $\bar\alpha, \bar\beta, \bar\gamma$.
5. `c_ne_one_imp_irreducible`: Assembled the final theorem using the trichotomy and the fixed-point lemma.

All declarations are available in the workspace.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 3aa95b40-e745-438d-b61b-52a93279ba79

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 11e5bcda-f90d-44d0-93f2-10b7e059f17d

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
This module proves the Dream Theorem in the cyclotomic field setting, following Approach 2b.
It defines the ring of integers `Okcyc` of the cyclotomic field `Q(ζ_q)` and proves it is generated by `ζ_q` (`Okcyc_eq_adjoin_zeta`).
It establishes the Artin property for the cyclotomic automorphism `σ_N` (`artin_property_cyc`), showing it acts as the Frobenius map modulo primes lying over `N`.
Finally, it proves `dream_theorem_cyclotomic`, which relates the cubic character `c(N)` to the action of the Frobenius on the periods `α`, `β`, `γ`.
Note: The theorem `dream_theorem_cyclotomic` requires the hypothesis `chi q (g_gen q) = s2 q a` to fix the alignment between the generator `g` and the parameter `a`.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 23c4f7f6-6b7f-481e-ba51-363699ad022f

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 155bf696-0c5b-46b0-963a-8f78ba2cd618

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
I have proved the main theorem `final_result_general_clean_no_generalize_v3` without using `generalize_proofs`.
I used a helper lemma `theta_cong_of_equiv` to handle the congruence arithmetic cleanly.
The proof establishes that if `c(N) = s1`, then `theta^N = gamma` modulo `P`, and if `c(N) = s2`, then `theta^N = beta` modulo `P`.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: e3f2d08d-60b0-44d0-9322-b12f5e4b21d8

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
The Dream Theorem for general q.

The proof follows the strategy:
1. Use reciprocity to get Frobenius phi.
2. Show phi(theta) is a root.
3. Show phi(theta) is congruent to s1*theta or s2*theta mod theta^2.
4. Use root_determined_by_congruence to identify phi(theta) as gamma or beta.
5. Use Frobenius property to conclude theta^N = gamma or beta.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 05e2cb05-1446-457a-80de-0420031a0aff

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
I have successfully formalized and proved the Dream Theorem for a general prime q, following the "3-hour clock" strategy and avoiding the explicit construction of the global automorphism sigma.

Key achievements:
1.  **`beta_congruence`**: Proved that $\beta \equiv s_2 \theta \pmod{\theta^2}$ directly from the defining relation, without using $\sigma$.
2.  **`gamma_congruence_proved`**: Derived $\gamma \equiv s_1 \theta \pmod{\theta^2}$ from the beta congruence.
3.  **`roots_distinct_mod_theta_sq_proved`**: Showed that $\theta, \beta, \gamma$ are distinct modulo $\theta^2$ using the congruences and the fact that $s_1, s_2, 1$ are distinct modulo $q$.
4.  **`roots_of_f_in_integers_proved`**: Proved that the roots of $f$ in the ring of integers are exactly $\theta, \beta, \gamma$ by lifting to the field and using `Subtype.ext`.
5.  **`root_determined_by_congruence_proved`**: Established that a root is uniquely determined by its congruence modulo $\theta^2$ (if the coefficient is $s_1$ or $s_2$).
6.  **`final_result_general_proved`**: Proved the main theorem. The Frobenius automorphism $\phi$ maps $\theta$ to a root $x$ such that $x \equiv c \theta \pmod{\theta^2}$. Since $c \in \{s_1, s_2\}$, $x$ is determined to be $\gamma$ or $\beta$ respectively. Thus $\theta^N \equiv \phi(\theta) \equiv \gamma \text{ or } \beta \pmod P$.

The proof assumes `reciprocity_lemma_statement q N`, which encapsulates the reciprocity law (Artin symbol computation) as requested. The development is now clean, robust, and free of the problematic `exists_sigma_global` dependency.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: aecfccff-f723-4b17-ac49-f899990909e3

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We proved the general theorem `final_result_general_v2` which states that under the assumption of the reciprocity lemma, the action of the Frobenius automorphism on the roots of `f(x) = x^3 - qx - q` is determined by the cubic character `c = N^((q-1)/3) mod q`. Specifically, if `c = s1`, then `alpha^N = gamma`, and if `c = s2`, then `alpha^N = beta`. We also proved the specific case for `q=1567` in `main_result_1567_v3` using the provided lemmas for the cyclotomic field `K1567`.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: ae3edc60-ad87-4b13-8d54-85466e537801

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 4d5462ff-36cc-484e-9865-b51f61259608

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 9153febd-f552-4fa4-a095-e66c059a953b

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 8011b3b0-5b9d-44a9-a431-7da2e7415d10

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We have successfully proved the Dream Theorem for the prime $q = 1567$.
The proof follows the structure of prior proofs for $q = 877, 937, 1063, 1129$.
We defined the field $K = \mathbb{Q}(\zeta_{1567})$, the ring of integers $\mathcal{O}_K$, and the Gaussian periods $\eta_0, \eta_1, \eta_2$.
We defined the period differences $\alpha, \beta, \gamma$ with the appropriate sign convention.
We established the algebraic relations between $\alpha, \beta, \gamma$ using the period equation and computation.
We proved the Artin property for the extension $K/\mathbb{Q}$.
We characterized the cosets $C_1, C_2$ using the cubic character $\chi$.
Finally, we proved `final_result_1567`, which states that for a prime $N \neq 1567$, the Frobenius action on $\alpha$ is determined by the value of the cubic character $\chi(N)$.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: ff94a4ce-df04-43b6-855b-2c35922c8831

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We define the cyclotomic field $K = \mathbb{Q}(\zeta_{1129})$, the ring of integers $\mathcal{O}_K$, and the Gaussian periods $\eta_0, \eta_1, \eta_2$. We define the period differences $\alpha, \beta, \gamma$ with the correct sign convention. We prove the Artin property for $\mathcal{O}_K$ and use it to prove the Dream Theorem for $q = 1129$, which relates the Frobenius action on $\alpha$ to the cubic character $c(N)$. The proof assumes the period equation for $\alpha$ as requested.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 49ab742d-7e60-49a0-9635-aa76ebf271b7

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Proof of the Dream Theorem for q = 1063.

We define the cyclotomic field K = Q(zeta_1063), the ring of integers Ok, and the Gaussian periods.
We identify a generator g = 6 such that the cubic character c(g) = s2 = 719.
We define the roots alpha, beta, gamma using this generator and the standard sign convention.
We prove the Artin property for the extension.
We prove the global permutation of roots under the Galois group.
Finally, we prove the Dream Theorem:
If c(N) = s1, then alpha^N = gamma mod P.
If c(N) = s2, then alpha^N = beta mod P.
This relies on the period equation alpha^3 = 1063*alpha + 1063, which is added as a hypothesis.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f1e85200-2efb-4b56-a019-1c5b75f4b05f

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Proof of the Dream Theorem for q = 937.

We define the cyclotomic field K = Q(zeta_937), its ring of integers Ok, and the Gaussian periods.
We identify a generator g = 7 for which the cubic character values match the s1/s2 definitions.
We prove the Artin property for the extension K/Q.
We prove the main theorem `dream_theorem_937` which states that for a prime N != 937:
- If c(N) = s1, then alpha^N = gamma mod P.
- If c(N) = s2, then alpha^N = beta mod P.
This assumes the period equation `alpha^3 = 937*alpha + 937`.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: b08f138a-15ed-40a2-a0c0-b8f4ce6443e1

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We define the cyclotomic field K for q = 877 and the Gaussian periods. We prove the Dream Theorem for q = 877, which states that the Frobenius automorphism maps the period difference α to β or γ depending on the cubic character of the prime N modulo 877. The proof relies on the Artin property of the Frobenius map and the explicit calculation of the Galois action on the periods.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f1f9f2e4-1b7a-4d8c-ad24-d62d489ea7c9

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: a7add749-96ca-48e2-a89d-fbb216918bc3

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 22a1ac83-9054-4f97-9a50-f0ea72bded01

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: e6ee589a-f550-42ef-89e5-1fd2afd7fa5e

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We defined the constants s1, s2, and the value c(N). We proved lemmas characterizing the cosets C1 and C2 in terms of the 12th power residue symbol (which relates to c(N)). Finally, we proved the main theorem `final_result` which establishes the Frobenius action on alpha (i.e., alpha^N) in terms of beta and gamma, depending on the value of c(N). The proof utilizes the `explicit_frobenius` theorem and the algebraic relations between alpha, beta, and gamma.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 939f55fb-68a7-4ef0-bca3-475f675055ca

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
This module formalizes the proof of the Frobenius Orientation conjecture for q=37.
It defines the cyclotomic field K = Q(zeta_37), the Gaussian periods, and the cubic roots.
It proves the cyclic algebraic relations between these roots and establishes the global Galois action.
It descends to the residue field modulo a prime P lying over N != 37, proving the Artin property.
Finally, it derives the explicit Frobenius action on the reduction of alpha modulo P.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section















/-
The residue classes $s_1$ and $s_2$ satisfy $s_1^2 + s_1 + 1 \equiv 0 \pmod{q}$ and $s_2^2 + s_2 + 1 \equiv 0 \pmod{q}$.
-/
def s1 (q : ℕ) (a : ℤ) : ZMod q := ((-a - 3) : ℤ) * (6 : ZMod q)⁻¹

def s2 (q : ℕ) (a : ℤ) : ZMod q := ((a - 3) : ℤ) * (6 : ZMod q)⁻¹

lemma lemma_s1s2 (q : ℕ) [Fact (Nat.Prime q)] (a : ℤ) (h_eq : 4 * (q : ℤ) = a^2 + 27) :
  s1 q a ^ 2 + s1 q a + 1 = 0 ∧ s2 q a ^ 2 + s2 q a + 1 = 0 := by
    -- By definition of $s1$ and $s2$, we know that $s1^2 + s1 + 1 \equiv 0 \pmod{q}$ and $s2^2 + s2 + 1 \equiv 0 \pmod{q}$.
    have h_s1 : (s1 q a : ZMod q) ^ 2 + (s1 q a : ZMod q) + 1 = 0 := by
      have h_s1 : (6 * s1 q a : ZMod q) ^ 2 + 6 * s1 q a * 6 + 6 ^ 2 = 0 := by
        have h_s1 : ((-a - 3) : ZMod q) ^ 2 + (-a - 3) * 6 + 6 ^ 2 = 0 := by
          norm_cast at *;
          erw [ ZMod.intCast_zmod_eq_zero_iff_dvd ] at *;
          exact ⟨ 4, by push_cast at *; linarith ⟩;
        rw [ show s1 q a = ( -a - 3 : ZMod q ) * ( 6 : ZMod q ) ⁻¹ from ?_ ];
        · by_cases h : ( 6 : ZMod q ) = 0 <;> simp_all +decide [ mul_comm, mul_left_comm ];
        · unfold s1;
          norm_num;
      have h_inv : (6 : ZMod q) ≠ 0 := by
        by_contra h_contra;
        erw [ ZMod.natCast_eq_zero_iff ] at h_contra ; have := Nat.le_of_dvd ( by decide ) h_contra ; interval_cases q <;> norm_num at *;
        · exact Nat.not_prime_one Fact.out;
        · nlinarith [ show a ≥ -4 by nlinarith, show a ≤ 4 by nlinarith ];
        · nlinarith [ show a ≤ 3 by nlinarith, show a ≥ -3 by nlinarith ];
        · exact absurd ( Fact.out ( p := Nat.Prime 6 ) ) ( by decide );
      exact mul_left_cancel₀ ( pow_ne_zero 2 h_inv ) ( by linear_combination' h_s1 )
    have h_s2 : (s2 q a : ZMod q) ^ 2 + (s2 q a : ZMod q) + 1 = 0 := by
      convert h_s1 using 1;
      unfold s1 s2;
      grind
    exact ⟨h_s1, h_s2⟩

/-
The discriminant of f(x) = x^3 - qx - q is (qa)^2.
-/
open Polynomial

def f_poly (q : ℤ) : Polynomial ℤ := X^3 - C q * X - C q

lemma disc_f_poly_eq (q : ℤ) (a : ℤ) (h_eq : 4 * q = a^2 + 27) :
  (f_poly q).disc = (q * a)^2 := by
    convert Polynomial.disc_of_degree_eq_three _ using 1;
    · unfold f_poly;
      norm_num [ Polynomial.coeff_eq_zero_of_natDegree_lt ] ; ring;
      linear_combination' -h_eq * q ^ 2;
    · erw [ Polynomial.degree_add_eq_left_of_degree_lt ] <;> erw [ Polynomial.degree_add_eq_left_of_degree_lt ] <;> norm_num;
      · exact lt_of_le_of_lt ( add_le_add_right Polynomial.degree_C_le _ ) ( by norm_num );
      · exact lt_of_le_of_lt Polynomial.degree_C_le ( WithBot.coe_lt_coe.mpr ( by norm_num ) );
      · exact lt_of_le_of_lt ( add_le_add_right Polynomial.degree_C_le _ ) ( by norm_num )

/-
Definitions of f(x) mod N, c, and the relation between alpha and beta.
-/
open Polynomial

def f_mod_N (q : ℕ) (N : ℕ) : Polynomial (ZMod N) := X^3 - C (q : ZMod N) * X - C (q : ZMod N)

def c_value (q : ℕ) (N : ℕ) : ZMod q := (N : ZMod q) ^ ((q - 1) / 3)

def beta_relation (a : ℤ) (q : ℕ) (N : ℕ) {K : Type*} [Field K] [Algebra (ZMod N) K] (alpha beta : K) : Prop :=
  2 * (a : K) * beta = 6 * alpha^2 - (a + 9 : K) * alpha - 4 * (q : K)

/-
Algebraic identity for beta.
-/
lemma beta_poly_identity {R : Type*} [CommRing R] (a q : R) (alpha : R)
  (h_root : alpha^3 = q * alpha + q)
  (h_a2 : a^2 = 4 * q - 27) :
  let B := 6 * alpha^2 - (a + 9) * alpha - 4 * q
  B^3 - 4 * a^2 * q * B - 8 * a^3 * q = 0 := by
    grind

/-
2a is a unit in K.
-/
lemma is_unit_2a (a : ℤ) (N : ℕ) [Fact (Nat.Prime N)] (h_N_odd : Odd N) (h_gcd : Int.gcd a N = 1)
  (K : Type*) [Field K] [Algebra (ZMod N) K] :
  IsUnit (2 * (a : K)) := by
    have h_unit : IsUnit (2 : ZMod N) ∧ IsUnit (a : ZMod N) := by
      constructor;
      · exact isUnit_iff_ne_zero.mpr ( by erw [ Ne.eq_def, ZMod.natCast_eq_zero_iff ] ; exact Nat.not_dvd_of_pos_of_lt Nat.zero_lt_two ( lt_of_le_of_ne ( Nat.Prime.two_le Fact.out ) ( Ne.symm <| by rintro rfl; contradiction ) ) );
      · rw [ isUnit_iff_exists_inv ];
        have := Int.gcd_eq_gcd_ab a N;
        exact ⟨ a.gcdA N, by simpa [ h_gcd ] using congr_arg ( ( ↑ ) : ℤ → ZMod N ) this.symm ⟩;
    convert h_unit.1.map ( algebraMap ( ZMod N ) K ) |> IsUnit.mul <| h_unit.2.map ( algebraMap ( ZMod N ) K ) using 1;
    erw [ map_ofNat, map_intCast ]

/-
(2a)^3 * f(beta) = 0.
-/
lemma beta_scaled_eq_zero (q : ℕ) (a : ℤ) (N : ℕ) [Fact (Nat.Prime N)]
  (K : Type*) [Field K] [Algebra (ZMod N) K]
  (alpha : K) (h_root : Polynomial.aeval alpha (f_mod_N q N) = 0)
  (beta : K) (h_beta : beta_relation a q N alpha beta)
  (h_eq : 4 * (q : ZMod N) = (a : ZMod N)^2 + 27) :
  (2 * (a : K))^3 * Polynomial.aeval beta (f_mod_N q N) = 0 := by
    -- Substitute $\beta$ into the polynomial $f(x)$ and simplify.
    have h_poly : (2 * (a : K) * beta)^3 - 4 * (a : K)^2 * (q : K) * (2 * (a : K) * beta) - 8 * (a : K)^3 * (q : K) = 0 := by
      -- Let $B = 2a\beta$. By `h_beta`, $B = 6\alpha^2 - (a+9)\alpha - 4q$.
      set B : K := 2 * (a : K) * beta
      have hB : B = 6 * alpha^2 - (a + 9) * alpha - 4 * (q : K) := by
        unfold beta_relation at h_beta; linear_combination h_beta;
      have hB_identity : B^3 - 4 * (a : K)^2 * (q : K) * B - 8 * (a : K)^3 * (q : K) = 0 := by
        have h_root_K : alpha^3 = (q : K) * alpha + (q : K) := by
          unfold f_mod_N at h_root; simp_all +decide [ sub_eq_iff_eq_add ] ;
          ring
        have h_a2_K : (a : K)^2 = 4 * (q : K) - 27 := by
          have h_a2 : (algebraMap (ZMod N) K) (4 * (q : ZMod N)) = (algebraMap (ZMod N) K) ((a : ZMod N)^2 + 27) := by
            exact?;
          norm_num +zetaDelta at *;
          convert eq_sub_of_add_eq h_a2.symm using 1;
          erw [ map_natCast, map_natCast ] ; norm_num
        grind;
      exact hB_identity;
    convert h_poly using 1 ; norm_num [ f_mod_N ] ; ring

/-
If u is a unit, then u^n * x = 0 implies x = 0.
-/
lemma unit_pow_mul_eq_zero {R : Type*} [CommRing R] (u : R) (hu : IsUnit u) (n : ℕ) (x : R) (h : u^n * x = 0) : x = 0 := by
  -- Since $u$ is a unit, $u^n$ is also a unit.
  have h_unit : IsUnit (u^n) := by
    exact hu.pow n;
  exact h_unit.mul_right_eq_zero.mp h

/-
If alpha is a root and beta satisfies the relation, then beta is also a root.
-/
lemma beta_is_root_of_relation (q : ℕ) (a : ℤ) (N : ℕ) [Fact (Nat.Prime N)] (h_N_odd : Odd N) (h_gcd : Int.gcd a N = 1)
  (K : Type*) [Field K] [Algebra (ZMod N) K]
  (alpha : K) (h_root : Polynomial.aeval alpha (f_mod_N q N) = 0)
  (beta : K) (h_beta : beta_relation a q N alpha beta)
  (h_eq : 4 * (q : ZMod N) = (a : ZMod N)^2 + 27) :
  Polynomial.aeval beta (f_mod_N q N) = 0 := by
    have h_beta_root : (2 * (a : K))^3 * Polynomial.aeval beta (f_mod_N q N) = 0 := by
      convert beta_scaled_eq_zero q a N K alpha h_root beta h_beta h_eq using 1;
    have h_unit : IsUnit (2 * (a : K)) := by
      exact?;
    aesop

/-
f is separable modulo N.
-/
lemma f_separable (q : ℕ) (N : ℕ) [Fact (Nat.Prime N)] (_h_N_odd : Odd N) (_h_N_ne_q : N ≠ q)
  (h_irr : Irreducible (f_mod_N q N)) :
  Polynomial.Separable (f_mod_N q N) := by
    exact?

/-
beta is a root of f.
-/
lemma beta_is_root_final (q : ℕ) (a : ℤ) (N : ℕ) [Fact (Nat.Prime N)] (h_N_odd : Odd N) (h_gcd : Int.gcd a N = 1)
  (K : Type*) [Field K] [Algebra (ZMod N) K]
  (alpha : K) (h_root : Polynomial.aeval alpha (f_mod_N q N) = 0)
  (beta : K) (h_beta : beta_relation a q N alpha beta)
  (h_eq : 4 * (q : ZMod N) = (a : ZMod N)^2 + 27) :
  Polynomial.aeval beta (f_mod_N q N) = 0 := by
    exact?

/-
alpha is not equal to beta.
-/
lemma alpha_ne_beta_proof (q : ℕ) (a : ℤ) (N : ℕ) [Fact (Nat.Prime N)] (h_N_odd : Odd N) (h_gcd : Int.gcd a N = 1)
  (K : Type*) [Field K] [Algebra (ZMod N) K]
  (alpha : K) (h_root : Polynomial.aeval alpha (f_mod_N q N) = 0)
  (beta : K) (h_beta : beta_relation a q N alpha beta)
  (h_eq : 4 * (q : ZMod N) = (a : ZMod N)^2 + 27)
  (h_irr : Irreducible (f_mod_N q N))
  (h_N_ne_q : (q : ZMod N) ≠ 0) :
  alpha ≠ beta := by
    by_contra h_eq_beta
    have h_contra : let g := Polynomial.C 6 * Polynomial.X^2 - Polynomial.C (3 * (a : ZMod N) + 9) * Polynomial.X - Polynomial.C (4 * (q : ZMod N))
      (aeval alpha g) = 0 := by
        have h_contra : (2 * (a : K)) * alpha = 6 * alpha^2 - (a + 9) * alpha - 4 * (q : K) := by
          unfold beta_relation at h_beta; aesop;
        simp +zetaDelta at *;
        convert sub_eq_zero.mpr h_contra.symm using 1 ; ring;
        erw [ map_ofNat, map_ofNat, map_ofNat, map_ofNat ] ; ring;
    -- Since $f$ is irreducible of degree 3, the minimal polynomial of $\alpha$ has degree 3.
    have h_min_poly : Polynomial.degree (minpoly (ZMod N) alpha) = 3 := by
      have h_min_poly : minpoly (ZMod N) alpha = Polynomial.C (1 : ZMod N) * f_mod_N q N := by
        refine' Eq.symm ( minpoly.eq_of_irreducible_of_monic _ _ _ ) <;> simp_all +decide [ Polynomial.Monic, Polynomial.leadingCoeff, Polynomial.natDegree ];
        unfold f_mod_N; erw [ Polynomial.degree_sub_C ] <;> erw [ Polynomial.degree_sub_eq_left_of_degree_lt ] <;> simp +decide ;
        · exact Or.inr ( by erw [ Polynomial.coeff_X ] ; simp +decide );
        · erw [ Polynomial.degree_C ] <;> simp +decide [ h_N_ne_q ];
        · erw [ Polynomial.degree_C ] <;> simp +decide [ h_N_ne_q ];
      rw [ h_min_poly, Polynomial.degree_C_mul ] <;> norm_num [ f_mod_N ];
      erw [ Polynomial.degree_sub_C ] <;> erw [ Polynomial.degree_sub_eq_left_of_degree_lt ] <;> norm_num [ h_N_ne_q ];
      · erw [ Polynomial.degree_C ] <;> simp +decide [ h_N_ne_q ];
      · erw [ Polynomial.degree_C ] <;> simp +decide [ h_N_ne_q ];
    -- Since $g$ is a polynomial of degree 2, it cannot be the minimal polynomial of $\alpha$.
    have h_deg_g : Polynomial.degree (Polynomial.C 6 * Polynomial.X^2 - Polynomial.C (3 * (a : ZMod N) + 9) * Polynomial.X - Polynomial.C (4 * (q : ZMod N))) < 3 := by
      erw [ Polynomial.degree_lt_iff_coeff_zero ];
      rintro ( _ | _ | _ | m ) <;> simp +decide [ Polynomial.coeff_eq_zero_of_natDegree_lt ];
    have h_not_min_poly : ¬(minpoly (ZMod N) alpha ∣ Polynomial.C 6 * Polynomial.X^2 - Polynomial.C (3 * (a : ZMod N) + 9) * Polynomial.X - Polynomial.C (4 * (q : ZMod N))) := by
      intro h_div
      have h_deg_div : Polynomial.degree (minpoly (ZMod N) alpha) ≤ Polynomial.degree (Polynomial.C 6 * Polynomial.X^2 - Polynomial.C (3 * (a : ZMod N) + 9) * Polynomial.X - Polynomial.C (4 * (q : ZMod N))) := by
        convert Polynomial.degree_le_of_dvd h_div _;
        intro h; simp_all +decide [ Polynomial.ext_iff ] ;
        have := h 0; have := h 1; have := h 2; simp_all +decide [ Polynomial.coeff_eq_zero_of_natDegree_lt ] ;
        erw [ ZMod.natCast_eq_zero_iff ] at this ; have := Nat.le_of_dvd ( by decide ) this ; interval_cases N <;> simp +decide at this h_N_odd h_N_ne_q h_eq ⊢;
        · exact Nat.not_prime_one Fact.out;
        · norm_num [ Polynomial.coeff_zero_eq_eval_zero ] at *;
          grind;
        · contradiction;
      exact h_deg_div.not_gt ( h_min_poly.symm ▸ h_deg_g );
    exact h_not_min_poly ( minpoly.dvd ( ZMod N ) alpha ( by aesop ) )

/-
If alpha and beta are distinct roots of x^3+cx+d, then -alpha-beta is a root.
-/
lemma cubic_root_sum_zero {K : Type*} [Field K] {c d : K} {alpha beta : K}
  (h_alpha : alpha^3 + c * alpha + d = 0)
  (h_beta : beta^3 + c * beta + d = 0)
  (h_ne : alpha ≠ beta) :
  let gamma := -alpha - beta
  gamma^3 + c * gamma + d = 0 := by
    grind

/-
Auxiliary polynomial g(x) = 6x^2 - (3a+9)x - 4q.
-/
def g_poly (q : ℕ) (a : ℤ) (N : ℕ) : Polynomial (ZMod N) :=
  Polynomial.C 6 * Polynomial.X^2 - Polynomial.C ((3 * a + 9) : ZMod N) * Polynomial.X - Polynomial.C ((4 * q) : ZMod N)

/-
gamma is a root of f.
-/
lemma gamma_is_root_final (q : ℕ) (a : ℤ) (N : ℕ) [Fact (Nat.Prime N)] (h_N_odd : Odd N) (h_gcd : Int.gcd a N = 1)
  (K : Type*) [Field K] [Algebra (ZMod N) K]
  (alpha : K) (h_root : Polynomial.aeval alpha (f_mod_N q N) = 0)
  (beta : K) (h_beta : beta_relation a q N alpha beta)
  (h_eq : 4 * (q : ZMod N) = (a : ZMod N)^2 + 27)
  (h_irr : Irreducible (f_mod_N q N))
  (h_N_ne_q : (q : ZMod N) ≠ 0)
  (_h_a_ne_zero : (a : ZMod N) ≠ 0)
  (gamma : K) (h_sum : alpha + beta + gamma = 0) :
  Polynomial.aeval gamma (f_mod_N q N) = 0 := by
    have h_gamma_root : (aeval beta) (f_mod_N q N) = 0 := by
      apply beta_is_root_final q a N h_N_odd h_gcd K alpha h_root beta h_beta h_eq;
    have h_gamma_root : (aeval alpha) (f_mod_N q N) = 0 ∧ (aeval beta) (f_mod_N q N) = 0 ∧ alpha ≠ beta := by
      exact ⟨ h_root, h_gamma_root, alpha_ne_beta_proof q a N h_N_odd h_gcd K alpha h_root beta h_beta h_eq h_irr h_N_ne_q ⟩;
    unfold f_mod_N at *; simp_all +decide [ ← eq_sub_iff_add_eq' ] ;
    grind

/-
If alpha = beta, then g(alpha) = 0.
-/
lemma g_poly_root (q : ℕ) (a : ℤ) (N : ℕ) [Fact (Nat.Prime N)]
  (K : Type*) [Field K] [Algebra (ZMod N) K]
  (alpha : K) (beta : K) (h_beta : beta_relation a q N alpha beta)
  (h_eq : alpha = beta) :
  Polynomial.aeval alpha (g_poly q a N) = 0 := by
    subst h_eq;
    unfold beta_relation g_poly at *;
    simp +zetaDelta at *;
    convert sub_eq_zero.mpr h_beta.symm using 1 ; ring;
    erw [ map_ofNat, map_ofNat, map_ofNat ] ; ring;
    erw [ map_ofNat ] ; ring

/-
Algebraic identity for the cyclic relation.
-/
lemma cyclic_identity_lemma {R : Type*} [CommRing R] (a q : R) (alpha : R)
  (h_root : alpha^3 = q * alpha + q)
  (h_a2 : a^2 = 4 * q - 27) :
  let B := (6 * alpha^2 - (a + 9) * alpha - 4 * q)
  6 * B^2 + (a - 9) * (2 * a) * B + 8 * a^3 * alpha - 16 * a^2 * q = 0 := by
    grind +ring

/-
The relation between roots is cyclic: if alpha->beta, then beta->gamma.
-/
lemma cyclic_relation (q : ℕ) (a : ℤ) (N : ℕ) [Fact (Nat.Prime N)] (h_N_odd : Odd N) (h_gcd : Int.gcd a N = 1)
  (K : Type*) [Field K] [Algebra (ZMod N) K]
  (alpha beta gamma : K)
  (h_root_alpha : Polynomial.aeval alpha (f_mod_N q N) = 0)
  (_h_root_beta : Polynomial.aeval beta (f_mod_N q N) = 0)
  (_h_root_gamma : Polynomial.aeval gamma (f_mod_N q N) = 0)
  (h_sum : alpha + beta + gamma = 0)
  (h_beta : beta_relation a q N alpha beta)
  (h_eq : 4 * (q : ZMod N) = (a : ZMod N)^2 + 27)
  (_h_irr : Irreducible (f_mod_N q N))
  (_h_N_ne_q : (q : ZMod N) ≠ 0)
  (_h_a_ne_zero : (a : ZMod N) ≠ 0) :
  beta_relation a q N beta gamma := by
    have h_cyclic : 6 * (2 * a * beta)^2 + (a - 9) * (2 * a) * (2 * a * beta) + 8 * a^3 * alpha - 16 * a^2 * q = 0 := by
      have h_eq : 6 * (2 * a * beta)^2 + (a - 9) * (2 * a) * (2 * a * beta) + 8 * a^3 * alpha - 16 * a^2 * q = 0 := by
        have h_beta_eq : 2 * a * beta = 6 * alpha^2 - (a + 9) * alpha - 4 * q := by
          exact?
        convert cyclic_identity_lemma ( a : K ) ( q : K ) alpha _ _ using 1;
        · rw [ h_beta_eq ];
        · unfold f_mod_N at h_root_alpha; simp_all +decide [ Polynomial.aeval_def ] ;
          linear_combination' h_root_alpha;
        · norm_cast;
          erw [ eq_comm ] ; erw [ ← map_intCast ( algebraMap ( ZMod N ) K ) ] ; aesop;
      convert h_eq using 1;
    -- Since $2a$ is a unit, we can divide by $4a^2$ to get the result.
    have h_div : 6 * beta^2 + (a - 9) * beta + 2 * a * alpha - 4 * q = 0 := by
      have h_div : (2 * a : K) ^ 2 * (6 * beta ^ 2 + (a - 9) * beta + 2 * a * alpha - 4 * q) = 0 := by
        linear_combination' h_cyclic;
      have h_unit : IsUnit (2 * a : K) := by
        exact?;
      exact eq_zero_of_ne_zero_of_mul_left_eq_zero ( pow_ne_zero 2 h_unit.ne_zero ) h_div;
    unfold beta_relation at *;
    grind +ring

/-
Arithmetic verification of the orientation constant.
-/
lemma orientation_arithmetic (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)]
  (h_eq : 4 * (q : ZMod q) = (a : ZMod q)^2 + 27)
  (h_a_ne_zero : (a : ZMod q) ≠ 0) :
  -(a + 9 : ZMod q) * (2 * a : ZMod q)⁻¹ = s2 q a := by
    by_cases ha : ( a : ZMod q ) = 0 <;> simp_all +decide [ sq, mul_assoc, mul_comm ];
    unfold s2; ring;
    field_simp;
    grind

/-
f(x) = x^3 - qx - q over Q.
-/
open Polynomial

def f_rat (q : ℕ) : Polynomial ℚ := X^3 - C (q : ℚ) * X - C (q : ℚ)

/-
Global field L definition.
-/
open Polynomial

noncomputable def L_field (q : ℕ) : Type := (f_rat q).SplittingField

noncomputable instance (q : ℕ) : Field (L_field q) :=
  Polynomial.SplittingField.instField (f_rat q)

noncomputable instance (q : ℕ) : Algebra ℚ (L_field q) :=
  Polynomial.SplittingField.instAlgebra (f_rat q)

noncomputable instance (q : ℕ) : FiniteDimensional ℚ (L_field q) :=
  Polynomial.IsSplittingField.instFiniteDimensionalSplittingField (f_rat q)

noncomputable instance (q : ℕ) : IsSplittingField ℚ (L_field q) (f_rat q) :=
  Polynomial.IsSplittingField.splittingField (f_rat q)

/-
Checking instances.
-/
#synth Field (L_field 1567)
#synth Algebra ℚ (L_field 1567)
#synth FiniteDimensional ℚ (L_field 1567)
#synth Polynomial.IsSplittingField ℚ (L_field 1567) (f_rat 1567)

/-
Global splitting field definition.
-/
open Polynomial

noncomputable def SplittingField_f (q : ℕ) := (f_rat q).SplittingField

noncomputable instance (q : ℕ) : Field (SplittingField_f q) :=
  Polynomial.SplittingField.instField (f_rat q)

noncomputable instance (q : ℕ) : Algebra ℚ (SplittingField_f q) :=
  Polynomial.SplittingField.instAlgebra (f_rat q)

noncomputable instance (q : ℕ) : FiniteDimensional ℚ (SplittingField_f q) :=
  Polynomial.IsSplittingField.instFiniteDimensionalSplittingField (f_rat q)

noncomputable instance (q : ℕ) : IsSplittingField ℚ (SplittingField_f q) (f_rat q) :=
  Polynomial.IsSplittingField.splittingField (f_rat q)

/-
f(x) is irreducible over Q.
-/
lemma f_rat_irreducible (q : ℕ) [Fact (Nat.Prime q)] (h_q_ge_5 : q ≥ 5) :
  Irreducible (f_rat q) := by
    have h_irred : Irreducible (Polynomial.X^3 - Polynomial.C (q : ℚ) * Polynomial.X - Polynomial.C (q : ℚ)) := by
      have h_eisenstein : Irreducible (Polynomial.X^3 - Polynomial.C (q : ℤ) * Polynomial.X - Polynomial.C (q : ℤ)) := by
        apply Polynomial.irreducible_of_eisenstein_criterion;
        any_goals erw [ Polynomial.degree_sub_C ] <;> erw [ Polynomial.degree_sub_eq_left_of_degree_lt ] <;> norm_num;
        any_goals erw [ Polynomial.degree_C ] <;> norm_num ; linarith;
        any_goals exact Ideal.span { ( q : ℤ ) };
        · rw [ Ideal.span_singleton_prime ] <;> norm_cast;
          · exact Nat.prime_iff_prime_int.mp ( Fact.out : Nat.Prime q );
          · grind;
        · rw [ Polynomial.leadingCoeff, Polynomial.natDegree_sub_C, Polynomial.natDegree_sub_eq_left_of_natDegree_lt ] <;> norm_num;
          · rw [ Ideal.mem_span_singleton ] ; norm_cast ; aesop;
          · erw [ Polynomial.natDegree_C_mul_X ] <;> norm_num ; linarith;
        · intro n hn; interval_cases n <;> norm_num [ Polynomial.coeff_X, Ideal.mem_span_singleton ] ;
        · norm_num [ Ideal.span_singleton_pow, Ideal.mem_span_singleton ];
          exact_mod_cast Nat.not_dvd_of_pos_of_lt ( by linarith ) ( by nlinarith );
        · refine' Polynomial.Monic.isPrimitive _;
          rw [ Polynomial.Monic, Polynomial.leadingCoeff, Polynomial.natDegree_sub_C, Polynomial.natDegree_sub_eq_left_of_natDegree_lt ] <;> norm_num;
          erw [ Polynomial.natDegree_C_mul_X ] <;> norm_num ; linarith
      have h_irred : Irreducible (Polynomial.map (Int.castRingHom ℚ) (Polynomial.X^3 - Polynomial.C (q : ℤ) * Polynomial.X - Polynomial.C (q : ℤ))) := by
        have h_primitive : Polynomial.IsPrimitive (Polynomial.X^3 - Polynomial.C (q : ℤ) * Polynomial.X - Polynomial.C (q : ℤ)) := by
          intro p hp;
          obtain ⟨ a, ha ⟩ := hp; replace ha := congr_arg ( fun f => Polynomial.coeff f 3 ) ha; norm_num [ Polynomial.coeff_eq_zero_of_natDegree_lt ] at ha;
          exact isUnit_of_mul_eq_one _ _ ha.symm
        exact?;
      aesop;
    exact h_irred

/-
The degree of f(x) is 3.
-/
open Polynomial

lemma degree_f_rat (q : ℕ) : (f_rat q).degree = 3 := by
  erw [ Polynomial.degree_sub_C ] <;> erw [ Polynomial.degree_sub_eq_left_of_degree_lt ] <;> by_cases hq : q = 0 <;> simp +decide [ hq ];
  · erw [ Polynomial.degree_C ] <;> simp +decide [ hq ];
  · erw [ Polynomial.degree_C ] <;> simp +decide [ hq ]

/-
theta_global definition.
-/
open Polynomial

noncomputable def theta_global (q : ℕ) : SplittingField_f q :=
  rootOfSplits (algebraMap ℚ (SplittingField_f q))
    (IsSplittingField.splits (SplittingField_f q) (f_rat q))
    (by rw [degree_f_rat]; norm_num)

/-
Global field definition (retry 4).
-/
open Polynomial

noncomputable def GlobalField (q : ℕ) : Type := (f_rat q).SplittingField

noncomputable instance (q : ℕ) : Field (GlobalField q) :=
  Polynomial.SplittingField.instField (f_rat q)

noncomputable instance (q : ℕ) : Algebra ℚ (GlobalField q) :=
  Polynomial.SplittingField.instAlgebra (f_rat q)

noncomputable instance (q : ℕ) : IsSplittingField ℚ (GlobalField q) (f_rat q) :=
  Polynomial.IsSplittingField.splittingField (f_rat q)

noncomputable instance (q : ℕ) : FiniteDimensional ℚ (GlobalField q) :=
  Polynomial.IsSplittingField.finiteDimensional (GlobalField q) (f_rat q)

/-
theta_global is a root of f_rat.
-/
lemma theta_global_is_root (q : ℕ) : Polynomial.aeval (theta_global q) (f_rat q) = 0 := by
  convert Polynomial.map_rootOfSplits _ _ _

/-
Global beta and gamma definitions.
-/
open Polynomial

noncomputable def beta_global (q : ℕ) (a : ℤ) : SplittingField_f q :=
  let alpha := theta_global q
  (6 * alpha^2 - (a + 9 : ℚ) • alpha - 4 * (q : ℚ)) * (2 * (a : ℚ))⁻¹

noncomputable def gamma_global (q : ℕ) (a : ℤ) : SplittingField_f q :=
  -theta_global q - beta_global q a

/-
beta_global is a root of f_rat.
-/
lemma beta_global_is_root (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (_h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27) :
  Polynomial.aeval (beta_global q a) (f_rat q) = 0 := by
    -- By definition of $beta_global$, we have $(2a)beta_global = 6\theta^2 - (a+9)\theta - 4q$.
    have h_beta_eq : (2 * (a : ℚ)) • (beta_global q a) = 6 * (theta_global q)^2 - (a + 9 : ℚ) • (theta_global q) - 4 * (q : ℚ) := by
      unfold beta_global; simp +decide [mul_comm] ;
      by_cases ha : a = 0 <;> simp_all +decide [ Algebra.smul_def ];
      · norm_cast at h_eq; omega;
      · simp +decide [mul_comm];
        simp +decide [ ← mul_assoc ];
        erw [ ← map_mul ] ; ring;
        simp +decide [ ha, mul_assoc, mul_left_comm ( a : ℚ ), mul_comm ];
        erw [ map_one ] ; ring;
    -- Substitute $\beta = \frac{6\theta^2 - (a + 9)\theta - 4q}{2a}$ into $f(\beta)$ and simplify.
    set B : SplittingField_f q := 6 * (theta_global q)^2 - (a + 9 : ℚ) • (theta_global q) - 4 * (q : ℚ)
    have h_fB : B^3 - 4 * (a : ℚ)^2 * (q : ℚ) * B - 8 * (a : ℚ)^3 * (q : ℚ) = 0 := by
      field_simp;
      have h_B_poly : B^3 - 4 * (a : SplittingField_f q)^2 * (q : SplittingField_f q) * B - 8 * (a : SplittingField_f q)^3 * (q : SplittingField_f q) = 0 := by
        have h_root : theta_global q ^ 3 = (q : SplittingField_f q) * theta_global q + (q : SplittingField_f q) := by
          have h_root : Polynomial.aeval (theta_global q) (f_rat q) = 0 := by
            exact theta_global_is_root q;
          unfold f_rat at h_root; norm_num at h_root; linear_combination' h_root;
        have h_a2 : (a : SplittingField_f q)^2 = 4 * (q : SplittingField_f q) - 27 := by
          norm_cast at *;
          simp_all +decide [ Int.subNatNat_eq_coe ]
        convert beta_poly_identity ( a : SplittingField_f q ) ( q : SplittingField_f q ) ( theta_global q ) h_root h_a2 using 1;
        norm_num +zetaDelta at *;
        norm_num [ Algebra.smul_def ];
        norm_cast;
      convert h_B_poly using 1 ; ring!;
    -- Since $B = (2a)beta_global$, we can substitute this into the equation $B^3 - 4a^2qB - 8a^3q = 0$.
    have h_sub : ((2 * (a : ℚ)) • (beta_global q a))^3 - 4 * (a : ℚ)^2 * (q : ℚ) * ((2 * (a : ℚ)) • (beta_global q a)) - 8 * (a : ℚ)^3 * (q : ℚ) = 0 := by
      aesop;
    -- Since $a \neq 0$, we can divide both sides of the equation by $8a^3$.
    have h_div : (beta_global q a)^3 - (q : ℚ) * (beta_global q a) - (q : ℚ) = 0 := by
      have h_div : (8 * (a : ℚ)^3) • (beta_global q a^3 - (q : ℚ) * (beta_global q a) - (q : ℚ)) = 0 := by
        convert h_sub using 1 ; norm_num [ mul_pow, mul_assoc, mul_comm, mul_left_comm ] ; ring;
        norm_cast ; ring;
        push_cast; ring;
      by_cases ha : a = 0 <;> simp_all +decide [ pow_succ, mul_assoc ];
      norm_cast at h_eq; omega;
    unfold f_rat; aesop;

/-
theta is not equal to beta in the global field.
-/
lemma alpha_ne_beta_global (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27) :
  theta_global q ≠ beta_global q a := by
    by_contra h_eq_beta
    have h_g_theta : (6 * (theta_global q) ^ 2 - (3 * a + 9) * theta_global q - 4 * q : SplittingField_f q) = 0 := by
      have h_g_theta : (2 * a : SplittingField_f q) * theta_global q = 6 * (theta_global q) ^ 2 - (a + 9) * theta_global q - 4 * q := by
        unfold beta_global at h_eq_beta;
        convert congr_arg ( fun x : SplittingField_f q => ( 2 * a : ℚ ) * x ) h_eq_beta using 1 ; norm_num ; ring;
        · exact Or.inl <| by norm_cast;
        · by_cases ha : ( 2 * a : ℚ ) = 0 <;> simp +decide [ ha, mul_comm, mul_left_comm ];
          · norm_num +zetaDelta at *;
            norm_num [ ha ] at * ; nlinarith [ ( by norm_cast : ( 7 : ℚ ) ≤ q ) ];
          · simp +decide [ mul_assoc, mul_comm, Algebra.smul_def ];
            simp +decide [ ← mul_assoc, ← mul_inv_rev ];
            norm_num +zetaDelta at *;
            erw [ ← map_mul ] ; norm_num [ ha ];
            norm_num [ ha, mul_assoc, mul_left_comm ( a : ℚ ) ];
            erw [ map_one ] ; norm_num;
            exact Or.inl <| by norm_cast;
      linear_combination' -h_g_theta;
    -- Since $f_rat$ is irreducible over $\mathbb{Q}$, it must divide $g_poly$.
    have h_div : f_rat q ∣ (Polynomial.C 6 * Polynomial.X ^ 2 - Polynomial.C ((3 * a + 9) : ℚ) * Polynomial.X - Polynomial.C (4 * (q : ℚ))) := by
      have h_min_poly : minpoly ℚ (theta_global q) = f_rat q := by
        refine' Eq.symm ( minpoly.eq_of_irreducible_of_monic _ _ _ );
        · exact f_rat_irreducible q ( by linarith );
        · exact?;
        · erw [ Polynomial.Monic, Polynomial.leadingCoeff, Polynomial.natDegree_sub_C, Polynomial.natDegree_sub_eq_left_of_natDegree_lt ] <;> norm_num;
          · unfold f_rat; norm_num [ Polynomial.coeff_eq_zero_of_natDegree_lt ] ;
          · erw [ Polynomial.natDegree_C_mul_X ] <;> norm_num ; linarith;
      refine' h_min_poly ▸ minpoly.dvd ℚ _ _;
      simpa [ Algebra.smul_def ] using h_g_theta;
    have := Polynomial.degree_le_of_dvd h_div;
    erw [ Polynomial.degree_sub_C ] at this <;> norm_num [ Polynomial.degree_sub_eq_left_of_degree_lt ] at *;
    · erw [ Polynomial.degree_sub_eq_left_of_degree_lt ] at this <;> norm_num at *;
      · contrapose! this;
        erw [ Polynomial.degree_lt_iff_coeff_zero ] ; norm_num;
        exact ⟨ ne_of_apply_ne ( fun p => p.coeff 2 ) ( by norm_num [ Polynomial.coeff_eq_zero_of_natDegree_lt ] ), fun m hm => by rcases m with ( _ | _ | _ | m ) <;> simp_all +decide [ Polynomial.coeff_eq_zero_of_natDegree_lt ] ⟩;
      · erw [ Polynomial.degree_C ] <;> norm_num ; linarith;
    · erw [ Polynomial.degree_sub_eq_left_of_degree_lt ] <;> norm_num;
      erw [ Polynomial.degree_C ] <;> norm_num ; linarith

#check NumberField

#check AlgHom.IsArithFrobAt

instance (q : ℕ) : NumberField (GlobalField q) :=
  { to_charZero := charZero_of_injective_algebraMap (algebraMap ℚ (GlobalField q)).injective
    to_finiteDimensional := inferInstance }

/-
Definition of the ring of integers of the global field.
-/
noncomputable def RingOfIntegers (q : ℕ) := NumberField.RingOfIntegers (GlobalField q)

/-
Property that an automorphism maps theta to beta.
-/
def sigma_global_prop (q : ℕ) (a : ℤ) (sigma : GlobalField q ≃ₐ[ℚ] GlobalField q) : Prop :=
  sigma (theta_global q) = beta_global q a

/-
Existence of an automorphism mapping theta to beta.
-/
lemma exists_sigma_global (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27) :
  ∃ σ : GlobalField q ≃ₐ[ℚ] GlobalField q, σ (theta_global q) = beta_global q a := by
    -- Since $\theta$ and $\beta$ are both roots of $f$, there exists an automorphism mapping $\theta$ to $\beta$.
    have h_trans : ∀ (x y : GlobalField q), Polynomial.aeval (R := ℚ) x (f_rat q) = 0 → Polynomial.aeval (R := ℚ) y (f_rat q) = 0 → ∃ σ : GlobalField q ≃ₐ[ℚ] GlobalField q, σ x = y := by
      intro x y hx hy;
      have h_trans : ∀ x y : GlobalField q, IsIntegral ℚ x → IsIntegral ℚ y → minpoly ℚ x = minpoly ℚ y → ∃ σ : GlobalField q ≃ₐ[ℚ] GlobalField q, σ x = y := by
        intros x y hx hy hxy
        have h_trans : ∀ (x y : GlobalField q), IsIntegral ℚ x → IsIntegral ℚ y → minpoly ℚ x = minpoly ℚ y → ∃ σ : GlobalField q ≃ₐ[ℚ] GlobalField q, σ x = y := by
          intros x y hx hy hxy
          have h_normal : Normal ℚ (GlobalField q) := by
            have h_normal : IsSplittingField ℚ (GlobalField q) (f_rat q) := by
              exact?
            generalize_proofs at *; (
            exact?)
          exact?
        generalize_proofs at *; (
        exact h_trans x y hx hy hxy)
      generalize_proofs at *; (
      apply h_trans x y;
      · exact?;
      · exact?;
      · refine' minpoly.eq_of_irreducible_of_monic _ _ _;
        · exact minpoly.irreducible ( show IsIntegral ℚ x from by exact? );
        · have h_minpoly : minpoly ℚ x = f_rat q := by
            refine' Eq.symm ( minpoly.eq_of_irreducible_of_monic _ _ _ );
            · convert f_rat_irreducible q ( by linarith ) using 1

            · exact hx;
            · erw [ Polynomial.Monic, Polynomial.leadingCoeff, Polynomial.natDegree_sub_C, Polynomial.natDegree_sub_eq_left_of_natDegree_lt ] <;> norm_num [ Polynomial.natDegree_X_pow, Polynomial.natDegree_C ];
              · unfold f_rat; norm_num [ Polynomial.coeff_eq_zero_of_natDegree_lt ] ;
              · erw [ Polynomial.natDegree_C_mul_X ] <;> norm_num ; linarith
          generalize_proofs at *; (
          grind);
        · exact minpoly.monic ( show IsIntegral ℚ x from by exact? ))
    generalize_proofs at *; (
    exact h_trans _ _ ( theta_global_is_root q ) ( beta_global_is_root q a h_q_ge_7 h_eq ) |> fun ⟨ σ, hσ ⟩ => ⟨ σ, hσ ⟩)

/-
Definition of the specific automorphism sigma that maps theta to beta.
-/
noncomputable def sigma_global (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27) : GlobalField q ≃ₐ[ℚ] GlobalField q :=
  Classical.choose (exists_sigma_global q a h_q_ge_7 h_eq)

lemma sigma_global_spec (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27) :
  (sigma_global q a h_q_ge_7 h_eq) (theta_global q) = beta_global q a :=
  Classical.choose_spec (exists_sigma_global q a h_q_ge_7 h_eq)

#check c_value

#check NumberField.RingOfIntegers.mapAlgEquiv

#check NumberField.RingOfIntegers

/-
The integer ring automorphism corresponding to sigma.
-/
noncomputable def sigma_int_global (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27) :
  NumberField.RingOfIntegers (GlobalField q) ≃ₐ[ℤ] NumberField.RingOfIntegers (GlobalField q) :=
  ((NumberField.RingOfIntegers.mapAlgEquiv (sigma_global q a h_q_ge_7 h_eq)).restrictScalars ℤ)

/-
Check CommRing instance.
-/
example (q : ℕ) : CommRing (NumberField.RingOfIntegers (GlobalField q)) := inferInstance

/-
Check CommRing instance again.
-/
example (q : ℕ) : CommRing (NumberField.RingOfIntegers (GlobalField q)) := inferInstance

/-
Proof that theta is an algebraic integer.
-/
lemma theta_is_integral (q : ℕ) : IsIntegral ℤ (theta_global q) := by
  refine' ⟨ Polynomial.X ^ 3 - Polynomial.C ( q : ℤ ) * Polynomial.X - Polynomial.C ( q : ℤ ), _, _ ⟩;
  · erw [ Polynomial.Monic, Polynomial.leadingCoeff, Polynomial.natDegree_sub_C, Polynomial.natDegree_sub_eq_left_of_natDegree_lt ] <;> by_cases hq : q = 0 <;> simp +decide [ hq ];
  · convert theta_global_is_root q using 1;
    unfold f_rat; norm_num [ Polynomial.aeval_def ] ;

/-
The polynomial f_poly is monic.
-/
lemma f_poly_monic (q : ℤ) : (f_poly q).Monic := by
  unfold f_poly; erw [ Polynomial.Monic, Polynomial.leadingCoeff, Polynomial.natDegree_sub_C, Polynomial.natDegree_sub_eq_left_of_natDegree_lt ] <;> norm_num [ Polynomial.coeff_eq_zero_of_natDegree_lt ] ;
  by_cases hq : q = 0 <;> simp +decide [ hq, Polynomial.natDegree_mul' ]

/-
Definition of theta as an algebraic integer.
-/
noncomputable def theta_int (q : ℕ) : NumberField.RingOfIntegers (GlobalField q) :=
  ⟨theta_global q, theta_is_integral q⟩

/-
Integer representative of s2 in the range (-q/2, q/2].
-/
noncomputable def s2_int (q : ℕ) (a : ℤ) : ℤ :=
  let s2_zmod : ZMod q := s2 q a
  if s2_zmod.val ≤ q / 2 then (s2_zmod.val : ℤ) else (s2_zmod.val : ℤ) - (q : ℤ)

#check theta_is_integral

/-
q is in the ideal generated by theta^2.
-/
lemma q_mem_theta_sq (q : ℕ) [Fact (Nat.Prime q)] (_h_q_ge_7 : q ≥ 7) :
  (q : NumberField.RingOfIntegers (GlobalField q)) ∈ Ideal.span {theta_int q ^ 2} := by
    -- First, we show that $q$ generates the ideal $(\theta)^3$.
    have h_q_gen_theta_cubed : (q : NumberField.RingOfIntegers (GlobalField q)) ∈ Ideal.span {theta_int q ^ 3} := by
      -- Since $\theta^3 = q(\theta + 1)$, we have $q \in (\theta^3)$.
      have h_q_in_theta_cubed : (q : NumberField.RingOfIntegers (GlobalField q)) = theta_int q ^ 3 - (q : NumberField.RingOfIntegers (GlobalField q)) * theta_int q := by
        have h_theta_cubed : theta_int q ^ 3 = (q : NumberField.RingOfIntegers (GlobalField q)) * theta_int q + (q : NumberField.RingOfIntegers (GlobalField q)) := by
          convert theta_global_is_root q;
          unfold f_rat; norm_num [ ← @Subtype.coe_inj ] ;
          erw [ ← Subtype.coe_inj ] ; simp +decide [ sub_eq_iff_eq_add' ] ; ring;
          exact?;
        rw [ h_theta_cubed, add_sub_cancel_left ];
      -- Since $\theta$ is a root of $x^3 - qx - q$, we have $\theta^3 = q(\theta + 1)$.
      have h_theta_cubed : theta_int q ^ 3 = (q : NumberField.RingOfIntegers (GlobalField q)) * (theta_int q + 1) := by
        grind;
      -- Since $\theta + 1$ is a unit in the ring of integers, we have $(q) = (\theta^3)$.
      have h_unit : IsUnit (theta_int q + 1 : NumberField.RingOfIntegers (GlobalField q)) := by
        have h_unit : (theta_int q + 1 : NumberField.RingOfIntegers (GlobalField q)) * (theta_int q ^ 2 - theta_int q + 1 - (q : NumberField.RingOfIntegers (GlobalField q))) = 1 := by
          grind;
        exact isUnit_of_mul_eq_one _ _ h_unit;
      rw [ h_theta_cubed, Ideal.mem_span_singleton ];
      exact ⟨ h_unit.unit.inv, by simp +decide [ mul_assoc ] ⟩;
    exact Ideal.mem_span_singleton.mpr ( dvd_trans ( by exact ⟨ theta_int q, by ring ⟩ ) ( Ideal.mem_span_singleton.mp h_q_gen_theta_cubed ) )

/-
The congruence 2a * s2 = -(a+9) holds in ZMod q.
-/
lemma s2_congruence_zmod (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27) :
  (2 * (a : ZMod q)) * (s2 q a) = -((a : ZMod q) + 9) := by
    unfold s2;
    have h_mod : (a ^ 2 + 27 : ZMod q) = 0 := by
      norm_cast at *;
      simp +decide [ ← h_eq ];
    by_cases h : ( 6 : ZMod q ) = 0 <;> simp_all +decide [ ← eq_sub_iff_add_eq', ← mul_assoc ];
    · rcases q with ( _ | _ | _ | _ | _ | _ | _ | q ) <;> cases h <;> trivial;
    · grind

/-
Step 1 of orientation lemma: 2a * sigma(theta) is congruent to -(a+9)theta modulo theta^2.
-/
lemma lemma_orientation_step1 (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27) :
  let theta := theta_int q
  let sigma := sigma_int_global q a h_q_ge_7 h_eq
  (2 * a : NumberField.RingOfIntegers (GlobalField q)) * sigma theta - (-(a + 9 : ℤ)) • theta ∈ Ideal.span {theta^2} := by
    have h_sigma_theta : 2 * (a : ℤ) * (sigma_int_global q a h_q_ge_7 h_eq) (theta_int q) = 6 * (theta_int q) ^ 2 - (a + 9) * (theta_int q) - 4 * (q : NumberField.RingOfIntegers (GlobalField q)) := by
      -- By definition of $sigma_global$, we know that $sigma_global (theta_int q) = beta_global q a$.
      have h_sigma_beta : (sigma_int_global q a h_q_ge_7 h_eq) (theta_int q) = ⟨beta_global q a, by
        have h_beta_int : IsIntegral ℤ (beta_global q a) := by
          have h_f_rat : Polynomial.aeval (beta_global q a) (f_rat q) = 0 := by
            exact?
          refine' ⟨ f_poly q, _, _ ⟩
          all_goals generalize_proofs at *;
          · exact f_poly_monic q;
          · convert h_f_rat using 1
            generalize_proofs at *;
            unfold f_poly f_rat; norm_num [ Polynomial.aeval_def ] ;
        generalize_proofs at *;
        exact h_beta_int⟩ := by
        exact Subtype.ext <| sigma_global_spec q a h_q_ge_7 h_eq
      generalize_proofs at *;
      -- Substitute the definition of `beta_global` into the equation.
      have h_beta_def : 2 * (a : ℤ) * (beta_global q a) = 6 * (theta_global q) ^ 2 - (a + 9) * (theta_global q) - 4 * (q : ℚ) := by
        unfold beta_global;
        by_cases ha : ( a : ℚ ) = 0 <;> simp_all +decide [ mul_assoc, mul_comm ];
        · nlinarith [ show ( q : ℚ ) ≥ 7 by norm_cast ];
        · simp_all +decide [ Algebra.smul_def, mul_comm ];
          simp +decide [ mul_left_comm ( a : GlobalField q ) ];
          field_simp;
          norm_cast ; ring;
          norm_num [ Rat.divInt_eq_div, ha ];
      aesop;
    simp_all +decide [ mul_comm, sub_sub ];
    convert Ideal.sub_mem _ ( Ideal.mul_mem_right _ _ ( Ideal.subset_span ( Set.mem_singleton ( theta_int q ^ 2 ) ) ) ) ( Ideal.mul_mem_right _ _ ( q_mem_theta_sq q h_q_ge_7 ) ) using 1 ; ring;
    convert rfl

/-
2a and q are coprime.
-/
lemma coprime_2a_q (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27) :
  IsCoprime (2 * a) (q : ℤ) := by
    have h_coprime : Int.gcd a q = 1 := by
      have h_not_div : ¬(q : ℤ) ∣ a := by
        rintro ⟨ k, rfl ⟩ ; norm_cast at * ; have := congr_arg ( · % ( q : ℤ ) ) h_eq ; norm_num [ sq, Int.add_emod, Int.mul_emod ] at this;
        rw [ eq_comm ] at this; norm_cast at this; have := Nat.le_of_dvd ( by decide ) ( Nat.dvd_of_mod_eq_zero this ) ; interval_cases q <;> norm_num at *;
        · exact False.elim <| Fact.out;
        · exact False.elim <| Fact.out;
      exact Int.gcd_comm _ _ ▸ ( Fact.out : Nat.Prime q ).coprime_iff_not_dvd.mpr fun h => h_not_div <| Int.natCast_dvd.mpr h;
    refine' IsCoprime.mul_left _ _;
    · exact Int.prime_two.coprime_iff_not_dvd.mpr fun h => by have := Nat.Prime.eq_two_or_odd ( Fact.out : Nat.Prime q ) ; omega;
    · exact?

/-
Step 2 of orientation lemma: 2a * s2 * theta is congruent to -(a+9)theta modulo theta^2.
-/
lemma lemma_orientation_step2 (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27) :
  let theta := theta_int q
  let s2 := s2_int q a
  (2 * a : NumberField.RingOfIntegers (GlobalField q)) * (s2 • theta) - (-(a + 9 : ℤ)) • theta ∈ Ideal.span {theta^2} := by
    have h_coprime : (2 * a : ℤ) * s2_int q a ≡ -(a + 9) [ZMOD q] := by
      have h_cong : (2 * a : ZMod q) * (s2 q a) = -(a + 9 : ZMod q) := by
        convert s2_congruence_zmod q a h_q_ge_7 h_eq using 1;
      simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ];
      unfold s2_int; aesop;
    obtain ⟨ k, hk ⟩ := h_coprime.symm.dvd;
    have h_q_theta : (q : NumberField.RingOfIntegers (GlobalField q)) * theta_int q ∈ Ideal.span {theta_int q ^ 2} := by
      have h_q_theta : (q : NumberField.RingOfIntegers (GlobalField q)) ∈ Ideal.span {theta_int q ^ 2} := by
        exact?;
      exact Ideal.mul_mem_right _ _ h_q_theta;
    convert Ideal.mul_mem_left _ ( k : NumberField.RingOfIntegers ( GlobalField q ) ) h_q_theta using 1 ; ring;
    rw [ ← @Int.cast_inj ( NumberField.RingOfIntegers ( GlobalField q ) ) ] at * ; push_cast at * ; linear_combination' hk * theta_int q

/-
The orientation lemma: sigma(theta) is congruent to s2 * theta modulo theta^2.
-/
lemma lemma_orientation_global (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27) :
  let theta := theta_int q
  let s2 := s2_int q a
  let sigma := sigma_int_global q a h_q_ge_7 h_eq
  sigma theta - s2 • theta ∈ Ideal.span {theta^2} := by
    -- Since $2a$ is coprime to $q$, and $q \in (\theta^2)$, $2a$ is invertible modulo $\theta^2$.
    have h_coprime : IsCoprime (2 * a : ℤ) (q : ℤ) := by
      exact?
    generalize_proofs at *;
    have h_inv : ∃ x : NumberField.RingOfIntegers (GlobalField q), (2 * a : NumberField.RingOfIntegers (GlobalField q)) * x - 1 ∈ Ideal.span {theta_int q ^ 2} := by
      -- Since $q \in (\theta^2)$, we have $q \in \text{Ideal.span} \{\theta^2\}$.
      have h_q_in_ideal : (q : NumberField.RingOfIntegers (GlobalField q)) ∈ Ideal.span {theta_int q ^ 2} := by
        exact?
      generalize_proofs at *;
      obtain ⟨ x, y, hxy ⟩ := h_coprime ; use x ; simp_all +decide [ ← eq_sub_iff_add_eq' ] ;
      rw [ Ideal.mem_span_singleton ] at *;
      obtain ⟨ k, hk ⟩ := h_q_in_ideal; use -k * y; push_cast [ ← @Int.cast_inj ( NumberField.RingOfIntegers ( GlobalField q ) ) ] at *; linear_combination' -hk * y + hxy;
    generalize_proofs at *;
    generalize_proofs at *;
    obtain ⟨ x, hx ⟩ := h_inv
    have h_comb : (2 * a : NumberField.RingOfIntegers (GlobalField q)) * (sigma_int_global q a h_q_ge_7 h_eq (theta_int q) - s2_int q a • theta_int q) ∈ Ideal.span {theta_int q ^ 2} := by
      have h_comb : (2 * a : NumberField.RingOfIntegers (GlobalField q)) * (sigma_int_global q a h_q_ge_7 h_eq (theta_int q) - s2_int q a • theta_int q) = ((2 * a : NumberField.RingOfIntegers (GlobalField q)) * sigma_int_global q a h_q_ge_7 h_eq (theta_int q) - (-(a + 9 : ℤ)) • theta_int q) - ((2 * a : NumberField.RingOfIntegers (GlobalField q)) * (s2_int q a • theta_int q) - (-(a + 9 : ℤ)) • theta_int q) := by
        simp +decide [ mul_sub, sub_sub_sub_cancel_right ]
      generalize_proofs at *;
      exact h_comb.symm ▸ Ideal.sub_mem _ ( lemma_orientation_step1 q a h_q_ge_7 h_eq ) ( lemma_orientation_step2 q a h_q_ge_7 h_eq )
    generalize_proofs at *;
    rw [ Ideal.mem_span_singleton ] at *;
    convert dvd_sub ( dvd_mul_of_dvd_left h_comb x ) ( hx.mul_left ( ( sigma_int_global q a h_q_ge_7 h_eq ) ( theta_int q ) - s2_int q a • theta_int q ) ) using 1 ; ring


/-
There exists an inverse of 2a modulo theta^2.
-/
lemma exists_inv_2a_mod_theta_sq (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27) :
  ∃ u : NumberField.RingOfIntegers (GlobalField q),
    (2 * a : NumberField.RingOfIntegers (GlobalField q)) * u - 1 ∈ Ideal.span {theta_int q ^ 2} := by
      -- By Bézout's identity, since gcd(2a, q) = 1, there exist integers x and y such that 2ax + qy = 1.
      obtain ⟨x, y, h_bezout⟩ : ∃ x y : ℤ, (2 * a : ℤ) * x + q * y = 1 := by
        have h_coprime : IsCoprime (2 * a) q := by
          exact?;
        exact ⟨ h_coprime.choose, h_coprime.choose_spec.choose, by linear_combination' h_coprime.choose_spec.choose_spec ⟩;
      -- Since $q \in (\theta^2)$ by `q_mem_theta_sq`, we have $qy \in (\theta^2)$.
      have h_qy_mem_theta_sq : (q : NumberField.RingOfIntegers (GlobalField q)) * y ∈ Ideal.span {theta_int q ^ 2} := by
        have h_qy_mem_theta_sq : (q : NumberField.RingOfIntegers (GlobalField q)) ∈ Ideal.span {theta_int q ^ 2} := by
          exact?;
        exact Ideal.mul_mem_right _ _ h_qy_mem_theta_sq;
      use x;
      convert Ideal.sub_mem _ ( Ideal.zero_mem _ ) h_qy_mem_theta_sq using 1 ; norm_cast ; linarith

/-
The orientation lemma: sigma(theta) is congruent to s2 * theta modulo theta^2.
-/
lemma lemma_orientation_global_final (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27) :
  let theta := theta_int q
  let s2 := s2_int q a
  let sigma := sigma_int_global q a h_q_ge_7 h_eq
  sigma theta - s2 • theta ∈ Ideal.span {theta^2} := by
    -- Apply the orientation lemma to conclude the proof.
    apply lemma_orientation_global q a h_q_ge_7 h_eq

/-
If a is invertible modulo I, and ax is in I, then x is in I.
-/
lemma ideal_cancel_of_unit_mod {R : Type*} [CommRing R] (I : Ideal R) (a u : R) (h_inv : a * u - 1 ∈ I) (x : R) (h_mem : a * x ∈ I) : x ∈ I := by
  convert I.sub_mem ( I.mul_mem_left u h_mem ) ( I.mul_mem_left x h_inv ) using 1 ; ring

/-
Proof that beta is an algebraic integer.
-/
lemma beta_is_integral (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27) : IsIntegral ℤ (beta_global q a) := by
    -- Since $\beta$ is a root of the polynomial $f(x) = x^3 - qx - q$, it is integral over $\mathbb{Z}$.
    have h_beta_root_poly : Polynomial.eval₂ (algebraMap ℚ (GlobalField q)) (beta_global q a) (f_rat q) = 0 := by
      convert beta_global_is_root q a h_q_ge_7 h_eq using 1;
    refine' ⟨ Polynomial.X ^ 3 - Polynomial.C ( q : ℤ ) * Polynomial.X - Polynomial.C ( q : ℤ ), _, _ ⟩;
    · erw [ Polynomial.Monic, Polynomial.leadingCoeff, Polynomial.natDegree_sub_C, Polynomial.natDegree_sub_eq_left_of_natDegree_lt ] <;> norm_num;
      erw [ Polynomial.natDegree_C_mul_X ] <;> norm_num ; linarith;
    · unfold f_rat at h_beta_root_poly; aesop;

/-
Statement of the reciprocity lemma.
-/
def reciprocity_lemma_statement (q : ℕ) (N : ℕ) [Fact (Nat.Prime q)] [Fact (Nat.Prime N)] : Prop :=
  ∀ (P : Ideal (NumberField.RingOfIntegers (GlobalField q))) [P.IsMaximal] (_hP : P.LiesOver (Ideal.span {(N : ℤ)})),
  ∃ phi : NumberField.RingOfIntegers (GlobalField q) ≃ₐ[ℤ] NumberField.RingOfIntegers (GlobalField q),
    phi.toAlgHom.IsArithFrobAt P ∧
    phi (theta_int q) - (c_value q N).val • (theta_int q) ∈ Ideal.span {theta_int q ^ 2}

/-
Checking if s1 is already defined.
-/
#check s1

/-
Opening Polynomial namespace.
-/
open Polynomial

/-
(2a)^3 * f(beta) = 0.
-/
lemma beta_scaled_eq_zero_fixed (q : ℕ) (a : ℤ) (N : ℕ) [Fact (Nat.Prime N)]
  (K : Type*) [Field K] [Algebra (ZMod N) K]
  (alpha : K) (h_root : Polynomial.aeval alpha (f_mod_N q N) = 0)
  (beta : K) (h_beta : beta_relation a q N alpha beta)
  (h_eq : 4 * (q : ZMod N) = (a : ZMod N)^2 + 27) :
  (2 * (a : K))^3 * Polynomial.aeval beta (f_mod_N q N) = 0 := by
  have h_a2 : (algebraMap (ZMod N) K) (4 * (q : ZMod N))
            = (algebraMap (ZMod N) K) ((a : ZMod N)^2 + 27) := by
    simpa using congrArg (algebraMap (ZMod N) K) h_eq
  convert beta_scaled_eq_zero q a N K alpha h_root beta h_beta h_eq using 1

/-
If alpha is a root and beta satisfies the relation, then beta is a root.
-/
lemma beta_is_root_of_relation_fixed (q : ℕ) (a : ℤ) (N : ℕ) [Fact (Nat.Prime N)] (h_N_odd : Odd N) (h_gcd : Int.gcd a N = 1)
  (K : Type*) [Field K] [Algebra (ZMod N) K]
  (alpha : K) (h_root : Polynomial.aeval alpha (f_mod_N q N) = 0)
  (beta : K) (h_beta : beta_relation a q N alpha beta)
  (h_eq : 4 * (q : ZMod N) = (a : ZMod N)^2 + 27) :
  Polynomial.aeval beta (f_mod_N q N) = 0 := by
  have h_unit : IsUnit (2 * (a : K)) :=
    is_unit_2a a N (by exact h_N_odd) h_gcd K
  apply unit_pow_mul_eq_zero (2 * (a : K)) h_unit 3
  apply beta_scaled_eq_zero_fixed q a N K alpha h_root beta h_beta h_eq

/-
f is separable modulo N.
-/
lemma f_separable_fixed (q : ℕ) (N : ℕ) [Fact (Nat.Prime N)] (h_N_odd : Odd N) (h_N_ne_q : N ≠ q)
  (h_irr : Irreducible (f_mod_N q N)) :
  Polynomial.Separable (f_mod_N q N) := by
    convert f_separable q N h_N_odd h_N_ne_q h_irr using 1

/-
f is separable modulo N.
-/
lemma f_separable_general (q : ℕ) (N : ℕ) [Fact (Nat.Prime N)] [Fact (Nat.Prime q)] (h_N_odd : Odd N) (h_N_ne_q : N ≠ q)
  (h_irr : Irreducible (f_mod_N q N)) :
  Polynomial.Separable (f_mod_N q N) := by
    apply f_separable_fixed q N h_N_odd h_N_ne_q h_irr

/-
If alpha = beta, then g(alpha) = 0.
-/
lemma g_poly_root_proved (q : ℕ) (a : ℤ) (N : ℕ) [Fact (Nat.Prime N)]
  (K : Type*) [Field K] [Algebra (ZMod N) K]
  (alpha : K) (beta : K) (h_beta : beta_relation a q N alpha beta)
  (h_eq : alpha = beta) :
  Polynomial.aeval alpha (g_poly q a N) = 0 := by
    convert g_poly_root q a N K alpha beta h_beta h_eq

/-
Algebraic identity for the cyclic relation.
-/
lemma cyclic_identity_lemma_proved {R : Type*} [CommRing R] (a q : R) (alpha : R)
  (h_root : alpha^3 = q * alpha + q)
  (h_a2 : a^2 = 4 * q - 27) :
  let B := (6 * alpha^2 - (a + 9) * alpha - 4 * q)
  6 * B^2 + (a - 9) * (2 * a) * B + 8 * a^3 * alpha - 16 * a^2 * q = 0 := by
    grind +ring

/-
If beta is related to alpha, then gamma is related to beta.
-/
lemma cyclic_relation_proved (q : ℕ) (a : ℤ) (N : ℕ) [Fact (Nat.Prime N)] (h_N_odd : Odd N) (h_gcd : Int.gcd a N = 1)
  (K : Type*) [Field K] [Algebra (ZMod N) K]
  (alpha beta gamma : K)
  (h_root_alpha : Polynomial.aeval alpha (f_mod_N q N) = 0)
  (h_root_beta : Polynomial.aeval beta (f_mod_N q N) = 0)
  (h_root_gamma : Polynomial.aeval gamma (f_mod_N q N) = 0)
  (h_sum : alpha + beta + gamma = 0)
  (h_beta : beta_relation a q N alpha beta)
  (h_eq : 4 * (q : ZMod N) = (a : ZMod N)^2 + 27)
  (h_irr : Irreducible (f_mod_N q N))
  (h_N_ne_q : (q : ZMod N) ≠ 0)
  (h_a_ne_zero : (a : ZMod N) ≠ 0) :
  beta_relation a q N beta gamma := by
    -- Apply the cyclic_identity_lemma to beta.
    apply cyclic_relation q a N h_N_odd h_gcd K alpha beta gamma h_root_alpha h_root_beta h_root_gamma h_sum h_beta h_eq h_irr h_N_ne_q h_a_ne_zero

/-
Arithmetic verification of the orientation constant.
-/
lemma orientation_arithmetic_proved (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)]
  (h_eq : 4 * (q : ZMod q) = (a : ZMod q)^2 + 27)
  (h_a_ne_zero : (a : ZMod q) ≠ 0) :
  -(a + 9 : ZMod q) * (2 * a : ZMod q)⁻¹ = s2 q a := by
    convert orientation_arithmetic q a _ h_a_ne_zero using 1;
    norm_cast at *

/-
theta^3 = q*theta + q in the ring of integers.
-/
lemma theta_int_cubic (q : ℕ) :
  theta_int q ^ 3
    = (q : NumberField.RingOfIntegers (GlobalField q)) * theta_int q
      + (q : NumberField.RingOfIntegers (GlobalField q)) := by
        unfold theta_int;
        erw [ Subtype.mk_eq_mk ];
        have := theta_global_is_root q;
        unfold f_rat at this;
        simp_all +decide [ sub_eq_iff_eq_add' ];
        norm_cast

/-
q is in the ideal generated by theta^2.
-/
lemma q_mem_theta_sq_proved (q : ℕ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7) :
  (q : NumberField.RingOfIntegers (GlobalField q)) ∈ Ideal.span {theta_int q ^ 2} := by
    -- Apply the lemma that states q is in the ideal generated by theta^2.
    apply q_mem_theta_sq q h_q_ge_7

/-
2a and q are coprime.
-/
lemma coprime_2a_q_proved (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℤ) = a^2 + 27) :
  IsCoprime (2 * a) (q : ℤ) := by
    refine' IsCoprime.mul_left _ _;
    · exact Int.prime_two.coprime_iff_not_dvd.mpr ( by simpa [ ← even_iff_two_dvd, parity_simps ] using Nat.Prime.odd_of_ne_two ( Fact.out : Nat.Prime q ) ( by linarith ) );
    · have h_coprime : Int.gcd a q = 1 := by
        refine' Nat.coprime_of_dvd' _;
        intros k hk hk_a hk_q
        have hk_div_27 : k ∣ 27 := by
          rw [ ← Int.natCast_dvd_natCast ] at *;
          convert dvd_sub ( hk_q.mul_left 4 ) ( hk_a.pow two_ne_zero ) using 1 ; norm_num ; linarith;
        have := Nat.le_of_dvd ( by decide ) hk_div_27; interval_cases k <;> norm_num at *;
        rw [ Nat.dvd_prime Fact.out ] at hk_q ; aesop_cat;
      exact?

/-
There exists an inverse of 2a modulo theta^2.
-/
lemma exists_inv_2a_mod_theta_sq_proved (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27) :
  ∃ u : NumberField.RingOfIntegers (GlobalField q),
    (2 * a : NumberField.RingOfIntegers (GlobalField q)) * u - 1 ∈ Ideal.span {theta_int q ^ 2} := by
      exact?

/-
If a is invertible modulo I, and ax is in I, then x is in I.
-/
lemma ideal_cancel_of_unit_mod_proved {R : Type*} [CommRing R] (I : Ideal R) (a u : R)
  (h_inv : a * u - 1 ∈ I) (x : R) (h_mem : a * x ∈ I) : x ∈ I := by
    convert I.sub_mem ( I.mul_mem_left u h_mem ) ( I.mul_mem_left x h_inv ) using 1 ; ring

/-
Proof that beta is an algebraic integer.
-/
lemma beta_is_integral_proved (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27) : IsIntegral ℤ (beta_global q a) := by
    convert beta_is_integral q a h_q_ge_7 h_eq using 1

/-
Step 1 of orientation lemma: 2a * sigma(theta) is congruent to -(a+9)theta modulo theta^2.
-/
lemma lemma_orientation_step1_proved (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27) :
  let theta := theta_int q
  let sigma := sigma_int_global q a h_q_ge_7 h_eq
  (2 * a : NumberField.RingOfIntegers (GlobalField q)) * sigma theta - (-(a + 9 : ℤ)) • theta ∈ Ideal.span {theta^2} := by
    convert lemma_orientation_step1 q a h_q_ge_7 h_eq using 1

/-
Step 1 of orientation lemma: 2a * sigma(theta) is congruent to -(a+9)theta modulo theta^2.
-/
lemma lemma_orientation_step1_fixed (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27) :
  let theta := theta_int q
  let sigma := sigma_int_global q a h_q_ge_7 h_eq
  (2 * a : NumberField.RingOfIntegers (GlobalField q)) * sigma theta - (-(a + 9 : ℤ)) • theta ∈ Ideal.span {theta^2} := by
    convert lemma_orientation_step1_proved q a h_q_ge_7 ( by exact_mod_cast h_eq ) using 1

/-
The congruence 2a * s2 = -(a+9) holds in ZMod q.
-/
lemma s2_congruence_zmod_proved (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27) :
  (2 * (a : ZMod q)) * (s2 q a) = -((a : ZMod q) + 9) := by
    convert s2_congruence_zmod q a h_q_ge_7 _ using 1;
    norm_cast at *

/-
Step 2 of orientation lemma: 2a * s2 * theta is congruent to -(a+9)theta modulo theta^2.
-/
lemma lemma_orientation_step2_proved (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27) :
  let theta := theta_int q
  let s2 := s2_int q a
  (2 * a : NumberField.RingOfIntegers (GlobalField q)) * (s2 • theta) - (-(a + 9 : ℤ)) • theta ∈ Ideal.span {theta^2} := by
    exact?

/-
Step 1 of orientation lemma: 2a * sigma(theta) is congruent to -(a+9)theta modulo theta^2.
-/
lemma lemma_orientation_step1_final (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27) :
  let theta := theta_int q
  let sigma := sigma_int_global q a h_q_ge_7 h_eq
  (2 * a : NumberField.RingOfIntegers (GlobalField q)) * sigma theta - (-(a + 9 : ℤ)) • theta ∈ Ideal.span {theta^2} := by
    -- Apply the lemma_orientation_step1_fixed with the given parameters.
    apply lemma_orientation_step1_fixed q a h_q_ge_7 h_eq

/-
Checking existence of lemmas.
-/
#check lemma_orientation_step1_proved
#check lemma_orientation_step2_proved
#check exists_inv_2a_mod_theta_sq_proved
#check ideal_cancel_of_unit_mod_proved

/-
Step 2 of orientation lemma: 2a * s2 * theta is congruent to -(a+9)theta modulo theta^2.
-/
lemma lemma_orientation_step2_final (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27) :
  let theta := theta_int q
  let s2_val := s2_int q a
  (2 * a : NumberField.RingOfIntegers (GlobalField q)) * (s2_val • theta) - (-(a + 9 : ℤ)) • theta ∈ Ideal.span {theta^2} := by
    -- Apply the lemma lemma_orientation_step2_proved with the given hypotheses.
    apply lemma_orientation_step2_proved q a h_q_ge_7 h_eq

/-
The orientation lemma: sigma(theta) is congruent to s2 * theta modulo theta^2.
-/
lemma lemma_orientation_global_proved (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27) :
  let theta := theta_int q
  let s2 := s2_int q a
  let sigma := sigma_int_global q a h_q_ge_7 h_eq
  sigma theta - s2 • theta ∈ Ideal.span {theta^2} := by
  let theta := theta_int q
  let s2 := s2_int q a
  let sigma := sigma_int_global q a h_q_ge_7 h_eq
  let I := Ideal.span {theta^2}
  let Delta := sigma theta - s2 • theta
  
  -- Step 1: (2a) * sigma(theta) - (-(a+9))theta in I
  have h1 := lemma_orientation_step1_final q a h_q_ge_7 h_eq
  
  -- Step 2: (2a) * (s2 theta) - (-(a+9))theta in I
  have h2 := lemma_orientation_step2_final q a h_q_ge_7 h_eq
  
  -- Subtract: (2a) * sigma(theta) - (2a) * (s2 theta) in I
  -- (2a) * (sigma(theta) - s2 theta) in I
  have h_mem : (2 * a : NumberField.RingOfIntegers (GlobalField q)) * Delta ∈ I := by
    dsimp [Delta]
    rw [mul_sub]
    -- h1 - h2
    -- (2a sigma - X) - (2a s2 theta - X) = 2a sigma - 2a s2 theta
    convert Ideal.sub_mem I h1 h2 using 1
    ring
    
  -- Get inverse u
  have h_inv_ex := exists_inv_2a_mod_theta_sq_proved q a h_q_ge_7 h_eq
  rcases h_inv_ex with ⟨u, h_inv⟩
  
  -- Apply cancellation lemma
  apply ideal_cancel_of_unit_mod_proved I (2 * a) u h_inv Delta h_mem

/-
Checking if reciprocity_lemma_statement is defined.
-/
#check reciprocity_lemma_statement

/-
Definitions of beta and gamma as algebraic integers.
-/
noncomputable def beta_int (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27) : NumberField.RingOfIntegers (GlobalField q) :=
  ⟨beta_global q a, beta_is_integral_proved q a h_q_ge_7 h_eq⟩

noncomputable def gamma_int (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27) : NumberField.RingOfIntegers (GlobalField q) :=
  -theta_int q - beta_int q a h_q_ge_7 h_eq

/-
Integer representative of s1 in the range (-q/2, q/2].
-/
noncomputable def s1_int (q : ℕ) (a : ℤ) : ℤ :=
  let s1_zmod : ZMod q := s1 q a
  if s1_zmod.val ≤ q / 2 then (s1_zmod.val : ℤ) else (s1_zmod.val : ℤ) - (q : ℤ)

/-
Checking if lemma_s1s2 is defined.
-/
#check lemma_s1s2

/-
s1, s2, and 1 are distinct modulo q.
-/
lemma s1_s2_distinct_mod_q (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℤ) = a^2 + 27) :
  (s1 q a) ≠ (s2 q a) ∧ (s1 q a) ≠ 1 ∧ (s2 q a) ≠ 1 := by
    refine' ⟨ _, _, _ ⟩;
    · unfold s1 s2;
      by_contra h_contra;
      -- By simplifying, we can see that this equation implies $a = 0$, which contradicts $q \geq 7$.
      have ha_zero : (a : ZMod q) = 0 := by
        by_cases h : ( 6 : ZMod q ) = 0 <;> simp_all +decide [ sub_eq_iff_eq_add ];
        · rcases q with ( _ | _ | _ | _ | _ | _ | _ | q ) <;> cases h <;> trivial;
        · grind;
      rw [ ZMod.intCast_zmod_eq_zero_iff_dvd ] at ha_zero;
      obtain ⟨ k, hk ⟩ := ha_zero; replace h_eq := congr_arg ( fun x => x % ( q : ℤ ) ) h_eq; norm_num [ sq, Int.add_emod, Int.mul_emod, hk ] at h_eq;
      rw [ eq_comm ] at h_eq ; norm_cast at h_eq ; have := Nat.le_of_dvd ( by linarith ) ( Nat.dvd_of_mod_eq_zero h_eq ) ; interval_cases q <;> trivial;
    · unfold s1;
      by_contra h_contra;
      -- If $-a - 3 \equiv 6 \pmod{q}$, then $a \equiv -9 \pmod{q}$.
      have h_a_neg9 : (a : ZMod q) = -9 := by
        grind;
      replace h_eq := congr_arg ( ( ↑ ) : ℤ → ZMod q ) h_eq ; simp_all +decide [ sq ];
      norm_num at h_eq;
      erw [ eq_comm, ZMod.natCast_eq_zero_iff ] at h_eq ; have := Nat.le_of_dvd ( by decide ) h_eq ; interval_cases q <;> contradiction;
    · -- By definition of $s2$, if $s2 q a = 1$, then $2a * 1 = -(a + 9)$ implies $3a = -9$, which simplifies to $a = -3$.
      by_contra h_contra
      have ha : a = -3 := by
        have h_a_neg3 : (a : ZMod q) = -3 := by
          have h_a_neg3 : (2 * a : ZMod q) * 1 = -(a + 9) := by
            convert s2_congruence_zmod q a h_q_ge_7 ( mod_cast h_eq ) using 1 ; aesop;
          exact mul_left_cancel₀ ( show ( 3 : ZMod q ) ≠ 0 from by erw [ Ne.eq_def, ZMod.natCast_eq_zero_iff ] ; exact fun h => by have := Nat.le_of_dvd ( by linarith ) h; interval_cases q ) <| by linear_combination' h_a_neg3;
        replace h_eq := congr_arg ( ( ↑ ) : ℤ → ZMod q ) h_eq ; simp_all +decide [ pow_succ ] ;
        norm_num at h_eq;
        rw [ eq_comm ] at h_eq;
        erw [ ZMod.natCast_eq_zero_iff ] at h_eq ; have := Nat.le_of_dvd ( by decide ) h_eq ; interval_cases q <;> trivial;
      nlinarith [ show q > 15 by contrapose! h_eq; interval_cases q <;> subst ha <;> trivial ]

/-
s1, s2, and 1 are distinct modulo q.
-/
lemma s1_s2_distinct_mod_q_proved (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℤ) = a^2 + 27) :
  (s1 q a) ≠ (s2 q a) ∧ (s1 q a) ≠ 1 ∧ (s2 q a) ≠ 1 := by
    apply s1_s2_distinct_mod_q q a h_q_ge_7 (by
    exact h_eq)

/-
Cubic character chi.
-/
def chi (q : ℕ) (x : ZMod q) : ZMod q := x ^ ((q - 1) / 3)

lemma chi_mul (q : ℕ) (x y : ZMod q) : chi q (x * y) = chi q x * chi q y := by
  dsimp [chi]
  rw [mul_pow]

/-
s1 is not equal to s2 modulo q.
-/
lemma s1_ne_s2 (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℤ) = a^2 + 27) :
  s1 q a ≠ s2 q a := by
    have := s1_s2_distinct_mod_q_proved q a h_q_ge_7 ( by linarith ) ; aesop;

/-
s1, s2, and 1 are distinct modulo q.
-/
lemma s1_s2_distinct_mod_q_final (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℤ) = a^2 + 27) :
  (s1 q a) ≠ (s2 q a) ∧ (s1 q a) ≠ 1 ∧ (s2 q a) ≠ 1 := by
    exact s1_s2_distinct_mod_q_proved q a h_q_ge_7 ( mod_cast h_eq ) |> fun h => ⟨ h.1, h.2.1, h.2.2 ⟩

/-
Checking if s1_s2_distinct_mod_q is defined.
-/
#check s1_s2_distinct_mod_q

/-
s2 squared is s1.
-/
lemma s2_sq_eq_s1_general (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_eq : 4 * (q : ℤ) = a^2 + 27) :
  (s2 q a)^2 = s1 q a := by
    unfold s1 s2;
    have h_simp : (a - 3 : ZMod q) ^ 2 = (-a - 3 : ZMod q) * 6 := by
      replace h_eq := congr_arg ( ( ↑ ) : ℤ → ZMod q ) h_eq ; norm_num at h_eq ; linear_combination' h_eq.symm;
    by_cases h : ( 6 : ZMod q ) = 0 <;> simp_all +decide [ sq, mul_assoc ];
    grind

/-
c(N) is 1, s1, or s2.
-/
lemma c_value_mem_roots (q : ℕ) (a : ℤ) (N : ℕ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℤ) = a^2 + 27) (hN : (N : ZMod q) ≠ 0) :
  c_value q N = 1 ∨ c_value q N = s1 q a ∨ c_value q N = s2 q a := by
    -- By definition of $c_value$, we know that $c_value q N$ is a root of $x^3 - 1$.
    have hc_root : (c_value q N)^3 = 1 := by
      unfold c_value;
      rw [ ← pow_mul, Nat.div_mul_cancel ];
      · exact ZMod.pow_card_sub_one_eq_one hN;
      · rw [ ← Nat.mod_add_div q 3 ] at *; have := Nat.mod_lt q three_pos; interval_cases q % 3 <;> norm_num at *;
        · exact absurd ( Fact.out ( p := Nat.Prime ( 3 * ( q / 3 ) ) ) ) ( Nat.not_prime_mul ( by decide ) ( by linarith ) );
        · exact absurd ( congr_arg ( · % 3 ) h_eq ) ( by norm_num [ sq, Int.add_emod, Int.mul_emod ] ; have := Int.emod_nonneg a three_pos.ne'; have := Int.emod_lt_of_pos a three_pos; interval_cases a % 3 <;> trivial );
    have h_poly : (s1 q a + s2 q a = -1) ∧ (s1 q a * s2 q a = 1) := by
      have h_poly : s1 q a + s2 q a = -1 := by
        unfold s1 s2; ring;
        field_simp;
        rw [ div_eq_iff ] <;> norm_num ; ring;
        erw [ ZMod.natCast_eq_zero_iff ] ; intro H; have := Nat.le_of_dvd ( by linarith ) H; interval_cases q ;
      have h_poly' : s1 q a * s2 q a = 1 := by
        have h_poly' : s2 q a ^ 2 = s1 q a := by
          exact?
        generalize_proofs at *; (
        grind +ring)
      exact ⟨h_poly, h_poly'⟩

    grind +ring

/-
Checking if s1_s2_distinct_mod_q_proved is defined.
-/
#check s1_s2_distinct_mod_q_proved

/-
Multiplicativity of the cubic character.
-/
lemma chi_mul_proved (q : ℕ) (x y : ZMod q) : chi q (x * y) = chi q x * chi q y := by
  dsimp [chi]
  rw [mul_pow]

/-
beta is in the ideal generated by theta.
-/
lemma beta_mem_ideal_theta (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27) :
  beta_int q a h_q_ge_7 h_eq ∈ Ideal.span {theta_int q} := by
    by_contra h_contra;
    convert lemma_orientation_global_proved q a h_q_ge_7 ( show ( 4 : ℚ ) * q = a ^ 2 + 27 by exact mod_cast h_eq ) using 1;
    constructor <;> intro h <;> simp_all +decide [ Ideal.mem_span_singleton ];
    obtain ⟨ k, hk ⟩ := h;
    refine' h_contra _;
    refine' ⟨ k * theta_int q + ( s2_int q a : ℤ ) • 1, _ ⟩;
    rw [ show beta_int q a h_q_ge_7 h_eq = sigma_int_global q a h_q_ge_7 ( mod_cast h_eq ) ( theta_int q ) from ?_ ];
    · convert eq_add_of_sub_eq hk using 1 ; ring;
    · exact Eq.symm ( by rw [ show sigma_int_global q a h_q_ge_7 ( mod_cast h_eq ) ( theta_int q ) = beta_int q a h_q_ge_7 h_eq from by exact Subtype.ext <| by exact sigma_global_spec q a h_q_ge_7 ( mod_cast h_eq ) ] )

/-
beta is in the ideal generated by theta.
-/
lemma beta_mem_ideal_theta_proved (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27) :
  beta_int q a h_q_ge_7 h_eq ∈ Ideal.span {theta_int q} := by
    convert beta_mem_ideal_theta q a h_q_ge_7 ( by exact_mod_cast h_eq ) using 1

/-
gamma is congruent to s1 * theta modulo theta^2.
-/
lemma gamma_congruence (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27) :
  gamma_int q a h_q_ge_7 h_eq - (s1_int q a) • theta_int q ∈ Ideal.span {theta_int q ^ 2} := by
    -- We have $s1 + s2 = -1$.
    have h_sum : (s2 q a : ZMod q) + (s1 q a : ZMod q) = -1 := by
      rw [ ← eq_sub_iff_add_eq' ];
      unfold s1 s2; ring;
      have h_div : (6 : ZMod q) ≠ 0 := by
        exact by erw [ Ne.eq_def, ZMod.natCast_eq_zero_iff ] ; exact Nat.not_dvd_of_pos_of_lt ( by norm_num ) ( by linarith ) ;
      generalize_proofs at *; (
      grind);
    -- Using the orientation lemma and the sum of s1 and s2, we get:
    have h_orientation : (gamma_int q a h_q_ge_7 h_eq : NumberField.RingOfIntegers (GlobalField q)) - (-1 - s2_int q a) • theta_int q ∈ Ideal.span {theta_int q ^ 2} := by
      have h_orientation : (beta_int q a h_q_ge_7 h_eq : NumberField.RingOfIntegers (GlobalField q)) - s2_int q a • theta_int q ∈ Ideal.span {theta_int q ^ 2} := by
        convert lemma_orientation_global_proved q a h_q_ge_7 ( mod_cast h_eq ) using 1;
        congr! 1
        generalize_proofs at *;
        exact Subtype.ext <| sigma_global_spec q a h_q_ge_7 h_eq |> Eq.symm;
      convert Submodule.neg_mem _ h_orientation using 1 ; ext ; norm_num ; ring!;
      unfold gamma_int beta_int; norm_num; ring;
    -- Using the sum of s1 and s2, we can rewrite $-1 - s2_int q a$ as $s1_int q a$.
    have h_rewrite : (-1 - s2_int q a : ℤ) ≡ (s1_int q a : ℤ) [ZMOD q] := by
      unfold s1_int s2_int; simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ] ;
      linear_combination' -h_sum;
    -- Since $q \in \theta^2$, we have $q \cdot \theta \in \theta^3$.
    have h_q_theta : (q : NumberField.RingOfIntegers (GlobalField q)) • theta_int q ∈ Ideal.span {theta_int q ^ 2} := by
      have h_q_theta : (q : NumberField.RingOfIntegers (GlobalField q)) ∈ Ideal.span {theta_int q ^ 2} := by
        convert q_mem_theta_sq_proved q h_q_ge_7 using 1;
      exact Ideal.mul_mem_right _ _ h_q_theta;
    obtain ⟨ k, hk ⟩ := h_rewrite.symm.dvd;
    convert Ideal.add_mem _ h_orientation ( Ideal.mul_mem_left _ ( k : NumberField.RingOfIntegers ( GlobalField q ) ) h_q_theta ) using 1 ; ext ; norm_num ; ring;
    rw [ show ( s1_int q a : ℤ ) = -1 - s2_int q a - q * k by linarith ] ; norm_num ; ring

/-
If q divides k, then k is in the ideal generated by theta.
-/
lemma int_mem_ideal_theta_of_dvd (q : ℕ) (k : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_dvd : (q : ℤ) ∣ k) :
  (k : NumberField.RingOfIntegers (GlobalField q)) ∈ Ideal.span {theta_int q} := by
    have h_mul_q_div : (q : NumberField.RingOfIntegers (GlobalField q)) ∈ Ideal.span {theta_int q} := by
      have := q_mem_theta_sq_proved q;
      exact Ideal.span_le.mpr ( Set.singleton_subset_iff.mpr <| Ideal.mem_span_singleton.mpr <| dvd_pow_self _ two_ne_zero ) ( this h_q_ge_7 );
    obtain ⟨ m, rfl ⟩ := h_dvd; simp_all +decide [ Ideal.mem_span_singleton ] ;
    exact dvd_mul_of_dvd_left h_mul_q_div _

/-
The minimal polynomial of theta is f_rat.
-/
lemma minpoly_theta_eq (q : ℕ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7) :
  minpoly ℚ (theta_global q) = f_rat q := by
    refine' Eq.symm ( minpoly.eq_of_irreducible_of_monic _ _ _ );
    · convert f_rat_irreducible q ( by linarith ) using 1

    · exact?;
    · unfold f_rat; erw [ Polynomial.Monic, Polynomial.leadingCoeff ] ; erw [ Polynomial.natDegree_sub_C ] ; erw [ Polynomial.natDegree_sub_eq_left_of_natDegree_lt ] <;> norm_num;
      erw [ Polynomial.natDegree_C_mul_X ] <;> norm_num ; linarith

/-
Checking if lemmas are defined.
-/
#check s1_s2_distinct_mod_q
#check s1_s2_distinct_mod_q_proved

/-
Discriminant of X^3 + pX + q is -4p^3 - 27q^2.
-/
lemma disc_cubic_reduced (p q : ℚ) :
  (Polynomial.X^3 + Polynomial.C p * Polynomial.X + Polynomial.C q).disc = -4 * p^3 - 27 * q^2 := by
    -- The discriminant of a cubic polynomial $X^3 + aX^2 + bX + c$ is given by $\Delta = 18abc - 4b^3 - 4a^3c - 27c^2 + a^2b^2$.
    have h_discriminant_formula : ∀ (a b c : ℚ), Polynomial.disc (Polynomial.X^3 + Polynomial.C a * Polynomial.X^2 + Polynomial.C b * Polynomial.X + Polynomial.C c) = 18 * a * b * c - 4 * b^3 - 4 * a^3 * c - 27 * c^2 + a^2 * b^2 := by
      intro a b c;
      convert Polynomial.disc_of_degree_eq_three _ using 1;
      · norm_num [ Polynomial.coeff_X, Polynomial.coeff_C ] ; ring;
      · rw [ Polynomial.degree_add_C ] <;> erw [ Polynomial.degree_add_eq_left_of_degree_lt ] <;> erw [ Polynomial.degree_add_eq_left_of_degree_lt ] <;> by_cases ha : a = 0 <;> by_cases hb : b = 0 <;> simp +decide [ ha, hb ];
    convert h_discriminant_formula 0 p q using 1 ; norm_num ; ring;

/-
The discriminant of f_rat is a square.
-/
lemma disc_f_rat_eq_sq (q : ℕ) (a : ℤ) (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27) :
  (f_rat q).disc = (q * a : ℚ)^2 := by
    -- Let's simplify the expression for the discriminant.
    have h_discriminant_simplified : (Polynomial.X^3 - Polynomial.C (q : ℚ) * Polynomial.X - Polynomial.C (q : ℚ)).disc = (-4 * (-q : ℚ)^3 - 27 * (-q : ℚ)^2) := by
      convert disc_cubic_reduced ( -q ) ( -q ) using 1 ; norm_num [ Polynomial.coeff_eq_zero_of_natDegree_lt ];
      exact?;
    convert h_discriminant_simplified using 1 ; ring! ; norm_cast ; ring;
    push_cast [ ← @Int.cast_inj ℚ ] at * ; nlinarith

/-
Checking if disc_f_rat_eq_sq is defined.
-/
#check disc_f_rat_eq_sq

/-
Helper lemma for discriminant calculation.
-/
lemma disc_val_helper (q : ℚ) (a : ℚ) (h : 4 * q = a^2 + 27) :
  -4 * (-q)^3 - 27 * (-q)^2 = (q * a)^2 := by
  have h1 : -4 * (-q)^3 = 4 * q^3 := by ring
  have h2 : 27 * (-q)^2 = 27 * q^2 := by ring
  rw [h1, h2]
  have h3 : 4 * q^3 - 27 * q^2 = q^2 * (4 * q - 27) := by ring
  rw [h3]
  have h4 : 4 * q - 27 = a^2 := by linarith
  rw [h4]
  ring

/-
Checking if Module.finrank is available.
-/
#check Module.finrank

/-
Checking existence of definitions.
-/
#check f_rat
#check GlobalField
#check f_rat_irreducible

/-
Checking Module.finrank.
-/
#check Module.finrank

/-
beta is in the algebra generated by theta.
-/
lemma beta_in_adjoin (q : ℕ) (a : ℤ) :
  beta_global q a ∈ Algebra.adjoin ℚ {theta_global q} := by
    refine' Subalgebra.mul_mem _ _ _;
    · exact Subalgebra.sub_mem _ ( Subalgebra.sub_mem _ ( Subalgebra.mul_mem _ ( Subalgebra.algebraMap_mem _ _ ) ( Subalgebra.pow_mem _ ( Algebra.subset_adjoin <| Set.mem_singleton _ ) _ ) ) ( Subalgebra.smul_mem _ ( Algebra.subset_adjoin <| Set.mem_singleton _ ) _ ) ) ( Subalgebra.mul_mem _ ( Subalgebra.algebraMap_mem _ _ ) ( Subalgebra.algebraMap_mem _ _ ) );
    · exact Subalgebra.algebraMap_mem _ _

/-
gamma is a root of f_rat.
-/
lemma gamma_global_is_root (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27) :
  Polynomial.aeval (gamma_global q a) (f_rat q) = 0 := by
    unfold gamma_global;
    unfold f_rat;
    have h_gamma_root : Polynomial.aeval (R := ℚ) (theta_global q) (Polynomial.X ^ 3 - Polynomial.C (q : ℚ) * Polynomial.X - Polynomial.C (q : ℚ)) = 0 ∧ Polynomial.aeval (R := ℚ) (beta_global q a) (Polynomial.X ^ 3 - Polynomial.C (q : ℚ) * Polynomial.X - Polynomial.C (q : ℚ)) = 0 := by
      exact ⟨ theta_global_is_root q, beta_global_is_root q a h_q_ge_7 h_eq ⟩;
    norm_num [ Polynomial.aeval_def ] at *;
    have h_gamma_root : theta_global q ^ 2 + theta_global q * beta_global q a + beta_global q a ^ 2 = q := by
      have h_gamma_root : theta_global q ≠ beta_global q a := by
        apply alpha_ne_beta_global q a h_q_ge_7 h_eq;
      grind;
    grind +ring

/-
gamma is in the algebra generated by theta.
-/
lemma gamma_in_adjoin (q : ℕ) (a : ℤ) :
  gamma_global q a ∈ Algebra.adjoin ℚ {theta_global q} := by
  dsimp [gamma_global]
  apply Subalgebra.sub_mem
  · apply Subalgebra.neg_mem
    apply Algebra.self_mem_adjoin_singleton
  · apply beta_in_adjoin

/-
If 4q = a^2 + 27, then q >= 7.
-/
lemma q_ge_7_of_eq (q : ℕ) (a : ℤ) (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27) : q ≥ 7 := by
  exact_mod_cast ( by nlinarith : ( 6 : ℚ ) < q )

/-
If c * theta is divisible by theta^2, then c is divisible by q.
-/
lemma coeff_unique_mod_theta_sq (q : ℕ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7) (c : ℤ)
  (h_mem : (c : NumberField.RingOfIntegers (GlobalField q)) * theta_int q ∈ Ideal.span {theta_int q ^ 2}) :
  (q : ℤ) ∣ c := by
    -- Since $c * \theta \in (\theta^2)$, we have $c \in (\theta)$.
    have h_c_in_theta : (c : NumberField.RingOfIntegers (GlobalField q)) ∈ Ideal.span {theta_int q} := by
      rw [ Ideal.mem_span_singleton ] at *;
      obtain ⟨ k, hk ⟩ := h_mem;
      -- Since $\theta$ is non-zero, we can divide both sides of the equation by $\theta$.
      have h_div : theta_int q ≠ 0 := by
        have := theta_int_cubic q; simp_all +decide [ pow_succ ] ;
        rw [ eq_comm ] at this ; aesop;
      exact ⟨ k, mul_left_cancel₀ h_div <| by linear_combination' hk ⟩;
    -- Since $c \in (\theta)$, we have $c^3 \in (\theta^3)$.
    have h_c_cubed_in_theta_cubed : (c : NumberField.RingOfIntegers (GlobalField q)) ^ 3 ∈ Ideal.span {theta_int q ^ 3} := by
      rw [ Ideal.mem_span_singleton ] at *;
      exact pow_dvd_pow_of_dvd h_c_in_theta 3;
    -- Since $\theta^3 = q\theta + q$, we have $\theta^3 \in (q)$.
    have h_theta_cubed_in_q : theta_int q ^ 3 ∈ Ideal.span {(q : NumberField.RingOfIntegers (GlobalField q))} := by
      rw [ Ideal.mem_span_singleton ];
      exact ⟨ theta_int q + 1, by rw [ theta_int_cubic ] ; ring ⟩;
    -- Since $\theta^3 \in (q)$, we have $c^3 \in (q)$.
    have h_c_cubed_in_q : (c : NumberField.RingOfIntegers (GlobalField q)) ^ 3 ∈ Ideal.span {(q : NumberField.RingOfIntegers (GlobalField q))} := by
      exact Ideal.span_le.mpr ( Set.singleton_subset_iff.mpr h_theta_cubed_in_q ) h_c_cubed_in_theta_cubed;
    rw [ Ideal.mem_span_singleton ] at h_c_cubed_in_q;
    obtain ⟨ k, hk ⟩ := h_c_cubed_in_q;
    replace hk := congr_arg ( algebraMap ( NumberField.RingOfIntegers ( GlobalField q ) ) ( GlobalField q ) ) hk ; norm_num at hk;
    -- Since $q$ is prime and $q \mid c^3$, it follows that $q \mid c$.
    have h_div : (q : ℤ) ∣ c ^ 3 := by
      -- Since $k$ is an algebraic integer, its image under the algebra map is also an algebraic integer.
      have h_k_alg_int : IsIntegral ℤ (algebraMap (NumberField.RingOfIntegers (GlobalField q)) (GlobalField q) k) := by
        exact k.2;
      -- Since $k$ is an algebraic integer, its image under the algebra map is also an algebraic integer, and hence an integer.
      obtain ⟨m, hm⟩ : ∃ m : ℤ, algebraMap (NumberField.RingOfIntegers (GlobalField q)) (GlobalField q) k = m := by
        have h_k_int : IsIntegral ℤ (algebraMap (NumberField.RingOfIntegers (GlobalField q)) (GlobalField q) k) ∧ algebraMap (NumberField.RingOfIntegers (GlobalField q)) (GlobalField q) k ∈ Set.range (algebraMap ℚ (GlobalField q)) := by
          exact ⟨ h_k_alg_int, ⟨ c ^ 3 / q, by simp +decide [ hk, mul_div_cancel_left₀, show q ≠ 0 by linarith ] ⟩ ⟩;
        obtain ⟨m, hm⟩ : ∃ m : ℚ, algebraMap (NumberField.RingOfIntegers (GlobalField q)) (GlobalField q) k = m := by
          simpa [ eq_comm ] using h_k_int.2;
        have h_m_int : IsIntegral ℤ m := by
          aesop;
        obtain ⟨ m, hm ⟩ := IsIntegrallyClosed.isIntegral_iff.mp h_m_int;
        aesop;
      exact ⟨ m, by simpa [ ← @Int.cast_inj ( GlobalField q ) ] using hk.trans ( by rw [ hm ] ) ⟩;
    exact Int.Prime.dvd_pow' ( Fact.out : Nat.Prime q ) h_div

/-
The roots theta, beta, gamma are distinct modulo theta^2.
-/
lemma roots_distinct_mod_theta_sq (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27) :
  let theta := theta_int q
  let beta := beta_int q a h_q_ge_7 h_eq
  let gamma := gamma_int q a h_q_ge_7 h_eq
  (theta - beta ∉ Ideal.span {theta^2}) ∧
  (theta - gamma ∉ Ideal.span {theta^2}) ∧
  (beta - gamma ∉ Ideal.span {theta^2}) := by
    have h_orientation : let theta := theta_int q;
      let beta := beta_int q a h_q_ge_7 h_eq;
      let gamma := gamma_int q a h_q_ge_7 h_eq;
      beta - s2_int q a • theta ∈ Ideal.span {theta^2} ∧
      gamma - s1_int q a • theta ∈ Ideal.span {theta^2} := by
        apply And.intro;
        · have h_beta_mod : beta_int q a h_q_ge_7 h_eq = sigma_int_global q a h_q_ge_7 h_eq (theta_int q) := by
            exact Eq.symm ( by exact Subtype.ext <| by exact Classical.choose_spec ( exists_sigma_global q a h_q_ge_7 h_eq ) );
          exact h_beta_mod.symm ▸ lemma_orientation_global_proved q a h_q_ge_7 ( mod_cast h_eq );
        · apply gamma_congruence q a h_q_ge_7 h_eq;
    have h_distinct_mod_q : (1 - s2_int q a : ℤ) % q ≠ 0 ∧ (1 - s1_int q a : ℤ) % q ≠ 0 ∧ (s2_int q a - s1_int q a : ℤ) % q ≠ 0 := by
      have h_distinct_mod_q : (1 : ZMod q) ≠ s2 q a ∧ (1 : ZMod q) ≠ s1 q a ∧ (s2 q a : ZMod q) ≠ s1 q a := by
        have := s1_s2_distinct_mod_q q a h_q_ge_7 ( by simpa [ ← @Int.cast_inj ℚ ] using h_eq ) ; aesop;
      simp_all +decide [ ← ZMod.intCast_zmod_eq_zero_iff_dvd, s2_int, s1_int ];
      exact ⟨ sub_ne_zero_of_ne h_distinct_mod_q.1, sub_ne_zero_of_ne h_distinct_mod_q.2.1, sub_ne_zero_of_ne h_distinct_mod_q.2.2 ⟩;
    refine' ⟨ fun h => _, fun h => _, fun h => _ ⟩;
    · have h_coeff : (1 - s2_int q a : ℤ) • theta_int q ∈ Ideal.span {theta_int q ^ 2} := by
        convert Ideal.add_mem _ h h_orientation.1 using 1 ; simp +decide [ sub_smul ];
      have := coeff_unique_mod_theta_sq q h_q_ge_7 ( 1 - s2_int q a ) ?_;
      · exact h_distinct_mod_q.1 ( Int.emod_eq_zero_of_dvd this );
      · grind;
    · have h_coeff : (1 - s1_int q a : ℤ) • theta_int q ∈ Ideal.span {theta_int q ^ 2} := by
        convert Ideal.add_mem _ h h_orientation.2 using 1 ; simp +decide [ sub_smul ];
      have h_coeff_div : (q : ℤ) ∣ (1 - s1_int q a) := by
        convert coeff_unique_mod_theta_sq q h_q_ge_7 ( 1 - s1_int q a ) _;
        grind;
      exact h_distinct_mod_q.2.1 ( Int.emod_eq_zero_of_dvd h_coeff_div );
    · have h_coeff : (s2_int q a - s1_int q a : ℤ) • theta_int q ∈ Ideal.span {theta_int q ^ 2} := by
        convert Ideal.sub_mem _ h ( Ideal.sub_mem _ h_orientation.1 h_orientation.2 ) using 1 ; simp +decide [ sub_smul ];
        ring;
      have := coeff_unique_mod_theta_sq q h_q_ge_7 ( s2_int q a - s1_int q a ) ?_ <;> simp_all +decide

/-
The roots of f in the ring of integers are theta, beta, gamma.
-/
lemma roots_of_f_in_integers (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27)
  (x : NumberField.RingOfIntegers (GlobalField q))
  (h_root : Polynomial.aeval x (f_poly q) = 0) :
  x = theta_int q ∨ x = beta_int q a h_q_ge_7 h_eq ∨ x = gamma_int q a h_q_ge_7 h_eq := by
    have h_distinct_roots : theta_int q ≠ beta_int q a h_q_ge_7 h_eq ∧ theta_int q ≠ gamma_int q a h_q_ge_7 h_eq ∧ beta_int q a h_q_ge_7 h_eq ≠ gamma_int q a h_q_ge_7 h_eq := by
      have := roots_distinct_mod_theta_sq q a h_q_ge_7 h_eq;
      exact ⟨ fun h => this.1 <| by rw [ h ] ; norm_num, fun h => this.2.1 <| by rw [ h ] ; norm_num, fun h => this.2.2 <| by rw [ h ] ; norm_num ⟩;
    have h_roots_set : ∀ x : GlobalField q, Polynomial.aeval x (f_rat q) = 0 → x = theta_global q ∨ x = beta_global q a ∨ x = gamma_global q a := by
      intro x hx_root
      have h_vieta_sum : theta_global q + beta_global q a + gamma_global q a = 0 := by
        unfold beta_global gamma_global; ring;
        unfold beta_global; ring;
      have h_vieta_prod_sum : theta_global q * beta_global q a + beta_global q a * gamma_global q a + gamma_global q a * theta_global q = -q := by
        have h_vieta_prod_sum : theta_global q * beta_global q a + beta_global q a * gamma_global q a + gamma_global q a * theta_global q = -q := by
          have h_poly_eq : (theta_global q)^3 = q * theta_global q + q := by
            have h_poly_eq : Polynomial.aeval (R := ℚ) (theta_global q) (f_rat q) = 0 := by
              exact theta_global_is_root q;
            unfold f_rat at h_poly_eq; norm_num at h_poly_eq; linear_combination' h_poly_eq;
          have h_poly_eq_beta : (beta_global q a)^3 = q * beta_global q a + q := by
            have h_poly_eq_beta : Polynomial.aeval (beta_global q a) (f_rat q) = 0 := by
              convert beta_global_is_root q a h_q_ge_7 h_eq using 1;
            unfold f_rat at h_poly_eq_beta; norm_num at h_poly_eq_beta; linear_combination' h_poly_eq_beta;
          have h_poly_eq_gamma : (gamma_global q a)^3 = q * gamma_global q a + q := by
            have h_poly_eq_gamma : gamma_global q a ^ 3 = q * gamma_global q a + q := by
              have := gamma_global_is_root q a h_q_ge_7 h_eq
              unfold f_rat at this; norm_num at this; linear_combination' this;
            exact h_poly_eq_gamma
          refine' mul_left_cancel₀ ( sub_ne_zero_of_ne ( show theta_global q ≠ beta_global q a from _ ) ) _;
          · exact fun h => h_distinct_roots.1 <| Subtype.ext h;
          · grind;
        exact h_vieta_prod_sum
      have h_vieta_prod : theta_global q * beta_global q a * gamma_global q a = q := by
        have h_vieta_prod : Polynomial.aeval (R := ℚ) (theta_global q) (f_rat q) = 0 := by
          exact theta_global_is_root q;
        unfold f_rat at h_vieta_prod; norm_num at h_vieta_prod; linear_combination h_vieta_prod - h_vieta_sum * theta_global q ^ 2 + h_vieta_prod_sum * theta_global q;
      unfold f_rat at hx_root; simp_all +decide [ sub_eq_iff_eq_add ] ;
      exact Classical.or_iff_not_imp_left.2 fun hx => Classical.or_iff_not_imp_left.2 fun hx' => mul_left_cancel₀ ( sub_ne_zero_of_ne hx ) <| mul_left_cancel₀ ( sub_ne_zero_of_ne hx' ) <| by linear_combination hx_root - h_vieta_sum * x^2 + h_vieta_prod_sum * x - h_vieta_prod;
    convert h_roots_set x _;
    · constructor <;> intro h <;> aesop;
    · aesop;
    · constructor <;> intro h <;> simp_all +decide ;
      · exact?;
      · exact Subtype.ext h;
    · convert congr_arg ( algebraMap ( NumberField.RingOfIntegers ( GlobalField q ) ) ( GlobalField q ) ) h_root using 1;
      unfold f_rat f_poly; aesop;

/-
If a root x is congruent to c * theta mod theta^2, and c is s1 or s2, then x is determined.
-/
lemma root_determined_by_congruence (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27)
  (x : NumberField.RingOfIntegers (GlobalField q))
  (h_root : Polynomial.aeval x (f_poly q) = 0)
  (c : ℤ)
  (h_cong : x - (c : NumberField.RingOfIntegers (GlobalField q)) • theta_int q ∈ Ideal.span {theta_int q ^ 2})
  (h_c_val : c = s1_int q a ∨ c = s2_int q a) :
  (c = s1_int q a → x = gamma_int q a h_q_ge_7 h_eq) ∧
  (c = s2_int q a → x = beta_int q a h_q_ge_7 h_eq) := by
    refine' ⟨ _, _ ⟩;
    · intro hc
      have h_x_gamma : x - gamma_int q a h_q_ge_7 h_eq ∈ Ideal.span {theta_int q ^ 2} := by
        have h_gamma_cong : gamma_int q a h_q_ge_7 h_eq - (s1_int q a) • theta_int q ∈ Ideal.span {theta_int q ^ 2} := by
          exact?;
        simpa [ hc ] using Ideal.sub_mem _ h_cong h_gamma_cong;
      obtain ⟨hx, hx_beta, hx_gamma⟩ : (x = theta_int q ∨ x = beta_int q a h_q_ge_7 h_eq ∨ x = gamma_int q a h_q_ge_7 h_eq) ∧ (theta_int q - beta_int q a h_q_ge_7 h_eq ∉ Ideal.span {theta_int q ^ 2}) ∧ (theta_int q - gamma_int q a h_q_ge_7 h_eq ∉ Ideal.span {theta_int q ^ 2}) ∧ (beta_int q a h_q_ge_7 h_eq - gamma_int q a h_q_ge_7 h_eq ∉ Ideal.span {theta_int q ^ 2}) := by
        exact ⟨ roots_of_f_in_integers q a h_q_ge_7 h_eq x h_root, roots_distinct_mod_theta_sq q a h_q_ge_7 h_eq |> And.left, roots_distinct_mod_theta_sq q a h_q_ge_7 h_eq |> And.right |> And.left, roots_distinct_mod_theta_sq q a h_q_ge_7 h_eq |> And.right |> And.right ⟩;
      rcases hx with ( rfl | rfl | rfl ) <;> simp_all +decide;
    · intro hc
      have h_beta : x - beta_int q a h_q_ge_7 h_eq ∈ Ideal.span {theta_int q ^ 2} := by
        convert Ideal.sub_mem _ h_cong ( lemma_orientation_global_proved q a h_q_ge_7 h_eq ) using 1 ; ring!;
        rw [ show sigma_int_global q a h_q_ge_7 h_eq ( theta_int q ) = beta_int q a h_q_ge_7 h_eq from ?_ ] ; ring!;
        · simp +decide [ hc, sub_eq_add_neg, add_assoc ];
          rw [ neg_add_eq_zero, mul_comm ];
        · exact Subtype.ext <| sigma_global_spec q a h_q_ge_7 h_eq;
      have h_distinct : x = theta_int q ∨ x = beta_int q a h_q_ge_7 h_eq ∨ x = gamma_int q a h_q_ge_7 h_eq := by
        convert roots_of_f_in_integers q a h_q_ge_7 ( mod_cast h_eq ) x h_root using 1;
      have h_distinct : theta_int q - beta_int q a h_q_ge_7 h_eq ∉ Ideal.span {theta_int q ^ 2} ∧ gamma_int q a h_q_ge_7 h_eq - beta_int q a h_q_ge_7 h_eq ∉ Ideal.span {theta_int q ^ 2} := by
        have := roots_distinct_mod_theta_sq q a h_q_ge_7 h_eq;
        exact ⟨ this.1, fun h => this.2.2 <| by simpa using Submodule.neg_mem _ h ⟩;
      aesop

/-
If a root x is congruent to c * theta mod theta^2, and c is s1 or s2, then x is determined.
-/
lemma root_determined_by_congruence_v2 (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27)
  (x : NumberField.RingOfIntegers (GlobalField q))
  (h_root : Polynomial.aeval x (f_poly q) = 0)
  (c : ℤ)
  (h_cong : x - (c : NumberField.RingOfIntegers (GlobalField q)) • theta_int q ∈ Ideal.span {theta_int q ^ 2})
  (h_c_val : c = s1_int q a ∨ c = s2_int q a) :
  (c = s1_int q a → x = gamma_int q a h_q_ge_7 h_eq) ∧
  (c = s2_int q a → x = beta_int q a h_q_ge_7 h_eq) := by
    apply_rules [ root_determined_by_congruence ]

/-
If a root x is congruent to c * theta mod theta^2, and c is s1 or s2, then x is determined.
-/
lemma root_determined_v3 (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27)
  (x : NumberField.RingOfIntegers (GlobalField q))
  (h_root : Polynomial.aeval x (f_poly q) = 0)
  (c : ℤ)
  (h_cong : x - c • theta_int q ∈ Ideal.span {theta_int q ^ 2})
  (h_c_val : c = s1_int q a ∨ c = s2_int q a) :
  (c = s1_int q a → x = gamma_int q a h_q_ge_7 h_eq) ∧
  (c = s2_int q a → x = beta_int q a h_q_ge_7 h_eq) := by
    apply_rules [ root_determined_by_congruence ];
    convert h_cong using 1;
    norm_num [ Algebra.smul_def ]

/-
The general theorem: if c=s1, then theta^N = gamma; if c=s2, then theta^N = beta.
-/
theorem final_result_general (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)]
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27)
  (N : ℕ) [Fact (Nat.Prime N)] (h_N_odd : N % 2 = 1) (h_N_ne_q : N ≠ q) (h_gcd : Int.gcd a N = 1)
  (P : Ideal (NumberField.RingOfIntegers (GlobalField q))) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_recip : reciprocity_lemma_statement q N) :
  let h_q_ge_7 : q ≥ 7 := q_ge_7_of_eq q a h_eq
  let theta_bar := Ideal.Quotient.mk P (theta_int q)
  let beta_bar := Ideal.Quotient.mk P (beta_int q a h_q_ge_7 h_eq)
  let gamma_bar := Ideal.Quotient.mk P (gamma_int q a h_q_ge_7 h_eq)
  (c_value q N = s1 q a → theta_bar ^ N = gamma_bar) ∧
  (c_value q N = s2 q a → theta_bar ^ N = beta_bar) := by
    obtain ⟨phi, hphi⟩ := h_recip P hP;
    -- By definition of `phi`, we know that `phi(theta_int q)` is a root of `f_poly`.
    have h_root : Polynomial.aeval (phi (theta_int q)) (f_poly q) = 0 := by
      have h_root : Polynomial.aeval (theta_int q) (f_poly q) = 0 := by
        have := theta_int_cubic q;
        unfold f_poly; aesop;
      convert congr_arg ( phi : NumberField.RingOfIntegers ( GlobalField q ) → NumberField.RingOfIntegers ( GlobalField q ) ) h_root using 1;
      · simp +decide [ Polynomial.aeval_def, Polynomial.eval₂_eq_sum_range ];
      · norm_num +zetaDelta at *;
    -- If `c = s1`, show `phi(theta) = s1_int * theta` mod `theta^2`.
    have h_s1 : c_value q N = s1 q a → phi (theta_int q) - (s1_int q a : NumberField.RingOfIntegers (GlobalField q)) • theta_int q ∈ Ideal.span {theta_int q ^ 2} := by
      have h_cong : (s1_int q a : NumberField.RingOfIntegers (GlobalField q)) • theta_int q - (s1 q a).val • theta_int q ∈ Ideal.span {theta_int q ^ 2} := by
        by_cases h_case : (s1 q a).val ≤ q / 2;
        · unfold s1_int; aesop;
        · simp +decide [ s1_int, h_case ];
          simp +decide [ sub_mul, Ideal.mem_span_singleton ];
          exact dvd_trans ( Ideal.mem_span_singleton.mp ( q_mem_theta_sq q ( show q ≥ 7 from by
                                                                              exact q_ge_7_of_eq q a ( mod_cast h_eq ) ) ) ) ( by norm_num [ sq, mul_assoc ] );
      convert Ideal.sub_mem _ hphi.2 h_cong using 1 ; aesop;
    -- If `c = s2`, show `phi(theta) = s2_int * theta` mod `theta^2`.
    have h_s2 : c_value q N = s2 q a → phi (theta_int q) - (s2_int q a : NumberField.RingOfIntegers (GlobalField q)) • theta_int q ∈ Ideal.span {theta_int q ^ 2} := by
      intro hc
      have h_cong : phi (theta_int q) - (c_value q N).val • theta_int q ∈ Ideal.span {theta_int q ^ 2} := by
        exact hphi.2;
      have h_q_mul_theta : (q : NumberField.RingOfIntegers (GlobalField q)) * theta_int q ∈ Ideal.span {theta_int q ^ 2} := by
        have h_q_mul_theta : (q : NumberField.RingOfIntegers (GlobalField q)) ∈ Ideal.span {theta_int q ^ 2} := by
          apply q_mem_theta_sq_proved;
          exact q_ge_7_of_eq q a ( mod_cast h_eq );
        exact Ideal.mul_mem_right _ _ h_q_mul_theta;
      unfold s2_int at *; simp_all +decide ;
      split_ifs <;> simp_all +decide [ sub_mul ];
      convert Ideal.add_mem _ hphi.2 h_q_mul_theta using 1 ; ring;
    -- Apply `root_determined_v3` to conclude `phi(theta) = gamma` or `phi(theta) = beta`.
    set h_q_ge_7' : q ≥ 7 := q_ge_7_of_eq q a h_eq with h_q_ge_7'_def
    have h_conclusion : c_value q N = s1 q a → phi (theta_int q) = gamma_int q a h_q_ge_7' h_eq := by
      intro h
      have h_s1_mem := h_s1 h
      have h_s1_conv : phi (theta_int q) - (s1_int q a) • theta_int q ∈ Ideal.span {theta_int q ^ 2} := by
        convert h_s1_mem using 2; norm_num [Algebra.smul_def]
      exact (root_determined_v3 q a h_q_ge_7' h_eq (phi (theta_int q)) h_root
        (s1_int q a) h_s1_conv (Or.inl rfl)).1 rfl
    have h_conclusion' : c_value q N = s2 q a → phi (theta_int q) = beta_int q a h_q_ge_7' h_eq := by
      intro h
      have h_s2_mem := h_s2 h
      have h_s2_conv : phi (theta_int q) - (s2_int q a) • theta_int q ∈ Ideal.span {theta_int q ^ 2} := by
        convert h_s2_mem using 2; norm_num [Algebra.smul_def]
      exact (root_determined_v3 q a h_q_ge_7' h_eq (phi (theta_int q)) h_root
        (s2_int q a) h_s2_conv (Or.inr rfl)).2 rfl
    have h_frobenius : ∀ x : NumberField.RingOfIntegers (GlobalField q), (Ideal.Quotient.mk P) (phi x) = (Ideal.Quotient.mk P) x ^ N := by
      intro x
      have h_card : Nat.card (ℤ ⧸ Ideal.under ℤ P) = N := by
        have h_under : Ideal.under ℤ P = Ideal.span {(N : ℤ)} := by
          exact hP.1.symm ▸ rfl
        rw [h_under]
        haveI : NeZero N := ⟨Nat.Prime.ne_zero (Fact.out : Nat.Prime N)⟩
        rw [show Nat.card (ℤ ⧸ Ideal.span {(N : ℤ)}) = Nat.card (ZMod N) from
          Nat.card_congr (Int.quotientSpanEquivZMod N).toEquiv]
        rw [Nat.card_eq_fintype_card, ZMod.card]
      rw [← h_card]; erw [Ideal.Quotient.eq]; aesop
    -- Finish: combine conclusions with Frobenius.
    refine ⟨fun hc => ?_, fun hc => ?_⟩
    · have := h_conclusion hc
      rw [← this, ← h_frobenius]
    · have := h_conclusion' hc
      rw [← this, ← h_frobenius]

/-
The general theorem: if c=s1, then theta^N = gamma; if c=s2, then theta^N = beta.
-/
theorem final_result_general_v2 (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)]
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27)
  (N : ℕ) [Fact (Nat.Prime N)] (h_N_odd : N % 2 = 1) (h_N_ne_q : N ≠ q) (h_gcd : Int.gcd a N = 1)
  (P : Ideal (NumberField.RingOfIntegers (GlobalField q))) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_recip : reciprocity_lemma_statement q N) :
  let h_q_ge_7 : q ≥ 7 := q_ge_7_of_eq q a h_eq
  let theta_bar := Ideal.Quotient.mk P (theta_int q)
  let beta_bar := Ideal.Quotient.mk P (beta_int q a h_q_ge_7 h_eq)
  let gamma_bar := Ideal.Quotient.mk P (gamma_int q a h_q_ge_7 h_eq)
  (c_value q N = s1 q a → theta_bar ^ N = gamma_bar) ∧
  (c_value q N = s2 q a → theta_bar ^ N = beta_bar) := by
    convert final_result_general q a h_eq N h_N_odd h_N_ne_q h_gcd P hP h_recip using 1

/-
Beta is congruent to s2 * theta modulo theta^2.
-/
lemma beta_congruence (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27) :
  beta_int q a h_q_ge_7 h_eq - (s2_int q a) • theta_int q
    ∈ Ideal.span {theta_int q ^ 2} := by
      -- From the definition of `beta_relation`, we have an expression for `2 * a * beta`.
      have h_beta_relation : (2 * a : NumberField.RingOfIntegers (GlobalField q)) * beta_int q a h_q_ge_7 h_eq = 6 * theta_int q ^ 2 - (a + 9 : NumberField.RingOfIntegers (GlobalField q)) * theta_int q - 4 * (q : NumberField.RingOfIntegers (GlobalField q)) := by
        -- By definition of `beta_int`, we know that it satisfies the equation `(2 * a) * beta = 6 * theta^2 - (a + 9) * theta - 4 * q`.
        have h_beta_eq : (2 * a : ℚ) * beta_global q a = 6 * theta_global q ^ 2 - (a + 9) * theta_global q - 4 * q := by
          unfold beta_global theta_global;
          by_cases ha : a = 0 <;> simp_all +decide [ mul_comm ];
          · norm_cast at h_eq; linarith [ show q = 7 by linarith ] ;
          · simp +decide [ Algebra.smul_def ];
            simp +decide [ ← mul_assoc ];
            erw [ ← map_mul ] ; norm_num [ ha ];
            simp +decide [ ha, mul_assoc, mul_left_comm ( a : ℚ ) ];
            erw [ map_intCast ] ; norm_num;
            exact Or.inl <| by norm_cast;
        convert h_beta_eq using 1
        generalize_proofs at *;
        constructor <;> intro h <;> norm_cast at * ; aesop;
      have h_beta_relation : (2 * a : NumberField.RingOfIntegers (GlobalField q)) * (beta_int q a h_q_ge_7 h_eq - (s2_int q a : NumberField.RingOfIntegers (GlobalField q)) • theta_int q) ∈ Ideal.span {theta_int q ^ 2} := by
        have h_beta_relation : (2 * a : NumberField.RingOfIntegers (GlobalField q)) * (s2_int q a : NumberField.RingOfIntegers (GlobalField q)) • theta_int q - (-(a + 9 : ℤ)) • theta_int q ∈ Ideal.span {theta_int q ^ 2} := by
          convert lemma_orientation_step2_final q a h_q_ge_7 h_eq using 1;
          norm_num [ Algebra.smul_def ];
        have h_beta_relation : (6 * theta_int q ^ 2 - 4 * (q : NumberField.RingOfIntegers (GlobalField q))) ∈ Ideal.span {theta_int q ^ 2} := by
          exact Ideal.sub_mem _ ( Ideal.mul_mem_left _ _ ( Ideal.subset_span ( Set.mem_singleton _ ) ) ) ( Ideal.mul_mem_left _ _ ( q_mem_theta_sq q h_q_ge_7 ) );
        simp_all +decide [ mul_sub ];
        convert Ideal.sub_mem _ h_beta_relation ‹2 * ↑a * ( ↑ ( s2_int q a ) * theta_int q ) - ( -9 + -↑a ) * theta_int q ∈ Ideal.span { theta_int q ^ 2 } › using 1 ; ring;
      have h_cancel : ∃ u : NumberField.RingOfIntegers (GlobalField q), (2 * a * u - 1 : NumberField.RingOfIntegers (GlobalField q)) ∈ Ideal.span {theta_int q ^ 2} := by
        convert exists_inv_2a_mod_theta_sq_proved q a h_q_ge_7 h_eq using 1;
      convert ideal_cancel_of_unit_mod _ _ _ h_cancel.choose_spec _ h_beta_relation using 1;
      norm_num [ Algebra.smul_def ]

/-
Gamma is congruent to s1 * theta modulo theta^2.
-/
lemma gamma_congruence_proved (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27) :
  gamma_int q a h_q_ge_7 h_eq - (s1_int q a) • theta_int q
    ∈ Ideal.span {theta_int q ^ 2} := by
      apply_rules [ gamma_congruence ]

/-
The roots theta, beta, gamma are distinct modulo theta^2.
-/
lemma roots_distinct_mod_theta_sq_proved (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27) :
  let theta := theta_int q
  let beta := beta_int q a h_q_ge_7 h_eq
  let gamma := gamma_int q a h_q_ge_7 h_eq
  (theta - beta ∉ Ideal.span {theta^2}) ∧
  (theta - gamma ∉ Ideal.span {theta^2}) ∧
  (beta - gamma ∉ Ideal.span {theta^2}) := by
    -- Apply the lemma that states the roots are distinct modulo theta^2.
    apply roots_distinct_mod_theta_sq q a h_q_ge_7 h_eq

/-
The roots of f in the ring of integers are theta, beta, and gamma.
-/
lemma roots_of_f_in_integers_proved (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27)
  (x : NumberField.RingOfIntegers (GlobalField q))
  (h_root : Polynomial.aeval x (f_poly q) = 0) :
  x = theta_int q ∨ x = beta_int q a h_q_ge_7 h_eq ∨ x = gamma_int q a h_q_ge_7 h_eq := by
    convert roots_of_f_in_integers q a h_q_ge_7 h_eq x h_root using 1


/-
If a root x is congruent to c * theta mod theta^2, and c is s1 or s2, then x is determined.
-/
lemma root_determined_by_congruence_proved (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27)
  (x : NumberField.RingOfIntegers (GlobalField q))
  (h_root : Polynomial.aeval x (f_poly q) = 0)
  (c : ℤ)
  (h_cong : x - (c : NumberField.RingOfIntegers (GlobalField q)) • theta_int q ∈ Ideal.span {theta_int q ^ 2})
  (h_c_val : c = s1_int q a ∨ c = s2_int q a) :
  (c = s1_int q a → x = gamma_int q a h_q_ge_7 h_eq) ∧
  (c = s2_int q a → x = beta_int q a h_q_ge_7 h_eq) := by
    convert root_determined_by_congruence_v2 q a h_q_ge_7 h_eq x h_root c h_cong h_c_val using 1

/-
The Dream Theorem: The Frobenius automorphism maps theta to gamma if c=s1, and to beta if c=s2.
-/
theorem final_result_general_proved (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)]
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27)
  (N : ℕ) [Fact (Nat.Prime N)] (h_N_odd : N % 2 = 1) (h_N_ne_q : N ≠ q) (h_gcd : Int.gcd a N = 1)
  (P : Ideal (NumberField.RingOfIntegers (GlobalField q))) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_recip : reciprocity_lemma_statement q N) :
  let h_q_ge_7 : q ≥ 7 := q_ge_7_of_eq q a h_eq
  let theta_bar := Ideal.Quotient.mk P (theta_int q)
  let beta_bar := Ideal.Quotient.mk P (beta_int q a h_q_ge_7 h_eq)
  let gamma_bar := Ideal.Quotient.mk P (gamma_int q a h_q_ge_7 h_eq)
  (c_value q N = s1 q a → theta_bar ^ N = gamma_bar) ∧
  (c_value q N = s2 q a → theta_bar ^ N = beta_bar) := by
    -- By definition of Frobenius automorphism, we have that $\phi(\theta) = \theta^N \mod P$.
    apply final_result_general q a h_eq N h_N_odd h_N_ne_q h_gcd P hP h_recip

/-
The Dream Theorem for general q: The Frobenius automorphism maps theta to gamma if c=s1, and to beta if c=s2.
-/
theorem final_result_general_completed (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)]
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27)
  (N : ℕ) [Fact (Nat.Prime N)] (h_N_odd : N % 2 = 1) (h_N_ne_q : N ≠ q) (h_gcd : Int.gcd a N = 1)
  (P : Ideal (NumberField.RingOfIntegers (GlobalField q))) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_recip : reciprocity_lemma_statement q N) :
  let h_q_ge_7 : q ≥ 7 := q_ge_7_of_eq q a h_eq
  let theta_bar := Ideal.Quotient.mk P (theta_int q)
  let beta_bar := Ideal.Quotient.mk P (beta_int q a h_q_ge_7 h_eq)
  let gamma_bar := Ideal.Quotient.mk P (gamma_int q a h_q_ge_7 h_eq)
  (c_value q N = s1 q a → theta_bar ^ N = gamma_bar) ∧
  (c_value q N = s2 q a → theta_bar ^ N = beta_bar) := by
    apply final_result_general_proved q a h_eq N h_N_odd h_N_ne_q h_gcd P hP h_recip

/-
The Dream Theorem for general q.
-/
theorem final_result_general_solved (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)]
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27)
  (N : ℕ) [Fact (Nat.Prime N)] (h_N_odd : N % 2 = 1) (h_N_ne_q : N ≠ q) (h_gcd : Int.gcd a N = 1)
  (P : Ideal (NumberField.RingOfIntegers (GlobalField q))) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_recip : reciprocity_lemma_statement q N) :
  let h_q_ge_7 : q ≥ 7 := q_ge_7_of_eq q a h_eq
  let theta_bar := Ideal.Quotient.mk P (theta_int q)
  let beta_bar := Ideal.Quotient.mk P (beta_int q a h_q_ge_7 h_eq)
  let gamma_bar := Ideal.Quotient.mk P (gamma_int q a h_q_ge_7 h_eq)
  (c_value q N = s1 q a → theta_bar ^ N = gamma_bar) ∧
  (c_value q N = s2 q a → theta_bar ^ N = beta_bar) := by
    apply final_result_general_completed q a h_eq N h_N_odd h_N_ne_q h_gcd P hP h_recip

/-
The Dream Theorem for general q.
-/
theorem final_result_general_solved_v2 (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)]
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27)
  (N : ℕ) [Fact (Nat.Prime N)] (h_N_odd : N % 2 = 1) (h_N_ne_q : N ≠ q) (h_gcd : Int.gcd a N = 1)
  (P : Ideal (NumberField.RingOfIntegers (GlobalField q))) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_recip : reciprocity_lemma_statement q N) :
  let h_q_ge_7 : q ≥ 7 := q_ge_7_of_eq q a h_eq
  let theta_bar := Ideal.Quotient.mk P (theta_int q)
  let beta_bar := Ideal.Quotient.mk P (beta_int q a h_q_ge_7 h_eq)
  let gamma_bar := Ideal.Quotient.mk P (gamma_int q a h_q_ge_7 h_eq)
  (c_value q N = s1 q a → theta_bar ^ N = gamma_bar) ∧
  (c_value q N = s2 q a → theta_bar ^ N = beta_bar) := by
    exact final_result_general_solved q a h_eq N h_N_odd h_N_ne_q h_gcd P hP h_recip

/-
Lifting a ZMod element to an integer in (-q/2, q/2] and casting back gives the original element.
-/
lemma zmod_lift_cast_eq_self (q : ℕ) [NeZero q] (x : ZMod q) :
  ((if x.val ≤ q/2 then (x.val : ℤ) else (x.val : ℤ) - q) : ZMod q) = x := by
    split_ifs <;> aesop

/-
The integer lifts of s1 and s2 reduce to s1 and s2 modulo q.
-/
lemma s1_int_cast (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] : (s1_int q a : ZMod q) = s1 q a := by
  unfold s1_int; aesop;

lemma s2_int_cast (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] : (s2_int q a : ZMod q) = s2 q a := by
  unfold s2_int; aesop;

/-
The cardinality of Z/NZ is N.
-/
lemma card_quotient_span (N : ℕ) [Fact (Nat.Prime N)] : Nat.card (ℤ ⧸ Ideal.span {(N : ℤ)}) = N := by
  haveI : NeZero N := ⟨Nat.Prime.ne_zero Fact.out⟩
  rw [Nat.card_congr (Int.quotientSpanEquivZMod N).toEquiv]
  rw [Int.natAbs_cast]
  rw [Nat.card_zmod]

#check s1_int_cast

#check s2_int_cast
#check card_quotient_span

/-
The Dream Theorem for general q.
-/
theorem final_result_general_done (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)]
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27)
  (N : ℕ) [Fact (Nat.Prime N)] (h_N_odd : N % 2 = 1) (h_N_ne_q : N ≠ q) (h_gcd : Int.gcd a N = 1)
  (P : Ideal (NumberField.RingOfIntegers (GlobalField q))) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_recip : reciprocity_lemma_statement q N) :
  let h_q_ge_7 : q ≥ 7 := q_ge_7_of_eq q a h_eq
  let theta_bar := Ideal.Quotient.mk P (theta_int q)
  let beta_bar := Ideal.Quotient.mk P (beta_int q a h_q_ge_7 h_eq)
  let gamma_bar := Ideal.Quotient.mk P (gamma_int q a h_q_ge_7 h_eq)
  (c_value q N = s1 q a → theta_bar ^ N = gamma_bar) ∧
  (c_value q N = s2 q a → theta_bar ^ N = beta_bar) := by
    apply final_result_general_solved_v2 q a h_eq N h_N_odd h_N_ne_q h_gcd P hP h_recip

/-
The Dream Theorem for general q.
-/
theorem final_result_general_proved_v2 (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)]
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27)
  (N : ℕ) [Fact (Nat.Prime N)] (h_N_odd : N % 2 = 1) (h_N_ne_q : N ≠ q) (h_gcd : Int.gcd a N = 1)
  (P : Ideal (NumberField.RingOfIntegers (GlobalField q))) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_recip : reciprocity_lemma_statement q N) :
  let h_q_ge_7 : q ≥ 7 := q_ge_7_of_eq q a h_eq
  let theta_bar := Ideal.Quotient.mk P (theta_int q)
  let beta_bar := Ideal.Quotient.mk P (beta_int q a h_q_ge_7 h_eq)
  let gamma_bar := Ideal.Quotient.mk P (gamma_int q a h_q_ge_7 h_eq)
  (c_value q N = s1 q a → theta_bar ^ N = gamma_bar) ∧
  (c_value q N = s2 q a → theta_bar ^ N = beta_bar) := by
    convert final_result_general_solved_v2 q a ( mod_cast h_eq ) N h_N_odd h_N_ne_q h_gcd P hP h_recip using 1

/-
q is divisible by theta^2 in the ring of integers.
-/
lemma q_mem_theta_sq_proved_v2 (q : ℕ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7) :
  (q : NumberField.RingOfIntegers (GlobalField q)) ∈ Ideal.span {theta_int q ^ 2} := by
    exact?

/-
q is in the ideal generated by theta.
-/
lemma q_mem_theta_aux (q : ℕ) [Fact (Nat.Prime q)] (_h_q_ge_7 : q ≥ 7) :
  (q : NumberField.RingOfIntegers (GlobalField q)) ∈ Ideal.span {theta_int q} := by
    convert Ideal.mul_mem_right _ _ ( Ideal.subset_span <| Set.mem_singleton <| theta_int q ) using 1;
    have := theta_int_cubic q;
    swap;
    exact theta_int q ^ 2 - q;
    grind

/-
q is in the ideal generated by theta^2.
-/
lemma q_mem_theta_sq_final (q : ℕ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7) :
  (q : NumberField.RingOfIntegers (GlobalField q)) ∈ Ideal.span {theta_int q ^ 2} := by
    -- Apply the lemma that states q is in the ideal generated by theta^2.
    apply q_mem_theta_sq_proved_v2 q h_q_ge_7

/-
q is in the ideal generated by theta^2.
-/
lemma q_mem_theta_sq_proved_v3 (q : ℕ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7) :
  (q : NumberField.RingOfIntegers (GlobalField q)) ∈ Ideal.span {theta_int q ^ 2} := by
    exact?

/-
The Dream Theorem for general q.
-/
theorem final_result_general_real_proof (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)]
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27)
  (N : ℕ) [Fact (Nat.Prime N)] (h_N_odd : N % 2 = 1) (h_N_ne_q : N ≠ q) (h_gcd : Int.gcd a N = 1)
  (P : Ideal (NumberField.RingOfIntegers (GlobalField q))) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_recip : reciprocity_lemma_statement q N) :
  let h_q_ge_7 : q ≥ 7 := q_ge_7_of_eq q a h_eq
  let theta_bar := Ideal.Quotient.mk P (theta_int q)
  let beta_bar := Ideal.Quotient.mk P (beta_int q a h_q_ge_7 h_eq)
  let gamma_bar := Ideal.Quotient.mk P (gamma_int q a h_q_ge_7 h_eq)
  (c_value q N = s1 q a → theta_bar ^ N = gamma_bar) ∧
  (c_value q N = s2 q a → theta_bar ^ N = beta_bar) := by
    -- Apply the final_result_general_proved_v2 theorem with the given hypotheses.
    apply final_result_general_proved_v2 q a h_eq N h_N_odd h_N_ne_q h_gcd P hP h_recip

/-
Algebraic identity for beta.
-/
lemma beta_poly_identity_proved (R : Type*) [CommRing R] (a q : R) (alpha : R)
  (h_root : alpha^3 = q * alpha + q)
  (h_a2 : a^2 = 4 * q - 27) :
  let B := 6 * alpha^2 - (a + 9) * alpha - 4 * q
  B^3 - 4 * a^2 * q * B - 8 * a^3 * q = 0 := by
    grind +ring

/-
(2a)^3 * f(beta) = 0.
-/
lemma beta_scaled_eq_zero_proved (q : ℕ) (a : ℤ) (N : ℕ) [Fact (Nat.Prime N)]
  (K : Type*) [Field K] [Algebra (ZMod N) K]
  (alpha : K) (h_root : Polynomial.aeval alpha (f_mod_N q N) = 0)
  (beta : K) (h_beta : beta_relation a q N alpha beta)
  (h_eq : 4 * (q : ZMod N) = (a : ZMod N)^2 + 27) :
  (2 * (a : K))^3 * Polynomial.aeval beta (f_mod_N q N) = 0 := by
    exact?

/-
(2a)^3 * f(beta) = 0.
-/
lemma beta_scaled_eq_zero_final (q : ℕ) (a : ℤ) (N : ℕ) [Fact (Nat.Prime N)]
  (K : Type*) [Field K] [Algebra (ZMod N) K]
  (alpha : K) (h_root : Polynomial.aeval alpha (f_mod_N q N) = 0)
  (beta : K) (h_beta : beta_relation a q N alpha beta)
  (h_eq : 4 * (q : ZMod N) = (a : ZMod N)^2 + 27) :
  (2 * (a : K))^3 * Polynomial.aeval beta (f_mod_N q N) = 0 := by
    convert beta_scaled_eq_zero_proved q a N K alpha h_root beta h_beta h_eq using 1

/-
If c*theta is divisible by theta^2, then c is divisible by q.
-/
lemma coeff_unique_mod_theta_sq_proved (q : ℕ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7) (c : ℤ)
  (h_mem : (c : NumberField.RingOfIntegers (GlobalField q)) * theta_int q ∈ Ideal.span {theta_int q ^ 2}) :
  (q : ℤ) ∣ c := by
    -- Apply the lemma that states if c * theta is in the ideal generated by theta^2, then q divides c.
    apply coeff_unique_mod_theta_sq q h_q_ge_7 c h_mem

/-
The main theorem relating the cubic character $c(N)$ to the Frobenius action on $\theta$.
-/
theorem final_result_general_finished (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)]
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27)
  (N : ℕ) [Fact (Nat.Prime N)] (h_N_odd : N % 2 = 1) (h_N_ne_q : N ≠ q) (h_gcd : Int.gcd a N = 1)
  (P : Ideal (NumberField.RingOfIntegers (GlobalField q))) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_recip : reciprocity_lemma_statement q N) :
  let h_q_ge_7 : q ≥ 7 := q_ge_7_of_eq q a h_eq
  let theta_bar := Ideal.Quotient.mk P (theta_int q)
  let beta_bar := Ideal.Quotient.mk P (beta_int q a h_q_ge_7 h_eq)
  let gamma_bar := Ideal.Quotient.mk P (gamma_int q a h_q_ge_7 h_eq)
  (c_value q N = s1 q a → theta_bar ^ N = gamma_bar) ∧
  (c_value q N = s2 q a → theta_bar ^ N = beta_bar) := by
  let h_q_ge_7 : q ≥ 7 := q_ge_7_of_eq q a h_eq
  have h_recip_inst := h_recip P hP
  obtain ⟨phi, h_frob, h_cong⟩ := h_recip_inst
  have h_phi_root : Polynomial.aeval (phi (theta_int q)) (f_poly q) = 0 := by
    simp +decide [ f_poly ];
    have h_root : (theta_int q)^3 - (q : NumberField.RingOfIntegers (GlobalField q)) * theta_int q - (q : NumberField.RingOfIntegers (GlobalField q)) = 0 := by
      -- By definition of theta_int q, we know that theta_int q^3 - q * theta_int q - q = 0.
      have h_theta_int_root : theta_int q ^ 3 - (q : NumberField.RingOfIntegers (GlobalField q)) * theta_int q - (q : NumberField.RingOfIntegers (GlobalField q)) = 0 := by
        have h_poly : Polynomial.aeval (theta_global q) (f_poly q) = 0 := by
          convert theta_global_is_root q;
          unfold f_poly f_rat; norm_num;
        convert h_poly using 1;
        erw [ ← Subtype.coe_inj ] ; norm_num [ aeval_def, f_poly ];
        erw [ ← Subalgebra.coe_eq_zero ] ; norm_num [ theta_int ];
        erw [ Subtype.mk_eq_mk ] ; ring!;
        erw [ Subalgebra.coe_add, Subalgebra.coe_neg, Subalgebra.coe_mul, Subalgebra.coe_pow ] ; norm_num ; ring;
      exact h_theta_int_root;
    simpa using congr_arg ( fun x => phi x ) h_root
  have h_theta_N_eq_phi : Ideal.Quotient.mk P (theta_int q) ^ N = Ideal.Quotient.mk P (phi (theta_int q)) := by
    -- By definition of IsArithFrobAt, we have that for any x in Ok, phi(x) ≡ x^N mod P.
    have h_frob_def : ∀ x : NumberField.RingOfIntegers (GlobalField q), phi x - x ^ N ∈ P := by
      -- Since $P$ is a prime ideal lying over $N$, the cardinality of the quotient ring $\mathbb{Z}/P$ is $N$.
      have h_card : Nat.card (ℤ ⧸ Ideal.under ℤ P) = N := by
        convert card_quotient_span N using 1;
        rw [ ← hP.1 ];
      aesop;
    exact Eq.symm ( Ideal.Quotient.eq.2 <| by simpa using h_frob_def ( theta_int q ) )
  constructor
  · intro h_c
    have h_cong_s1 : phi (theta_int q) - (s1_int q a) • (theta_int q) ∈ Ideal.span {theta_int q ^ 2} := by
      -- Convert the ZMod element to an integer using the fact that s1_int q a is the integer representation of s1 q a.
      have h_convert : (s1_int q a : ZMod q) = s1 q a := by
        exact?
      generalize_proofs at *; (
      have h_convert : (s1_int q a : ℤ) ≡ (s1 q a).val [ZMOD q] := by
        simp +decide [ ← ZMod.intCast_eq_intCast_iff, h_convert ]
      generalize_proofs at *; (
      obtain ⟨ k, hk ⟩ := h_convert.symm.dvd
      generalize_proofs at *; (
      have h_convert : (q : NumberField.RingOfIntegers (GlobalField q)) ∈ Ideal.span {theta_int q ^ 2} := by
        exact q_mem_theta_sq_final q ( by linarith ) |> fun h => by simpa using h;
      generalize_proofs at *; (
      convert Ideal.sub_mem _ h_cong ( Ideal.mul_mem_left _ ( k • theta_int q ) h_convert ) using 1 ; simp +decide [ sub_eq_iff_eq_add.mp hk ] ; ring

      rw [ h_c ] ; ring!;))))
    have h_phi_eq_gamma : phi (theta_int q) = gamma_int q a h_q_ge_7 h_eq := by
      have h_phi_gamma : ∀ x : NumberField.RingOfIntegers (GlobalField q), Polynomial.aeval x (f_poly q) = 0 → x - (s1_int q a) • theta_int q ∈ Ideal.span {theta_int q ^ 2} → x = gamma_int q a h_q_ge_7 h_eq := by
        intros y hy_root hy_cong_s1
        have h_unique : y = theta_int q ∨ y = beta_int q a h_q_ge_7 h_eq ∨ y = gamma_int q a h_q_ge_7 h_eq := by
          apply roots_of_f_in_integers q a h_q_ge_7 h_eq y hy_root;
        obtain rfl | rfl | rfl := h_unique <;> simp_all +decide;
        · have h_unique : (1 - s1_int q a : ℤ) * theta_int q ∈ Ideal.span {theta_int q ^ 2} := by
            convert hy_cong_s1 using 1 ; norm_num ; ring;
          have h_unique : (q : ℤ) ∣ (1 - s1_int q a) := by
            apply coeff_unique_mod_theta_sq q h_q_ge_7 (1 - s1_int q a) h_unique;
          have h_unique : (s1 q a : ZMod q) = 1 := by
            have h_unique : (s1_int q a : ZMod q) = 1 := by
              obtain ⟨ k, hk ⟩ := h_unique; replace hk := congr_arg ( ( ↑ ) : ℤ → ZMod q ) hk; simp_all +decide ;
              linear_combination' -hk;
            convert h_unique using 1;
            unfold s1_int; aesop;
          exact absurd h_unique ( by have := s1_s2_distinct_mod_q_final q a h_q_ge_7 ( mod_cast h_eq ) ; aesop );
        · have h_unique : beta_int q a h_q_ge_7 h_eq - gamma_int q a h_q_ge_7 h_eq ∈ Ideal.span {theta_int q ^ 2} := by
            convert Ideal.sub_mem _ hy_cong_s1 ( gamma_congruence_proved q a h_q_ge_7 h_eq ) using 1 ; ring;
          exact False.elim <| roots_distinct_mod_theta_sq_proved q a h_q_ge_7 h_eq |>.2.2 h_unique;
      exact h_phi_gamma _ h_phi_root h_cong_s1
    rw [h_theta_N_eq_phi, h_phi_eq_gamma]
  · intro h_c
    have h_cong_s2 : phi (theta_int q) - (s2_int q a) • (theta_int q) ∈ Ideal.span {theta_int q ^ 2} := by
      -- Substitute $c_value q N$ with $s2 q a$ in $h_cong$.
      have h_sub : phi (theta_int q) - (s2 q a).val • theta_int q ∈ Ideal.span {theta_int q ^ 2} := by
        grind +ring;
      have h_coeff : (s2 q a).val ≡ s2_int q a [ZMOD q] := by
        unfold s2_int; simp +decide [ ← ZMod.intCast_eq_intCast_iff ] ;
      generalize_proofs at *; (
      rw [ Int.modEq_iff_dvd ] at h_coeff
      generalize_proofs at *; (
      obtain ⟨ k, hk ⟩ := h_coeff
      generalize_proofs at *; (
      convert Ideal.sub_mem _ h_sub ( Ideal.mul_mem_left _ ( k • theta_int q ) ( q_mem_theta_sq_final q h_q_ge_7 ) ) using 1 ; simp +decide [ mul_assoc, mul_comm ];
      rw [ show ( s2_int q a : NumberField.RingOfIntegers ( GlobalField q ) ) = ( s2 q a |> ZMod.val : ℤ ) + ( q : ℤ ) * k by exact mod_cast hk ▸ by ring ] ; norm_num ; ring;)))
    have h_phi_eq_beta : phi (theta_int q) = beta_int q a h_q_ge_7 h_eq := by
      have := root_determined_v3 q a h_q_ge_7 h_eq (phi (theta_int q)) h_phi_root (s2_int q a) h_cong_s2; aesop;
    rw [h_theta_N_eq_phi, h_phi_eq_beta]

/-
The main theorem relating the cubic character $c(N)$ to the Frobenius action on $\theta$.
-/
theorem final_result_general_clean (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)]
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27)
  (N : ℕ) [Fact (Nat.Prime N)] (h_N_odd : N % 2 = 1) (h_N_ne_q : N ≠ q) (h_gcd : Int.gcd a N = 1)
  (P : Ideal (NumberField.RingOfIntegers (GlobalField q))) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_recip : reciprocity_lemma_statement q N) :
  let h_q_ge_7 : q ≥ 7 := q_ge_7_of_eq q a h_eq
  let theta_bar := Ideal.Quotient.mk P (theta_int q)
  let beta_bar := Ideal.Quotient.mk P (beta_int q a h_q_ge_7 h_eq)
  let gamma_bar := Ideal.Quotient.mk P (gamma_int q a h_q_ge_7 h_eq)
  (c_value q N = s1 q a → theta_bar ^ N = gamma_bar) ∧
  (c_value q N = s2 q a → theta_bar ^ N = beta_bar) := by
    convert final_result_general_finished q a h_eq N h_N_odd h_N_ne_q h_gcd P hP h_recip using 1

#check AlgHom.IsArithFrobAt

/-
The main theorem relating the cubic character $c(N)$ to the Frobenius action on $\theta$.
-/
theorem final_result_general_fixed (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)]
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27)
  (N : ℕ) [Fact (Nat.Prime N)] (h_N_odd : N % 2 = 1) (h_N_ne_q : N ≠ q) (h_gcd : Int.gcd a N = 1)
  (P : Ideal (NumberField.RingOfIntegers (GlobalField q))) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_recip : reciprocity_lemma_statement q N) :
  let h_q_ge_7 : q ≥ 7 := q_ge_7_of_eq q a h_eq
  let theta_bar := Ideal.Quotient.mk P (theta_int q)
  let beta_bar := Ideal.Quotient.mk P (beta_int q a h_q_ge_7 h_eq)
  let gamma_bar := Ideal.Quotient.mk P (gamma_int q a h_q_ge_7 h_eq)
  (c_value q N = s1 q a → theta_bar ^ N = gamma_bar) ∧
  (c_value q N = s2 q a → theta_bar ^ N = beta_bar) := by
    convert final_result_general_finished q a ( mod_cast h_eq ) N h_N_odd h_N_ne_q h_gcd P hP h_recip using 1

/-
The main theorem relating the cubic character $c(N)$ to the Frobenius action on $\theta$.
-/
theorem final_result_general_no_gen (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)]
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27)
  (N : ℕ) [Fact (Nat.Prime N)] (h_N_odd : N % 2 = 1) (h_N_ne_q : N ≠ q) (h_gcd : Int.gcd a N = 1)
  (P : Ideal (NumberField.RingOfIntegers (GlobalField q))) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_recip : reciprocity_lemma_statement q N) :
  let h_q_ge_7 : q ≥ 7 := q_ge_7_of_eq q a h_eq
  let theta_bar := Ideal.Quotient.mk P (theta_int q)
  let beta_bar := Ideal.Quotient.mk P (beta_int q a h_q_ge_7 h_eq)
  let gamma_bar := Ideal.Quotient.mk P (gamma_int q a h_q_ge_7 h_eq)
  (c_value q N = s1 q a → theta_bar ^ N = gamma_bar) ∧
  (c_value q N = s2 q a → theta_bar ^ N = beta_bar) := by
    -- Let's unfold the definition of the Frobenius automorphism and the conditions given by the reciprocity lemma.
    apply final_result_general_finished q a h_eq N h_N_odd h_N_ne_q h_gcd P hP h_recip

/-
The main theorem relating the cubic character $c(N)$ to the Frobenius action on $\theta$.
-/
theorem final_result_general_fixed_v2 (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)]
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27)
  (N : ℕ) [Fact (Nat.Prime N)] (h_N_odd : N % 2 = 1) (h_N_ne_q : N ≠ q) (h_gcd : Int.gcd a N = 1)
  (P : Ideal (NumberField.RingOfIntegers (GlobalField q))) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_recip : reciprocity_lemma_statement q N) :
  let h_q_ge_7 : q ≥ 7 := q_ge_7_of_eq q a h_eq
  let theta_bar := Ideal.Quotient.mk P (theta_int q)
  let beta_bar := Ideal.Quotient.mk P (beta_int q a h_q_ge_7 h_eq)
  let gamma_bar := Ideal.Quotient.mk P (gamma_int q a h_q_ge_7 h_eq)
  (c_value q N = s1 q a → theta_bar ^ N = gamma_bar) ∧
  (c_value q N = s2 q a → theta_bar ^ N = beta_bar) := by
    apply_rules [ final_result_general_no_gen ]

/-
The main theorem relating the cubic character $c(N)$ to the Frobenius action on $\theta$.
-/
theorem final_result_general_clean_proof (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)]
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27)
  (N : ℕ) [Fact (Nat.Prime N)] (h_N_odd : N % 2 = 1) (h_N_ne_q : N ≠ q) (h_gcd : Int.gcd a N = 1)
  (P : Ideal (NumberField.RingOfIntegers (GlobalField q))) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_recip : reciprocity_lemma_statement q N) :
  let h_q_ge_7 : q ≥ 7 := q_ge_7_of_eq q a h_eq
  let theta_bar := Ideal.Quotient.mk P (theta_int q)
  let beta_bar := Ideal.Quotient.mk P (beta_int q a h_q_ge_7 h_eq)
  let gamma_bar := Ideal.Quotient.mk P (gamma_int q a h_q_ge_7 h_eq)
  (c_value q N = s1 q a → theta_bar ^ N = gamma_bar) ∧
  (c_value q N = s2 q a → theta_bar ^ N = beta_bar) := by
    -- Apply the final_result_general_fixed_v2 theorem with the given hypotheses.
    apply final_result_general_fixed_v2 q a h_eq N h_N_odd h_N_ne_q h_gcd P hP h_recip


/-
The main theorem relating the cubic character $c(N)$ to the Frobenius action on $\theta$.
-/
theorem final_result_general_explicit (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)]
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27)
  (N : ℕ) [Fact (Nat.Prime N)] (h_N_odd : N % 2 = 1) (h_N_ne_q : N ≠ q) (h_gcd : Int.gcd a N = 1)
  (P : Ideal (NumberField.RingOfIntegers (GlobalField q))) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_recip : reciprocity_lemma_statement q N) :
  let h_q_ge_7 : q ≥ 7 := q_ge_7_of_eq q a h_eq
  let theta_bar := Ideal.Quotient.mk P (theta_int q)
  let beta_bar := Ideal.Quotient.mk P (beta_int q a h_q_ge_7 h_eq)
  let gamma_bar := Ideal.Quotient.mk P (gamma_int q a h_q_ge_7 h_eq)
  (c_value q N = s1 q a → theta_bar ^ N = gamma_bar) ∧
  (c_value q N = s2 q a → theta_bar ^ N = beta_bar) := by
    apply final_result_general_fixed_v2 q a h_eq N h_N_odd h_N_ne_q h_gcd P hP h_recip

/-
The main theorem relating the cubic character $c(N)$ to the Frobenius action on $\theta$.
-/
theorem final_result_general_clean_proof_v2 (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)]
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27)
  (N : ℕ) [Fact (Nat.Prime N)] (h_N_odd : N % 2 = 1) (h_N_ne_q : N ≠ q) (h_gcd : Int.gcd a N = 1)
  (P : Ideal (NumberField.RingOfIntegers (GlobalField q))) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_recip : reciprocity_lemma_statement q N) :
  let h_q_ge_7 : q ≥ 7 := q_ge_7_of_eq q a h_eq
  let theta_bar := Ideal.Quotient.mk P (theta_int q)
  let beta_bar := Ideal.Quotient.mk P (beta_int q a h_q_ge_7 h_eq)
  let gamma_bar := Ideal.Quotient.mk P (gamma_int q a h_q_ge_7 h_eq)
  (c_value q N = s1 q a → theta_bar ^ N = gamma_bar) ∧
  (c_value q N = s2 q a → theta_bar ^ N = beta_bar) := by
    convert final_result_general_explicit q a h_eq N h_N_odd h_N_ne_q h_gcd P hP h_recip using 1

/-
If an integer and a natural number are congruent modulo q, their actions on theta are congruent modulo theta^2.
-/
lemma theta_cong_of_equiv (q : ℕ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (n : ℕ) (z : ℤ) (h_equiv : (n : ZMod q) = (z : ZMod q)) :
  ((n : NumberField.RingOfIntegers (GlobalField q)) * theta_int q - (z : NumberField.RingOfIntegers (GlobalField q)) * theta_int q) ∈ Ideal.span {theta_int q ^ 2} := by
    rw [ ← sub_mul ];
    -- Since $n \equiv z \pmod{q}$, we have $n - z = kq$ for some integer $k$.
    obtain ⟨k, hk⟩ : ∃ k : ℤ, (n : ℤ) - z = k * q := by
      exact exists_eq_mul_left_of_dvd <| by rw [ ← ZMod.intCast_zmod_eq_zero_iff_dvd ] ; aesop;
    -- Since $q \in (\theta^2)$, we have $kq \in (\theta^2)$.
    have h_q_mem_theta_sq : (q : NumberField.RingOfIntegers (GlobalField q)) ∈ Ideal.span {theta_int q ^ 2} := by
      exact?;
    rw [ show ( n : NumberField.RingOfIntegers ( GlobalField q ) ) - z = k * q by exact_mod_cast hk ] ; exact Ideal.mul_mem_right _ _ ( Ideal.mul_mem_left _ _ h_q_mem_theta_sq ) ;

/-
The main theorem relating the cubic character $c(N)$ to the Frobenius action on $\theta$.
-/
theorem final_result_general_clean_no_generalize (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)]
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27)
  (N : ℕ) [Fact (Nat.Prime N)] (h_N_odd : N % 2 = 1) (h_N_ne_q : N ≠ q) (h_gcd : Int.gcd a N = 1)
  (P : Ideal (NumberField.RingOfIntegers (GlobalField q))) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_recip : reciprocity_lemma_statement q N) :
  let h_q_ge_7 : q ≥ 7 := q_ge_7_of_eq q a h_eq
  let theta_bar := Ideal.Quotient.mk P (theta_int q)
  let beta_bar := Ideal.Quotient.mk P (beta_int q a h_q_ge_7 h_eq)
  let gamma_bar := Ideal.Quotient.mk P (gamma_int q a h_q_ge_7 h_eq)
  (c_value q N = s1 q a → theta_bar ^ N = gamma_bar) ∧
  (c_value q N = s2 q a → theta_bar ^ N = beta_bar) := by
    -- Apply the final_result_general theorem with the given hypotheses.
    apply final_result_general_fixed q a h_eq N h_N_odd h_N_ne_q h_gcd P hP h_recip

#check theta_cong_of_equiv

/-
The main theorem relating the cubic character $c(N)$ to the Frobenius action on $\theta$.
-/
theorem final_result_general_clean_no_generalize_v2 (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)]
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27)
  (N : ℕ) [Fact (Nat.Prime N)] (h_N_odd : N % 2 = 1) (h_N_ne_q : N ≠ q) (h_gcd : Int.gcd a N = 1)
  (P : Ideal (NumberField.RingOfIntegers (GlobalField q))) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_recip : reciprocity_lemma_statement q N) :
  let h_q_ge_7 : q ≥ 7 := q_ge_7_of_eq q a h_eq
  let theta_bar := Ideal.Quotient.mk P (theta_int q)
  let beta_bar := Ideal.Quotient.mk P (beta_int q a h_q_ge_7 h_eq)
  let gamma_bar := Ideal.Quotient.mk P (gamma_int q a h_q_ge_7 h_eq)
  (c_value q N = s1 q a → theta_bar ^ N = gamma_bar) ∧
  (c_value q N = s2 q a → theta_bar ^ N = beta_bar) := by
    exact?

/-
The main theorem relating the cubic character $c(N)$ to the Frobenius action on $\theta$.
-/
theorem final_result_general_complete (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)]
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27)
  (N : ℕ) [Fact (Nat.Prime N)] (h_N_odd : N % 2 = 1) (h_N_ne_q : N ≠ q) (h_gcd : Int.gcd a N = 1)
  (P : Ideal (NumberField.RingOfIntegers (GlobalField q))) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_recip : reciprocity_lemma_statement q N) :
  let h_q_ge_7 : q ≥ 7 := q_ge_7_of_eq q a h_eq
  let theta_bar := Ideal.Quotient.mk P (theta_int q)
  let beta_bar := Ideal.Quotient.mk P (beta_int q a h_q_ge_7 h_eq)
  let gamma_bar := Ideal.Quotient.mk P (gamma_int q a h_q_ge_7 h_eq)
  (c_value q N = s1 q a → theta_bar ^ N = gamma_bar) ∧
  (c_value q N = s2 q a → theta_bar ^ N = beta_bar) := by
    apply_rules [ final_result_general_solved ]

/-
The main theorem relating the cubic character $c(N)$ to the Frobenius action on $\theta$.
-/
theorem final_result_general_clean_no_generalize_v3 (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)]
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27)
  (N : ℕ) [Fact (Nat.Prime N)] (h_N_odd : N % 2 = 1) (h_N_ne_q : N ≠ q) (h_gcd : Int.gcd a N = 1)
  (P : Ideal (NumberField.RingOfIntegers (GlobalField q))) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_recip : reciprocity_lemma_statement q N) :
  let h_q_ge_7 : q ≥ 7 := q_ge_7_of_eq q a h_eq
  let theta_bar := Ideal.Quotient.mk P (theta_int q)
  let beta_bar := Ideal.Quotient.mk P (beta_int q a h_q_ge_7 h_eq)
  let gamma_bar := Ideal.Quotient.mk P (gamma_int q a h_q_ge_7 h_eq)
  (c_value q N = s1 q a → theta_bar ^ N = gamma_bar) ∧
  (c_value q N = s2 q a → theta_bar ^ N = beta_bar) := by
    -- Apply the final_result_general_complete theorem with the given parameters.
    apply final_result_general_complete q a h_eq N h_N_odd h_N_ne_q h_gcd P hP h_recip

/-
The subgroup of cubes in (ZMod q)^*.
-/
def H_cubes (q : ℕ) [Fact (Nat.Prime q)] : Subgroup (ZMod q)ˣ :=
  MonoidHom.range (powMonoidHom 3 : (ZMod q)ˣ →* (ZMod q)ˣ)

/-
Check if (ZMod q)ˣ is cyclic.
-/
example (q : ℕ) [Fact (Nat.Prime q)] : IsCyclic (ZMod q)ˣ := inferInstance

/-
A generator of the cyclic group (ZMod q)^*.
-/
noncomputable def g_gen (q : ℕ) [Fact (Nat.Prime q)] : (ZMod q)ˣ :=
  Classical.choose (IsCyclic.exists_generator : ∃ g : (ZMod q)ˣ, ∀ x, x ∈ Subgroup.zpowers g)

/-
The subgroup of cubes as a Finset.
-/
noncomputable def H_finset (q : ℕ) [Fact (Nat.Prime q)] : Finset (ZMod q)ˣ :=
  (H_cubes q : Set (ZMod q)ˣ).toFinset

/-
The cosets C_i of the subgroup of cubes.
-/
noncomputable def C_coset (q : ℕ) [Fact (Nat.Prime q)] (i : ZMod 3) : Finset (ZMod q) :=
  (H_finset q).image (fun x => ((g_gen q ^ i.val * x) : ZMod q))

/-
The primitive q-th root of unity in the cyclotomic field.
-/
noncomputable def zeta_q (q : ℕ) [Fact (Nat.Prime q)] : CyclotomicField q ℚ :=
  have : Nat.Prime q := Fact.out
  haveI : NeZero q := ⟨this.ne_zero⟩
  IsCyclotomicExtension.zeta q ℚ (CyclotomicField q ℚ)

/-
The Gaussian periods eta_i.
-/
noncomputable def eta_period (q : ℕ) [Fact (Nat.Prime q)] (i : ZMod 3) : CyclotomicField q ℚ :=
  ∑ t ∈ C_coset q i, (zeta_q q) ^ t.val

/-
The period differences alpha, beta, gamma in the cyclotomic field.
-/
noncomputable def alpha_cyclotomic (q : ℕ) [Fact (Nat.Prime q)] : CyclotomicField q ℚ :=
  eta_period q 0 - eta_period q 1

noncomputable def beta_cyclotomic (q : ℕ) [Fact (Nat.Prime q)] : CyclotomicField q ℚ :=
  eta_period q 1 - eta_period q 2

noncomputable def gamma_cyclotomic (q : ℕ) [Fact (Nat.Prime q)] : CyclotomicField q ℚ :=
  eta_period q 2 - eta_period q 0

/-
The automorphism sigma_n of the cyclotomic field.
-/
noncomputable def sigma_cyclotomic (q : ℕ) [Fact (Nat.Prime q)] (n : (ZMod q)ˣ) : CyclotomicField q ℚ ≃ₐ[ℚ] CyclotomicField q ℚ :=
  have h_prime : Nat.Prime q := Fact.out
  haveI : NeZero q := ⟨h_prime.ne_zero⟩
  let h_irr := Polynomial.cyclotomic.irreducible_rat (n := q) h_prime.pos
  (IsCyclotomicExtension.autEquivPow (CyclotomicField q ℚ) h_irr).symm n

/-
The automorphism sigma_n of the cyclotomic field.
-/
noncomputable def sigma_cyclotomic_def (q : ℕ) [Fact (Nat.Prime q)] (n : (ZMod q)ˣ) : CyclotomicField q ℚ ≃ₐ[ℚ] CyclotomicField q ℚ :=
  have h_prime : Nat.Prime q := Fact.out
  haveI : NeZero q := ⟨h_prime.ne_zero⟩
  let h_irr := Polynomial.cyclotomic.irreducible_rat (n := q) h_prime.pos
  (IsCyclotomicExtension.autEquivPow (CyclotomicField q ℚ) h_irr).symm n

/-
The automorphism sigma_n of the cyclotomic field.
-/
noncomputable def sigma_cyclotomic_v2 (q : ℕ) [Fact (Nat.Prime q)] (n : (ZMod q)ˣ) : CyclotomicField q ℚ ≃ₐ[ℚ] CyclotomicField q ℚ :=
  have h_prime : Nat.Prime q := Fact.out
  haveI : NeZero q := ⟨h_prime.ne_zero⟩
  let h_irr := Polynomial.cyclotomic.irreducible_rat (n := q) h_prime.pos
  (IsCyclotomicExtension.autEquivPow (CyclotomicField q ℚ) h_irr).symm n

/-
The index of the coset containing n.
-/
noncomputable def coset_index (q : ℕ) [Fact (Nat.Prime q)] (n : (ZMod q)ˣ) : ZMod 3 :=
  if (n : ZMod q) ∈ C_coset q 0 then 0
  else if (n : ZMod q) ∈ C_coset q 1 then 1
  else 2

lemma mem_coset_index (q : ℕ) [Fact (Nat.Prime q)] (n : (ZMod q)ˣ) :
  (n : ZMod q) ∈ C_coset q (coset_index q n) := by
    unfold C_coset coset_index;
    -- By definition of $C_coset$, there exists some $i \in \{0, 1, 2\}$ such that $n \in C_coset q i$.
    obtain ⟨i, hi⟩ : ∃ i : ZMod 3, (n : ZMod q) ∈ C_coset q i := by
      -- Since $n$ is a unit, it must be congruent to some power of $g$ modulo $q$. Let $k$ be such that $n \equiv g^k \pmod{q}$.
      obtain ⟨k, hk⟩ : ∃ k : ℕ, (n : ZMod q) = (g_gen q : ZMod q) ^ k := by
        have h_gen : ∀ n : (ZMod q)ˣ, ∃ k : ℕ, n = (g_gen q) ^ k := by
          intro n
          have h_gen : ∃ k : ℕ, n = (g_gen q) ^ k := by
            have h_cyclic : ∀ n : (ZMod q)ˣ, n ∈ Subgroup.zpowers (g_gen q) := by
              exact Classical.choose_spec ( IsCyclic.exists_generator : ∃ g : ( ZMod q ) ˣ, ∀ x : ( ZMod q ) ˣ, x ∈ Subgroup.zpowers g )
            obtain ⟨ k, rfl ⟩ := h_cyclic n; use Int.toNat ( k % ( orderOf ( g_gen q ) ) ) ; rw [ ← zpow_natCast, Int.toNat_of_nonneg ( Int.emod_nonneg _ <| Nat.cast_ne_zero.mpr <| ne_of_gt <| orderOf_pos _ ) ] ; simp +decide [ ← zpow_mod_orderOf ] ;
          exact h_gen;
        exact Exists.elim ( h_gen n ) fun k hk => ⟨ k, by simpa using congr_arg ( fun x : ( ZMod q ) ˣ => ( x : ZMod q ) ) hk ⟩;
      -- Since $k$ is a natural number, we can write it as $3m + i$ for some $m$ and $i \in \{0, 1, 2\}$.
      obtain ⟨m, i, hi⟩ : ∃ m i : ℕ, k = 3 * m + i ∧ i < 3 := by
        exact ⟨ k / 3, k % 3, by rw [ Nat.div_add_mod ], Nat.mod_lt _ <| by decide ⟩;
      use ⟨i, by
        linarith⟩
      generalize_proofs at *;
      unfold C_coset
      simp [hk, hi];
      refine' ⟨ _, _, _ ⟩;
      exact ( g_gen q ^ m ) ^ 3;
      · unfold H_finset;
        unfold H_cubes; aesop;
      · interval_cases i <;> norm_num [ pow_add, pow_mul' ] <;> ring!;
        · norm_num [ ZMod.val ];
        · rfl;
    split_ifs <;> simp_all +decide [ C_coset ];
    fin_cases i <;> aesop

/-
The automorphism sigma_n maps zeta_q to zeta_q^n.
-/
lemma sigma_zeta_q (q : ℕ) [Fact (Nat.Prime q)] (n : (ZMod q)ˣ) :
  sigma_cyclotomic_v2 q n (zeta_q q) = (zeta_q q) ^ (n : ZMod q).val := by
    unfold sigma_cyclotomic_v2;
    simp +decide [ IsCyclotomicExtension.autEquivPow ];
    rw [ PowerBasis.equivOfMinpoly_apply ];
    convert ( PowerBasis.lift_gen _ _ _ )

/-
Multiplying the coset C_i by n gives the coset C_{i + ind(n)}.
-/
lemma mul_coset_eq (q : ℕ) [Fact (Nat.Prime q)] (n : (ZMod q)ˣ) (i : ZMod 3) :
  (C_coset q i).image (fun x => (n : ZMod q) * x) = C_coset q (i + coset_index q n) := by
    -- By definition of $C_coset$, we know that $C_coset q i$ is the image of $H_finset q$ under the map $x \mapsto g_gen q^i * x$.
    have hC_coset_def : ∀ i : ZMod 3, C_coset q i = (H_finset q).image (fun x => (g_gen q ^ (i.val : ℕ) * x : ZMod q)) := by
      unfold C_coset; aesop;
    -- By definition of coset_index, we know that $n = g_gen q^{coset_index q n} * h$ for some $h \in H_finset q$.
    obtain ⟨h, hh⟩ : ∃ h ∈ H_finset q, (n : ZMod q) = (g_gen q ^ (coset_index q n).val * h : ZMod q) := by
      have := mem_coset_index q n;
      aesop;
    -- By definition of $C_coset$, we know that $C_coset q (i + coset_index q n)$ is the image of $H_finset q$ under the map $x \mapsto g_gen q^{i + coset_index q n} * x$.
    have hC_coset_def' : C_coset q (i + coset_index q n) = (H_finset q).image (fun x => (g_gen q ^ (i.val + (coset_index q n).val) * x : ZMod q)) := by
      convert hC_coset_def ( i + coset_index q n ) using 1;
      norm_num [ ZMod.val_add ];
      rw [ ← Nat.mod_add_div ( i.val + ( coset_index q n ).val ) 3 ] ; norm_num [ pow_add, pow_mul ] ;
      have h_order : (g_gen q ^ 3 : (ZMod q)ˣ) ∈ H_finset q := by
        exact Set.mem_toFinset.mpr ( MonoidHom.mem_range.mpr ⟨ g_gen q, by simp +decide ⟩ );
      ext; simp [h_order];
      constructor <;> rintro ⟨ a, ha, rfl ⟩;
      · use (g_gen q ^ 3) ^ ((i.val + (coset_index q n).val) / 3) * a; simp_all +decide [ pow_add, pow_mul ] ;
        exact ⟨ by exact Set.mem_toFinset.mpr ( Subgroup.mul_mem _ ( Subgroup.pow_mem _ ( Set.mem_toFinset.mp h_order ) _ ) ( Set.mem_toFinset.mp ha ) ), by ring ⟩;
      · use a * (g_gen q ^ 3)⁻¹ ^ ((i.val + (coset_index q n).val) / 3);
        simp_all +decide [ H_finset ];
        exact ⟨ Subgroup.mul_mem _ ha ( Subgroup.inv_mem _ ( Subgroup.pow_mem _ h_order _ ) ), by simp +decide [ mul_assoc, mul_left_comm, mul_comm ] ⟩;
    simp_all +decide [ pow_add, mul_assoc, mul_comm, mul_left_comm, Finset.ext_iff ];
    intro a; constructor <;> rintro ⟨ x, hx, rfl ⟩;
    · use h * x; simp_all +decide [ mul_assoc, mul_comm, mul_left_comm ] ;
      unfold H_finset at *; aesop;
    · -- Since $h \in H_finset q$, we can find $a \in H_finset q$ such that $h * a = x$.
      obtain ⟨a, ha⟩ : ∃ a ∈ H_finset q, h * a = x := by
        have h_subgroup : ∀ h x : (ZMod q)ˣ, h ∈ H_finset q → x ∈ H_finset q → h⁻¹ * x ∈ H_finset q := by
          unfold H_finset; aesop;
        exact ⟨ h⁻¹ * x, h_subgroup h x hh.1 hx, by simp +decide ⟩;
      exact ⟨ a, ha.1, by rw [ ← ha.2 ] ; push_cast; ring ⟩

/-
The automorphism sigma_n permutes the Gaussian periods by shifting the index by the coset index of n.
-/
lemma sigma_eta_period (q : ℕ) [Fact (Nat.Prime q)] (n : (ZMod q)ˣ) (i : ZMod 3) :
  sigma_cyclotomic_v2 q n (eta_period q i) = eta_period q (i + coset_index q n) := by
    convert congr_arg ( fun x : Finset ( ZMod q ) => ∑ t ∈ x, ( zeta_q q ) ^ t.val ) ( mul_coset_eq q n i ) using 1;
    unfold eta_period;
    simp +zetaDelta at *;
    rw [ sigma_zeta_q ];
    refine' Finset.sum_congr rfl fun x hx => _;
    rw [ ← pow_mul, ZMod.val_mul ];
    rw [ ← Nat.mod_add_div ( ( n : ZMod q ).val * x.val ) q, pow_add, pow_mul ] ; norm_num [ zeta_q ];
    rw [ IsCyclotomicExtension.zeta_pow ] ; aesop

/-
The corrected period differences alpha, beta, gamma.
-/
noncomputable def alpha_correct (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] : CyclotomicField q ℚ :=
  if chi q (g_gen q) = s2 q a then alpha_cyclotomic q else gamma_cyclotomic q

noncomputable def beta_correct (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] : CyclotomicField q ℚ :=
  if chi q (g_gen q) = s2 q a then beta_cyclotomic q else alpha_cyclotomic q

noncomputable def gamma_correct (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] : CyclotomicField q ℚ :=
  if chi q (g_gen q) = s2 q a then gamma_cyclotomic q else beta_cyclotomic q

/-
The action of sigma_n on alpha is determined by the coset index of n.
-/
lemma sigma_alpha_eq (q : ℕ) [Fact (Nat.Prime q)] (n : (ZMod q)ˣ) :
  sigma_cyclotomic_v2 q n (alpha_cyclotomic q) =
    if coset_index q n = 0 then alpha_cyclotomic q
    else if coset_index q n = 1 then beta_cyclotomic q
    else gamma_cyclotomic q := by
      unfold alpha_cyclotomic beta_cyclotomic gamma_cyclotomic at *; split_ifs at * <;> norm_num at *;
      · rw [ sigma_eta_period, sigma_eta_period ] ; simp +decide [ * ];
      · rw [ sigma_eta_period, sigma_eta_period ] ; aesop;
      · rw [ sigma_eta_period, sigma_eta_period ];
        rcases h : coset_index q n with ( _ | _ | _ | k ) <;> simp_all +decide [ Fin.ext_iff ];
        · rfl;
        · grind

/-
3 divides q - 1.
-/
lemma three_dvd_q_sub_one (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_eq : 4 * (q : ℤ) = a^2 + 27) :
  3 ∣ q - 1 := by
    -- From the problem statement, we have 4q = a^2 + 27. Since 3 doesn't divide a, we can look at this equation modulo 3.
    have h_mod3 : 4 * (q : ℤ) ≡ a^2 + 27 [ZMOD 3] := by
      rw [h_eq];
    -- Since $a$ is not divisible by 3, we have $a^2 \equiv 1 \pmod{3}$.
    have h_a_sq_mod3 : a^2 % 3 = 1 := by
      by_cases h_div3_a : 3 ∣ a;
      · obtain ⟨ k, rfl ⟩ := h_div3_a; ring_nf at *; norm_num [ Int.ModEq, Int.add_emod, Int.mul_emod ] at *;
        norm_cast at *; simp_all +decide [ Nat.Prime.dvd_iff_eq Fact.out ] ;
        grind;
      · rw [ sq, Int.mul_emod ] ; ( rw [ Int.dvd_iff_emod_eq_zero ] at h_div3_a; have := Int.emod_nonneg a three_pos.ne'; have := Int.emod_lt_of_pos a three_pos; interval_cases a % 3 <;> trivial; );
    grind

/-
The cube of the cubic character is 1.
-/
lemma chi_pow_three (q : ℕ) [Fact (Nat.Prime q)] (h_div : 3 ∣ q - 1) (x : ZMod q) (hx : x ≠ 0) :
  (chi q x) ^ 3 = 1 := by
    unfold chi;
    rw [ ← pow_mul, Nat.div_mul_cancel h_div, ZMod.pow_card_sub_one_eq_one hx ]

/-
The cubic character of the generator is not 1.
-/
lemma chi_g_ne_one (q : ℕ) [Fact (Nat.Prime q)] (h_div : 3 ∣ q - 1) :
  chi q (g_gen q) ≠ 1 := by
    -- By definition of $chi$, we know that $chi(g_gen(q))$ is a primitive cube root of unity.
    have h_primitive : (chi q (g_gen q)) ^ 3 = 1 ∧ (chi q (g_gen q)) ≠ 1 := by
      refine' ⟨ _, _ ⟩;
      · exact chi_pow_three q h_div _ ( by simp );
      · -- If $\chi(g_gen(q))^3 = 1$, then $g_gen(q)^{(q-1)/3} = 1$.
        by_contra h_contra
        have h_exp : (g_gen q : ZMod q) ^ ((q - 1) / 3) = 1 := by
          unfold chi at h_contra; aesop;
        -- Since $g_gen(q)$ is a generator of the multiplicative group modulo $q$, its order is $q-1$.
        have h_order : orderOf (g_gen q : ZMod q) = q - 1 := by
          rw [ orderOf_units ];
          rw [ orderOf_eq_card_of_forall_mem_zpowers ];
          · norm_num [ Nat.totient_prime Fact.out ];
          · exact Classical.choose_spec ( IsCyclic.exists_generator : ∃ g : ( ZMod q ) ˣ, ∀ x : ( ZMod q ) ˣ, x ∈ Subgroup.zpowers g );
        exact absurd ( orderOf_dvd_iff_pow_eq_one.mpr h_exp ) ( by rw [ h_order ] ; exact Nat.not_dvd_of_pos_of_lt ( Nat.div_pos ( Nat.le_of_dvd ( Nat.sub_pos_of_lt ( Nat.Prime.one_lt Fact.out ) ) h_div ) zero_lt_three ) ( Nat.div_lt_self ( Nat.sub_pos_of_lt ( Nat.Prime.one_lt Fact.out ) ) ( by decide ) ) );
    exact h_primitive.2

/-
An element is in the i-th coset iff its cubic character is chi(g)^i.
-/
lemma mem_coset_iff_chi_eq (q : ℕ) [Fact (Nat.Prime q)] (h_div : 3 ∣ q - 1) (n : (ZMod q)ˣ) (i : ZMod 3) :
  (n : ZMod q) ∈ C_coset q i ↔ chi q n = chi q (g_gen q) ^ i.val := by
    constructor;
    · intro hn
      obtain ⟨h, hh⟩ := Finset.mem_image.mp hn;
      -- Since $h$ is in the subgroup of cubes, we have $\chi(h) = 1$.
      have h_chi_h : chi q h = 1 := by
        by_cases hh' : h = 0 <;> simp_all +decide [ Subgroup.mem_zpowers_iff ];
        obtain ⟨ a, ha, rfl ⟩ := hh.1; simp_all +decide [ H_finset ] ;
        obtain ⟨ b, hb, rfl ⟩ := ha; simp_all +decide [ H_cubes ] ;
        unfold chi ;
        rw [ ← pow_mul, Nat.mul_div_cancel' h_div, ZMod.pow_card_sub_one_eq_one ] ; aesop;
      have h_chi_prod : chi q (↑(g_gen q) ^ i.val * h) = chi q (↑(g_gen q) ^ i.val) * chi q h := by
        exact?;
      convert h_chi_prod using 1 <;> simp +decide [ h_chi_h, hh.2.symm ];
      unfold chi;
      ring;
    · -- If $\chi_q(n) = \chi_q(g)^i$, then $n$ is in the coset $C_i$ because $\chi_q$ is determined by the coset.
      have h_coset : ∀ n : (ZMod q)ˣ, chi q n = chi q (g_gen q) ^ (coset_index q n).val := by
        intro n
        have h_coset_eq : (n : ZMod q) ∈ C_coset q (coset_index q n) := by
          exact?
        have h_char_eq : chi q (n : ZMod q) = chi q ((g_gen q ^ (coset_index q n).val) : ZMod q) := by
          obtain ⟨ x, hx, hx' ⟩ := Finset.mem_image.mp h_coset_eq;
          have h_char_eq : chi q x = 1 := by
            -- Since $x$ is in the image of the cube map, there exists some $y$ such that $x = y^3$.
            obtain ⟨ y, hy ⟩ : ∃ y : (ZMod q)ˣ, x = y^3 := by
              contrapose! hx; simp_all +decide [ H_finset ] ;
              intro y hy; obtain ⟨ z, rfl ⟩ := hy; specialize hx z; aesop;
            have h_char_eq : chi q (y^3) = (chi q y)^3 := by
              unfold chi;
              ring;
            have h_char_eq : (chi q y)^3 = 1 := by
              exact chi_pow_three q h_div y ( by simp +decide );
            aesop;
          have h_char_eq : chi q (↑(g_gen q) ^ (coset_index q n).val * x) = chi q (↑(g_gen q) ^ (coset_index q n).val) * chi q x := by
            convert chi_mul q _ _;
          aesop
        have h_char_eq' : chi q ((g_gen q ^ (coset_index q n).val) : ZMod q) = chi q (g_gen q) ^ (coset_index q n).val := by
          unfold chi;
          ring
        rw [h_char_eq, h_char_eq'];
      intro hn
      have h_ind : coset_index q n = i := by
        have h_coset_eq : ∀ i j : ZMod 3, chi q (g_gen q) ^ i.val = chi q (g_gen q) ^ j.val → i = j := by
          have h_coset_eq : chi q (g_gen q) ^ 3 = 1 ∧ chi q (g_gen q) ≠ 1 := by
            exact ⟨ chi_pow_three q h_div _ ( by simp +decide [ ZMod.natCast_eq_zero_iff ] ), chi_g_ne_one q h_div ⟩;
          have h_coset_eq : ∀ i j : ℕ, i < 3 → j < 3 → chi q (g_gen q) ^ i = chi q (g_gen q) ^ j → i = j := by
            intros i j hi hj h_eq;
            interval_cases i <;> interval_cases j <;> simp +decide [ h_coset_eq ] at h_eq ⊢;
            · exact h_coset_eq.2 h_eq.symm;
            · grind +ring;
            · grind;
            · norm_num [ h_eq ] at h_coset_eq;
            · grind;
          exact fun i j hij => by simpa [ ZMod.natCast_zmod_val ] using congr_arg ( fun x : ℕ => x : ℕ → ZMod 3 ) ( h_coset_eq i.val j.val ( ZMod.val_lt i ) ( ZMod.val_lt j ) hij ) ;
        exact h_coset_eq _ _ ( h_coset n ▸ hn );
      exact h_ind ▸ mem_coset_index q n

/-
The coset index corresponds to the value of the cubic character.
-/
lemma coset_index_chi_eq (q : ℕ) [Fact (Nat.Prime q)] (h_div : 3 ∣ q - 1) (n : (ZMod q)ˣ) :
  (coset_index q n = 0 ↔ chi q n = 1) ∧
  (coset_index q n = 1 ↔ chi q n = chi q (g_gen q)) ∧
  (coset_index q n = 2 ↔ chi q n = chi q (g_gen q) ^ 2) := by
    constructor;
    · unfold coset_index;
      split_ifs <;> simp_all +decide [ mem_coset_iff_chi_eq ];
    · constructor;
      · constructor <;> intro h;
        · convert mem_coset_iff_chi_eq q h_div n 1 |>.1 _;
          · norm_num [ ZMod.val ];
          · convert mem_coset_index q n;
            exact h.symm;
        · unfold coset_index;
          split_ifs <;> simp_all +decide [ mem_coset_iff_chi_eq ];
          · exact chi_g_ne_one q h_div ‹_›;
          · exact ‹¬chi q ( g_gen q : ZMod q ) = chi q ( g_gen q : ZMod q ) ^ ZMod.val 1› ( by erw [ ZMod.val ] ; norm_num );
      · constructor <;> intro h;
        · convert mem_coset_iff_chi_eq q h_div n 2 |>.1 _;
          exact mem_coset_index q n |> fun h' => by simpa [ h ] using h';
        · unfold coset_index;
          split_ifs <;> simp_all +decide [ mem_coset_iff_chi_eq ];
          · have := chi_pow_three q h_div ( g_gen q ) ; rcases ‹chi q ( g_gen q : ZMod q ) = 1 ∨ chi q ( g_gen q : ZMod q ) = -1› with h | h <;> norm_num [ h ] at this;
            · exact absurd h ( chi_g_ne_one q h_div );
            · rw [ neg_eq_iff_add_eq_zero ] at this;
              rcases q with ( _ | _ | _ | q ) <;> cases this <;> contradiction;
          · simp_all +decide [ sq, ZMod.val ];
            unfold chi at * ; aesop

/-
The powers of the cubic character of the generator are distinct for distinct exponents modulo 3.
-/
lemma chi_g_pow_distinct (q : ℕ) [Fact (Nat.Prime q)] (h_div : 3 ∣ q - 1) (i j : ZMod 3) :
  chi q (g_gen q) ^ i.val = chi q (g_gen q) ^ j.val ↔ i = j := by
    -- Since $q$ divides $q-1$, the multiplicative group $(\mathbb{Z}/q\mathbb{Z})^\times$ is cyclic of order $q-1$, and thus the cubic character $\chi$ is a homomorphism with kernel of order $3$.
    have h_order : chi q (g_gen q) ^ 3 = 1 ∧ chi q (g_gen q) ≠ 1 := by
      exact ⟨ chi_pow_three q h_div _ ( by simp +decide ), chi_g_ne_one q h_div ⟩
    generalize_proofs at *; (
    have := h_order.1; simp_all +decide [ pow_succ, mul_assoc ] ;
    fin_cases i <;> fin_cases j <;> simp_all +decide [ pow_succ, mul_assoc ] ;
    all_goals simp_all +decide [ ZMod.val, pow_succ ] ;
    · exact Ne.symm h_order;
    · grind;
    · grind +ring;
    · grind +ring;
    · grind)

/-
The normalized period differences alpha*, beta*, gamma* which satisfy X^3 - qX - q = 0.
-/
noncomputable def epsilon_cyclotomic (q : ℕ) [Fact (Nat.Prime q)] : ℤ :=
  if alpha_cyclotomic q * beta_cyclotomic q * gamma_cyclotomic q = (q : CyclotomicField q ℚ) then 1 else -1

noncomputable def alpha_star (q : ℕ) [Fact (Nat.Prime q)] : CyclotomicField q ℚ :=
  (epsilon_cyclotomic q : ℚ) • alpha_cyclotomic q

noncomputable def beta_star (q : ℕ) [Fact (Nat.Prime q)] : CyclotomicField q ℚ :=
  (epsilon_cyclotomic q : ℚ) • beta_cyclotomic q

noncomputable def gamma_star (q : ℕ) [Fact (Nat.Prime q)] : CyclotomicField q ℚ :=
  (epsilon_cyclotomic q : ℚ) • gamma_cyclotomic q

/-
The cosets C_i are pairwise disjoint.
-/
lemma C_coset_disjoint (q : ℕ) [Fact (Nat.Prime q)] (h_div : 3 ∣ q - 1) (i j : ZMod 3) (h_neq : i ≠ j) :
  Disjoint (C_coset q i) (C_coset q j) := by
    -- By definition of $C_coset$, we know that if $x \in C_coset q i$ and $y \in C_coset q j$, then $\chi_q(x) = \chi_q(g_gen q)^i$ and $\chi_q(y) = \chi_q(g_gen q)^j$.
    have h_char : ∀ i : ZMod 3, ∀ x ∈ C_coset q i, chi q x = chi q (g_gen q) ^ i.val := by
      intro i x hx
      have h_char : chi q x = chi q (g_gen q) ^ i.val := by
        have h_mem : (x : ZMod q) ∈ C_coset q i := by
          exact hx
        have := mem_coset_iff_chi_eq q h_div (Units.mk0 x (by
        unfold C_coset at h_mem; aesop;)) i
        generalize_proofs at *; aesop;
      generalize_proofs at *; exact h_char;
    generalize_proofs at *; (
    rw [ Finset.disjoint_left ] ; intro x hx hx'; have := h_char i x hx; have := h_char j x hx'; simp_all +decide [ pow_succ' ] ;
    have := chi_g_pow_distinct q h_div i j; simp_all +decide ;)

/-
The cosets C_i are pairwise disjoint.
-/
lemma C_coset_disjoint_v2 (q : ℕ) [Fact (Nat.Prime q)] (h_div : 3 ∣ q - 1) (i j : ZMod 3) (h_neq : i ≠ j) :
  Disjoint (C_coset q i) (C_coset q j) := by
    convert C_coset_disjoint q h_div i j h_neq using 1

/-
The sum of zeta^x for x in (ZMod q)* is -1.
-/
lemma sum_zeta_units_eq_neg_one (q : ℕ) [Fact (Nat.Prime q)] :
  ∑ x : (ZMod q)ˣ, (zeta_q q) ^ (x : ZMod q).val = -1 := by
    have h_sum_zeta : ∑ x ∈ Finset.univ.erase 0, (zeta_q q) ^ (x : ZMod q).val = -1 := by
      have h_sum_zeta : ∑ x ∈ Finset.range q, (zeta_q q) ^ x = 0 := by
        rw [ geom_sum_eq ] <;> norm_num [ zeta_q ];
        · exact Or.inl ( sub_eq_zero_of_eq <| IsCyclotomicExtension.zeta_pow _ _ _ );
        · have h_zeta_ne_one : IsPrimitiveRoot (IsCyclotomicExtension.zeta q ℚ (CyclotomicField q ℚ)) q := by
            exact?
          generalize_proofs at *; (
          exact h_zeta_ne_one.ne_one ( Nat.Prime.one_lt Fact.out ));
      rcases q with ( _ | _ | q ) <;> simp_all +decide [ Finset.sum_range, ZMod ];
      · exact absurd Fact.out ( Nat.not_prime_zero );
      · convert h_sum_zeta using 1;
    convert h_sum_zeta using 1;
    refine' Finset.sum_bij ( fun x _ => x ) _ _ _ _ <;> simp +decide;
    · exact fun a₁ a₂ h => Units.ext h;
    · exact fun b hb => ⟨ Units.mk0 b hb, by simp +decide ⟩

/-
The union of the cosets is the set of units (as elements of ZMod q).
-/
lemma C_coset_union (q : ℕ) [Fact (Nat.Prime q)] (h_div : 3 ∣ q - 1) :
  Finset.biUnion Finset.univ (fun i : ZMod 3 => C_coset q i) = Finset.univ.image (fun x : (ZMod q)ˣ => (x : ZMod q)) := by
    ext x;
    by_cases hx : x = 0 <;> simp +decide [ hx ];
    · rintro i hi; simp_all +decide [ C_coset ] ;
    · constructor <;> intro h;
      · exact ⟨ Units.mk0 x hx, by simp +decide ⟩;
      · obtain ⟨ a, rfl ⟩ := h; exact ⟨ coset_index q a, mem_coset_index q a ⟩ ;

/-
Every unit belongs to some coset.
-/
lemma exists_coset_mem (q : ℕ) [Fact (Nat.Prime q)] (x : (ZMod q)ˣ) :
  ∃ i : ZMod 3, (x : ZMod q) ∈ C_coset q i := by
    exact ⟨ _, mem_coset_index q x ⟩

/-
The sum of alpha, beta, and gamma is zero.
-/
lemma sum_alpha_beta_gamma_eq_zero (q : ℕ) [Fact (Nat.Prime q)] :
  alpha_cyclotomic q + beta_cyclotomic q + gamma_cyclotomic q = 0 := by
    unfold alpha_cyclotomic beta_cyclotomic gamma_cyclotomic; ring;

/-
The sum of the Gaussian periods is -1.
-/
lemma sum_eta_period_eq_neg_one (q : ℕ) [Fact (Nat.Prime q)] (h_div : 3 ∣ q - 1) :
  eta_period q 0 + eta_period q 1 + eta_period q 2 = -1 := by
    -- The sum of the sums of the cosets is equal to the sum over all units because the cosets are disjoint and their union is the set of units.
    have h_sum_cosets : ∑ i : ZMod 3, ∑ t ∈ C_coset q i, (zeta_q q) ^ t.val = ∑ t ∈ Finset.univ.image (fun x : (ZMod q)ˣ => (x : ZMod q)), (zeta_q q) ^ t.val := by
      rw [ ← Finset.sum_biUnion ];
      · congr;
        exact?;
      · exact fun i _ j _ hij => C_coset_disjoint_v2 q h_div i j hij;
    rw [ Finset.sum_image ] at h_sum_cosets;
    · convert h_sum_cosets using 1;
      · erw [ Fin.sum_univ_three ] ; rfl;
      · exact?;
    · intro x hx y hy; aesop;

/-
The sum of the Gaussian periods is -1.
-/
lemma sum_eta_period_eq_neg_one_v2 (q : ℕ) [Fact (Nat.Prime q)] (h_div : 3 ∣ q - 1) :
  eta_period q 0 + eta_period q 1 + eta_period q 2 = -1 := by
    -- Apply the lemma that states the sum of the Gaussian periods is -1.
    apply sum_eta_period_eq_neg_one q h_div

/-
Checking if sum_eta_period_eq_neg_one is defined.
-/
#check sum_eta_period_eq_neg_one

/-
-1 is in the subgroup of cubes.
-/
lemma neg_one_in_H (q : ℕ) [Fact (Nat.Prime q)] :
  (-1 : (ZMod q)ˣ) ∈ H_finset q := by
    convert Set.mem_setOf.mpr ( Set.mem_image_of_mem _ ( Subgroup.one_mem _ ) );
    rotate_left;
    exact ZMod q;
    exact fun _ => -1;
    exact ( ZMod q )ˣ;
    exact inferInstance;
    exact?;
    simp +decide [ H_finset, H_cubes ];
    constructor <;> intro h;
    · exact ⟨ 1, 1, by norm_num ⟩;
    · exact ⟨ -1, by norm_num ⟩

/-
Algebraic identity relating sum of pairwise products of period differences to sum of squares of periods.
-/
lemma sum_mul_pairs_algebraic_identity (q : ℕ) [Fact (Nat.Prime q)] (h_div : 3 ∣ q - 1) :
  2 * (alpha_cyclotomic q * beta_cyclotomic q + beta_cyclotomic q * gamma_cyclotomic q + gamma_cyclotomic q * alpha_cyclotomic q) =
  1 - 3 * (eta_period q 0 ^ 2 + eta_period q 1 ^ 2 + eta_period q 2 ^ 2) := by
  let e0 := eta_period q 0
  let e1 := eta_period q 1
  let e2 := eta_period q 2
  have h_sum : e0 + e1 + e2 = -1 := sum_eta_period_eq_neg_one_v2 q h_div
  have h_sq_sum : (e0 + e1 + e2)^2 = 1 := by rw [h_sum]; norm_num
  have h_expand : (e0 + e1 + e2)^2 = e0^2 + e1^2 + e2^2 + 2 * (e0 * e1 + e1 * e2 + e2 * e0) := by ring
  have h_cross : 2 * (e0 * e1 + e1 * e2 + e2 * e0) = 1 - (e0^2 + e1^2 + e2^2) := by linear_combination h_sq_sum - h_expand
  
  have h_alpha : alpha_cyclotomic q = e0 - e1 := rfl
  have h_beta : beta_cyclotomic q = e1 - e2 := rfl
  have h_gamma : gamma_cyclotomic q = e2 - e0 := rfl
  
  rw [h_alpha, h_beta, h_gamma]
  ring_nf
  linear_combination h_cross

/-
Algebraic identity relating sum of pairwise products of period differences to sum of squares of periods.
-/
lemma sum_mul_pairs_algebraic_identity_v2 (q : ℕ) [Fact (Nat.Prime q)] (h_div : 3 ∣ q - 1) :
  2 * (alpha_cyclotomic q * beta_cyclotomic q + beta_cyclotomic q * gamma_cyclotomic q + gamma_cyclotomic q * alpha_cyclotomic q) =
  1 - 3 * (eta_period q 0 ^ 2 + eta_period q 1 ^ 2 + eta_period q 2 ^ 2) := by
  let e0 := eta_period q 0
  let e1 := eta_period q 1
  let e2 := eta_period q 2
  
  have h_sum : e0 + e1 + e2 = -1 := sum_eta_period_eq_neg_one_v2 q h_div
  
  have h_sq_sum : (e0 + e1 + e2)^2 = 1 := by rw [h_sum]; norm_num
  
  have h_expand : (e0 + e1 + e2)^2 = e0^2 + e1^2 + e2^2 + 2 * (e0 * e1 + e1 * e2 + e2 * e0) := by ring
  
  have h_cross : 2 * (e0 * e1 + e1 * e2 + e2 * e0) = 1 - (e0^2 + e1^2 + e2^2) := by
    rw [h_expand] at h_sq_sum
    linear_combination h_sq_sum
    
  have h_alpha : alpha_cyclotomic q = e0 - e1 := rfl
  have h_beta : beta_cyclotomic q = e1 - e2 := rfl
  have h_gamma : gamma_cyclotomic q = e2 - e0 := rfl
  
  rw [h_alpha, h_beta, h_gamma]
  
  have h_lhs : 2 * ((e0 - e1) * (e1 - e2) + (e1 - e2) * (e2 - e0) + (e2 - e0) * (e0 - e1)) = 
               2 * (e0 * e1 + e1 * e2 + e2 * e0) - 2 * (e0^2 + e1^2 + e2^2) := by ring
               
  rw [h_lhs, h_cross]
  ring

/-
Abbreviations for the cyclotomic field and its ring of integers.
-/
abbrev Kcyc (q : ℕ) [Fact (Nat.Prime q)] := CyclotomicField q ℚ

abbrev Okcyc (q : ℕ) [Fact (Nat.Prime q)] := NumberField.RingOfIntegers (Kcyc q)

/-
The primitive q-th root of unity as an algebraic integer.
-/
noncomputable def zeta_int_q (q : ℕ) [Fact (Nat.Prime q)] : Okcyc q :=
  ⟨zeta_q q, IsPrimitiveRoot.isIntegral (IsCyclotomicExtension.zeta_spec q ℚ (Kcyc q)) (Fact.out : Nat.Prime q).pos⟩

/-
N as a unit in ZMod q.
-/
noncomputable def N_unit (q : ℕ) (N : ℕ) [Fact (Nat.Prime q)] [Fact (Nat.Prime N)] (hN : N ≠ q) : (ZMod q)ˣ :=
  Units.mk0 (N : ZMod q) (by
  rw [ Ne.eq_def, ZMod.natCast_eq_zero_iff ];
  exact fun h => hN <| by rw [ Nat.prime_dvd_prime_iff_eq Fact.out Fact.out ] at h; tauto;)

/-
The automorphism sigma restricted to the ring of integers, as a Z-algebra equivalence.
-/
noncomputable def sigma_int_cyc (q : ℕ) [Fact (Nat.Prime q)] (n : (ZMod q)ˣ) : Okcyc q ≃ₐ[ℤ] Okcyc q :=
  (NumberField.RingOfIntegers.mapAlgEquiv (sigma_cyclotomic_v2 q n)).restrictScalars ℤ

/-
alpha as an algebraic integer.
-/
noncomputable def alpha_int_cyc (q : ℕ) [Fact (Nat.Prime q)] : Okcyc q :=
  ⟨alpha_cyclotomic q, by
    -- Since each Gaussian period is a sum of roots of unity, which are algebraic integers, their differences are also algebraic integers.
    have h_gauss_period_int : ∀ i : ZMod 3, eta_period q i ∈ integralClosure ℤ (Kcyc q) := by
      intro i
      have h_sum_int : ∀ t ∈ C_coset q i, (zeta_q q) ^ t.val ∈ integralClosure ℤ (Kcyc q) := by
        intro t ht
        have h_zeta_int : zeta_q q ∈ integralClosure ℤ (Kcyc q) := by
          exact IsPrimitiveRoot.isIntegral ( IsCyclotomicExtension.zeta_spec q ℚ ( Kcyc q ) ) ( Fact.out : Nat.Prime q ).pos;
        exact IsIntegral.pow h_zeta_int _;
      exact Subalgebra.sum_mem _ h_sum_int;
    exact Subalgebra.sub_mem _ ( h_gauss_period_int 0 ) ( h_gauss_period_int 1 )⟩

/-
beta as an algebraic integer.
-/
noncomputable def beta_int_cyc (q : ℕ) [Fact (Nat.Prime q)] : Okcyc q :=
  ⟨beta_cyclotomic q, by
    -- Similar to alpha, beta is a difference of Gaussian periods, which are sums of roots of unity (integers).
    have h_gauss_period_int : ∀ i : ZMod 3, eta_period q i ∈ integralClosure ℤ (Kcyc q) := by
      intro i
      have h_sum_int : ∀ t ∈ C_coset q i, (zeta_q q) ^ t.val ∈ integralClosure ℤ (Kcyc q) := by
        intro t ht
        have h_zeta_int : zeta_q q ∈ integralClosure ℤ (Kcyc q) := by
          exact IsPrimitiveRoot.isIntegral ( IsCyclotomicExtension.zeta_spec q ℚ ( Kcyc q ) ) ( Fact.out : Nat.Prime q ).pos;
        exact IsIntegral.pow h_zeta_int _;
      exact Subalgebra.sum_mem _ h_sum_int;
    exact Subalgebra.sub_mem _ ( h_gauss_period_int 1 ) ( h_gauss_period_int 2 )⟩

/-
gamma as an algebraic integer.
-/
noncomputable def gamma_int_cyc (q : ℕ) [Fact (Nat.Prime q)] : Okcyc q :=
  ⟨gamma_cyclotomic q, by
    -- Similar to alpha and beta, gamma is a difference of Gaussian periods.
    have h_gauss_period_int : ∀ i : ZMod 3, eta_period q i ∈ integralClosure ℤ (Kcyc q) := by
      intro i
      have h_sum_int : ∀ t ∈ C_coset q i, (zeta_q q) ^ t.val ∈ integralClosure ℤ (Kcyc q) := by
        intro t ht
        have h_zeta_int : zeta_q q ∈ integralClosure ℤ (Kcyc q) := by
          exact IsPrimitiveRoot.isIntegral ( IsCyclotomicExtension.zeta_spec q ℚ ( Kcyc q ) ) ( Fact.out : Nat.Prime q ).pos;
        exact IsIntegral.pow h_zeta_int _;
      exact Subalgebra.sum_mem _ h_sum_int;
    exact Subalgebra.sub_mem _ ( h_gauss_period_int 2 ) ( h_gauss_period_int 0 )⟩

/-
The ring of integers of the q-th cyclotomic field is generated by zeta_q.
-/
theorem Okcyc_eq_adjoin_zeta (q : ℕ) [Fact (Nat.Prime q)] :
  (⊤ : Subalgebra ℤ (Okcyc q)) = Algebra.adjoin ℤ {zeta_int_q q} := by
    apply le_antisymm;
    · intro x hx;
      obtain ⟨ y, hy ⟩ := x;
      have h_gen : y ∈ Algebra.adjoin ℤ {zeta_q q} := by
        have h_gen : IsIntegralClosure (Algebra.adjoin ℤ {zeta_q q}) ℤ (Kcyc q) := by
          convert IsCyclotomicExtension.Rat.isIntegralClosure_adjoin_singleton_of_prime ( show IsPrimitiveRoot ( zeta_q q ) q from ?_ ) using 1;
          convert IsCyclotomicExtension.zeta_spec q ℚ ( Kcyc q );
        convert h_gen.isIntegral_iff.mp hy;
        exact ⟨ fun h => ⟨ ⟨ y, h ⟩, rfl ⟩, by rintro ⟨ y, rfl ⟩ ; exact y.2 ⟩;
      rw [ Algebra.adjoin_singleton_eq_range_aeval ] at *;
      obtain ⟨ p, rfl ⟩ := h_gen;
      use p;
      ext; simp +decide [ aeval_def ] ;
      congr;
    · exact le_top

/-
The automorphism sigma_N acts as the Frobenius map modulo P.
-/
theorem artin_property_cyc (q : ℕ) [Fact (Nat.Prime q)]
  (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ q)
  (P : Ideal (Okcyc q)) [P.IsMaximal]
  (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (x : Okcyc q) :
  Ideal.Quotient.mk P (sigma_int_cyc q (N_unit q N hN) x)
    = (Ideal.Quotient.mk P x) ^ N := by
      convert Ideal.Quotient.eq.2 _ using 1
      generalize_proofs at *;
      have h_fermat : ∀ (x : ℤ), (sigma_int_cyc q (N_unit q N hN)) ↑x - ↑x ^ N ∈ P := by
        intro x
        have h_fermat : (x ^ N - x : ℤ) ∈ Ideal.span {(N : ℤ)} := by
          haveI := Fact.mk ( Fact.out : Nat.Prime N ) ; simp +decide [ ← ZMod.intCast_zmod_eq_zero_iff_dvd, Ideal.mem_span_singleton ] ;
        generalize_proofs at *;
        have h_fermat : (x ^ N - x : Okcyc q) ∈ P := by
          have h_fermat : (x ^ N - x : Okcyc q) ∈ Ideal.map (algebraMap ℤ (Okcyc q)) (Ideal.span {(N : ℤ)}) := by
            convert Ideal.mem_map_of_mem _ h_fermat using 1
            generalize_proofs at *;
            norm_num +zetaDelta at *
          generalize_proofs at *;
          exact hP.1 ▸ h_fermat |> fun h => Ideal.map_le_iff_le_comap.mpr ( by aesop ) h
        generalize_proofs at *;
        convert P.neg_mem h_fermat using 1 ; simp +decide [ sub_eq_iff_eq_add ]
      generalize_proofs at *;
      have h_induction : ∀ (x : Okcyc q), (∀ y : Okcyc q, y ∈ Algebra.adjoin ℤ {zeta_int_q q} → (sigma_int_cyc q (N_unit q N hN)) y - y ^ N ∈ P) := by
        intro x y hy
        induction' hy using Algebra.adjoin_induction with y hy ih
        all_goals generalize_proofs at *;
        · have h_zeta_pow : (sigma_int_cyc q (N_unit q N hN)) (zeta_int_q q) = (zeta_int_q q) ^ N := by
            have h_zeta_pow : (sigma_cyclotomic_v2 q (N_unit q N hN)) (zeta_q q) = (zeta_q q) ^ N := by
              convert sigma_zeta_q q ( N_unit q N hN ) using 1
              generalize_proofs at *;
              simp +decide [ N_unit ];
              rw [ ← Nat.mod_add_div N q, pow_add, pow_mul ] ; norm_num [ IsPrimitiveRoot.pow_eq_one ] ; ring;
              rw [ pow_mul, show zeta_q q ^ q = 1 from ?_, one_pow, mul_one ];
              exact IsCyclotomicExtension.zeta_pow q ℚ ( CyclotomicField q ℚ )
            generalize_proofs at *;
            exact Subtype.ext h_zeta_pow
          generalize_proofs at *;
          aesop
          skip;
        · exact h_fermat ih;
        · rename_i x y hx hy hx' hy';
          have h_frobenius : (x + y) ^ N ≡ x ^ N + y ^ N [SMOD P] := by
            have h_frobenius : (x + y) ^ N = x ^ N + y ^ N + ∑ k ∈ Finset.Ico 1 N, Nat.choose N k * x ^ k * y ^ (N - k) := by
              rw [ add_pow ] ; ring;
              rw [ add_comm, Finset.sum_Ico_eq_sub _ ] <;> norm_num [ Finset.sum_range_succ ] ; ring
              skip;
              exact Nat.Prime.pos Fact.out
            generalize_proofs at *;
            rw [ h_frobenius, SModEq ];
            rw [ Submodule.Quotient.eq ] ; simp +decide [ Ideal.Quotient.eq_zero_iff_mem ] ; (
            refine' P.sum_mem _;
            intro k hk; have := hP.1; simp_all +decide [ Ideal.mem_span_singleton ] ;
            replace this := SetLike.ext_iff.mp this ( N.choose k : ℤ ) ; simp_all +decide [ Ideal.mem_span_singleton ] ;
            exact P.mul_mem_right _ ( P.mul_mem_right _ ( this.mp ( mod_cast Nat.dvd_of_mod_eq_zero ( by rw [ Nat.mod_eq_zero_of_dvd ] ; exact Nat.Prime.dvd_choose_self ( Fact.out : Nat.Prime N ) ( by linarith ) ( by linarith ) ) ) ) ))
          generalize_proofs at *;
          rw [ SModEq ] at h_frobenius
          generalize_proofs at *;
          rw [ Submodule.Quotient.eq ] at h_frobenius
          generalize_proofs at *;
          convert P.sub_mem ( P.add_mem hx' hy' ) h_frobenius using 1 ; ring!;
          rw [ map_add ] ; ring!;
        · rename_i hx hy hx' hy' ihx ihy
          generalize_proofs at *;
          have h_mul : (sigma_int_cyc q (N_unit q N hN)) (‹Okcyc q› * ‹Okcyc q›) - (‹Okcyc q› * ‹Okcyc q›) ^ N = (sigma_int_cyc q (N_unit q N hN)) ‹Okcyc q› * (sigma_int_cyc q (N_unit q N hN)) ‹Okcyc q› - ‹Okcyc q› ^ N * ‹Okcyc q› ^ N := by
            rw [ map_mul, mul_pow ]
          generalize_proofs at *;
          rw [h_mul] at *; (
          have h_mul : (sigma_int_cyc q (N_unit q N hN)) hx * (sigma_int_cyc q (N_unit q N hN)) hy - hx ^ N * hy ^ N = (sigma_int_cyc q (N_unit q N hN)) hx * ((sigma_int_cyc q (N_unit q N hN)) hy - hy ^ N) + hy ^ N * ((sigma_int_cyc q (N_unit q N hN)) hx - hx ^ N) := by
            ring
            skip
          generalize_proofs at *; (
          exact h_mul.symm ▸ P.add_mem ( P.mul_mem_left _ ihy ) ( P.mul_mem_left _ ihx ) |> fun h => by simpa [ mul_pow ] using h;));
      generalize_proofs at *;
      convert h_induction x x _ using 1
      generalize_proofs at *;
      have := Okcyc_eq_adjoin_zeta q
      generalize_proofs at *;
      exact this ▸ Algebra.mem_top
      skip

/-
If chi(g) = s2, then s1 = chi(g)^2.
-/
lemma s1_eq_chi_g_sq (q : ℕ) (a : ℤ) [Fact (Nat.Prime q)] (h_q_ge_7 : q ≥ 7)
  (h_eq : 4 * (q : ℤ) = a^2 + 27)
  (h_chi_s2 : chi q (g_gen q) = s2 q a) :
  s1 q a = chi q (g_gen q) ^ 2 := by
    rw [ h_chi_s2, pow_two ];
    unfold s1 s2; ring;
    field_simp;
    rw [ div_eq_div_iff ] <;> norm_cast ; ring;
    · rw [ show a ^ 2 = 4 * q - 27 by linarith ] ; norm_num ; ring;
    · erw [ ZMod.natCast_eq_zero_iff ] ; intro H; have := Nat.le_of_dvd ( by linarith ) H; interval_cases q;
    · erw [ ZMod.natCast_eq_zero_iff ] ; intro H; have := Nat.le_of_dvd ( by decide ) H; interval_cases q <;> trivial;

/-
The Dream Theorem in the cyclotomic field: the Frobenius automorphism maps alpha to gamma or beta depending on the cubic character.
-/
theorem dream_theorem_cyclotomic (q : ℕ) (a : ℤ)
  [Fact (Nat.Prime q)]
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27)
  (h_period : alpha_cyclotomic q ^ 3
    = (q : CyclotomicField q ℚ) * alpha_cyclotomic q
    + (q : CyclotomicField q ℚ))
  (N : ℕ) [Fact (Nat.Prime N)]
  (h_N_ne_q : N ≠ q) (h_gcd : Int.gcd a N = 1)
  (P : Ideal (Okcyc q)) [P.IsMaximal]
  (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_chi_s2 : chi q (g_gen q) = s2 q a) :
  let alpha_bar := Ideal.Quotient.mk P (alpha_int_cyc q)
  let beta_bar := Ideal.Quotient.mk P (beta_int_cyc q)
  let gamma_bar := Ideal.Quotient.mk P (gamma_int_cyc q)
  (c_value q N = s1 q a → alpha_bar ^ N = gamma_bar) ∧
  (c_value q N = s2 q a → alpha_bar ^ N = beta_bar) := by
    constructor;
    · intro h
      have h_coset : coset_index q (N_unit q N h_N_ne_q) = 2 := by
        have h_coset : chi q (N_unit q N h_N_ne_q) = chi q (g_gen q) ^ 2 := by
          have h_coset : c_value q N = chi q (N_unit q N h_N_ne_q) := by
            unfold c_value; aesop;
          rw [ ← h_coset, h, s1_eq_chi_g_sq q a ( q_ge_7_of_eq q a h_eq ) ( mod_cast h_eq ) h_chi_s2 ];
        have := coset_index_chi_eq q ( show 3 ∣ q - 1 from ?_ ) ( N_unit q N h_N_ne_q );
        · exact this.2.2.mpr h_coset;
        · have h_div : 3 ∣ q - 1 := by
            have h_eq : 4 * (q : ℤ) = a^2 + 27 := by
              exact_mod_cast h_eq
            exact?;
          exact h_div;
      have h_sigma_alpha : sigma_int_cyc q (N_unit q N h_N_ne_q) (alpha_int_cyc q) = gamma_int_cyc q := by
        have h_sigma_alpha : sigma_cyclotomic_v2 q (N_unit q N h_N_ne_q) (alpha_cyclotomic q) = gamma_cyclotomic q := by
          rw [ sigma_alpha_eq ] ; aesop;
        exact Subtype.ext h_sigma_alpha;
      rw [ ← h_sigma_alpha, ← artin_property_cyc ];
      exact hP;
    · intro h_case2
      have h_coset_index : coset_index q (N_unit q N h_N_ne_q) = 1 := by
        have := coset_index_chi_eq q ( show 3 ∣ q - 1 from ?_ ) ( N_unit q N h_N_ne_q ) ; aesop;
        exact three_dvd_q_sub_one q a ( mod_cast h_eq );
      have h_sigma_alpha : sigma_int_cyc q (N_unit q N h_N_ne_q) (alpha_int_cyc q) = beta_int_cyc q := by
        have h_sigma_alpha : sigma_cyclotomic_v2 q (N_unit q N h_N_ne_q) (alpha_cyclotomic q) = beta_cyclotomic q := by
          rw [ sigma_alpha_eq ] ; aesop;
        exact Subtype.ext h_sigma_alpha;
      rw [ ← h_sigma_alpha, artin_property_cyc ];
      exact hP

/-
A monic cubic polynomial is irreducible if and only if it has no roots in the field.
-/
lemma cubic_irred_iff_no_roots {F : Type*} [Field F]
  (p : Polynomial F) (hp : p.natDegree = 3) (hm : p.Monic) :
  Irreducible p ↔ ∀ x : F, Polynomial.aeval x p ≠ 0 := by
    constructor;
    · intro h x hx; have := Polynomial.degree_eq_one_of_irreducible_of_root h hx; rw [ Polynomial.degree_eq_natDegree ] at this <;> aesop;
    · intro h_no_roots
      have h_irred : ∀ f g : F[X], p = f * g → f.degree > 0 → g.degree > 0 → False := by
        intro f g hfg hf hg
        have h_deg : f.degree + g.degree = 3 := by
          rw [ ← Polynomial.degree_mul, ← hfg, Polynomial.degree_eq_natDegree hm.ne_zero, hp ] ; norm_cast;
        -- Since $f$ and $g$ are non-constant polynomials with degrees adding up to 3, one of them must have degree 1.
        have h_deg_one : f.degree = 1 ∨ g.degree = 1 := by
          rw [ Polynomial.degree_eq_natDegree ( Polynomial.ne_zero_of_degree_gt hf ), Polynomial.degree_eq_natDegree ( Polynomial.ne_zero_of_degree_gt hg ) ] at * ; norm_cast at * ; omega;
        rcases h_deg_one with ( h | h ) <;> obtain ⟨ x, hx ⟩ := Polynomial.exists_root_of_degree_eq_one h <;> simp_all +decide [ Polynomial.aeval_mul ];
      constructor;
      · exact fun h => absurd ( Polynomial.natDegree_eq_zero_of_isUnit h ) ( by simp +decide [ hp ] );
      · intro f g hfg; contrapose! h_irred; simp_all +decide [ Polynomial.isUnit_iff_degree_eq_zero ] ;
        exact ⟨ f, g, rfl, lt_of_le_of_ne ( le_of_not_gt fun h => by aesop ) ( Ne.symm h_irred.1 ), lt_of_le_of_ne ( le_of_not_gt fun h => by aesop ) ( Ne.symm h_irred.2 ) ⟩

/-
The polynomial f_mod_N is monic.
-/
lemma f_mod_N_monic (q N : ℕ) [Fact (Nat.Prime N)] :
  (f_mod_N q N).Monic := by
    unfold f_mod_N;
    rw [ Polynomial.Monic, Polynomial.leadingCoeff_sub_of_degree_lt ] <;> norm_num;
    · rw [ Polynomial.leadingCoeff_sub_of_degree_lt ] <;> norm_num;
      exact lt_of_le_of_lt ( add_le_add_right Polynomial.degree_C_le _ ) ( by norm_num );
    · rw [ Polynomial.degree_sub_eq_left_of_degree_lt ] <;> norm_num;
      · exact lt_of_le_of_lt Polynomial.degree_C_le ( WithBot.coe_lt_coe.mpr ( by norm_num ) );
      · exact lt_of_le_of_lt ( add_le_add_right Polynomial.degree_C_le _ ) ( by norm_num )

/-
The degree of f_mod_N is 3.
-/
lemma f_mod_N_degree (q N : ℕ) [Fact (Nat.Prime N)] :
  (f_mod_N q N).natDegree = 3 := by
    -- The degree of $X^3$ is 3, and the degree of $C q * X + C q$ is 1. Since 1 < 3, the degree of the difference is 3.
    have h_deg : Polynomial.natDegree (Polynomial.X^3 - Polynomial.C (q : ZMod N) * Polynomial.X - Polynomial.C (q : ZMod N)) = 3 := by
      rw [ Polynomial.natDegree_sub_C, Polynomial.natDegree_sub_eq_left_of_natDegree_lt ] <;> by_cases h : ( q : ZMod N ) = 0 <;> simp +decide [ h ];
      erw [ Polynomial.natDegree_C_mul_X ] <;> simp +decide [ h ];
    exact h_deg

/-
For primes q != N, there exists a maximal ideal P of Okcyc q lying over the ideal generated by N in Z.
-/
lemma exists_maximal_lies_over (q N : ℕ)
  [Fact (Nat.Prime q)] [Fact (Nat.Prime N)] (h : N ≠ q) :
  ∃ P : Ideal (Okcyc q),
    P.IsMaximal ∧ P.LiesOver (Ideal.span {(N : ℤ)}) := by
      have := Ideal.exists_le_maximal ( Ideal.span { ( N : Okcyc q ) } ) ?_;
      · obtain ⟨ M, hM₁, hM₂ ⟩ := this; use M; refine' ⟨ hM₁, _ ⟩ ; simp_all +decide [ Ideal.LiesOver ] ;
        have h_comap_max : Ideal.IsMaximal (M.comap (algebraMap ℤ (Okcyc q))) := by
          exact?;
        have h_comap_eq : Ideal.comap (algebraMap ℤ (Okcyc q)) M = Ideal.span {↑N} := by
          have h_comap_eq : Ideal.comap (algebraMap ℤ (Okcyc q)) M ≥ Ideal.span {↑N} := by
            exact Ideal.span_le.mpr ( Set.singleton_subset_iff.mpr <| by simpa using hM₂ <| Ideal.mem_span_singleton_self _ );
          have h_comap_eq : Ideal.IsMaximal (Ideal.span {↑N} : Ideal ℤ) := by
            exact?;
          have := h_comap_eq.1;
          have := this.2;
          contrapose! this;
          exact ⟨ Ideal.comap ( algebraMap ℤ ( Okcyc q ) ) M, lt_of_le_of_ne ‹_› ( Ne.symm this ), h_comap_max.ne_top ⟩;
        exact h_comap_eq.symm ▸ by tauto;
      · rw [ Ne.eq_def, Ideal.eq_top_iff_one ];
        rw [ Ideal.mem_span_singleton ];
        intro h_div_one
        obtain ⟨u, hu⟩ := h_div_one
        have h_unit : IsUnit (N : Okcyc q) := by
          exact isUnit_of_mul_eq_one _ _ hu.symm
        have h_unit_z : IsUnit (N : ℤ) := by
          have h_unit_z : IsUnit (algebraMap ℤ (Okcyc q) N) := by
            exact?;
          convert h_unit_z using 1;
          exact?
        have h_unit_q : N = 1 := by
          exact Nat.dvd_one.mp ( Int.natCast_dvd_natCast.mp h_unit_z.dvd )
        exact absurd h_unit_q (by
        exact Nat.Prime.ne_one Fact.out)

/-
The characteristic of the residue field Ok/P is N.
-/
lemma ringChar_Ok_P (q N : ℕ) [Fact (Nat.Prime N)]
  [Fact (Nat.Prime q)]
  (P : Ideal (Okcyc q)) [P.IsMaximal]
  (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  ringChar (Okcyc q ⧸ P) = N := by
    have h_char : (N : Okcyc q ⧸ P) = 0 := by
      erw [ Ideal.Quotient.eq_zero_iff_mem ];
      exact hP.1.le ( Ideal.mem_span_singleton_self _ ) |> fun h => by simpa [ ← ZMod.intCast_zmod_eq_zero_iff_dvd ] using h;
    have h_char_prime : ringChar (Okcyc q ⧸ P) ∣ N := by
      exact?;
    rw [ Nat.dvd_prime Fact.out ] at h_char_prime;
    cases h_char_prime <;> simp_all +decide [ ringChar.eq_iff ];
    exact absurd ( CharP.char_is_prime_or_zero ( Okcyc q ⧸ P ) 1 ) ( by simp +decide [ Fact.out ( p := Nat.Prime N ) ] )

/-
The images of alpha, beta, and gamma in the residue field Ok/P satisfy the cubic equation x^3 - qx - q = 0.
-/
lemma roots_satisfy_f_in_quotient (q : ℕ) (a : ℤ) (N : ℕ)
  [Fact (Nat.Prime q)] [Fact (Nat.Prime N)]
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27)
  (h_period : alpha_cyclotomic q ^ 3 = (q : Kcyc q) * alpha_cyclotomic q + (q : Kcyc q))
  (P : Ideal (Okcyc q)) [P.IsMaximal]
  (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  let ab := Ideal.Quotient.mk P (alpha_int_cyc q)
  let bb := Ideal.Quotient.mk P (beta_int_cyc q)
  let gb := Ideal.Quotient.mk P (gamma_int_cyc q)
  ab ^ 3 - (q : Okcyc q ⧸ P) * ab - (q : Okcyc q ⧸ P) = 0 ∧
  bb ^ 3 - (q : Okcyc q ⧸ P) * bb - (q : Okcyc q ⧸ P) = 0 ∧
  gb ^ 3 - (q : Okcyc q ⧸ P) * gb - (q : Okcyc q ⧸ P) = 0 := by
    have h_beta_gamma : beta_cyclotomic q ^ 3 = q * beta_cyclotomic q + q ∧ gamma_cyclotomic q ^ 3 = q * gamma_cyclotomic q + q := by
      have h_coset_index_g : coset_index q (g_gen q) = 1 := by
        have := coset_index_chi_eq q ( three_dvd_q_sub_one q a ( mod_cast h_eq ) ) ( g_gen q ) ; simp_all +decide [ pow_succ ] ;
      have h_sigma_beta : sigma_cyclotomic_v2 q (g_gen q) (alpha_cyclotomic q) = beta_cyclotomic q := by
        rw [ sigma_alpha_eq ] ; aesop
      have h_sigma_gamma : sigma_cyclotomic_v2 q (g_gen q) (beta_cyclotomic q) = gamma_cyclotomic q := by
        unfold beta_cyclotomic gamma_cyclotomic; simp +decide [ h_coset_index_g, sigma_eta_period ] ;
        rfl;
      have h_sigma_beta_eq : sigma_cyclotomic_v2 q (g_gen q) (alpha_cyclotomic q ^ 3) = beta_cyclotomic q ^ 3 := by
        rw [ ← h_sigma_beta, map_pow ];
      have h_sigma_gamma_eq : sigma_cyclotomic_v2 q (g_gen q) (beta_cyclotomic q ^ 3) = gamma_cyclotomic q ^ 3 := by
        rw [ ← h_sigma_gamma, map_pow ];
      rw [ ← h_sigma_beta_eq, h_period ] at * ; aesop ( simp_config := { decide := true } ) ;
    have h_lift : ∀ x : Okcyc q, x.val ^ 3 = (q : Kcyc q) * x.val + (q : Kcyc q) → (Ideal.Quotient.mk P x) ^ 3 - (q : Okcyc q ⧸ P) * (Ideal.Quotient.mk P x) - (q : Okcyc q ⧸ P) = 0 := by
      intro x hx; erw [ sub_eq_zero ] ; erw [ sub_eq_iff_eq_add ] ; norm_cast at *;
      convert congr_arg ( Ideal.Quotient.mk P ) hx using 1 ; ring;
      exact?;
    exact ⟨ h_lift _ h_period, h_lift _ h_beta_gamma.1, h_lift _ h_beta_gamma.2 ⟩

/-
The images of alpha, beta, and gamma in the residue field Ok/P are roots of f_mod_N.
-/
lemma roots_satisfy_f_in_quotient_v2 (q : ℕ) (a : ℤ) (N : ℕ)
  [Fact (Nat.Prime q)] [Fact (Nat.Prime N)]
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27)
  (h_period : alpha_cyclotomic q ^ 3 = (q : Kcyc q) * alpha_cyclotomic q + (q : Kcyc q))
  (P : Ideal (Okcyc q)) [P.IsMaximal]
  (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  [Algebra (ZMod N) (Okcyc q ⧸ P)] :
  let ab := Ideal.Quotient.mk P (alpha_int_cyc q)
  let bb := Ideal.Quotient.mk P (beta_int_cyc q)
  let gb := Ideal.Quotient.mk P (gamma_int_cyc q)
  Polynomial.aeval ab (f_mod_N q N) = 0 ∧
  Polynomial.aeval bb (f_mod_N q N) = 0 ∧
  Polynomial.aeval gb (f_mod_N q N) = 0 := by
    convert roots_satisfy_f_in_quotient q a N h_eq h_period P hP using 1;
    unfold f_mod_N; norm_num [ Polynomial.eval₂_sub, Polynomial.eval₂_one, Polynomial.eval₂_mul, Polynomial.eval₂_X, Polynomial.eval₂_pow ] ;

/-
The discriminant of X^3 - qX - q is 4q^3 - 27q^2.
-/
def f_cubic {K : Type*} [CommRing K] (q : K) : Polynomial K := Polynomial.X^3 - Polynomial.C q * Polynomial.X - Polynomial.C q

lemma f_cubic_disc {K : Type*} [Field K] (q : K) :
  (f_cubic q).disc = 4 * q^3 - 27 * q^2 := by
    convert Polynomial.disc_of_degree_eq_three _ using 1;
    · unfold f_cubic; norm_num [ Polynomial.coeff_one, Polynomial.coeff_X, Polynomial.coeff_C ] ; ring;
    · unfold f_cubic;
      rw [ Polynomial.degree_sub_C ] <;> rw [ Polynomial.degree_sub_eq_left_of_degree_lt ] <;> by_cases hq : q = 0 <;> simp +decide [ hq ]

/-
If a cubic x^3 - qx - q has a double root, then 4q = 27, provided characteristic is not 2 or 3.
-/
lemma roots_distinct_algebraic {K : Type*} [Field K] (q : K) (hq : q ≠ 0) (a b c : K)
  (h_char_2 : (2 : K) ≠ 0) (h_char_3 : (3 : K) ≠ 0)
  (h_sum : a + b + c = 0)
  (ha : a^3 - q*a - q = 0)
  (hb : b^3 - q*b - q = 0)
  (hc : c^3 - q*c - q = 0) :
  a = b → 4 * q = 27 := by
    grind

/-
If a cubic x^3 - qx - q has a double root, then 4q = 27, provided characteristic is not 2 or 3.
-/
lemma roots_distinct_algebraic_v2 {K : Type*} [Field K] (q : K) (hq : q ≠ 0) (a b c : K)
  (h_char_2 : (2 : K) ≠ 0) (h_char_3 : (3 : K) ≠ 0)
  (h_sum : a + b + c = 0)
  (ha : a^3 - q*a - q = 0)
  (hb : b^3 - q*b - q = 0)
  (hc : c^3 - q*c - q = 0) :
  a = b → 4 * q = 27 := by
    exact?

/-
If a cubic x^3 - qx - q has a double root, then 4q = 27, provided characteristic is not 2 or 3.
-/
lemma roots_distinct_algebraic_v3 {K : Type*} [Field K] (q : K) (hq : q ≠ 0) (a b c : K)
  (h_char_2 : (2 : K) ≠ 0) (h_char_3 : (3 : K) ≠ 0)
  (h_sum : a + b + c = 0)
  (ha : a^3 - q*a - q = 0)
  (hb : b^3 - q*b - q = 0)
  (hc : c^3 - q*c - q = 0) :
  a = b → 4 * q = 27 := by
    exact?

/-
If a cubic x^3 - qx - q has a double root a=b, then 2a = -3.
-/
lemma double_root_implies_val {K : Type*} [Field K] (q : K) (hq : q ≠ 0) (a b c : K)
  (h_char_2 : (2 : K) ≠ 0) (h_char_3 : (3 : K) ≠ 0)
  (h_sum : a + b + c = 0)
  (ha : a^3 - q*a - q = 0)
  (hb : b^3 - q*b - q = 0)
  (hc : c^3 - q*c - q = 0)
  (hab : a = b) :
  2 * a = -3 := by
    grind

/-
If a cubic x^3 - qx - q has a double root, then 4q = 27, provided characteristic is not 2 or 3.
-/
lemma roots_distinct_algebraic_final {K : Type*} [Field K] (q : K) (hq : q ≠ 0) (a b c : K)
  (h_char_2 : (2 : K) ≠ 0) (h_char_3 : (3 : K) ≠ 0)
  (h_sum : a + b + c = 0)
  (ha : a^3 - q*a - q = 0)
  (hb : b^3 - q*b - q = 0)
  (hc : c^3 - q*c - q = 0) :
  a = b → 4 * q = 27 := by
    grind

/-
If N=2, then f has no roots in ZMod N.
-/
lemma f_mod_N_no_roots_if_N_eq_2 (q : ℕ) (a : ℤ) (N : ℕ)
  [Fact (Nat.Prime N)] (hN : N = 2)
  (h_eq : 4 * (q : ℤ) = a^2 + 27)
  (h_gcd : Int.gcd a N = 1) :
  ∀ x : ZMod N, Polynomial.eval x (f_mod_N q N) ≠ 0 := by
    subst hN;
    unfold f_mod_N; have := congr_arg ( · % 4 ) h_eq; rcases Int.even_or_odd' a with ⟨ k, rfl | rfl ⟩ <;> ring_nf at this ⊢ <;> norm_num [ Int.add_emod, Int.mul_emod ] at this;
    rcases Nat.even_or_odd' q with ⟨ c, rfl | rfl ⟩ <;> ring_nf at * <;> norm_num [ ZMod ] at *;
    · replace h_eq := congr_arg ( · % 8 ) h_eq ; rcases Int.even_or_odd' k with ⟨ k, rfl | rfl ⟩ <;> ring_nf at h_eq ⊢ <;> norm_num [ Int.add_emod, Int.mul_emod ] at h_eq;
    · replace h_eq := congr_arg ( · % 8 ) h_eq ; rcases Int.even_or_odd' k with ⟨ k, rfl | rfl ⟩ <;> ring_nf at * <;> norm_num [ Int.add_emod, Int.mul_emod ] at *;
      · simp +decide [ ZMod, Fin.forall_fin_two ];
        norm_cast ; simp +decide [ ZMod ];
        decide +revert;
      · simp +decide [ ZMod, Fin.forall_fin_two ];
        norm_cast ; simp +decide [ ZMod ];
        decide +revert

/-
If N=3, then f has no roots in ZMod N.
-/
lemma f_mod_N_no_roots_if_N_eq_3 (q : ℕ) (a : ℤ) (N : ℕ)
  [Fact (Nat.Prime N)] (hN : N = 3)
  (h_eq : 4 * (q : ℤ) = a^2 + 27)
  (h_gcd : Int.gcd a N = 1) :
  ∀ x : ZMod N, Polynomial.eval x (f_mod_N q N) ≠ 0 := by
    -- Since $q \equiv 1 \pmod{3}$, we have $4q \equiv 4 \equiv 1 \pmod{3}$.
    have hq_mod_3 : q % 3 = 1 ∨ q % 3 = 2 := by
      have := congr_arg ( · % 3 ) h_eq; norm_num [ sq, Int.add_emod, Int.mul_emod ] at this; norm_cast at this; have := Nat.mod_lt q zero_lt_three; interval_cases _ : q % 3 <;> simp_all +decide ;
      exact absurd ( Int.dvd_coe_gcd ( Int.dvd_of_emod_eq_zero ( show a % 3 = 0 by have := Int.emod_nonneg a three_pos.ne'; have := Int.emod_lt_of_pos a three_pos; interval_cases a % 3 <;> trivial ) ) ( Int.dvd_refl 3 ) ) ( by norm_num [ h_gcd ] );
    rcases hq_mod_3 with ( h | h ) <;> subst_vars <;> simp_all +decide [ f_mod_N ];
    · erw [ ← Nat.mod_add_div q 3, h ] ; norm_num [ ZMod, pow_succ ] ; ring_nf ;
      grind;
    · erw [ ← Nat.mod_add_div q 3, h ] at h_eq; replace h_eq := congr_arg ( fun x : ℤ => x % 3 ) h_eq ; norm_num [ sq, Int.add_emod, Int.mul_emod ] at h_eq ; have := Int.emod_nonneg a three_ne_zero ; have := Int.emod_lt_of_pos a three_pos ; interval_cases a % 3 <;> trivial;

/-
If N > 3, the roots alpha, beta, gamma are distinct in the residue field Ok/P.
-/
lemma roots_distinct_in_Ok_P_large_N (q : ℕ) (a : ℤ) (N : ℕ)
  [Fact (Nat.Prime q)] [Fact (Nat.Prime N)]
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27)
  (h_period : alpha_cyclotomic q ^ 3 = (q : Kcyc q) * alpha_cyclotomic q + (q : Kcyc q))
  (P : Ideal (Okcyc q)) [P.IsMaximal]
  (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_N_ne_q : N ≠ q) (h_gcd : Int.gcd a N = 1)
  (h_N_gt_3 : N > 3)
  [Algebra (ZMod N) (Okcyc q ⧸ P)] :
  let ab := Ideal.Quotient.mk P (alpha_int_cyc q)
  let bb := Ideal.Quotient.mk P (beta_int_cyc q)
  let gb := Ideal.Quotient.mk P (gamma_int_cyc q)
  ab ≠ bb ∧ bb ≠ gb ∧ gb ≠ ab := by
    have h_char : ringChar (Okcyc q ⧸ P) = N := by
      exact?
    have h_char_ne_2_3 : (2 : Okcyc q ⧸ P) ≠ 0 ∧ (3 : Okcyc q ⧸ P) ≠ 0 := by
      have := h_char ▸ ringChar.spec ( Okcyc q ⧸ P );
      exact ⟨ by specialize this 2; exact fun h => by have := Nat.le_of_dvd ( by decide ) ( this.mp h ) ; interval_cases N, by specialize this 3; exact fun h => by have := Nat.le_of_dvd ( by decide ) ( this.mp h ) ; interval_cases N ⟩
    have h_q_ne_0 : (q : Okcyc q ⧸ P) ≠ 0 := by
      have h_q_ne_zero : ¬(N ∣ q) := by
        exact fun h => h_N_ne_q <| by rw [ Nat.prime_dvd_prime_iff_eq Fact.out Fact.out ] at h; tauto;
      have := ringChar.spec ( Okcyc q ⧸ P ) q; aesop;
    have h_sum : (Ideal.Quotient.mk P (alpha_int_cyc q)) + (Ideal.Quotient.mk P (beta_int_cyc q)) + (Ideal.Quotient.mk P (gamma_int_cyc q)) = 0 := by
      convert congr_arg ( Ideal.Quotient.mk P ) ( show alpha_int_cyc q + beta_int_cyc q + gamma_int_cyc q = 0 from ?_ ) using 1;
      exact Subtype.ext <| sum_alpha_beta_gamma_eq_zero q
    have h_roots : (Ideal.Quotient.mk P (alpha_int_cyc q)) ^ 3 - (q : Okcyc q ⧸ P) * (Ideal.Quotient.mk P (alpha_int_cyc q)) - (q : Okcyc q ⧸ P) = 0 ∧ (Ideal.Quotient.mk P (beta_int_cyc q)) ^ 3 - (q : Okcyc q ⧸ P) * (Ideal.Quotient.mk P (beta_int_cyc q)) - (q : Okcyc q ⧸ P) = 0 ∧ (Ideal.Quotient.mk P (gamma_int_cyc q)) ^ 3 - (q : Okcyc q ⧸ P) * (Ideal.Quotient.mk P (gamma_int_cyc q)) - (q : Okcyc q ⧸ P) = 0 := by
      convert roots_satisfy_f_in_quotient q a N h_eq h_period P hP using 1;
    have h_distinct : ∀ x y z : Okcyc q ⧸ P, x + y + z = 0 → x^3 - (q : Okcyc q ⧸ P) * x - (q : Okcyc q ⧸ P) = 0 → y^3 - (q : Okcyc q ⧸ P) * y - (q : Okcyc q ⧸ P) = 0 → z^3 - (q : Okcyc q ⧸ P) * z - (q : Okcyc q ⧸ P) = 0 → x = y → 4 * (q : Okcyc q ⧸ P) = 27 := by
      intros x y z h_sum h_root_x h_root_y h_root_z hxy
      have h_double_root : 2 * x = -3 := by
        have h_eq'' : 3 * x * (2 * x + 3) = 0 := by
          have h_eq'' : 3 * x * (2 * x + 3) * (q : Okcyc q ⧸ P) = 0 := by
            grind +ring;
          exact eq_zero_of_ne_zero_of_mul_right_eq_zero h_q_ne_0 h_eq'';
        have h_eq'' : 3 * x = 0 ∨ 2 * x + 3 = 0 := by
          exact mul_eq_zero.mp ‹_›;
        have h_char_ne_3 : (3 : Okcyc q ⧸ P) ≠ 0 := by
          exact h_char_ne_2_3.2;
        exact eq_neg_of_add_eq_zero_left ( h_eq''.resolve_left ( mul_ne_zero h_char_ne_3 ( by aesop_cat ) ) );
      grind +ring;
    have h_contra : 4 * (q : Okcyc q ⧸ P) = 27 → False := by
      intro h_contra
      have h_div : (N : ℤ) ∣ (4 * q - 27) := by
        rw [ ← h_char, ← CharP.intCast_eq_zero_iff ( Okcyc q ⧸ P ) ] ; aesop ( simp_config := { singlePass := true } ) ;
      norm_num [ show ( 4 * q : ℤ ) = a ^ 2 + 27 by exact_mod_cast h_eq ] at h_div ⊢
      generalize_proofs at *; (
      exact absurd ( Int.Prime.dvd_pow' ( Fact.out : Nat.Prime N ) h_div ) ( by intro h; have := Int.dvd_coe_gcd h ( dvd_refl _ ) ; norm_cast at this; simp_all +decide [ Nat.dvd_prime ] ) ;);
    grind +ring

/-
If N divides 4q - 27 and 4q = a^2 + 27 with gcd(a, N) = 1, then we have a contradiction.
-/
lemma arithmetic_contradiction (q : ℕ) (a : ℤ) (N : ℕ) [Fact (Nat.Prime N)]
  (h_eq : 4 * (q : ℤ) = a^2 + 27)
  (h_gcd : Int.gcd a N = 1)
  (h_div : (N : ℤ) ∣ 4 * (q : ℤ) - 27) : False := by
    simp_all +decide [ ← ZMod.intCast_zmod_eq_zero_iff_dvd ];
    rw [ ZMod.intCast_zmod_eq_zero_iff_dvd ] at h_div ; exact absurd ( Int.dvd_gcd h_div ( dvd_refl _ ) ) ( by norm_num [ h_gcd ] ; exact Nat.Prime.ne_one Fact.out )

/-
If N > 3, the roots alpha, beta, gamma are distinct in the residue field Ok/P.
-/
lemma roots_distinct_in_Ok_P_large_N_v2 (q : ℕ) (a : ℤ) (N : ℕ)
  [Fact (Nat.Prime q)] [Fact (Nat.Prime N)]
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27)
  (h_period : alpha_cyclotomic q ^ 3 = (q : Kcyc q) * alpha_cyclotomic q + (q : Kcyc q))
  (P : Ideal (Okcyc q)) [P.IsMaximal]
  (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_N_ne_q : N ≠ q) (h_gcd : Int.gcd a N = 1)
  (h_N_gt_3 : N > 3)
  [Algebra (ZMod N) (Okcyc q ⧸ P)] :
  let ab := Ideal.Quotient.mk P (alpha_int_cyc q)
  let bb := Ideal.Quotient.mk P (beta_int_cyc q)
  let gb := Ideal.Quotient.mk P (gamma_int_cyc q)
  ab ≠ bb ∧ bb ≠ gb ∧ gb ≠ ab := by
    convert roots_distinct_in_Ok_P_large_N q a N h_eq h_period P hP h_N_ne_q h_gcd h_N_gt_3

/-
If N=2, f_mod_N is separable.
-/
lemma f_separable_N_eq_2 (q : ℕ) (a : ℤ) (N : ℕ)
  [Fact (Nat.Prime N)] (hN : N = 2)
  (h_eq : 4 * (q : ℤ) = a^2 + 27)
  (h_gcd : Int.gcd a N = 1) :
  Polynomial.Separable (f_mod_N q N) := by
    -- Since $N = 2$, we have $f_mod_N q N = X^3 - X - 1$.
    have h_f_mod_N_eq : f_mod_N q N = Polynomial.X ^ 3 - Polynomial.X - 1 := by
      subst hN; unfold f_mod_N; norm_num;
      rcases Nat.even_or_odd' q with ⟨ k, rfl | rfl ⟩ <;> norm_num at * <;> ring_nf at * <;> have := congr_arg Even h_eq <;> norm_num [ parity_simps ] at this ⊢;
      · obtain ⟨ m, rfl ⟩ := this; replace h_eq := congr_arg ( · % 8 ) h_eq ; norm_num [ Int.add_emod, Int.mul_emod, sq ] at h_eq; have := Int.emod_nonneg m ( by decide : ( 8 : ℤ ) ≠ 0 ) ; have := Int.emod_lt_of_pos m ( by decide : ( 0 : ℤ ) < 8 ) ; interval_cases m % 8 <;> contradiction;
      · grind;
    rw [ h_f_mod_N_eq ];
    refine' IsCoprime.symm _;
    norm_num [ IsCoprime ];
    use -X, 3;
    ring_nf;
    erw [ Polynomial.ext_iff ] ; norm_num;
    intro n; erw [ Polynomial.coeff_C, Polynomial.coeff_X, Polynomial.coeff_one ] ; aesop;

/-
If N > 3, the roots alpha, beta, gamma are distinct in the residue field Ok/P.
-/
lemma roots_distinct_in_Ok_P_large_N_v3 (q : ℕ) (a : ℤ) (N : ℕ)
  [Fact (Nat.Prime q)] [Fact (Nat.Prime N)]
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27)
  (h_period : alpha_cyclotomic q ^ 3 = (q : Kcyc q) * alpha_cyclotomic q + (q : Kcyc q))
  (P : Ideal (Okcyc q)) [P.IsMaximal]
  (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_N_ne_q : N ≠ q) (h_gcd : Int.gcd a N = 1)
  (h_N_gt_3 : N > 3) :
  let ab := Ideal.Quotient.mk P (alpha_int_cyc q)
  let bb := Ideal.Quotient.mk P (beta_int_cyc q)
  let gb := Ideal.Quotient.mk P (gamma_int_cyc q)
  ab ≠ bb ∧ bb ≠ gb ∧ gb ≠ ab := by
    convert roots_distinct_in_Ok_P_large_N_v2 q a N h_eq h_period P hP h_N_ne_q h_gcd h_N_gt_3 using 1;
    have h_char : ringChar (Okcyc q ⧸ P) = N := by
      exact?;
    convert ( ZMod.algebra _ _ ) using 1;
    exact h_char ▸ inferInstance

/-
If N=3, f_mod_N is separable.
-/
lemma f_separable_N_eq_3 (q : ℕ) (a : ℤ) (N : ℕ)
  [Fact (Nat.Prime N)] (hN : N = 3)
  (h_eq : 4 * (q : ℤ) = a^2 + 27)
  (h_gcd : Int.gcd a N = 1) :
  Polynomial.Separable (f_mod_N q N) := by
    -- Let's compute the derivative of $f_mod_N q N$.
    have h_deriv : Polynomial.derivative (f_mod_N q N) = -1 := by
      unfold f_mod_N; norm_num [ hN ] ;
      have hq_mod_3 : q % 3 = 1 := by
        have := congr_arg ( · % 3 ) h_eq; norm_num [ sq, Int.add_emod, Int.mul_emod ] at this; norm_cast at this; have := Nat.mod_lt q zero_lt_three; interval_cases _ : q % 3 <;> simp_all +decide ;
        · exact absurd ( Int.dvd_coe_gcd ( Int.dvd_of_emod_eq_zero ( show a % 3 = 0 by have := Int.emod_nonneg a three_pos.ne'; have := Int.emod_lt_of_pos a three_pos; interval_cases a % 3 <;> trivial ) ) ( Int.dvd_refl 3 ) ) ( by norm_num [ h_gcd ] );
        · have := Int.emod_nonneg a three_pos.ne'; have := Int.emod_lt_of_pos a three_pos; interval_cases a % 3 <;> contradiction;
      erw [ ← Nat.mod_add_div q 3, hq_mod_3 ] ; norm_num ; ring_nf ; aesop;
    exact ⟨ 0, -1, by aesop ⟩

/-
If N=2, the roots alpha, beta, gamma are distinct in the residue field Ok/P.
-/
lemma roots_distinct_in_Ok_P_N_eq_2 (q : ℕ) (a : ℤ) (N : ℕ)
  [Fact (Nat.Prime q)] [Fact (Nat.Prime N)]
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27)
  (h_period : alpha_cyclotomic q ^ 3 = (q : Kcyc q) * alpha_cyclotomic q + (q : Kcyc q))
  (P : Ideal (Okcyc q)) [P.IsMaximal]
  (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_N_ne_q : N ≠ q) (h_gcd : Int.gcd a N = 1)
  (hN : N = 2)
  [Algebra (ZMod N) (Okcyc q ⧸ P)] :
  let ab := Ideal.Quotient.mk P (alpha_int_cyc q)
  let bb := Ideal.Quotient.mk P (beta_int_cyc q)
  let gb := Ideal.Quotient.mk P (gamma_int_cyc q)
  ab ≠ bb ∧ bb ≠ gb ∧ gb ≠ ab := by
    by_contra h_contra;
    obtain ⟨ab, bb, gb, hab, hb, hg⟩ : ∃ ab bb gb : Okcyc q ⧸ P, ab + bb + gb = 0 ∧ ab^3 - (q : Okcyc q ⧸ P) * ab - (q : Okcyc q ⧸ P) = 0 ∧ bb^3 - (q : Okcyc q ⧸ P) * bb - (q : Okcyc q ⧸ P) = 0 ∧ gb^3 - (q : Okcyc q ⧸ P) * gb - (q : Okcyc q ⧸ P) = 0 ∧ (ab = bb ∨ bb = gb ∨ gb = ab) := by
      use Ideal.Quotient.mk P (alpha_int_cyc q), Ideal.Quotient.mk P (beta_int_cyc q), Ideal.Quotient.mk P (gamma_int_cyc q);
      refine' ⟨ _, _, _, _, _ ⟩;
      · convert congr_arg ( Ideal.Quotient.mk P ) ( show alpha_int_cyc q + beta_int_cyc q + gamma_int_cyc q = 0 from _ ) using 1;
        ext; simp [alpha_int_cyc, beta_int_cyc, gamma_int_cyc];
        convert sum_alpha_beta_gamma_eq_zero q using 1;
      · convert roots_satisfy_f_in_quotient q a N h_eq h_period P hP |> And.left using 1;
      · convert roots_satisfy_f_in_quotient q a N h_eq h_period P hP |> And.right |> And.left using 1;
      · convert roots_satisfy_f_in_quotient q a N h_eq h_period P hP |> And.right |> And.right using 1;
      · grind;
    have h_char : ringChar (Okcyc q ⧸ P) = 2 := by
      convert ringChar_Ok_P q N P hP;
      exact hN.symm;
    have h_q_one : (q : Okcyc q ⧸ P) = 1 := by
      have h_q_one : (q : Okcyc q ⧸ P) = 1 := by
        have h_q_odd : Odd q := by
          exact Nat.Prime.odd_of_ne_two Fact.out ( by rintro rfl; contradiction )
        obtain ⟨ k, hk ⟩ := h_q_odd; simp_all +decide [ parity_simps ] ;
        exact Or.inl ( by rw [ ← Nat.cast_two, ← h_char, ringChar.spec ] );
      exact h_q_one;
    rcases hg.2.2 with ( rfl | rfl | rfl ) <;> simp_all +decide [ pow_succ, add_assoc ];
    · have := ringChar.spec ( Okcyc q ⧸ P ) 2; simp_all +decide [ ← two_mul ] ;
      simp_all +decide [ ← add_assoc ];
      simp_all +decide [ ← two_mul ];
    · have := ringChar.spec ( Okcyc q ⧸ P ) 2; simp_all +decide [ ← two_mul ] ;
    · have h_char_two : ∀ x : Okcyc q ⧸ P, x + x = 0 := by
        intro x; have := ringChar.spec ( Okcyc q ⧸ P ) 2; simp_all +decide [ ← two_mul ] ;
      simp_all +decide [ add_comm, add_left_comm ]

/-
In the residue field modulo 3, the sum of pairwise products of alpha, beta, gamma is -1.
-/
lemma sum_mul_pairs_in_quotient (q : ℕ) (a : ℤ) (N : ℕ)
  [Fact (Nat.Prime q)] [Fact (Nat.Prime N)]
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27)
  (P : Ideal (Okcyc q)) [P.IsMaximal]
  (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (hN : N = 3)
  [Algebra (ZMod N) (Okcyc q ⧸ P)] :
  let ab := Ideal.Quotient.mk P (alpha_int_cyc q)
  let bb := Ideal.Quotient.mk P (beta_int_cyc q)
  let gb := Ideal.Quotient.mk P (gamma_int_cyc q)
  ab * bb + bb * gb + gb * ab = -1 := by
    have h_sum_mul_pairs_mod_3 : 2 * (alpha_int_cyc q * beta_int_cyc q + beta_int_cyc q * gamma_int_cyc q + gamma_int_cyc q * alpha_int_cyc q) = 1 - 3 * (eta_period q 0 ^ 2 + eta_period q 1 ^ 2 + eta_period q 2 ^ 2) := by
      convert sum_mul_pairs_algebraic_identity_v2 q _;
      -- Since $q$ is a prime number and $4q = a^2 + 27$, we can deduce that $q \equiv 1 \pmod{3}$.
      have hq_mod_3 : q % 3 = 1 := by
        norm_cast at h_eq; have := congr_arg ( · % 3 ) h_eq; norm_num [ Nat.add_mod, Nat.mul_mod, Nat.pow_mod ] at this; have := Nat.mod_lt q zero_lt_three; interval_cases _ : q % 3 <;> simp_all +decide ;
        · simp_all +decide [ ← Nat.dvd_iff_mod_eq_zero, Nat.Prime.dvd_iff_eq Fact.out ];
          nlinarith;
        · exact absurd ( congr_arg ( · % 3 ) h_eq ) ( by norm_num [ sq, Int.add_emod, Int.mul_emod ] ; have := Int.emod_nonneg a three_pos.ne'; have := Int.emod_lt_of_pos a three_pos; interval_cases a % 3 <;> norm_cast <;> simp_all +decide );
      exact Nat.dvd_of_mod_eq_zero ( by rw [ ← Nat.mod_add_div q 3, hq_mod_3 ] ; norm_num );
    have h_char_3 : (3 : Okcyc q ⧸ P) = 0 := by
      have h_char_3 : (3 : Okcyc q) ∈ P := by
        have := hP.1;
        replace this := SetLike.ext_iff.mp this 3; simp_all +decide [ Ideal.mem_span_singleton ] ;
      exact Ideal.Quotient.eq_zero_iff_mem.mpr h_char_3;
    erw [ Ideal.Quotient.eq ] at *;
    simp_all +decide [ ← ZMod.intCast_zmod_eq_zero_iff_dvd, sub_eq_iff_eq_add ];
    have h_sum_mul_pairs_mod_3 : 2 * (alpha_int_cyc q * beta_int_cyc q + beta_int_cyc q * gamma_int_cyc q + gamma_int_cyc q * alpha_int_cyc q + 1) ∈ P := by
      have h_sum_mul_pairs_mod_3 : 2 * (alpha_int_cyc q * beta_int_cyc q + beta_int_cyc q * gamma_int_cyc q + gamma_int_cyc q * alpha_int_cyc q + 1) = 3 * (1 - (eta_period q 0 ^ 2 + eta_period q 1 ^ 2 + eta_period q 2 ^ 2)) := by
        linear_combination' h_sum_mul_pairs_mod_3;
      convert P.mul_mem_right _ h_char_3 using 1;
      convert h_sum_mul_pairs_mod_3 using 1;
      rw [ ← Subtype.coe_inj ];
      swap;
      exact ⟨ 1 - ( eta_period q 0 ^ 2 + eta_period q 1 ^ 2 + eta_period q 2 ^ 2 ), by
        have h_sum_mul_pairs_mod_3 : ∀ i : ZMod 3, eta_period q i ∈ integralClosure ℤ (Kcyc q) := by
          intro i
          have h_sum_int : ∀ t ∈ C_coset q i, (zeta_q q) ^ t.val ∈ integralClosure ℤ (Kcyc q) := by
            intro t ht
            have h_zeta_int : zeta_q q ∈ integralClosure ℤ (Kcyc q) := by
              exact IsPrimitiveRoot.isIntegral ( IsCyclotomicExtension.zeta_spec q ℚ ( Kcyc q ) ) ( Fact.out : Nat.Prime q ).pos
            exact IsIntegral.pow h_zeta_int _
          exact Subalgebra.sum_mem _ h_sum_int;
        exact Subalgebra.sub_mem _ ( Subalgebra.one_mem _ ) ( Subalgebra.add_mem _ ( Subalgebra.add_mem _ ( Subalgebra.pow_mem _ ( h_sum_mul_pairs_mod_3 0 ) 2 ) ( Subalgebra.pow_mem _ ( h_sum_mul_pairs_mod_3 1 ) 2 ) ) ( Subalgebra.pow_mem _ ( h_sum_mul_pairs_mod_3 2 ) 2 ) ) ⟩
      generalize_proofs at *;
      bound;
    have h_inv : ∃ x : Okcyc q, 2 * x - 1 ∈ P := by
      use 2;
      convert h_char_3 using 1 ; norm_num;
    obtain ⟨ x, hx ⟩ := h_inv;
    have h_inv : (2 * x - 1) * (alpha_int_cyc q * beta_int_cyc q + beta_int_cyc q * gamma_int_cyc q + gamma_int_cyc q * alpha_int_cyc q + 1) ∈ P := by
      exact P.mul_mem_right _ hx;
    have h_inv : (2 * x) * (alpha_int_cyc q * beta_int_cyc q + beta_int_cyc q * gamma_int_cyc q + gamma_int_cyc q * alpha_int_cyc q + 1) ∈ P := by
      convert P.mul_mem_left x h_sum_mul_pairs_mod_3 using 1 ; ring;
    convert P.sub_mem h_inv ‹ ( 2 * x - 1 ) * ( alpha_int_cyc q * beta_int_cyc q + beta_int_cyc q * gamma_int_cyc q + gamma_int_cyc q * alpha_int_cyc q + 1 ) ∈ P › using 1 ; ring

/-
If N=3, the roots alpha, beta, gamma are distinct in the residue field Ok/P.
-/
lemma roots_distinct_in_Ok_P_N_eq_3 (q : ℕ) (a : ℤ) (N : ℕ)
  [Fact (Nat.Prime q)] [Fact (Nat.Prime N)]
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27)
  (h_period : alpha_cyclotomic q ^ 3 = (q : Kcyc q) * alpha_cyclotomic q + (q : Kcyc q))
  (P : Ideal (Okcyc q)) [P.IsMaximal]
  (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_N_ne_q : N ≠ q) (h_gcd : Int.gcd a N = 1)
  (hN3 : N = 3)
  [Algebra (ZMod N) (Okcyc q ⧸ P)] :
  let ab := Ideal.Quotient.mk P (alpha_int_cyc q)
  let bb := Ideal.Quotient.mk P (beta_int_cyc q)
  let gb := Ideal.Quotient.mk P (gamma_int_cyc q)
  ab ≠ bb ∧ bb ≠ gb ∧ gb ≠ ab := by
    -- By Lemma~\ref{lem:sum_mul_pairs_in_quotient}, we know $ab \neq bb$.
    have h_ab_ne_bb : (Ideal.Quotient.mk P (alpha_int_cyc q)) ≠ (Ideal.Quotient.mk P (beta_int_cyc q)) := by
      -- By contradiction, assume α = β in the residue field.
      by_contra h_eq_ab;
      -- From this, roots are distinct because: if ab = bb, then ab + bb + gb = 0 gives 2*ab + gb = 0, and the sum-of-products relation gives ab^2 + ab*gb + ab*gb = -1, i.e., ab^2 + 2*ab*gb = -1.
      obtain ⟨ab, gb, hab⟩ : ∃ ab gb : Okcyc q ⧸ P, (Ideal.Quotient.mk P (alpha_int_cyc q)) = ab ∧ (Ideal.Quotient.mk P (gamma_int_cyc q)) = gb ∧ ab + ab + gb = 0 ∧ ab^2 + 2 * ab * gb = -1 := by
        have h_sum : (Ideal.Quotient.mk P (alpha_int_cyc q)) + (Ideal.Quotient.mk P (beta_int_cyc q)) + (Ideal.Quotient.mk P (gamma_int_cyc q)) = 0 := by
          have h_sum : (alpha_int_cyc q : Okcyc q) + (beta_int_cyc q : Okcyc q) + (gamma_int_cyc q : Okcyc q) = 0 := by
            have h_sum : (alpha_cyclotomic q : Kcyc q) + (beta_cyclotomic q : Kcyc q) + (gamma_cyclotomic q : Kcyc q) = 0 := by
              convert sum_alpha_beta_gamma_eq_zero q using 1;
            exact Subtype.ext h_sum;
          convert congr_arg ( Ideal.Quotient.mk P ) h_sum using 1
        have h_prod : (Ideal.Quotient.mk P (alpha_int_cyc q)) * (Ideal.Quotient.mk P (beta_int_cyc q)) + (Ideal.Quotient.mk P (beta_int_cyc q)) * (Ideal.Quotient.mk P (gamma_int_cyc q)) + (Ideal.Quotient.mk P (gamma_int_cyc q)) * (Ideal.Quotient.mk P (alpha_int_cyc q)) = -1 := by
          convert sum_mul_pairs_in_quotient q a N h_eq P hP hN3 using 1;
        grind;
      -- Using gb = -2*ab: ab^2 - 4*ab^2 = -1, so -3*ab^2 = -1, i.e., 3*ab^2 = 1.
      have h_gb : gb = -2 * ab := by
        linear_combination' hab.2.2.1
      have h_eq : 3 * ab^2 = 1 := by
        subst h_gb; linear_combination' hab.2.2.2.symm;
      -- But 3 = 0 in F_3, so 0 = 1, contradiction.
      have h_contra : (3 : Okcyc q ⧸ P) = 0 := by
        have h_char : ringChar (Okcyc q ⧸ P) = 3 := by
          convert ringChar_Ok_P q N P hP using 1;
          exact hN3.symm;
        rw [ ← Nat.cast_ofNat, ← h_char, ringChar.spec ];
      aesop;
    -- By Lemma~\ref{lem:sum_mul_pairs_in_quotient}, we know $ab + bb + gb = 0$.
    have h_sum : (Ideal.Quotient.mk P (alpha_int_cyc q)) + (Ideal.Quotient.mk P (beta_int_cyc q)) + (Ideal.Quotient.mk P (gamma_int_cyc q)) = 0 := by
      have h_sum : (alpha_int_cyc q : Okcyc q) + (beta_int_cyc q : Okcyc q) + (gamma_int_cyc q : Okcyc q) = 0 := by
        ext; simp [alpha_int_cyc, beta_int_cyc, gamma_int_cyc];
        convert sum_alpha_beta_gamma_eq_zero q using 1;
      convert congr_arg ( Ideal.Quotient.mk P ) h_sum using 1;
    have h_char : (3 : Okcyc q ⧸ P) = 0 := by
      have h_char : (3 : Okcyc q) ∈ P := by
        have := hP.1; simp_all +decide [ Ideal.mem_span_singleton ] ;
        replace this := SetLike.ext_iff.mp this 3; simp_all +decide [ Ideal.mem_span_singleton ] ;
      generalize_proofs at *; (
      exact Ideal.Quotient.eq_zero_iff_mem.mpr h_char)
    generalize_proofs at *; (
    grind +ring)

/-
The roots alpha, beta, gamma are distinct in the residue field Ok/P for any prime N != q.
-/
lemma roots_distinct_in_Ok_P (q : ℕ) (a : ℤ) (N : ℕ)
  [Fact (Nat.Prime q)] [Fact (Nat.Prime N)]
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27)
  (h_period : alpha_cyclotomic q ^ 3 = (q : Kcyc q) * alpha_cyclotomic q + (q : Kcyc q))
  (P : Ideal (Okcyc q)) [P.IsMaximal]
  (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_N_ne_q : N ≠ q) (h_gcd : Int.gcd a N = 1)
  [Algebra (ZMod N) (Okcyc q ⧸ P)] :
  let ab := Ideal.Quotient.mk P (alpha_int_cyc q)
  let bb := Ideal.Quotient.mk P (beta_int_cyc q)
  let gb := Ideal.Quotient.mk P (gamma_int_cyc q)
  ab ≠ bb ∧ bb ≠ gb ∧ gb ≠ ab := by
    by_cases hN2 : N = 2;
    · subst hN2;
      apply roots_distinct_in_Ok_P_N_eq_2 q a 2;
      all_goals norm_cast at *;
    · by_cases hN3 : N = 3;
      · exact roots_distinct_in_Ok_P_N_eq_3 q a N ( mod_cast h_eq ) h_period P ( by simpa [ hN3 ] using hP ) ( by simpa [ hN3 ] using h_N_ne_q ) ( by simpa [ hN3 ] using h_gcd ) hN3;
      · apply roots_distinct_in_Ok_P_large_N_v2 q a N h_eq h_period P hP h_N_ne_q h_gcd (by
        exact not_le.mp fun contra => by interval_cases N <;> contradiction;)

/-
If c(N) != 1, then no root alpha_bar, beta_bar, gamma_bar is fixed by the Frobenius automorphism x -> x^N.
-/
lemma no_root_fixed_by_frobenius (q : ℕ) (a : ℤ) (N : ℕ)
  [Fact (Nat.Prime q)] [Fact (Nat.Prime N)]
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27)
  (h_period : alpha_cyclotomic q ^ 3 = (q : Kcyc q) * alpha_cyclotomic q + (q : Kcyc q))
  (h_N_ne_q : N ≠ q) (h_gcd : Int.gcd a N = 1)
  (h_chi_s2 : chi q (g_gen q) = s2 q a)
  (P : Ideal (Okcyc q)) [P.IsMaximal]
  (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_c_ne_one : c_value q N ≠ 1)
  [Algebra (ZMod N) (Okcyc q ⧸ P)] :
  let ab := Ideal.Quotient.mk P (alpha_int_cyc q)
  let bb := Ideal.Quotient.mk P (beta_int_cyc q)
  let gb := Ideal.Quotient.mk P (gamma_int_cyc q)
  (ab ^ N ≠ ab) ∧ (bb ^ N ≠ bb) ∧ (gb ^ N ≠ gb) := by
    -- Apply the dream_theorem_cyclotomic to connect the coset index of N to the behavior of the roots under the Frobenius automorphism.
    have h_coset_index : coset_index q (N_unit q N h_N_ne_q) ≠ 0 := by
      contrapose! h_c_ne_one;
      convert ( coset_index_chi_eq q ( three_dvd_q_sub_one q a ( mod_cast h_eq ) ) ( N_unit q N h_N_ne_q ) ) |>.1.mp h_c_ne_one using 1;
    obtain h_coset_index | h_coset_index : coset_index q (N_unit q N h_N_ne_q) = 1 ∨ coset_index q (N_unit q N h_N_ne_q) = 2 := by
      unfold coset_index at *; aesop;
    · have h_alpha_beta : sigma_int_cyc q (N_unit q N h_N_ne_q) (alpha_int_cyc q) = beta_int_cyc q := by
        have h_alpha_gamma : sigma_cyclotomic_v2 q (N_unit q N h_N_ne_q) (alpha_cyclotomic q) = beta_cyclotomic q := by
          rw [ sigma_alpha_eq ] ; aesop;
        generalize_proofs at *;
        exact Subtype.ext h_alpha_gamma
      have h_beta_gamma : sigma_int_cyc q (N_unit q N h_N_ne_q) (beta_int_cyc q) = gamma_int_cyc q := by
        have h_beta_gamma : sigma_cyclotomic_v2 q (N_unit q N h_N_ne_q) (beta_cyclotomic q) = gamma_cyclotomic q := by
          unfold beta_cyclotomic gamma_cyclotomic
          generalize_proofs at *; (
          rw [ map_sub, sigma_eta_period, sigma_eta_period ] ; simp +decide [ h_coset_index ];
          rfl)
        generalize_proofs at *; (
        exact Subtype.ext h_beta_gamma)
      have h_gamma_alpha : sigma_int_cyc q (N_unit q N h_N_ne_q) (gamma_int_cyc q) = alpha_int_cyc q := by
        have h_gamma_alpha : sigma_cyclotomic_v2 q (N_unit q N h_N_ne_q) (gamma_cyclotomic q) = alpha_cyclotomic q := by
          unfold gamma_cyclotomic alpha_cyclotomic
          generalize_proofs at *; (
          rw [ map_sub, sigma_eta_period, sigma_eta_period ] ; simp +decide [ h_coset_index ];
          exact?)
        generalize_proofs at *; (
        exact Subtype.ext h_gamma_alpha)
      generalize_proofs at *; (
      have h_alpha_beta : (Ideal.Quotient.mk P (alpha_int_cyc q)) ^ N = Ideal.Quotient.mk P (beta_int_cyc q) := by
        rw [ ← h_alpha_beta, ← artin_property_cyc q N h_N_ne_q P hP ]
      have h_beta_gamma : (Ideal.Quotient.mk P (beta_int_cyc q)) ^ N = Ideal.Quotient.mk P (gamma_int_cyc q) := by
        rw [ ← h_beta_gamma, ← artin_property_cyc ];
        exact hP
      have h_gamma_alpha : (Ideal.Quotient.mk P (gamma_int_cyc q)) ^ N = Ideal.Quotient.mk P (alpha_int_cyc q) := by
        rw [ ← h_gamma_alpha, ← artin_property_cyc ];
        exact hP
      generalize_proofs at *; (
      have h_distinct : (Ideal.Quotient.mk P (alpha_int_cyc q)) ≠ (Ideal.Quotient.mk P (beta_int_cyc q)) ∧ (Ideal.Quotient.mk P (beta_int_cyc q)) ≠ (Ideal.Quotient.mk P (gamma_int_cyc q)) ∧ (Ideal.Quotient.mk P (gamma_int_cyc q)) ≠ (Ideal.Quotient.mk P (alpha_int_cyc q)) := by
        apply roots_distinct_in_Ok_P q a N h_eq h_period P hP h_N_ne_q h_gcd
        skip
      generalize_proofs at *; (
      grind +ring)));
    · have h_coset_index_beta : sigma_int_cyc q (N_unit q N h_N_ne_q) (beta_int_cyc q) = alpha_int_cyc q := by
        have h_coset_index_beta : sigma_cyclotomic_v2 q (N_unit q N h_N_ne_q) (beta_cyclotomic q) = alpha_cyclotomic q := by
          unfold beta_cyclotomic alpha_cyclotomic
          rw [map_sub, sigma_eta_period, sigma_eta_period]
          simp [h_coset_index];
          erw [ show ( 1 + 2 : ZMod 3 ) = 0 by decide, show ( 2 + 2 : ZMod 3 ) = 1 by decide ];
        exact Subtype.ext h_coset_index_beta
      have h_coset_index_gamma : sigma_int_cyc q (N_unit q N h_N_ne_q) (gamma_int_cyc q) = beta_int_cyc q := by
        have h_coset_index_gamma : sigma_cyclotomic_v2 q (N_unit q N h_N_ne_q) (gamma_cyclotomic q) = beta_cyclotomic q := by
          unfold gamma_cyclotomic beta_cyclotomic
          rw [map_sub, sigma_eta_period, sigma_eta_period]
          simp [h_coset_index];
          exact?;
        exact Subtype.ext h_coset_index_gamma;
      have h_beta : (Ideal.Quotient.mk P (beta_int_cyc q)) ^ N = Ideal.Quotient.mk P (alpha_int_cyc q) := by
        rw [ ← h_coset_index_beta, ← artin_property_cyc q N h_N_ne_q P hP ]
      have h_gamma : (Ideal.Quotient.mk P (gamma_int_cyc q)) ^ N = Ideal.Quotient.mk P (beta_int_cyc q) := by
        rw [ ← h_coset_index_gamma, ← artin_property_cyc q N h_N_ne_q P hP ]
      have h_alpha : (Ideal.Quotient.mk P (alpha_int_cyc q)) ^ N = Ideal.Quotient.mk P (gamma_int_cyc q) := by
        have h_alpha : sigma_int_cyc q (N_unit q N h_N_ne_q) (alpha_int_cyc q) = gamma_int_cyc q := by
          have h_alpha : sigma_cyclotomic_v2 q (N_unit q N h_N_ne_q) (alpha_cyclotomic q) = gamma_cyclotomic q := by
            unfold alpha_cyclotomic gamma_cyclotomic
            rw [map_sub, sigma_eta_period, sigma_eta_period]
            simp [h_coset_index];
            exact?
          generalize_proofs at *; (
          exact Subtype.ext h_alpha
          skip)
        generalize_proofs at *; (
        rw [ ← h_alpha, ← artin_property_cyc q N h_N_ne_q P hP ])
      generalize_proofs at *; (
      have := roots_distinct_in_Ok_P q a N ( by linarith ) ( by
        exact h_period ) P hP h_N_ne_q h_gcd; aesop;)

/-
Any root of f modulo N in Ok/P must be one of alpha, beta, or gamma.
-/
lemma roots_trichotomy (q : ℕ) (a : ℤ) (N : ℕ)
  [Fact (Nat.Prime q)] [Fact (Nat.Prime N)]
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27)
  (h_period : alpha_cyclotomic q ^ 3 = (q : Kcyc q) * alpha_cyclotomic q + (q : Kcyc q))
  (P : Ideal (Okcyc q)) [P.IsMaximal]
  (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_N_ne_q : N ≠ q) (h_gcd : Int.gcd a N = 1)
  [Algebra (ZMod N) (Okcyc q ⧸ P)]
  (x : Okcyc q ⧸ P)
  (hx : Polynomial.aeval x (f_mod_N q N) = 0) :
  let ab := Ideal.Quotient.mk P (alpha_int_cyc q)
  let bb := Ideal.Quotient.mk P (beta_int_cyc q)
  let gb := Ideal.Quotient.mk P (gamma_int_cyc q)
  x = ab ∨ x = bb ∨ x = gb := by
    have h_poly_eq : (Polynomial.X - Polynomial.C (Ideal.Quotient.mk P (alpha_int_cyc q))) * (Polynomial.X - Polynomial.C (Ideal.Quotient.mk P (beta_int_cyc q))) * (Polynomial.X - Polynomial.C (Ideal.Quotient.mk P (gamma_int_cyc q))) = Polynomial.map (algebraMap ℤ (Okcyc q ⧸ P)) (f_cubic (q : ℤ)) := by
      refine' Polynomial.eq_of_degree_sub_lt_of_eval_finset_eq _ _ _;
      exact { Ideal.Quotient.mk P ( alpha_int_cyc q ), Ideal.Quotient.mk P ( beta_int_cyc q ), Ideal.Quotient.mk P ( gamma_int_cyc q ) };
      · refine' lt_of_lt_of_le ( Polynomial.degree_sub_lt _ _ _ ) _ <;> norm_num [ Polynomial.degree_sub_eq_left_of_degree_lt ];
        · erw [ Polynomial.degree_map_eq_of_leadingCoeff_ne_zero ] <;> norm_num [ f_cubic ];
          · erw [ Polynomial.degree_sub_C ] <;> erw [ Polynomial.degree_sub_eq_left_of_degree_lt ] <;> norm_num;
            · erw [ Polynomial.degree_C ] <;> norm_num ; linarith [ show q > 0 from Nat.Prime.pos Fact.out ];
            · erw [ Polynomial.degree_C ] <;> norm_num ; linarith [ show q > 0 from Nat.Prime.pos Fact.out ];
          · erw [ Polynomial.leadingCoeff, Polynomial.natDegree_sub_C, Polynomial.natDegree_sub_eq_left_of_natDegree_lt ] <;> norm_num [ Polynomial.coeff_eq_zero_of_natDegree_lt ];
            by_cases hq : q = 0 <;> simp +decide [ hq ];
        · exact ⟨ ⟨ Polynomial.X_sub_C_ne_zero _, Polynomial.X_sub_C_ne_zero _ ⟩, Polynomial.X_sub_C_ne_zero _ ⟩;
        · erw [ Polynomial.leadingCoeff_map_of_leadingCoeff_ne_zero ] <;> norm_num [ f_cubic ];
          · erw [ Polynomial.leadingCoeff, Polynomial.natDegree_sub_C, Polynomial.natDegree_sub_eq_left_of_natDegree_lt ] <;> norm_num [ Polynomial.coeff_eq_zero_of_natDegree_lt ];
            by_cases hq : q = 0 <;> simp +decide [ hq ];
          · erw [ Polynomial.leadingCoeff, Polynomial.natDegree_sub_C, Polynomial.natDegree_sub_eq_left_of_natDegree_lt ] <;> norm_num [ Polynomial.coeff_eq_zero_of_natDegree_lt ];
            by_cases hq : q = 0 <;> simp +decide [ hq ];
        · rw [ Finset.card_insert_of_notMem, Finset.card_insert_of_notMem, Finset.card_singleton ] <;> norm_num [ roots_distinct_in_Ok_P q a N h_eq h_period P hP h_N_ne_q h_gcd ];
          exact roots_distinct_in_Ok_P q a N h_eq h_period P hP h_N_ne_q h_gcd |>.2.2.symm;
      · have := roots_satisfy_f_in_quotient_v2 q a N h_eq h_period P hP; simp_all +decide [ Polynomial.eval_map ] ;
        unfold f_cubic f_mod_N at *; aesop;
    replace h_poly_eq := congr_arg ( Polynomial.eval x ) h_poly_eq ; simp_all +decide [ sub_eq_iff_eq_add ] ;
    simp_all +decide [ f_mod_N, f_cubic ];
    simpa only [ sub_eq_zero, or_assoc ] using h_poly_eq

/-
If c(N) != 1, then f(x) = x^3 - qx - q is irreducible modulo N.
-/
theorem c_ne_one_imp_irreducible (q : ℕ) (a : ℤ)
  [Fact (Nat.Prime q)]
  (h_eq : 4 * (q : ℚ) = (a : ℚ)^2 + 27)
  (h_period : alpha_cyclotomic q ^ 3
    = (q : Kcyc q) * alpha_cyclotomic q + (q : Kcyc q))
  (N : ℕ) [Fact (Nat.Prime N)]
  (h_N_ne_q : N ≠ q) (h_gcd : Int.gcd a N = 1)
  (h_chi_s2 : chi q (g_gen q) = s2 q a)
  (h_c_ne_one : c_value q N ≠ 1) :
  Irreducible (f_mod_N q N) := by
    -- By contradiction, assume there exists a root $x_0$ of $f(x)$ in $\mathbb{Z}/N\mathbb{Z}$.
    by_contra h_root_exists;
    obtain ⟨x0, hx0⟩ : ∃ x0 : ZMod N, Polynomial.eval x0 (f_mod_N q N) = 0 := by
      apply Classical.byContradiction
      intro h_no_root;
      exact h_root_exists <| cubic_irred_iff_no_roots _ ( f_mod_N_degree q N ) ( f_mod_N_monic q N ) |>.2 fun x => by aesop;
    obtain ⟨P, hP_max, hP_lies⟩ := exists_maximal_lies_over q N h_N_ne_q
    haveI := hP_max
    haveI : CharP (Okcyc q ⧸ P) N := by
      have := ringChar_Ok_P q N P hP_lies; exact ringChar.of_eq this;
    haveI : Algebra (ZMod N) (Okcyc q ⧸ P) := ZMod.algebra _ _
    let phi := algebraMap (ZMod N) (Okcyc q ⧸ P)
    have h_root : Polynomial.aeval (phi x0) (f_mod_N q N) = 0 := by
      convert congr_arg phi hx0 using 1;
      · simp +decide [ Polynomial.aeval_def, Polynomial.eval₂_eq_sum_range ];
        simp +decide [ Polynomial.eval_eq_sum_range, Finset.sum_range_succ', f_mod_N ];
        simp +decide [ Polynomial.coeff_X ];
      · norm_num +zetaDelta at *;
    have h_dist := roots_distinct_in_Ok_P q a N ( by simpa [ ← @Rat.cast_inj ℚ ] using h_eq ) h_period P hP_lies h_N_ne_q h_gcd
    have h_tri := roots_trichotomy q a N ( by simpa [ ← @Rat.cast_inj ℚ ] using h_eq ) h_period P hP_lies h_N_ne_q h_gcd ( phi x0 ) h_root
    rcases h_tri with ( h | h | h ) <;> simp_all +decide [ ← map_pow ];
    · have := no_root_fixed_by_frobenius q a N ( by simpa [ ← @Rat.cast_inj ℚ ] using h_eq ) h_period h_N_ne_q h_gcd h_chi_s2 P hP_lies h_c_ne_one;
      exact this.1 ( by rw [ ← h, ← map_pow, ZMod.pow_card ] );
    · have h_fixed : (phi x0) ^ N = phi x0 := by
        rw [ ← map_pow, ZMod.pow_card ];
      have h_nf := no_root_fixed_by_frobenius q a N ( by simpa [ ← @Rat.cast_inj ℚ ] using h_eq ) h_period h_N_ne_q h_gcd h_chi_s2 P hP_lies h_c_ne_one; simp_all +decide [ ← map_pow ] ;
    · have h_fixed : (phi x0) ^ N = phi x0 := by
        rw [ ← map_pow, ZMod.pow_card ];
      have h_nf := no_root_fixed_by_frobenius q a N ( by simpa [ ← @Rat.cast_inj ℚ ] using h_eq ) h_period h_N_ne_q h_gcd h_chi_s2 P hP_lies h_c_ne_one; simp_all +decide [ ← map_pow ] ;