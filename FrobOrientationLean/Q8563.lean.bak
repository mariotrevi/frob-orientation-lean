/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f90ecc47-b234-4e08-b4d1-eff1974a2756

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We have successfully proved the Dream Theorem for q = 8563.
The main result is `Q0037.final_result_8563`, which states that for a prime N (distinct from 8563 and coprime to 185),
if c(N) = s1 then alpha^N = gamma (modulo P), and if c(N) = s2 then alpha^N = beta (modulo P).
The proof relies on the Artin property (`Q0037.artin_property_8563`) and the global permutation properties of the Gaussian periods (`Q0037.global_permutation_int_8563`).
We also established the necessary algebraic number theory background, including the fact that the ring of integers is generated by zeta (`Q0037.Ok8563_eq_adjoin`) and the characteristic of the residue field (`Q0037.charP_quotient_8563`).
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: a3f224f3-7e17-4759-bef8-19391311d10f

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: e6ee589a-f550-42ef-89e5-1fd2afd7fa5e

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We defined the constants s1, s2, and the value c(N). We proved lemmas characterizing the cosets C1 and C2 in terms of the 12th power residue symbol (which relates to c(N)). Finally, we proved the main theorem `final_result` which establishes the Frobenius action on alpha (i.e., alpha^N) in terms of beta and gamma, depending on the value of c(N). The proof utilizes the `explicit_frobenius` theorem and the algebraic relations between alpha, beta, and gamma.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 939f55fb-68a7-4ef0-bca3-475f675055ca

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
This module formalizes the proof of the Frobenius Orientation conjecture for q=37.
It defines the cyclotomic field K = Q(zeta_37), the Gaussian periods, and the cubic roots.
It proves the cyclic algebraic relations between these roots and establishes the global Galois action.
It descends to the residue field modulo a prime P lying over N != 37, proving the Artin property.
Finally, it derives the explicit Frobenius action on the reduction of alpha modulo P.
-/

import Mathlib

namespace Q0037


set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Let L = Q(zeta_37) be the 37th cyclotomic field.
-/
abbrev K := CyclotomicField 37 ℚ

/-
zeta is the primitive 37th root of unity in K.
-/
noncomputable def zeta : K := IsCyclotomicExtension.zeta 37 ℚ K

/-
H is the subgroup of cubic residues modulo 37.
-/
def H : Finset (ZMod 37) := ((Finset.univ : Finset (ZMod 37)).filter (fun x => x ≠ 0)).image (fun x => x^3)

/-
g = 2 is a primitive root modulo 37.
-/
def g : ZMod 37 := 2

/-
C1 is the coset of H with index 1.
-/
def C1 : Finset (ZMod 37) := H.image (fun x => g * x)

/-
C2 is the coset of H with index 2.
-/
def C2 : Finset (ZMod 37) := H.image (fun x => g^2 * x)

/-
Open BigOperators for sum notation.
-/
open BigOperators

/-
The Gaussian period for a set S is the sum of zeta^x for x in S.
-/
noncomputable def eta (S : Finset (ZMod 37)) : K := ∑ x ∈ S, zeta^(x.val)

/-
Define the three Gaussian periods eta_0, eta_1, eta_2.
-/
noncomputable def eta_0 := eta H
noncomputable def eta_1 := eta C1
noncomputable def eta_2 := eta C2

/-
Define the roots alpha, beta, gamma.
-/
noncomputable def alpha := eta_2 - eta_1
noncomputable def beta := eta_0 - eta_2
noncomputable def gamma := eta_1 - eta_0

/-
The non-zero elements of ZMod 37 are the disjoint union of H, C1, and C2.
-/
lemma units_decomp :
  let units := (Finset.univ : Finset (ZMod 37)).filter (fun x => x ≠ 0)
  units = H ∪ C1 ∪ C2 ∧
  Disjoint H C1 ∧ Disjoint H C2 ∧ Disjoint C1 C2 := by
    native_decide

/-
The sum of zeta^x for all non-zero x is -1.
-/
lemma sum_zeta_units :
  let units := (Finset.univ : Finset (ZMod 37)).filter (fun x => x ≠ 0)
  ∑ x ∈ units, zeta^(x.val) = -1 := by
    -- Since $zeta$ is a primitive 37th root of unity, we know that $\sum_{x=0}^{36} zeta^x = 0$.
    have h_sum_zero : ∑ x ∈ Finset.range 37, zeta ^ x = 0 := by
      rw [ geom_sum_eq ] <;> norm_num [ zeta ];
      · exact Or.inl ( sub_eq_zero_of_eq <| by exact IsCyclotomicExtension.zeta_pow 37 ℚ K );
      · have h_order : orderOf (IsCyclotomicExtension.zeta 37 ℚ K) = 37 := by
          rw [ orderOf_eq_of_pow_and_pow_div_prime ] <;> norm_num;
          · exact IsCyclotomicExtension.zeta_pow 37 ℚ K;
          · intro p pp dp; have := Nat.le_of_dvd ( by decide ) dp; interval_cases p <;> norm_num at *;
            have h_order : IsPrimitiveRoot (IsCyclotomicExtension.zeta 37 ℚ K) 37 := by
              exact?;
            exact h_order.ne_one ( by decide );
        aesop;
    simp_all +decide [ Finset.sum_range, ZMod, Fin.sum_univ_succ ];
    simp_all +decide [ Fin.sum_univ_succ, Finset.sum_filter, ZMod.val ];
    linear_combination' h_sum_zero

/-
The sum of the three Gaussian periods is -1.
-/
lemma sum_eta_eq_minus_one : eta_0 + eta_1 + eta_2 = -1 := by
  -- Using the decomposition of the units into H, C1, and C2, we can split the sum into three parts.
  have h_split : ∑ x ∈ (Finset.univ : Finset (ZMod 37)).filter (fun x => x ≠ 0), zeta^(x.val) = ∑ x ∈ H, zeta^(x.val) + ∑ x ∈ C1, zeta^(x.val) + ∑ x ∈ C2, zeta^(x.val) := by
    rw [ ← Finset.sum_union, ← Finset.sum_union ];
    · rw [ ← units_decomp.1 ];
    · decide +revert;
    · native_decide +revert;
  convert sum_zeta_units using 1 ; aesop

/-
Explicit enumeration of the cosets H, C1, C2.
-/
lemma H_explicit : H = {1, 6, 8, 10, 11, 14, 23, 26, 27, 29, 31, 36} := by
  native_decide
lemma C1_explicit : C1 = {2, 9, 12, 15, 16, 17, 20, 21, 22, 25, 28, 35} := by
  native_decide
lemma C2_explicit : C2 = {3, 4, 5, 7, 13, 18, 19, 24, 30, 32, 33, 34} := by
  native_decide +revert

/-
The algebraic relation 11β = 3α² - 10α - 74 holds.
-/
theorem relation_beta : 11 * beta = 3 * alpha^2 - 10 * alpha - 74 := by
  -- Let's simplify the left-hand side of the equation.
  simp +decide only [alpha, beta] at *; (
  -- By definition of eta, we can expand the left-hand side and right-hand side of the equation.
  have h_expand : 11 * (∑ x ∈ ({1, 6, 8, 10, 11, 14, 23, 26, 27, 29, 31, 36} : Finset (ZMod 37)), zeta^(x.val) - ∑ x ∈ ({3, 4, 5, 7, 13, 18, 19, 24, 30, 32, 33, 34} : Finset (ZMod 37)), zeta^(x.val)) =
                (∑ x ∈ ({3, 4, 5, 7, 13, 18, 19, 24, 30, 32, 33, 34} : Finset (ZMod 37)), zeta^(x.val) - ∑ x ∈ ({2, 9, 12, 15, 16, 17, 20, 21, 22, 25, 28, 35} : Finset (ZMod 37)), zeta^(x.val)) *
                ((∑ x ∈ ({3, 4, 5, 7, 13, 18, 19, 24, 30, 32, 33, 34} : Finset (ZMod 37)), zeta^(x.val) - ∑ x ∈ ({2, 9, 12, 15, 16, 17, 20, 21, 22, 25, 28, 35} : Finset (ZMod 37)), zeta^(x.val)) * 3 - 10) - 74 := by
                  -- By definition of $zeta$, we know that $zeta^{37} = 1$ and $zeta^k \neq 1$ for $1 \leq k < 37$.
                  have h_zeta_prop : zeta ^ 37 = 1 ∧ ∀ k : ℕ, 1 ≤ k → k < 37 → zeta ^ k ≠ 1 := by
                    have h_zeta_prop : zeta ^ 37 = 1 := by
                      convert IsCyclotomicExtension.zeta_pow 37 ℚ K using 1;
                    have h_zeta_order : IsPrimitiveRoot zeta 37 := by
                      convert IsCyclotomicExtension.zeta_spec 37 ℚ K using 1;
                    exact ⟨ h_zeta_prop, fun k hk₁ hk₂ hk₃ => by have := h_zeta_order.pow_eq_one_iff_dvd k; interval_cases k <;> simp_all +decide ⟩;
                  simp_all +decide [ ZMod.val ];
                  grind +ring;
  convert h_expand using 1;
  · congr! 2;
    · exact H_explicit ▸ rfl;
    · exact C2_explicit ▸ rfl;
  · unfold eta_1 eta_2;
    unfold eta C1 C2; simp +decide ;
    rw [ show ( Finset.image ( fun x : ZMod 37 => g ^ 2 * x ) H : Finset ( ZMod 37 ) ) = { 3, 4, 5, 7, 13, 18, 19, 24, 30, 32, 33, 34 } from ?_, show ( Finset.image ( fun x : ZMod 37 => g * x ) H : Finset ( ZMod 37 ) ) = { 2, 9, 12, 15, 16, 17, 20, 21, 22, 25, 28, 35 } from ?_ ] ; simp +decide [ Finset.sum ] ; ring!;
    · native_decide +revert;
    · native_decide +revert);

/-
The algebraic relation 11γ = -3α² - α + 74 holds.
-/
theorem relation_gamma : 11 * gamma = -3 * alpha^2 - alpha + 74 := by
  have h_gamma : 11 * gamma = 11 * (eta_1 - eta_0) := by
    rfl
  have h_alpha : 11 * alpha = 11 * (eta_2 - eta_1) := by
    rfl
  have h_beta : 11 * beta = 11 * (eta_0 - eta_2) := by
    rfl
  have h_sum : eta_0 + eta_1 + eta_2 = -1 := by
    exact?
  have h_beta_eq : 11 * beta = 3 * alpha^2 - 10 * alpha - 74 := by
    convert relation_beta using 1
  have h_gamma_eq : 11 * gamma = -3 * alpha^2 - alpha + 74 := by
    grind
  exact h_gamma_eq.symm ▸ by ring;

/-
Checking availability of necessary theorems.
-/
#check Polynomial.cyclotomic.irreducible_rat
#check IsCyclotomicExtension.autEquivPow

/-
The 37th cyclotomic polynomial is irreducible over Q.
-/
theorem h_irr : Irreducible (Polynomial.cyclotomic 37 ℚ) := Polynomial.cyclotomic.irreducible_rat (by norm_num)

/-
sigma n is the Galois automorphism mapping zeta to zeta^n.
-/
noncomputable def sigma (n : (ZMod 37)ˣ) : K ≃ₐ[ℚ] K := (IsCyclotomicExtension.autEquivPow K h_irr).symm n

/-
sigma n maps zeta to zeta^n.
-/
theorem sigma_zeta (n : (ZMod 37)ˣ) : sigma n zeta = zeta^(n : ZMod 37).val := by
  -- By definition of automorphisms in the Galois group, $\sigma_n$ maps $zeta$ to $zeta^n$.
  have h_sigma_zeta : ∀ n : (ZMod 37)ˣ, (sigma n) zeta = zeta^(n.val.val) := by
    intro n
    simp [sigma];
    erw [ PowerBasis.equivOfMinpoly_apply ];
    erw [ PowerBasis.lift_gen ];
    exact?;
  exact h_sigma_zeta n

/-
The action of sigma n on alpha is determined by the cubic character of n.
-/
theorem global_permutation (n : (ZMod 37)ˣ) :
  ((n : ZMod 37) ∈ C1 → sigma n alpha = beta) ∧
  ((n : ZMod 37) ∈ C2 → sigma n alpha = gamma) ∧
  ((n : ZMod 37) ∈ H → sigma n alpha = alpha) := by
    -- Let's simplify the goal using the definitions of $C1$, $C2$, and $H$.
    suffices h_simp : ∀ n : (ZMod 37)ˣ, (n.val ∈ C1 → sigma n eta_0 = eta_1 ∧ sigma n eta_1 = eta_2 ∧ sigma n eta_2 = eta_0) ∧ (n.val ∈ C2 → sigma n eta_0 = eta_2 ∧ sigma n eta_1 = eta_0 ∧ sigma n eta_2 = eta_1) ∧ (n.val ∈ H → sigma n eta_0 = eta_0 ∧ sigma n eta_1 = eta_1 ∧ sigma n eta_2 = eta_2) by
      unfold alpha beta gamma; aesop;
    -- By definition of $sigma$, we know that $sigma n (zeta^x) = zeta^{n.val * x}$ for any $x \in \mathbb{Z}/37\mathbb{Z}$.
    have h_sigma_exp : ∀ n : (ZMod 37)ˣ, ∀ x : ZMod 37, (sigma n) (zeta^(x.val)) = zeta^((n.val * x).val) := by
      intro n x; exact (by
      convert congr_arg ( · ^ x.val ) ( sigma_zeta n ) using 1 ; norm_num [ pow_mul ];
      rw [ ← pow_mul, ZMod.val_mul ];
      -- Since $zeta$ is a primitive $37$th root of unity, we have $zeta^{37} = 1$.
      have h_zeta_37 : zeta ^ 37 = 1 := by
        convert IsCyclotomicExtension.zeta_pow 37 ℚ K;
      rw [ ← Nat.mod_add_div ( ( n : ZMod 37 ).val * x.val ) 37, pow_add, pow_mul ] ; aesop);
    -- Apply the definition of $sigma$ to each term in the sum.
    have h_sigma_sum : ∀ n : (ZMod 37)ˣ, ∀ S : Finset (ZMod 37), (sigma n) (∑ x ∈ S, zeta^(x.val)) = ∑ x ∈ S, zeta^((n.val * x).val) := by
      exact fun n S => by rw [ map_sum, Finset.sum_congr rfl fun x hx => h_sigma_exp n x ] ;
    intro n
    simp [h_sigma_sum, eta_0, eta_1, eta_2];
    unfold eta; simp +decide [ h_sigma_sum ] ;
    -- By definition of $C1$, $C2$, and $H$, we can rewrite the sums accordingly.
    have h_cosets : ∀ n : (ZMod 37)ˣ, (n.val ∈ C1 → Finset.image (fun x => (n.val * x : ZMod 37)) H = C1 ∧ Finset.image (fun x => (n.val * x : ZMod 37)) C1 = C2 ∧ Finset.image (fun x => (n.val * x : ZMod 37)) C2 = H) ∧ (n.val ∈ C2 → Finset.image (fun x => (n.val * x : ZMod 37)) H = C2 ∧ Finset.image (fun x => (n.val * x : ZMod 37)) C1 = H ∧ Finset.image (fun x => (n.val * x : ZMod 37)) C2 = C1) ∧ (n.val ∈ H → Finset.image (fun x => (n.val * x : ZMod 37)) H = H ∧ Finset.image (fun x => (n.val * x : ZMod 37)) C1 = C1 ∧ Finset.image (fun x => (n.val * x : ZMod 37)) C2 = C2) := by
      native_decide +revert;
    refine' ⟨ fun hn => _, fun hn => _, fun hn => _ ⟩;
    · have := h_cosets n |>.1 hn;
      exact ⟨ by rw [ ← this.1, Finset.sum_image ( Finset.card_image_iff.mp <| by simp +decide [ this ] ) ], by rw [ ← this.2.1, Finset.sum_image ( Finset.card_image_iff.mp <| by simp +decide [ this ] ) ], by rw [ ← this.2.2, Finset.sum_image ( Finset.card_image_iff.mp <| by simp +decide [ this ] ) ] ⟩;
    · have := h_cosets n |>.2.1 hn;
      exact ⟨ by rw [ ← this.1, Finset.sum_image ( Finset.card_image_iff.mp <| by simp +decide [ this ] ) ], by rw [ ← this.2.1, Finset.sum_image ( Finset.card_image_iff.mp <| by simp +decide [ this ] ) ], by rw [ ← this.2.2, Finset.sum_image ( Finset.card_image_iff.mp <| by simp +decide [ this ] ) ] ⟩;
    · have := h_cosets n |>.2.2 hn; simp_all +decide [ Finset.sum_image ] ;
      refine' ⟨ _, _, _ ⟩;
      · conv_rhs => rw [ ← this.1, Finset.sum_image ( Finset.card_image_iff.mp <| by simp +decide [ this.1 ] ) ] ;
      · conv_rhs => rw [ ← this.2.1, Finset.sum_image ( Finset.card_image_iff.mp <| by simp +decide [ * ] ) ] ;
      · conv_rhs => rw [ ← this.2.2, Finset.sum_image ( Finset.card_image_iff.mp <| by simp +decide [ * ] ) ] ;

/-
Ok is the ring of integers of K.
-/
abbrev Ok := NumberField.RingOfIntegers K

/-
sigma_int n is the restriction of sigma n to the ring of integers, viewed as a Z-algebra equivalence.
-/
noncomputable def sigma_int (n : (ZMod 37)ˣ) : Ok ≃ₐ[ℤ] Ok :=
  (NumberField.RingOfIntegers.mapAlgEquiv (sigma n)).restrictScalars ℤ

/-
N_mod_37 N is the element N in (ZMod 37)ˣ.
-/
def N_mod_37 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 37) : (ZMod 37)ˣ :=
  ZMod.unitOfCoprime N (Nat.Coprime.symm ((Nat.coprime_primes (by norm_num) (Fact.out)).mpr hN.symm))

/-
zeta is an algebraic integer.
-/
theorem zeta_isIntegral : IsIntegral ℤ zeta := IsPrimitiveRoot.isIntegral (IsCyclotomicExtension.zeta_spec 37 ℚ K) (by norm_num)

/-
zeta_int is zeta viewed as an element of the ring of integers.
-/
def zeta_int : Ok := ⟨zeta, zeta_isIntegral⟩

/-
The Artin property holds for zeta.
-/
theorem artin_property_zeta (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 37) (P : Ideal Ok) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) zeta_int) = (Ideal.Quotient.mk P zeta_int)^N := by
    have h_norm : ((Ideal.Quotient.mk P) (sigma_int (N_mod_37 N hN) zeta_int)) = ((Ideal.Quotient.mk P) (zeta_int)) ^ N := by
      have h_norm_eq : (sigma_int (N_mod_37 N hN) zeta_int) = zeta_int ^ N := by
        have h_sigma_zeta : sigma (N_mod_37 N hN) zeta = zeta ^ N := by
          convert sigma_zeta ( N_mod_37 N hN ) using 1;
          -- Since $N$ is coprime to $37$, we have $N \equiv N \mod 37 \pmod{37}$.
          have h_cong : (N : ZMod 37) = (N_mod_37 N hN : ZMod 37) := by
            exact?;
          rw [ ← h_cong, ZMod.val_natCast ];
          have h_order : zeta ^ 37 = 1 := by
            convert IsCyclotomicExtension.zeta_pow 37 ℚ K;
          rw [ ← Nat.mod_add_div N 37, pow_add, pow_mul ] ; aesop;
        exact?
      aesop;
    convert h_norm using 1

/-
zeta_int is a primitive 37th root of unity in the ring of integers.
-/
theorem zeta_int_isPrimitiveRoot : IsPrimitiveRoot zeta_int 37 := by
  have h_prim : IsPrimitiveRoot (zeta : K) 37 := by
    apply_rules [ IsCyclotomicExtension.zeta_spec ];
  simp_all +decide [ IsPrimitiveRoot.iff_def ];
  apply And.intro;
  · exact Subtype.ext h_prim.1;
  · intro l hl;
    convert h_prim.2 l _;
    convert congr_arg ( fun x : Ok => x : Ok → K ) hl using 1

/-
The ring of integers is generated by zeta.
-/
theorem Ok_eq_adjoin : ⊤ = Algebra.adjoin ℤ {zeta_int} := by
  have h_cyclotomic : IsCyclotomicExtension {37} ℤ (NumberField.RingOfIntegers (CyclotomicField 37 ℚ)) := by
    have h_cyclotomic : IsCyclotomicExtension {37} ℚ (CyclotomicField 37 ℚ) := by
      infer_instance;
    convert IsPrimitiveRoot.IsCyclotomicExtension.ringOfIntegers using 1;
    rotate_left;
    exacts [ 37, 1, ⟨ by norm_num ⟩, by infer_instance, by simpa using h_cyclotomic, by norm_num ];
  have h_primitive_root : IsPrimitiveRoot (zeta_int : NumberField.RingOfIntegers (CyclotomicField 37 ℚ)) 37 := by
    convert zeta_int_isPrimitiveRoot using 1;
  rw [ eq_comm ] ; exact IsCyclotomicExtension.adjoin_primitive_root_eq_top h_primitive_root;

/-
Define the integer versions of the Gaussian periods and roots.
-/
noncomputable def eta_int (S : Finset (ZMod 37)) : Ok := ∑ x ∈ S, zeta_int^(x.val)
noncomputable def eta_0_int := eta_int H
noncomputable def eta_1_int := eta_int C1
noncomputable def eta_2_int := eta_int C2
noncomputable def alpha_int := eta_2_int - eta_1_int
noncomputable def beta_int := eta_0_int - eta_2_int
noncomputable def gamma_int := eta_1_int - eta_0_int

/-
The integer roots map to the field roots.
-/
theorem alpha_int_coe : (alpha_int : K) = alpha := by
  exact?
theorem beta_int_coe : (beta_int : K) = beta := by
  unfold beta_int beta;
  unfold eta_0_int eta_2_int eta_0 eta_2; aesop;
theorem gamma_int_coe : (gamma_int : K) = gamma := by
  exact?

/-
The cyclic relations hold in the ring of integers.
-/
theorem cyclic_relations_int :
  11 * beta_int = 3 * alpha_int^2 - 10 * alpha_int - 74 ∧
  11 * gamma_int = -3 * alpha_int^2 - alpha_int + 74 := by
    -- By definition of alpha_int, beta_int, and gamma_int, we know that their images in K satisfy the same relations as their counterparts in K.
    have alpha_int_eq : (alpha_int : K) = alpha := by
      exact?
    have beta_int_eq : (beta_int : K) = beta := by
      exact?
    have gamma_int_eq : (gamma_int : K) = gamma := by
      exact?;
    -- Since these are equalities in K, we can conclude that the relations hold in the ring of integers as well.
    have h_rel : (11 * beta_int : K) = 3 * alpha_int^2 - 10 * alpha_int - 74 ∧ (11 * gamma_int : K) = -3 * alpha_int^2 - alpha_int + 74 := by
      exact ⟨ by rw [ alpha_int_eq, beta_int_eq, relation_beta ], by rw [ alpha_int_eq, gamma_int_eq, relation_gamma ] ⟩;
    have h_inj : Function.Injective (algebraMap (NumberField.RingOfIntegers K) K) := by
      exact?;
    exact ⟨ h_inj <| by simpa using h_rel.1, h_inj <| by simpa using h_rel.2 ⟩

/-
The global permutation holds in the ring of integers.
-/
theorem global_permutation_int (n : (ZMod 37)ˣ) :
  ((n : ZMod 37) ∈ C1 → sigma_int n alpha_int = beta_int) ∧
  ((n : ZMod 37) ∈ C2 → sigma_int n alpha_int = gamma_int) ∧
  ((n : ZMod 37) ∈ H → sigma_int n alpha_int = alpha_int) := by
    have := @global_permutation n;
    refine' ⟨ _, _, _ ⟩;
    · intro hn
      have h_eq : (sigma_int n alpha_int : K) = beta := by
        convert this.1 hn using 1;
      exact ( by rw [ ← beta_int_coe ] at *; exact Subtype.ext h_eq );
    · intro hn;
      have h_sigma_int_gamma : (sigma n : K → K) alpha = gamma := by
        exact this.2.1 hn;
      exact?;
    · intro hn;
      have := this.2.2 hn;
      exact?

/-
The automorphism sigma N reduces to the Frobenius map x |-> x^N modulo P.
-/
theorem artin_property (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 37) (P : Ideal Ok) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) (x : Ok) :
  Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) x) = (Ideal.Quotient.mk P x)^N := by
    -- The set of x satisfying the property is a subalgebra of Ok.
    have h_subalgebra : ∀ x y : Ok, ((Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) x)) = (Ideal.Quotient.mk P x) ^ N) → ((Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) y)) = (Ideal.Quotient.mk P y) ^ N) → ((Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) (x + y))) = (Ideal.Quotient.mk P (x + y)) ^ N) ∧ ((Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) (x * y))) = (Ideal.Quotient.mk P (x * y)) ^ N) := by
      intro x y hx hy;
      have h_frobenius_mul : ∀ (x y : Ok ⧸ P), (x + y) ^ N = x ^ N + y ^ N ∧ (x * y) ^ N = x ^ N * y ^ N := by
        intro x y; haveI := Fact.mk ( Fact.out : Nat.Prime N ) ; simp +decide [ add_pow_char, mul_pow ] ;
        -- Since $P$ is a prime ideal lying over $N$, the quotient ring $Ok/P$ has characteristic $N$.
        have h_char : ringChar (Ok ⧸ P) = N := by
          have h_char : Ideal.Quotient.mk P (N : Ok) = 0 := by
            rw [ Ideal.Quotient.eq_zero_iff_mem ];
            have := hP.1;
            rw [ Ideal.ext_iff ] at this;
            specialize this N; simp_all +decide [ Ideal.mem_span_singleton ] ;
          rw [ ringChar.eq_iff ];
          constructor;
          intro x; rw [ ← Nat.modEq_zero_iff_dvd ] ; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ] ;
          erw [ ZMod.natCast_eq_zero_iff ];
          erw [ Ideal.Quotient.eq_zero_iff_mem ] at *;
          constructor <;> intro hx;
          · have := hP.1;
            rw [ SetLike.ext_iff ] at this;
            specialize this x;
            simp_all +decide [ Ideal.mem_span_singleton, Ideal.mem_comap ];
            exact_mod_cast this;
          · obtain ⟨ k, rfl ⟩ := hx; simp +decide [ h_char, Ideal.mul_mem_right ] ;
        haveI := ringChar.of_eq h_char; simp +decide [ add_pow_char ] ;
      have h_frobenius_mul : ∀ (x y : Ok), (Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) x)) = (Ideal.Quotient.mk P x) ^ N → (Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) y)) = (Ideal.Quotient.mk P y) ^ N → (Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) (x + y))) = (Ideal.Quotient.mk P (x + y)) ^ N ∧ (Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) (x * y))) = (Ideal.Quotient.mk P (x * y)) ^ N := by
        intros x y hx hy; exact ⟨by
        convert h_frobenius_mul ( Ideal.Quotient.mk P x ) ( Ideal.Quotient.mk P y ) |>.1 using 1;
        · convert congr_arg₂ ( · + · ) hx hy using 1;
          · exact congr_arg _ ( map_add _ _ _ );
          · exact h_frobenius_mul _ _ |>.1;
        · convert h_frobenius_mul ( Ideal.Quotient.mk P x ) ( Ideal.Quotient.mk P y ) |>.1 using 1, by
          convert h_frobenius_mul ( Ideal.Quotient.mk P x ) ( Ideal.Quotient.mk P y ) |>.2 using 1;
          · convert congr_arg₂ ( · * · ) hx hy using 1;
            · exact congr_arg _ ( map_mul _ _ _ );
            · ring;
          · rw [ ← h_frobenius_mul ( Ideal.Quotient.mk P x ) ( Ideal.Quotient.mk P y ) |>.2 ];
            exact?⟩;
      exact h_frobenius_mul x y hx hy;
    -- Since Ok is generated by zeta_int (Ok_eq_adjoin), and the property holds for zeta_int (artin_property_zeta), it holds for all x.
    have h_generate : ∀ x ∈ Algebra.adjoin ℤ {zeta_int}, ((Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) x)) = (Ideal.Quotient.mk P x) ^ N) := by
      refine' fun x hx => Algebra.adjoin_induction _ _ _ _ hx;
      · exact fun x hx => by rw [ Set.mem_singleton_iff.mp hx ] ; exact artin_property_zeta N hN P hP;
      · intro r; erw [ map_intCast ] ; simp +decide [ pow_succ ] ;
        -- Since $P$ lies over $(N)$, we have $N \in P$.
        have hN_in_P : (N : Ok) ∈ P := by
          have := hP.1;
          exact Ideal.mem_comap.mp ( this ▸ Ideal.mem_span_singleton_self _ );
        erw [ Ideal.Quotient.eq ];
        -- Since $N$ is prime, we have $r^N \equiv r \pmod{N}$.
        have h_r_pow_N : (r : Ok) ^ N - r ∈ Ideal.span {(N : Ok)} := by
          rw [ Ideal.mem_span_singleton ];
          have h_r_pow_N : (r : ℤ) ^ N ≡ r [ZMOD N] := by
            haveI := Fact.mk ( Fact.out : Nat.Prime N ) ; simp +decide [ ← ZMod.intCast_eq_intCast_iff ] ;
          obtain ⟨ k, hk ⟩ := h_r_pow_N.symm.dvd;
          exact ⟨ k, by simpa [ ← @Int.cast_inj Ok ] using hk ⟩;
        simpa using P.neg_mem ( Ideal.span_le.mpr ( Set.singleton_subset_iff.mpr hN_in_P ) h_r_pow_N );
      · exact fun x y hx hy hx' hy' => h_subalgebra x y hx' hy' |>.1;
      · exact fun x y hx hy hx' hy' => h_subalgebra x y hx' hy' |>.2;
    convert h_generate x ?_;
    convert Ok_eq_adjoin ▸ Algebra.mem_top

/-
The polynomial f(X) = X^3 - 37X - 37.
-/
def f_poly : Polynomial ℤ := Polynomial.X^3 - 37 * Polynomial.X - 37

/-
P is a maximal ideal.
-/
theorem P_is_maximal (N : ℕ) [Fact (Nat.Prime N)] (P : Ideal Ok) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) : P.IsMaximal := by
  -- Since $P$ is a prime ideal in the ring of integers $Ok$ and $Ok$ is integral over $\mathbb{Z}$, $P$ must be maximal in $Ok$.
  have h_max : P.IsPrime → P ≠ ⊥ → P.IsMaximal := by
    exact?;
  refine h_max ‹_› ?_;
  intro h; have := hP.1; simp_all +decide [ Ideal.span_singleton_eq_bot ] ;

/-
The explicit Frobenius action on alpha_bar is given by the formulas (multiplied by 11 to avoid division).
-/
theorem explicit_frobenius (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 37) (hN11 : N ≠ 11)
  (P : Ideal Ok) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  let alpha_bar := Ideal.Quotient.mk P alpha_int
  let beta_bar := Ideal.Quotient.mk P beta_int
  let gamma_bar := Ideal.Quotient.mk P gamma_int
  ((N : ZMod 37) ∈ C1 → 11 * alpha_bar ^ N = 3 * alpha_bar ^ 2 - 10 * alpha_bar - 74) ∧
  ((N : ZMod 37) ∈ C2 → 11 * alpha_bar ^ N = -3 * alpha_bar ^ 2 - alpha_bar + 74) := by
    refine' ⟨ _, _ ⟩;
    · intro hN1
      have h_beta : Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) alpha_int) = Ideal.Quotient.mk P beta_int := by
        have h_beta : sigma_int (N_mod_37 N hN) alpha_int = beta_int := by
          convert global_permutation_int ( N_mod_37 N hN ) |>.1 _;
          exact?;
        rw [h_beta];
      have h_beta_eq : 11 * Ideal.Quotient.mk P beta_int = 3 * (Ideal.Quotient.mk P alpha_int)^2 - 10 * (Ideal.Quotient.mk P alpha_int) - 74 := by
        have h_beta_eq : 11 * beta_int = 3 * alpha_int^2 - 10 * alpha_int - 74 := by
          exact cyclic_relations_int.left;
        convert congr_arg ( Ideal.Quotient.mk P ) h_beta_eq using 1;
      have h_beta_eq : Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) alpha_int) = (Ideal.Quotient.mk P alpha_int)^N := by
        convert artin_property N hN P hP alpha_int using 1;
      aesop;
    · intro hN2
      have h_gamma_bar : (Ideal.Quotient.mk P gamma_int) = (Ideal.Quotient.mk P alpha_int)^N := by
        convert artin_property N hN P hP alpha_int using 1;
        rw [ global_permutation_int ( N_mod_37 N hN ) |>.2.1 ];
        convert hN2 using 1;
      convert congr_arg ( Ideal.Quotient.mk P ) ( congr_arg ( fun x : Ok => x : Ok → Ok ) ( show 11 * gamma_int = -3 * alpha_int^2 - alpha_int + 74 from ( cyclic_relations_int ) |>.2 ) ) using 1;
      simp +decide [ ← h_gamma_bar ];
      exact Or.inl rfl

/-
Definitions of s1, s2, and c.
-/
def s1 : ZMod 37 := 10
def s2 : ZMod 37 := 26
def c (N : ℕ) : ZMod 37 := (N : ZMod 37)^12

/-
Characterization of C1 and C2 by 12th powers.
-/
lemma mem_C1_iff (x : ZMod 37) (hx : x ≠ 0) : x ∈ C1 ↔ x^12 = s2 := by
  fin_cases x <;> trivial
lemma mem_C2_iff (x : ZMod 37) (hx : x ≠ 0) : x ∈ C2 ↔ x^12 = s1 := by
  native_decide +revert

/-
The main theorem: alpha^N = gamma if c == s1, and alpha^N = beta if c == s2.
-/
theorem final_result (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 37) (hN_odd : N % 2 = 1) (hN_a : Nat.Coprime 11 N)
  (P : Ideal Ok) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  let alpha_bar := Ideal.Quotient.mk P alpha_int
  let beta_bar := Ideal.Quotient.mk P beta_int
  let gamma_bar := Ideal.Quotient.mk P gamma_int
  (c N = s1 → alpha_bar ^ N = gamma_bar) ∧
  (c N = s2 → alpha_bar ^ N = beta_bar) := by
    have := explicit_frobenius N ( by aesop ) ( by aesop ) P hP;
    -- Since $11$ is invertible in $Ok/P$, we can cancel $11$ from the equations.
    have h_cancel : ∀ (x y : Ok ⧸ P), 11 * x = 11 * y → x = y := by
      -- Since $11$ is invertible in $Ok/P$, we can cancel $11$ from the equation $11 * x = 11 * y$.
      have h_inv : ∃ (inv_11 : Ok ⧸ P), inv_11 * 11 = 1 := by
        have h_inv : (11 : Ok ⧸ P) ≠ 0 := by
          intro h; have := hP.1; simp_all +decide [ Ideal.mem_span_singleton ] ;
          -- Since $11 \in P$, we have $11 \in \text{Ideal.under } \mathbb{Z} P$, which implies $11 \in \text{Ideal.span } \{N\}$.
          have h11_in_span : (11 : ℤ) ∈ Ideal.span {(N : ℤ)} := by
            convert Ideal.Quotient.eq_zero_iff_mem.mp h using 1;
            simp +decide [ Ideal.mem_span_singleton, this ];
          rw [ Ideal.mem_span_singleton ] at h11_in_span;
          norm_cast at h11_in_span; have := Nat.le_of_dvd ( by decide ) h11_in_span; interval_cases N <;> trivial;
        have h_inv : IsUnit (11 : Ok ⧸ P) := by
          have h_inv : IsField (Ok ⧸ P) := by
            exact @Field.toIsField _ ( Ideal.Quotient.field P );
          exact isUnit_iff_exists_inv.mpr ( h_inv.mul_inv_cancel ‹_› );
        exact h_inv.exists_left_inv;
      intro x y hxy; obtain ⟨ inv_11, h_inv ⟩ := h_inv; have := congr_arg ( · * inv_11 ) hxy; norm_num [ mul_assoc, mul_comm, mul_left_comm, h_inv ] at this; aesop;
    refine' ⟨ fun h => h_cancel _ _ _, fun h => h_cancel _ _ _ ⟩;
    · convert this.2 _ using 1;
      · convert congr_arg ( Ideal.Quotient.mk P ) ( cyclic_relations_int.2 ) using 1;
      · convert mem_C2_iff _ _ |>.2 _;
        · intro h; have := hP.1; simp_all +decide [ Ideal.span_singleton_eq_bot ] ;
          erw [ ZMod.natCast_eq_zero_iff ] at h ; have := Nat.dvd_gcd ( show 37 ∣ N from h ) ( show 37 ∣ 37 from dvd_refl 37 ) ; simp_all +decide;
          simp_all +decide [ Nat.Prime.dvd_iff_eq Fact.out ];
        · convert h using 1;
    · convert this.1 _ using 1;
      · convert congr_arg ( Ideal.Quotient.mk P ) ( cyclic_relations_int.1 ) using 1;
      · convert mem_C1_iff _ _ |>.2 h;
        rw [ Ne.eq_def, ZMod.natCast_eq_zero_iff ];
        exact fun h => hN <| by have := Nat.prime_dvd_prime_iff_eq ( by decide : Nat.Prime 37 ) ( Fact.out : Nat.Prime N ) ; tauto;


/-
Define the cyclotomic field K for q=8563.
-/
abbrev K8563 := CyclotomicField 8563 ℚ

/-
Define zeta as the primitive 8563rd root of unity in K.
-/
noncomputable def zeta8563 : K8563 := IsCyclotomicExtension.zeta 8563 ℚ K8563

/-
Define H as the subgroup of cubic residues modulo 8563.
-/
def H8563 : Finset (ZMod 8563) := ((Finset.univ : Finset (ZMod 8563)).filter (fun x => x ≠ 0)).image (fun x => x^3)

/-
Define s1 and s2 for q=8563.
-/
def s1_8563 : ZMod 8563 := 2823
def s2_8563 : ZMod 8563 := 5739

/-
Define c(N) = N^2854 mod 8563.
-/
def c_8563 (N : ℕ) : ZMod 8563 := (N : ZMod 8563)^2854

/-
Define C1 and C2 using the cubic character values s2 and s1.
-/
def C1_8563 : Finset (ZMod 8563) := (Finset.univ : Finset (ZMod 8563)).filter (fun x => x ≠ 0 ∧ x^2854 = s2_8563)
def C2_8563 : Finset (ZMod 8563) := (Finset.univ : Finset (ZMod 8563)).filter (fun x => x ≠ 0 ∧ x^2854 = s1_8563)

/-
Define the Gaussian period for a set S.
-/
noncomputable def eta_8563 (S : Finset (ZMod 8563)) : K8563 := ∑ x ∈ S, zeta8563^(x.val)

/-
Define the three Gaussian periods eta_0, eta_1, eta_2.
-/
noncomputable def eta_0_8563 := eta_8563 H8563
noncomputable def eta_1_8563 := eta_8563 C1_8563
noncomputable def eta_2_8563 := eta_8563 C2_8563

/-
Define the roots alpha, beta, gamma.
-/
noncomputable def alpha_8563 := eta_2_8563 - eta_1_8563
noncomputable def beta_8563 := eta_0_8563 - eta_2_8563
noncomputable def gamma_8563 := eta_1_8563 - eta_0_8563

/-
The non-zero elements of ZMod 8563 are the disjoint union of H, C1, and C2.
-/
lemma units_decomp_8563 :
  let units := (Finset.univ : Finset (ZMod 8563)).filter (fun x => x ≠ 0)
  units = H8563 ∪ C1_8563 ∪ C2_8563 ∧
  Disjoint H8563 C1_8563 ∧ Disjoint H8563 C2_8563 ∧ Disjoint C1_8563 C2_8563 := by
    native_decide +revert

/-
The sum of zeta^x for all non-zero x is -1.
-/
lemma sum_zeta_units_8563 :
  let units := (Finset.univ : Finset (ZMod 8563)).filter (fun x => x ≠ 0)
  ∑ x ∈ units, zeta8563^(x.val) = -1 := by
    -- The sum of all elements in the cyclotomic field is zero.
    have h_sum_all : ∑ x ∈ Finset.range 8563, zeta8563 ^ x = 0 := by
      rw [ geom_sum_eq ];
      · rw [ show zeta8563 ^ 8563 = 1 from ?_, sub_self, zero_div ];
        convert IsCyclotomicExtension.zeta_pow _ _ _;
      · -- By definition of $zeta8563$, we know that $zeta8563$ is a primitive 8563rd root of unity.
        have h_primitive : IsPrimitiveRoot zeta8563 8563 := by
          convert IsCyclotomicExtension.zeta_spec 8563 ℚ K8563 using 1;
        exact h_primitive.ne_one ( by decide );
    -- The sum of all elements in the cyclotomic field is zero, which includes the term for x=0.
    have h_sum_all : ∑ x ∈ Finset.range 8563, zeta8563 ^ x = ∑ x ∈ Finset.filter (fun x => x ≠ 0) (Finset.univ : Finset (ZMod 8563)), zeta8563 ^ x.val + 1 := by
      rw [ Finset.sum_range, Finset.sum_eq_sum_diff_singleton_add ( Finset.mem_univ 0 ) ];
      simp +contextual [ Finset.filter_ne' ];
      rfl;
    grind

/-
The sum of the three Gaussian periods is -1.
-/
lemma sum_eta_eq_minus_one_8563 : eta_0_8563 + eta_1_8563 + eta_2_8563 = -1 := by
  -- By definition of eta_0, eta_1, and eta_2, we can write their sum as the sum over the union of H8563, C1_8563, and C2_8563.
  have h_sum_def : eta_0_8563 + eta_1_8563 + eta_2_8563 = ∑ x ∈ H8563 ∪ C1_8563 ∪ C2_8563, zeta8563^(x.val) := by
    rw [ Finset.sum_union, Finset.sum_union ];
    · rfl;
    · native_decide;
    · native_decide +revert;
  rw [ h_sum_def, ← sum_zeta_units_8563 ];
  rw [ ← units_decomp_8563.1 ]

/-
Define the proposition representing the period equation.
-/
def period_equation_holds : Prop := alpha_8563^3 = 8563 * alpha_8563 + 8563

/-
Define the Galois automorphism sigma and its action on zeta.
-/
theorem h_irr_8563 : Irreducible (Polynomial.cyclotomic 8563 ℚ) := by
  exact Polynomial.cyclotomic.irreducible_rat ( by norm_num )

noncomputable def sigma_8563 (n : (ZMod 8563)ˣ) : K8563 ≃ₐ[ℚ] K8563 := (IsCyclotomicExtension.autEquivPow K8563 h_irr_8563).symm n

theorem sigma_zeta_8563 (n : (ZMod 8563)ˣ) : sigma_8563 n zeta8563 = zeta8563^(n : ZMod 8563).val := by
  have h_sigma_zeta : ∀ (n : (ZMod 8563)ˣ), (sigma_8563 n) zeta8563 = zeta8563^(n : ZMod 8563).val := by
    intro n
    unfold sigma_8563
    simp [sigma_8563];
    convert ( IsPrimitiveRoot.powerBasis ℚ _ ).equivOfMinpoly_apply _ _ _;
    erw [ PowerBasis.lift_gen ];
    rfl;
  exact h_sigma_zeta n

/-
Define the ring of integers and the integer automorphism.
-/
abbrev Ok8563 := NumberField.RingOfIntegers K8563

noncomputable def sigma_int_8563 (n : (ZMod 8563)ˣ) : Ok8563 ≃ₐ[ℤ] Ok8563 :=
  (NumberField.RingOfIntegers.mapAlgEquiv (sigma_8563 n)).restrictScalars ℤ

/-
Define N mod 8563 as a unit, and zeta as an integer.
-/
def N_mod_8563 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 8563) : (ZMod 8563)ˣ :=
  ZMod.unitOfCoprime N (Nat.Coprime.symm ((Nat.coprime_primes (by norm_num) (Fact.out)).mpr hN.symm))

theorem zeta_isIntegral_8563 : IsIntegral ℤ zeta8563 := by
  refine' ⟨ Polynomial.X ^ 8563 - 1, _, _ ⟩;
  · exact Polynomial.monic_X_pow_sub_C _ ( by norm_num );
  · have h_zeta_pow : IsPrimitiveRoot zeta8563 8563 := by
      convert IsCyclotomicExtension.zeta_spec 8563 ℚ K8563;
    simp +zetaDelta at *;
    rw [ h_zeta_pow.pow_eq_one, sub_self ]

def zeta_int_8563 : Ok8563 := ⟨zeta8563, zeta_isIntegral_8563⟩

/-
Define the hypotheses for the Dream Theorem (period equation and algebraic relations).
-/
def DreamTheoremHypotheses : Prop :=
  period_equation_holds ∧
  (185 * beta_8563 = 3 * alpha_8563^2 - 97 * alpha_8563 - 17126) ∧
  (185 * gamma_8563 = -3 * alpha_8563^2 + 88 * alpha_8563 + 17126)

/-
Define the integer versions of the Gaussian periods and roots.
-/
noncomputable def eta_int_8563 (S : Finset (ZMod 8563)) : Ok8563 := ∑ x ∈ S, zeta_int_8563^(x.val)
noncomputable def eta_0_int_8563 := eta_int_8563 H8563
noncomputable def eta_1_int_8563 := eta_int_8563 C1_8563
noncomputable def eta_2_int_8563 := eta_int_8563 C2_8563

noncomputable def alpha_int_8563 := eta_2_int_8563 - eta_1_int_8563
noncomputable def beta_int_8563 := eta_0_int_8563 - eta_2_int_8563
noncomputable def gamma_int_8563 := eta_1_int_8563 - eta_0_int_8563

/-
The integer roots map to the field roots.
-/
theorem alpha_int_coe_8563 : (alpha_int_8563 : K8563) = alpha_8563 := by
  -- By definition of coercion, we can rewrite the left-hand side using the definitions of the sums.
  simp [eta_int_8563, eta_0_int_8563, eta_1_int_8563, eta_2_int_8563, alpha_int_8563, alpha_8563];
  rfl
theorem beta_int_coe_8563 : (beta_int_8563 : K8563) = beta_8563 := by
  -- By definition of `beta_int_8563`, we have `beta_int_8563 = eta_0_int_8563 - eta_2_int_8563`.
  simp [beta_int_8563, eta_0_int_8563, eta_2_int_8563];
  simp +decide [ beta_8563, eta_int_8563 ];
  rfl
theorem gamma_int_coe_8563 : (gamma_int_8563 : K8563) = gamma_8563 := by
  -- By definition of $gamma_int_8563$, we have $gamma_int_8563 = \eta_1_int - \eta_0_int$.
  simp [gamma_int_8563, eta_1_int_8563, eta_0_int_8563];
  simp +decide only [eta_int_8563];
  unfold gamma_8563; aesop;

/-
The cyclic relation for beta in the ring of integers.
-/
theorem relation_beta_int_8563 (h : DreamTheoremHypotheses) :
  185 * beta_int_8563 = 3 * alpha_int_8563^2 - 97 * alpha_int_8563 - 17126 := by
    -- By definition of DreamTheoremHypotheses, we know that 185 * beta_8563 = 3 * alpha_8563^2 - 97 * alpha_8563 - 17126.
    obtain ⟨h_period, h_beta, h_gamma⟩ := h;
    -- By definition of coercion, the equality in the field implies the equality in the integers.
    have h_coerce : (185 * beta_int_8563 : K8563) = 3 * (alpha_int_8563 : K8563) ^ 2 - 97 * (alpha_int_8563 : K8563) - 17126 := by
      linear_combination' h_beta + alpha_int_coe_8563 * 97 - alpha_int_coe_8563 * 3 * alpha_int_coe_8563 + beta_int_coe_8563 * 185;
    -- By definition of coercion, the equality in the field implies the equality in the integers. We can use the fact that the coercion from the ring of integers to the field is injective.
    have h_inj : Function.Injective (algebraMap Ok8563 K8563) := by
      exact Subtype.coe_injective;
    exact h_inj <| by simpa using h_coerce;

/-
The cyclic relation for gamma in the ring of integers.
-/
theorem relation_gamma_int_8563 (h : DreamTheoremHypotheses) :
  185 * gamma_int_8563 = -3 * alpha_int_8563^2 + 88 * alpha_int_8563 + 17126 := by
    obtain ⟨h_period, h_beta, h_gamma⟩ := h;
    -- Since the inclusion map from Ok8563 to K8563 is injective, we can conclude that the equation holds in Ok8563 by applying the inclusion map to both sides of the equation.
    have h_inj : Function.Injective (algebraMap Ok8563 K8563) := by
      exact Subtype.coe_injective;
    exact h_inj <| by simpa [ ← alpha_int_coe_8563, ← beta_int_coe_8563, ← gamma_int_coe_8563 ] using h_gamma;

/-
Multiplication by an element of H fixes the cosets H, C1, C2.
-/
lemma perm_H_8563 (n : ZMod 8563) (hn : n ∈ H8563) :
  (H8563.image (fun x => n * x) = H8563) ∧
  (C1_8563.image (fun x => n * x) = C1_8563) ∧
  (C2_8563.image (fun x => n * x) = C2_8563) := by
    refine ⟨ ?_, ?_, ?_ ⟩
    all_goals generalize_proofs at *;
    · rw [ Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr fun x hx => ?_ ) ];
      · rw [ Finset.card_image_of_injective ];
        intro x y hxy; haveI := Fact.mk ( by norm_num : Nat.Prime 8563 ) ; exact mul_left_cancel₀ ( show n ≠ 0 from by rintro rfl; exact absurd hn ( by native_decide ) ) hxy;
      · unfold H8563 at *;
        rw [ Finset.mem_image ] at *;
        obtain ⟨ a, ha, rfl ⟩ := hn; obtain ⟨ b, hb, rfl ⟩ := hx; exact ⟨ a * b, by
          simp +zetaDelta at *;
          haveI := Fact.mk ( by norm_num : Nat.Prime 8563 ) ; exact mul_ne_zero ha hb;, by ring ⟩ ;
    · refine Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr ?_ ) ?_;
      · intro x hx
        obtain ⟨y, hy⟩ : ∃ y : ZMod 8563, y ≠ 0 ∧ y^2854 = s2_8563 ∧ x = y := by
          unfold C1_8563 at hx; aesop;
        obtain ⟨z, hz⟩ : ∃ z : ZMod 8563, z ≠ 0 ∧ n = z^3 := by
          native_decide +revert;
        have h_mul : (z^3 * y)^2854 = s2_8563 := by
          rw [ mul_pow, ← hy.2.1 ];
          have h_mul : z ^ 8562 = 1 := by
            haveI := Fact.mk ( by norm_num : Nat.Prime 8563 ) ; exact ZMod.pow_card_sub_one_eq_one hz.1;
          rw [ ← pow_mul, h_mul, one_mul ];
        simp_all +decide [ C1_8563 ];
        haveI := Fact.mk ( by norm_num : Nat.Prime 8563 ) ; exact mul_ne_zero ( pow_ne_zero 3 hz.1 ) hy.1;
      · rw [ Finset.card_image_of_injective _ fun x y hxy => _ ];
        intro x y hxy;
        haveI := Fact.mk ( by norm_num : Nat.Prime 8563 ) ; exact mul_left_cancel₀ ( show n ≠ 0 from by rintro rfl; exact absurd hn ( by native_decide ) ) hxy;
    · refine' Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr _ ) _;
      · intro x hx
        have hnx : (n * x)^2854 = s1_8563 := by
          -- Since $n \in H8563$, we have $n^{2854} = 1$.
          have hn_pow : n^2854 = 1 := by
            native_decide +revert;
          rw [ mul_pow, hn_pow, one_mul ];
          exact Finset.mem_filter.mp hx |>.2.2
        exact (by
        exact Finset.mem_filter.mpr ⟨ Finset.mem_univ _, by
          exact ⟨ by intro h; rw [ h ] at hnx; exact absurd hnx ( by native_decide ), hnx ⟩ ⟩);
      · rw [ Finset.card_image_of_injective _ fun x y hxy => _ ];
        intro x y hxy;
        haveI := Fact.mk ( by norm_num : Nat.Prime 8563 ) ; exact mul_left_cancel₀ ( show n ≠ 0 from by rintro rfl; exact absurd hn ( by native_decide ) ) hxy;

/-
Multiplication by an element of C1 permutes the cosets cyclically.
-/
lemma perm_C1_8563 (n : ZMod 8563) (hn : n ∈ C1_8563) :
  (H8563.image (fun x => n * x) = C1_8563) ∧
  (C1_8563.image (fun x => n * x) = C2_8563) ∧
  (C2_8563.image (fun x => n * x) = H8563) := by
    revert n hn;
    -- By definition of $C1_8563$, we know that $n \in C1_8563$ implies $n^{2854} = s2_8563$.
    intro n hn
    have hn_cubic : n^2854 = s2_8563 := by
      exact Finset.mem_filter.mp hn |>.2.2;
    -- By definition of $H8563$, $C1_8563$, and $C2_8563$, we know that multiplying any element in $H8563$ by $n$ will result in an element in $C1_8563$, and similarly for the other sets.
    have h_mul_H : ∀ x ∈ H8563, n * x ∈ C1_8563 := by
      intro x hx
      have hx_cubic : x^2854 = 1 := by
        native_decide +revert;
      have h_mul_H : (n * x)^2854 = s2_8563 := by
        rw [ mul_pow, hn_cubic, hx_cubic, mul_one ];
      by_cases h : n * x = 0 <;> simp_all +decide [ C1_8563 ]
    have h_mul_C1 : ∀ x ∈ C1_8563, n * x ∈ C2_8563 := by
      intro x hx
      have hx_cubic : x^2854 = s2_8563 := by
        exact Finset.mem_filter.mp hx |>.2.2
      have h_mul_C1 : (n * x)^2854 = s1_8563 := by
        rw [ mul_pow, hn_cubic, hx_cubic ] ; native_decide
      exact (by
      by_cases h : n * x = 0 <;> simp_all +decide [ C2_8563 ])
    have h_mul_C2 : ∀ x ∈ C2_8563, n * x ∈ H8563 := by
      intro x hx
      have hx_cubic : x^2854 = s1_8563 := by
        exact Finset.mem_filter.mp hx |>.2.2;
      -- Since $n \in C1_8563$, we have $n^{2854} = s2_8563$. Therefore, $(n * x)^{2854} = n^{2854} * x^{2854} = s2_8563 * s1_8563 = 1$.
      have h_mul_C2_cubic : (n * x)^2854 = 1 := by
        rw [ mul_pow, hn_cubic, hx_cubic ] ; native_decide;
      -- Since $(n * x)^{2854} = 1$, we have $n * x \in H8563$ by definition of $H8563$.
      have h_mul_C2_in_H : ∀ y : ZMod 8563, y^2854 = 1 → y ∈ H8563 := by
        native_decide +revert;
      exact h_mul_C2_in_H _ h_mul_C2_cubic;
    refine' ⟨ Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr h_mul_H ) _, Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr h_mul_C1 ) _, Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr h_mul_C2 ) _ ⟩;
    · rw [ Finset.card_image_of_injective _ fun x y hxy => _ ];
      · native_decide +revert;
      · intro x y hxy
        have h_inv : n ≠ 0 := by
          exact fun h => by rw [ h ] at hn_cubic; exact absurd hn_cubic ( by native_decide ) ;
        haveI := Fact.mk ( by norm_num : Nat.Prime 8563 ) ; exact mul_left_cancel₀ h_inv hxy;
    · rw [ Finset.card_image_of_injective _ fun x y hxy => _ ];
      · native_decide;
      · intro x y hxy
        have h_inv : n ≠ 0 := by
          exact fun h => by rw [ h ] at hn_cubic; exact absurd hn_cubic ( by native_decide ) ;
        haveI := Fact.mk ( by norm_num : Nat.Prime 8563 ) ; exact mul_left_cancel₀ h_inv hxy;
    · rw [ Finset.card_image_of_injective _ fun x y hxy => _ ];
      · native_decide +revert;
      · intro x y hxy
        have h_inv : n ≠ 0 := by
          exact fun h => by rw [ h ] at hn_cubic; exact absurd hn_cubic ( by native_decide ) ;
        haveI := Fact.mk ( by norm_num : Nat.Prime 8563 ) ; exact mul_left_cancel₀ h_inv hxy;

/-
Multiplication by an element of C2 permutes the cosets cyclically.
-/
lemma perm_C2_8563 (n : ZMod 8563) (hn : n ∈ C2_8563) :
  (H8563.image (fun x => n * x) = C2_8563) ∧
  (C1_8563.image (fun x => n * x) = H8563) ∧
  (C2_8563.image (fun x => n * x) = C1_8563) := by
    revert n hn;
    -- By definition of $C2_8563$, we know that any element $n \in C2_8563$ can be written as $g^2 * h$ for some $h \in H8563$.
    obtain ⟨g, hg⟩ : ∃ g : ZMod 8563, g ∈ C1_8563 ∧ ∀ h : ZMod 8563, h ∈ H8563 → h * g ∈ C1_8563 ∧ h * g^2 ∈ C2_8563 := by
      native_decide;
    -- By definition of $C2_8563$, we know that any element $n \in C2_8563$ can be written as $g^2 * h$ for some $h \in H8563$. Use this fact.
    intro n hn
    obtain ⟨h, hh⟩ : ∃ h : ZMod 8563, h ∈ H8563 ∧ n = g^2 * h := by
      have h_perm : Finset.image (fun h => g^2 * h) H8563 = C2_8563 := by
        have h_perm : Finset.card (Finset.image (fun h => g^2 * h) H8563) = Finset.card C2_8563 := by
          rw [ Finset.card_image_of_injective ];
          · native_decide +revert;
          · have h_inv : IsUnit (g^2) := by
              have h_inv : IsUnit g := by
                have h_inv : g ≠ 0 := by
                  exact fun h => by rw [ h ] at hg; exact absurd hg.1 ( by native_decide ) ;
                haveI := Fact.mk ( by norm_num : Nat.Prime 8563 ) ; exact IsUnit.mk0 _ h_inv;
              exact h_inv.pow 2;
            exact fun x y hxy => h_inv.mul_left_cancel hxy;
        exact Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr fun x hx => by simpa [ mul_comm ] using hg.2 x hx |>.2 ) h_perm.ge;
      rw [ Finset.ext_iff ] at h_perm; specialize h_perm n; aesop;
    -- Since $g^2$ is in $C1_8563$, multiplying by $g^2$ permutes the cosets.
    have h_perm_g2 : Finset.image (fun x => g^2 * x) H8563 = C2_8563 ∧ Finset.image (fun x => g^2 * x) C1_8563 = H8563 ∧ Finset.image (fun x => g^2 * x) C2_8563 = C1_8563 := by
      have h_perm_g2 : Finset.image (fun x => g * x) H8563 = C1_8563 ∧ Finset.image (fun x => g * x) C1_8563 = C2_8563 ∧ Finset.image (fun x => g * x) C2_8563 = H8563 := by
        have := perm_C1_8563 g hg.1; simp_all +decide [ mul_comm g ] ;
      have h_perm_g2 : Finset.image (fun x => g^2 * x) H8563 = Finset.image (fun x => g * x) (Finset.image (fun x => g * x) H8563) ∧ Finset.image (fun x => g^2 * x) C1_8563 = Finset.image (fun x => g * x) (Finset.image (fun x => g * x) C1_8563) ∧ Finset.image (fun x => g^2 * x) C2_8563 = Finset.image (fun x => g * x) (Finset.image (fun x => g * x) C2_8563) := by
        simp +decide [ sq, mul_assoc, Finset.ext_iff ];
      grind;
    -- Since $h \in H8563$, multiplication by $h$ permutes the cosets.
    have h_perm_h : Finset.image (fun x => h * x) H8563 = H8563 ∧ Finset.image (fun x => h * x) C1_8563 = C1_8563 ∧ Finset.image (fun x => h * x) C2_8563 = C2_8563 := by
      have := perm_H_8563 h hh.1; aesop;
    simp +decide only [hh.2, mul_assoc];
    have h_perm_combined : Finset.image (fun x => g^2 * (h * x)) H8563 = Finset.image (fun x => g^2 * x) (Finset.image (fun x => h * x) H8563) ∧ Finset.image (fun x => g^2 * (h * x)) C1_8563 = Finset.image (fun x => g^2 * x) (Finset.image (fun x => h * x) C1_8563) ∧ Finset.image (fun x => g^2 * (h * x)) C2_8563 = Finset.image (fun x => g^2 * x) (Finset.image (fun x => h * x) C2_8563) := by
      simp +decide [ Finset.ext_iff ];
    aesop

/-
zeta_int is a primitive 8563rd root of unity in the ring of integers.
-/
theorem zeta_int_isPrimitiveRoot_8563 : IsPrimitiveRoot zeta_int_8563 8563 := by
  refine' ⟨ _, _ ⟩;
  · -- By definition of zeta, we know that zeta_int_8563 is a root of unity, so its order is 8563.
    have h_zeta_root : zeta8563 ^ 8563 = 1 := by
      convert IsPrimitiveRoot.pow_eq_one ( IsCyclotomicExtension.zeta_spec 8563 ℚ K8563 );
    exact Subtype.ext h_zeta_root;
  · intro l hl
    have h_order : orderOf zeta8563 = 8563 := by
      have h_order : IsPrimitiveRoot zeta8563 8563 := by
        convert IsCyclotomicExtension.zeta_spec 8563 ℚ K8563 using 1;
      exact?;
    rw [ ← h_order, orderOf_dvd_iff_pow_eq_one ];
    convert congr_arg Subtype.val hl using 1

/-
Global permutation properties of alpha, beta, gamma under Galois automorphisms for q=8563.
-/
theorem Q0037.global_permutation_8563 (n : (ZMod 8563)ˣ) :
  ((n : ZMod 8563) ∈ Q0037.C1_8563 → Q0037.sigma_8563 n Q0037.alpha_8563 = Q0037.beta_8563) ∧
  ((n : ZMod 8563) ∈ Q0037.C2_8563 → Q0037.sigma_8563 n Q0037.alpha_8563 = Q0037.gamma_8563) ∧
  ((n : ZMod 8563) ∈ Q0037.H8563 → Q0037.sigma_8563 n Q0037.alpha_8563 = Q0037.alpha_8563) := by
    have h_sigma_eta : ∀ S : Finset (ZMod 8563), sigma_8563 n (eta_8563 S) = eta_8563 (S.image (fun x => (n : ZMod 8563) * x)) := by
      unfold eta_8563;
      simp +zetaDelta at *;
      intro S; congr; ext x; rw [ sigma_zeta_8563 ] ; norm_num [ ZMod.val_mul ] ;
      rw [ ← pow_mul, ← Nat.mod_add_div ( ( n : ZMod 8563 ).val * x.val ) 8563 ] ; norm_num [ pow_add, pow_mul ];
      have h_zeta_pow : zeta8563 ^ 8563 = 1 := by
        exact IsCyclotomicExtension.zeta_pow _ _ _;
      rw [ h_zeta_pow, one_pow, mul_one ];
    unfold C1_8563 C2_8563 H8563 at *;
    unfold alpha_8563 beta_8563 gamma_8563;
    unfold eta_2_8563 eta_1_8563 eta_0_8563; simp +decide [ h_sigma_eta ] ;
    refine' ⟨ _, _, _ ⟩;
    · intro hn hn';
      have := perm_C1_8563 n.val (by
      exact Finset.mem_filter.mpr ⟨ Finset.mem_univ _, hn, hn' ⟩);
      rw [ this.2.1, this.2.2 ];
    · intro hn hn';
      rw [ show ( Finset.image ( fun x : ZMod 8563 => ( n : ZMod 8563 ) * x ) C2_8563 ) = C1_8563 from ?_, show ( Finset.image ( fun x : ZMod 8563 => ( n : ZMod 8563 ) * x ) C1_8563 ) = H8563 from ?_ ];
      · have := perm_C2_8563 ( n : ZMod 8563 ) ?_;
        · exact this.2.1;
        · exact Finset.mem_filter.mpr ⟨ Finset.mem_univ _, hn, hn' ⟩;
      · have := perm_C2_8563 n; simp_all +decide [ Finset.ext_iff ] ;
        exact this ( by unfold C2_8563; exact Finset.mem_filter.mpr ⟨ Finset.mem_univ _, hn, hn' ⟩ ) |>.2.2;
    · intro x hx hx'; rw [ show ( Finset.image ( fun x => ( n : ZMod 8563 ) * x ) C2_8563 ) = C2_8563 from ?_, show ( Finset.image ( fun x => ( n : ZMod 8563 ) * x ) C1_8563 ) = C1_8563 from ?_ ] ;
      · have := perm_H_8563 ( n : ZMod 8563 ) ?_;
        · exact this.2.1;
        · exact Finset.mem_image.mpr ⟨ x, Finset.mem_filter.mpr ⟨ Finset.mem_univ _, hx ⟩, hx' ⟩;
      · have := perm_H_8563 ( n : ZMod 8563 ) ?_;
        · exact this.2.2;
        · exact Finset.mem_image.mpr ⟨ x, Finset.mem_filter.mpr ⟨ Finset.mem_univ _, hx ⟩, hx' ⟩

/-
Global permutation properties for the integer roots alpha_int, beta_int, gamma_int.
-/
theorem Q0037.global_permutation_int_8563 (n : (ZMod 8563)ˣ) :
  ((n : ZMod 8563) ∈ Q0037.C1_8563 → Q0037.sigma_int_8563 n Q0037.alpha_int_8563 = Q0037.beta_int_8563) ∧
  ((n : ZMod 8563) ∈ Q0037.C2_8563 → Q0037.sigma_int_8563 n Q0037.alpha_int_8563 = Q0037.gamma_int_8563) ∧
  ((n : ZMod 8563) ∈ Q0037.H8563 → Q0037.sigma_int_8563 n Q0037.alpha_int_8563 = Q0037.alpha_int_8563) := by
    have h_restrict : ∀ (x : Ok8563), (sigma_int_8563 n x : K8563) = sigma_8563 n x := by
      exact?;
    have h_restrict_eq : ∀ (x y : Ok8563), (x : K8563) = y → x = y := by
      aesop;
    refine' ⟨ _, _, _ ⟩;
    · intro hn
      have h_sigma_eq : sigma_8563 n alpha_8563 = beta_8563 := by
        exact Q0037.global_permutation_8563 n |>.1 hn;
      apply h_restrict_eq;
      rw [ h_restrict, alpha_int_coe_8563, h_sigma_eq, beta_int_coe_8563 ];
    · intro hn;
      apply h_restrict_eq;
      rw [ h_restrict, alpha_int_coe_8563, gamma_int_coe_8563 ];
      exact Q0037.global_permutation_8563 n |>.2.1 hn;
    · intro hn;
      apply h_restrict_eq;
      rw [ h_restrict, alpha_int_coe_8563 ];
      exact Q0037.global_permutation_8563 n |>.2.2 hn

/-
zeta_int_8563 is a primitive 8563rd root of unity.
-/
theorem Q0037.zeta_int_isPrimitiveRoot_8563 : IsPrimitiveRoot Q0037.zeta_int_8563 8563 := by
  exact?

/-
The ring of integers of K is generated by zeta over Z.
-/
theorem Q0037.Ok8563_eq_adjoin : ⊤ = Algebra.adjoin ℤ {Q0037.zeta_int_8563} := by
  rw [ eq_comm ];
  convert Ok_eq_adjoin using 1;
  constructor <;> intro h <;> rw [ eq_comm ] at h;
  · exact?;
  · -- Since $zeta_int_8563$ is a primitive 8563rd root of unity, it generates the entire ring of integers.
    have h_gen : IsPrimitiveRoot zeta_int_8563 8563 := by
      exact?;
    have := @IsPrimitiveRoot.IsCyclotomicExtension.ringOfIntegers;
    specialize @this 8563 1 ( CyclotomicField 8563 ℚ );
    have := @this ( by infer_instance ) ( by exact ⟨ by norm_num ⟩ ) ( by exact? ) ( by infer_instance );
    cases this;
    rename_i h₁ h₂;
    refine' le_antisymm _ _;
    · exact le_top;
    · intro x hx;
      refine' Algebra.adjoin_le _ _;
      exact { b : Ok8563 | ∃ n ∈ ( { 8563 ^ 1 } : Set ℕ ), n ≠ 0 ∧ b ^ n = 1 };
      · rintro b ⟨ n, hn₁, hn₂, hn₃ ⟩;
        obtain ⟨ k, hk ⟩ := h_gen.eq_pow_of_pow_eq_one ( show b ^ 8563 = 1 from by aesop );
        exact hk.2 ▸ Subalgebra.pow_mem _ ( Algebra.subset_adjoin <| Set.mem_singleton _ ) _;
      · exact h₂ x

/-
The characteristic of Ok/P is N.
-/
theorem Q0037.charP_quotient_8563 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 8563) (P : Ideal Q0037.Ok8563) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  CharP (Q0037.Ok8563 ⧸ P) N := by
    refine' CharP.mk _;
    intro x;
    erw [ Ideal.Quotient.eq_zero_iff_mem ];
    constructor <;> intro hx;
    · have := hP.1;
      rw [ SetLike.ext_iff ] at this;
      specialize this x;
      rw [ Ideal.mem_span_singleton ] at this;
      exact Int.natCast_dvd_natCast.mp ( this.mpr hx );
    · obtain ⟨ k, rfl ⟩ := hx;
      convert P.mul_mem_right ( k : Ok8563 ) ( hP.1.symm ▸ Ideal.mem_span_singleton_self _ ) using 1;
      norm_num [ mul_comm ]

/-
sigma_int maps zeta_int to zeta_int^n.
-/
theorem Q0037.sigma_int_zeta_8563 (n : (ZMod 8563)ˣ) : Q0037.sigma_int_8563 n Q0037.zeta_int_8563 = Q0037.zeta_int_8563^(n : ZMod 8563).val := by
  refine' Subtype.ext _;
  convert sigma_zeta_8563 n using 1

/-
The Artin property for q=8563.
-/
theorem Q0037.artin_property_8563 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 8563) (P : Ideal Q0037.Ok8563) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) (x : Q0037.Ok8563) :
  Ideal.Quotient.mk P (Q0037.sigma_int_8563 (Q0037.N_mod_8563 N hN) x) = (Ideal.Quotient.mk P x)^N := by
    have h_fermat : ∀ n : ℤ, (Ideal.Quotient.mk P) (sigma_int_8563 (N_mod_8563 N hN) (n : Ok8563)) = (Ideal.Quotient.mk P) (n : Ok8563) ^ N := by
      intro n
      have h_fermat_int : (n : ℤ) ^ N ≡ n [ZMOD N] := by
        haveI := Fact.mk ( Fact.out : Nat.Prime N ) ; simp +decide [ ← ZMod.intCast_eq_intCast_iff ] ;
      have h_fermat_int : (n : Ok8563) ^ N - n ∈ P := by
        obtain ⟨ k, hk ⟩ := h_fermat_int.symm.dvd;
        convert P.mul_mem_right ( k : Ok8563 ) ( hP.1.symm ▸ Ideal.mem_span_singleton_self ( N : ℤ ) ) using 1 ; norm_cast ; aesop;
      erw [ Ideal.Quotient.eq ];
      convert P.neg_mem h_fermat_int using 1 ; ring;
      erw [ map_intCast ];
    have h_gen : x ∈ Algebra.adjoin ℤ {Q0037.zeta_int_8563} := by
      rw [ ← Q0037.Ok8563_eq_adjoin ];
      trivial;
    refine' Algebra.adjoin_induction _ _ _ _ h_gen;
    · have h_fermat_zeta : (Ideal.Quotient.mk P) (sigma_int_8563 (N_mod_8563 N hN) Q0037.zeta_int_8563) = (Ideal.Quotient.mk P) Q0037.zeta_int_8563 ^ N := by
        rw [ Q0037.sigma_int_zeta_8563 ];
        have h_fermat_zeta : (Ideal.Quotient.mk P) Q0037.zeta_int_8563 ^ (N : ℕ) = (Ideal.Quotient.mk P) Q0037.zeta_int_8563 ^ ((N_mod_8563 N hN) : ZMod 8563).val := by
          have h_fermat_zeta : (Ideal.Quotient.mk P) Q0037.zeta_int_8563 ^ 8563 = 1 := by
            have h_fermat_zeta : Q0037.zeta_int_8563 ^ 8563 = 1 := by
              exact Q0037.zeta_int_isPrimitiveRoot_8563.pow_eq_one;
            rw [ ← map_pow, h_fermat_zeta, map_one ];
          have h_fermat_zeta : (Ideal.Quotient.mk P) Q0037.zeta_int_8563 ^ N = (Ideal.Quotient.mk P) Q0037.zeta_int_8563 ^ (N % 8563) := by
            rw [ ← Nat.mod_add_div N 8563, pow_add, pow_mul ] ; aesop;
          convert h_fermat_zeta using 1;
        convert h_fermat_zeta.symm using 1;
      aesop;
    · exact h_fermat;
    · intro x y hx hy hx' hy'; simp_all +decide [ ← map_add ] ;
      convert congr_arg₂ ( · + · ) hx' hy' using 1 ; ring;
      · exact congr_arg _ ( map_add _ _ _ );
      · have h_fermat : ∀ x y : Ok8563 ⧸ P, (x + y) ^ N = x ^ N + y ^ N := by
          have h_fermat : CharP (Ok8563 ⧸ P) N := by
            exact?;
          exact fun x y => by rw [ add_pow_char ] ;
        convert h_fermat ( Ideal.Quotient.mk P x ) ( Ideal.Quotient.mk P y ) using 1;
    · simp +contextual [ mul_pow ]

/-
The Dream Theorem for q=8563.
-/
theorem Q0037.final_result_8563 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 8563) (hN_odd : N % 2 = 1) (hN_a : Nat.Coprime 185 N)
  (P : Ideal Q0037.Ok8563) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_dream : Q0037.DreamTheoremHypotheses) :
  let alpha_bar := Ideal.Quotient.mk P Q0037.alpha_int_8563
  let beta_bar := Ideal.Quotient.mk P Q0037.beta_int_8563
  let gamma_bar := Ideal.Quotient.mk P Q0037.gamma_int_8563
  (Q0037.c_8563 N = Q0037.s1_8563 → alpha_bar ^ N = gamma_bar) ∧
  (Q0037.c_8563 N = Q0037.s2_8563 → alpha_bar ^ N = beta_bar) := by
    constructor;
    · intro hc
      have h_sigma : Q0037.sigma_int_8563 (ZMod.unitOfCoprime N (Nat.Coprime.symm ((Nat.coprime_primes (by norm_num) (Fact.out)).mpr hN.symm))) Q0037.alpha_int_8563 = Q0037.gamma_int_8563 := by
        apply (global_permutation_int_8563 _).right.left;
        simp +zetaDelta at *;
        unfold C2_8563 c_8563 s1_8563 at *;
        grind;
      have := Q0037.artin_property_8563 N hN P hP;
      exact this _ ▸ h_sigma ▸ rfl;
    · -- By definition of `C1` and `c(N)`, this means `N` (mod 8563) is in `C1`.
      intro hc
      have hn_C1 : (N : ZMod 8563) ∈ C1_8563 := by
        unfold C1_8563 c_8563 s2_8563 at *;
        grind;
      -- By `global_permutation_int_8563`, `sigma_int n_unit alpha_int = beta_int`.
      have h_sigma_beta : Q0037.sigma_int_8563 (Q0037.N_mod_8563 N hN) Q0037.alpha_int_8563 = Q0037.beta_int_8563 := by
        convert Q0037.global_permutation_int_8563 ( N_mod_8563 N hN ) |>.1 _;
        exact?;
      rw [ ← h_sigma_beta, Q0037.artin_property_8563 ];
      exact hP