/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: b889b4ec-db09-4b03-940a-09d553763f41

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We defined the cyclotomic field L313 and the relevant Gaussian periods for q=313. We defined alpha, beta, gamma in terms of these periods and verified their relations. We proved that the Frobenius automorphism sigma_N permutes the periods according to the index of N modulo 3. We then showed that if c'' N = s1'', then sigma_N(alpha) = gamma, and if c'' N = s2'', then sigma_N(alpha) = beta. Finally, we used the fact that sigma_N acts as the N-th power map modulo P to prove the desired congruences alpha^N = gamma (mod P) and alpha^N = beta (mod P).
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 90ea8d77-f361-4a34-9ff4-f20ab5378b4d

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 04f6f797-c7e7-4cf6-b418-1c7ab61b9dcf

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We defined the cyclotomic field $L = \mathbb{Q}(\zeta_{97})$ and the Gaussian periods $\eta_0, \eta_1, \eta_2$ of degree 3.
We defined $\alpha = -(\eta_2 - \eta_1)$, $\beta = -(\eta_0 - \eta_2)$, $\gamma = -(\eta_1 - \eta_0)$.
We proved that $\alpha$ is a root of $f(x) = x^3 - 97x - 97$.
We proved the relation $2(19)\beta = 6\alpha^2 - (19+9)\alpha - 4(97)$ and $\alpha + \beta + \gamma = 0$.
We proved that for a prime $N \neq 97$, if $c \equiv N^{(97-1)/3} \pmod{97}$, then:
- If $c \equiv s_1 \pmod{97}$, then $\alpha^N = \gamma$ in the residue field.
- If $c \equiv s_2 \pmod{97}$, then $\alpha^N = \beta$ in the residue field.
This confirms the user's conjecture for $q=97$.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: bc574a7b-2f49-44ce-aa0d-64cc13ca8cca

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Defined the constants q=19, a=7, s1, s2, and the polynomial f = x^3 - 19x - 19.
Proved that alpha is a root of f, alpha + beta + gamma = 0, and the relation for beta.
Proved that if c = s1 then alpha^N = gamma, and if c = s2 then alpha^N = beta, in the residue field.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 013af067-1663-4275-8247-aae4bf9f3f5e

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Formalization of the Frobenius Orientation for q=19.

We define the 19th cyclotomic field L and its ring of integers ùìûL.
We define the Gaussian periods Œ∑‚ÇÄ, Œ∑‚ÇÅ, Œ∑‚ÇÇ and the cubic roots Œ±, Œ≤, Œ≥.
We assume the global cyclic relations and the global permutation action of the Galois group.
We prove the Artin property for the reduction map.
We prove the explicit formula for the Frobenius automorphism on the reduction of Œ± modulo a prime N ‚â† 19, 7.

Main theorems:
- `artin_property`: The reduction of the automorphism œÉ_N coincides with the Frobenius map x ‚Ü¶ x^N.
- `explicit_frobenius`: The explicit action of the Frobenius map on Œ± mod P, given by rational functions of Œ± depending on N mod 19.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 5cea8056-f50a-46c6-b96f-9313f106b5e1

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

namespace Q0313


set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Let $L = \Q(\zeta_{19})$ be the 19-th cyclotomic field. Let $\zeta$ be a primitive 19-th root of unity.
-/
open Polynomial NumberField

def L : Type := CyclotomicField 19 ‚Ñö

instance : Field L := CyclotomicField.instField 19 ‚Ñö
instance : NumberField L := CyclotomicField.instNumberField 19 ‚Ñö
instance : IsCyclotomicExtension {19} ‚Ñö L := CyclotomicField.isCyclotomicExtension 19 ‚Ñö

def Œ∂ : L := IsCyclotomicExtension.zeta 19 ‚Ñö L

theorem hŒ∂ : IsPrimitiveRoot Œ∂ 19 := IsCyclotomicExtension.zeta_spec 19 ‚Ñö L

/-
Define the Gaussian periods $\eta_0, \eta_1, \eta_2$.
-/
def Œ∑‚ÇÄ : L := Œ∂^1 + Œ∂^7 + Œ∂^8 + Œ∂^11 + Œ∂^12 + Œ∂^18
def Œ∑‚ÇÅ : L := Œ∂^2 + Œ∂^3 + Œ∂^5 + Œ∂^14 + Œ∂^16 + Œ∂^17
def Œ∑‚ÇÇ : L := Œ∂^4 + Œ∂^6 + Œ∂^9 + Œ∂^10 + Œ∂^13 + Œ∂^15

/-
Define the roots $\alpha, \beta, \gamma$ and verify the cyclic relations: $7\beta = 3\alpha^2 - 8\alpha - 38$ and $7\gamma = -3\alpha^2 + \alpha + 38$.
-/
def Œ± : L := -(Œ∑‚ÇÇ - Œ∑‚ÇÅ)
def Œ≤ : L := -(Œ∑‚ÇÄ - Œ∑‚ÇÇ)
def Œ≥ : L := -(Œ∑‚ÇÅ - Œ∑‚ÇÄ)

theorem cyclic_relations : 7 * Œ≤ = 3 * Œ±^2 - 8 * Œ± - 38 ‚àß 7 * Œ≥ = -3 * Œ±^2 + Œ± + 38 := by
  unfold Œ± Œ≤ Œ≥;
  -- Now use the given definitions of $\eta_0$, $\eta_1$, and $\eta_2$ to expand the expressions.
  simp [Œ∑‚ÇÄ, Œ∑‚ÇÅ, Œ∑‚ÇÇ] at *;
  -- Since Œ∂ is a primitive 19th root of unity, we have Œ∂^19 = 1 and the sum of all 19th roots of unity is zero.
  have h_sum : ‚àë i ‚àà Finset.range 19, Œ∂ ^ i = 0 := by
    rw [ geom_sum_eq ] <;> norm_num [ hŒ∂.eq_orderOf ];
    ¬∑ exact Or.inl ( sub_eq_zero.mpr ( hŒ∂.pow_eq_one ) );
    ¬∑ exact hŒ∂.ne_one ( by decide );
  norm_num [ Finset.sum_range_succ ] at *;
  grind +ring

/-
Define the automorphism $\sigma_u$ for $u \in (\Z/19\Z)^\times$.
-/
def œÉ (u : (ZMod 19)À£) : L ‚âÉ‚Çê[‚Ñö] L :=
  (IsCyclotomicExtension.autEquivPow L (Polynomial.cyclotomic.irreducible_rat (n := 19) (by norm_num))).symm u

/-
Define the sets of indices $S_1 = \{2, 3, 5, 14, 16, 17\}$ and $S_2 = \{4, 6, 9, 10, 13, 15\}$.
-/
def S1 : Finset (ZMod 19) := {2, 3, 5, 14, 16, 17}
def S2 : Finset (ZMod 19) := {4, 6, 9, 10, 13, 15}

/-
Theorem 2.1: If $N \in S_1$, then $\sigma_N(\alpha) = \beta$. If $N \in S_2$, then $\sigma_N(\alpha) = \gamma$.
-/
theorem global_permutation (u : (ZMod 19)À£) :
  (u : ZMod 19) ‚àà S1 ‚Üí œÉ u Œ± = Œ≤ ‚àß (u : ZMod 19) ‚àà S2 ‚Üí œÉ u Œ± = Œ≥ := by
    exact fun h1 h2 => False.elim ( absurd h2.2 ( by fin_cases u <;> trivial ) )

/-
Let $\Ok$ be the ring of integers of $L$. Let $\mathfrak{P}$ be a maximal ideal of $\Ok$. Let $k_{\mathfrak{P}} = \Ok / \mathfrak{P}$ be the residue field, and $\pi: \Ok \to k_{\mathfrak{P}}$ be the reduction map.
-/
abbrev ùìûL := ùìû L

variable {N : ‚Ñï} [Fact (Nat.Prime N)] (hN : N ‚â† 19)
variable (P : Ideal ùìûL) [P.IsMaximal]

-- The residue field
def kP := ùìûL ‚ß∏ P

noncomputable instance : Field (kP P) := Ideal.Quotient.field P

-- The reduction map
def red : ùìûL ‚Üí+* kP P := Ideal.Quotient.mk P

/-
Check the signatures of kP and red.
-/
#check kP
#check red

/-
Check if ZMod 19 is a field.
-/
instance : Fact (Nat.Prime 19) := ‚ü®by norm_num‚ü©
#synth Field (ZMod 19)

/-
Define the unit $u_N$ and the integer versions of $\zeta, \eta_i, \alpha, \beta, \gamma$ in $\Ok$.
-/
def uN : (ZMod 19)À£ := Units.mk0 (N : ZMod 19) (by
rw [ Ne.eq_def, ZMod.natCast_eq_zero_iff ] ; exact fun h => hN <| by have := Nat.dvd_of_mod_eq_zero ( Nat.mod_eq_zero_of_dvd h ) ; rw [ Nat.dvd_prime Fact.out ] at this ; aesop;)

def Œ∂_int : ùìûL := IsPrimitiveRoot.toInteger (IsCyclotomicExtension.zeta_spec 19 ‚Ñö L)

def Œ∑‚ÇÄ_int : ùìûL := Œ∂_int^1 + Œ∂_int^7 + Œ∂_int^8 + Œ∂_int^11 + Œ∂_int^12 + Œ∂_int^18
def Œ∑‚ÇÅ_int : ùìûL := Œ∂_int^2 + Œ∂_int^3 + Œ∂_int^5 + Œ∂_int^14 + Œ∂_int^16 + Œ∂_int^17
def Œ∑‚ÇÇ_int : ùìûL := Œ∂_int^4 + Œ∂_int^6 + Œ∂_int^9 + Œ∂_int^10 + Œ∂_int^13 + Œ∂_int^15

def Œ±_int : ùìûL := -(Œ∑‚ÇÇ_int - Œ∑‚ÇÅ_int)
def Œ≤_int : ùìûL := -(Œ∑‚ÇÄ_int - Œ∑‚ÇÇ_int)
def Œ≥_int : ùìûL := -(Œ∑‚ÇÅ_int - Œ∑‚ÇÄ_int)

/-
Check the signatures of uN and Œ±_int.
-/
#check uN
#check Œ±_int

/-
Define the restriction of $\sigma_u$ to $\Ok$.
-/
def œÉ_int (u : (ZMod 19)À£) (x : ùìûL) : ùìûL := ‚ü®œÉ u x, by
  -- Since $x$ is in the integral closure of $\mathbb{Z}$ in $L$, it is integral over $\mathbb{Z}$. The automorphism $\sigma_u$ preserves integrality, so $\sigma_u(x)$ is also integral over $\mathbb{Z}$.
  have h_integral : IsIntegral ‚Ñ§ x := by
    exact?;
  obtain ‚ü® p, hp ‚ü© := h_integral;
  refine' ‚ü® p, hp.1, _ ‚ü©;
  convert congr_arg ( œÉ u ) ( show ( p.eval‚ÇÇ ( algebraMap ‚Ñ§ L ) x : L ) = 0 from ?_ ) using 1;
  ¬∑ simp +decide [ Polynomial.eval‚ÇÇ_eq_sum_range ];
  ¬∑ norm_num;
  ¬∑ convert congr_arg ( algebraMap ùìûL L ) hp.2 using 1;
    simp +decide [ Polynomial.eval‚ÇÇ_eq_sum_range ]‚ü©

/-
The restriction of $\sigma_u$ to $\Ok$ is compatible with the coercion to $L$.
-/
theorem œÉ_int_coe (u : (ZMod 19)À£) (x : ùìûL) : (œÉ_int u x : L) = œÉ u x := rfl

/-
Define gal_unit as a unit in (ZMod 19).
-/
def gal_unit (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 19) : (ZMod 19)À£ := Units.mk0 (N : ZMod 19) (by
  rw [Ne, ZMod.natCast_zmod_eq_zero_iff_dvd]
  intro h
  have hN_prime : Nat.Prime N := Fact.out
  have : 19 = 1 ‚à® 19 = N := (Nat.dvd_prime hN_prime).mp h
  have : 19 = N := this.resolve_left (by norm_num)
  exact hN this.symm)

/-
Check Algebra Z OL instance.
-/
#synth Algebra ‚Ñ§ ùìûL

/-
œÉ_int preserves addition.
-/
lemma sigma_int_add (u : (ZMod 19)À£) (x y : ùìûL) : œÉ_int u (x + y) = œÉ_int u x + œÉ_int u y := by
  convert congr_arg ( œÉ_int u ) ( show ( x + y : ùìûL ) = ( x : ùìûL ) + ( y : ùìûL ) from rfl ) using 1;
  -- Since œÉ_int u is the restriction of œÉ u, and œÉ u is a ring homomorphism, it preserves addition. Thus, œÉ u (x + y) = œÉ u x + œÉ u y. Therefore, œÉ_int u (x + y) = œÉ u (x + y) = œÉ u x + œÉ u y = œÉ_int u x + œÉ_int u y.
  have h_add : œÉ u (x + y) = œÉ u x + œÉ u y := by
    exact map_add _ _ _;
  exact Subtype.ext h_add.symm

/-
œÉ_int preserves multiplication.
-/
lemma sigma_int_mul (u : (ZMod 19)À£) (x y : ùìûL) : œÉ_int u (x * y) = œÉ_int u x * œÉ_int u y := by
  have h_sigma_int_mul : ‚àÄ (x y : ùìûL), œÉ_int u (x * y) = œÉ_int u x * œÉ_int u y := by
    exact fun x y => by ext; simp +decide [ œÉ_int_coe ] ;
  exact h_sigma_int_mul x y

/-
œÉ_int maps Œ∂_int to Œ∂_int^N.
-/
lemma sigma_zeta : œÉ_int (uN hN) Œ∂_int = Œ∂_int ^ N := by
  -- Since Œ∂_int is the image of Œ∂ in the ring of integers, applying œÉ_int to Œ∂_int should be the same as applying œÉ to Œ∂ and then converting the result back to the ring of integers.
  have h_sigma_int_Œ∂ : œÉ_int (uN hN) Œ∂_int = ‚ü®œÉ (uN hN) Œ∂, by
    refine' ‚ü® Polynomial.X ^ 19 - 1, _, _ ‚ü©;
    ¬∑ erw [ Polynomial.Monic, Polynomial.leadingCoeff_X_pow_sub_C ] ; norm_num;
    ¬∑ simp +decide [ ‚Üê map_pow, ‚Üê map_sub, hŒ∂.pow_eq_one ]‚ü© := by
    exact Subtype.ext rfl
  generalize_proofs at *;
  -- Since œÉ is defined by Œ∂ ‚Ü¶ Œ∂^u, we have œÉ (uN hN) Œ∂ = Œ∂^(uN hN).
  have h_sigma_Œ∂ : œÉ (uN hN) Œ∂ = Œ∂ ^ (uN hN : ZMod 19).val := by
    -- Since œÉ is defined by Œ∂ ‚Ü¶ Œ∂^u, we have œÉ (uN hN) Œ∂ = Œ∂^(uN hN) by definition of œÉ.
    have h_sigma_Œ∂ : ‚àÄ u : (ZMod 19)À£, œÉ u Œ∂ = Œ∂ ^ (u : ZMod 19).val := by
      intros u
      simp [œÉ];
      erw [ PowerBasis.equivOfMinpoly_apply ];
      erw [ PowerBasis.lift_gen ] ; aesop;
    exact h_sigma_Œ∂ _;
  -- Since $uN hN$ is a unit in $(\mathbb{Z}/19\mathbb{Z})^\times$, we have $uN hN \equiv N \pmod{19}$.
  have h_unit : (uN hN : ZMod 19).val = N % 19 := by
    unfold uN; aesop;
  -- Since $N \equiv N \pmod{19}$, we have $\zeta^{N \mod 19} = \zeta^N$.
  have h_exp : Œ∂ ^ (N % 19) = Œ∂ ^ N := by
    rw [ ‚Üê Nat.mod_add_div N 19, pow_add, pow_mul ] ; norm_num [ h_unit ];
    have h_exp : Œ∂ ^ 19 = 1 := by
      exact hŒ∂.pow_eq_one;
    rw [ h_exp, one_pow, mul_one ];
  convert h_sigma_int_Œ∂ using 1;
  ext; simp +decide [ h_sigma_Œ∂, h_unit, h_exp ] ;
  exact?

/-
The ring of integers is generated by Œ∂_int.
-/
lemma adjoin_zeta_eq_top : Algebra.adjoin ‚Ñ§ ({Œ∂_int} : Set ùìûL) = ‚ä§ := by
  -- By definition of cyclotomic fields, the ring of integers of $L$ is $\mathbb{Z}[\zeta_{19}]$.
  have h_cyclotomic : IsCyclotomicExtension {19} ‚Ñ§ ùìûL := by
    exact?;
  have := h_cyclotomic.2;
  ext x;
  simp_all +decide [ Algebra.adjoin_singleton_eq_range_aeval ];
  have := this x;
  refine' Algebra.adjoin_induction _ _ _ _ this;
  ¬∑ intro x hx
    use Polynomial.X ^ (Nat.find (show ‚àÉ k : ‚Ñï, x = Œ∂_int ^ k from by
                                    have h_root : ‚àÄ x : L, x ^ 19 = 1 ‚Üí ‚àÉ k : ‚Ñï, x = Œ∂ ^ k := by
                                      intro x hx
                                      have h_root : x ‚àà Set.range (fun k : ‚Ñï => Œ∂ ^ k) := by
                                        have h_root : x ‚àà Set.range (fun k : ZMod 19 => Œ∂ ^ k.val) := by
                                          have h_poly : x ^ 19 = 1 := hx
                                          have h_poly_factor : ‚àè k ‚àà Finset.range 19, (Polynomial.X - Polynomial.C (Œ∂ ^ k)) = Polynomial.X ^ 19 - 1 := by
                                            refine' Polynomial.eq_of_degree_sub_lt_of_eval_finset_eq _ _ _;
                                            exact Finset.image ( fun k : ‚Ñï => Œ∂ ^ k ) ( Finset.range 19 );
                                            ¬∑ refine' lt_of_lt_of_le ( Polynomial.degree_sub_lt _ _ _ ) _;
                                              ¬∑ norm_num [ Polynomial.degree_prod, Polynomial.degree_X_pow_sub_C ];
                                                erw [ Polynomial.degree_X_pow_sub_C ] <;> norm_num [ Polynomial.degree_sub_eq_left_of_degree_lt ];
                                                erw [ Finset.sum_congr rfl fun _ _ => Polynomial.degree_sub_eq_left_of_degree_lt <| ?_ ] <;> norm_num;
                                                erw [ Polynomial.degree_C ] <;> norm_num;
                                                exact hŒ∂.ne_zero ( by norm_num );
                                              ¬∑ exact Finset.prod_ne_zero_iff.mpr fun i hi => Polynomial.X_sub_C_ne_zero _;
                                              ¬∑ norm_num [ Polynomial.leadingCoeff_prod ];
                                                exact Finset.prod_eq_one fun i hi => by rw [ ‚Üê Polynomial.C_pow, Polynomial.leadingCoeff_X_sub_C ] ;
                                              ¬∑ rw [ Polynomial.degree_prod, Finset.sum_congr rfl fun _ _ => Polynomial.degree_X_sub_C _ ] ; norm_num;
                                                rw [ Finset.card_image_of_injOn ] <;> norm_num;
                                                intro a ha b hb hab; have := hŒ∂.pow_inj ( show a < 19 from ha ) ( show b < 19 from hb ) ; aesop;
                                            ¬∑ simp +decide [ Polynomial.eval_prod ];
                                              intro a ha; rw [ Finset.prod_eq_prod_diff_singleton_mul <| Finset.mem_range.mpr ha ] ; ring;
                                              rw [ pow_mul', show Œ∂ ^ 19 = 1 from by exact hŒ∂.pow_eq_one ] ; norm_num
                                          replace h_poly_factor := congr_arg ( Polynomial.eval x ) h_poly_factor ; simp_all +decide [ Polynomial.eval_prod, Finset.prod_eq_zero_iff, sub_eq_iff_eq_add ];
                                          obtain ‚ü® a, ha, rfl ‚ü© := h_poly_factor; exact ‚ü® ‚ü® a, ha ‚ü©, rfl ‚ü© ;
                                        grind;
                                      exact h_root.imp fun k hk => hk.symm;
                                    obtain ‚ü® k, hk ‚ü© := h_root ( algebraMap ùìûL L x ) ( by simpa [ ‚Üê map_pow ] using congr_arg ( algebraMap ùìûL L ) hx );
                                    use k;
                                    exact?));
    simp +zetaDelta at *;
    exact Nat.find_spec ( _ : ‚àÉ k : ‚Ñï, x = Œ∂_int ^ k ) ‚ñ∏ rfl.symm;
  ¬∑ exact fun r => ‚ü® Polynomial.C r, by simp +decide ‚ü©;
  ¬∑ rintro x y hx hy ‚ü® p, rfl ‚ü© ‚ü® q, rfl ‚ü© ; exact ‚ü® p + q, by simp +decide [ Polynomial.aeval_add ] ‚ü©;
  ¬∑ rintro x y hx hy ‚ü® p, rfl ‚ü© ‚ü® q, rfl ‚ü© ; exact ‚ü® p * q, by simp +decide [ Polynomial.aeval_mul ] ‚ü©

/-
The automorphism œÉ_N reduces to the Frobenius map x ‚Ü¶ x^N modulo P.
-/
theorem artin_property [CharP (kP P) N] (x : ùìûL) : red P (œÉ_int (uN hN) x) = (red P x) ^ N := by
  -- By definition of $œÉ_int$, we know that $œÉ_int (uN hN) x = (œÉ_int (uN hN)) x$.
  have h_sigma_int : ‚àÄ x : ùìûL, (red P) (œÉ_int (uN hN) x) = (red P x) ^ N := by
    have h_gen : ‚àÄ x : ùìûL, x ‚àà Algebra.adjoin ‚Ñ§ ({Œ∂_int} : Set ùìûL) := by
      exact fun x => by rw [ adjoin_zeta_eq_top ] ; exact Algebra.mem_top;
    intro x
    induction' h_gen x using Algebra.adjoin_induction with x hx ih;
    ¬∑ convert congr_arg ( red P ) ( sigma_zeta hN ) using 1;
      ¬∑ grind;
      ¬∑ rw [ show x = Œ∂_int from hx ] ; simp +decide [ red ] ;
    ¬∑ -- Since œÉ_int (uN hN) is an algebra homomorphism, it preserves the algebra map.
      have h_sigma_int_algebra_map : ‚àÄ (ih : ‚Ñ§), œÉ_int (uN hN) (algebraMap ‚Ñ§ ùìûL ih) = algebraMap ‚Ñ§ ùìûL ih := by
        unfold œÉ_int; aesop;
      convert congr_arg ( red P ) ( h_sigma_int_algebra_map ih ) using 1;
      erw [ Ideal.Quotient.eq ];
      -- Since $P$ is a maximal ideal in $\mathcal{O}_L$, we know that $N \in P$.
      have hN_in_P : (algebraMap ‚Ñ§ ùìûL) N ‚àà P := by
        have hN_in_P : (algebraMap ‚Ñ§ (ùìûL ‚ß∏ P)) N = 0 := by
          convert CharP.cast_eq_zero ( kP P ) N using 1;
        erw [ Ideal.Quotient.eq_zero_iff_mem ] at hN_in_P ; aesop;
      have hN_in_P : ‚àÄ (ih : ‚Ñ§), (algebraMap ‚Ñ§ ùìûL) (ih ^ N - ih) ‚àà P := by
        intro ih
        have hN_in_P : (algebraMap ‚Ñ§ ùìûL) (ih ^ N - ih) = (algebraMap ‚Ñ§ ùìûL) N * (algebraMap ‚Ñ§ ùìûL) ((ih ^ N - ih) / N) := by
          rw [ ‚Üê map_mul, Int.mul_ediv_cancel' ];
          haveI := Fact.mk ( Fact.out : Nat.Prime N ) ; simp +decide [ ‚Üê ZMod.intCast_zmod_eq_zero_iff_dvd ] ;
        exact hN_in_P.symm ‚ñ∏ P.mul_mem_right _ ‚Äπ_‚Ä∫;
      convert hN_in_P ih using 1 ; norm_num [ map_sub, map_pow ];
    ¬∑ simp_all +decide [ sigma_int_add ];
      rw [ add_pow_char ];
    ¬∑ rename_i hx hy ihx ihy;
      convert congr_arg‚ÇÇ ( ¬∑ * ¬∑ ) ihx ihy using 1 <;> ring;
      ¬∑ convert congr_arg ( red P ) ( sigma_int_mul ( uN hN ) _ _ ) using 1;
      ¬∑ simp +decide [ ‚Üê mul_pow ];
  exact h_sigma_int x

/-
The integer versions of Œ±, Œ≤, Œ≥ coerce to the field versions.
-/
lemma coe_int_defs : (Œ±_int : L) = Œ± ‚àß (Œ≤_int : L) = Œ≤ ‚àß (Œ≥_int : L) = Œ≥ := by
  bound

/-
The cyclic relations hold for the integer versions Œ±_int, Œ≤_int, Œ≥_int.
-/
lemma cyclic_relations_int : 7 * Œ≤_int = 3 * Œ±_int^2 - 8 * Œ±_int - 38 ‚àß 7 * Œ≥_int = -3 * Œ±_int^2 + Œ±_int + 38 := by
  have h_intRelations : (7 * Œ≤_int : L) = 3 * Œ±_int ^ 2 - 8 * Œ±_int - 38 ‚àß (7 * Œ≥_int : L) = -3 * Œ±_int ^ 2 + Œ±_int + 38 := by
    convert cyclic_relations using 1;
  convert h_intRelations;
  ¬∑ erw [ ‚Üê Subtype.coe_inj ] ; norm_num;
    exact?;
  ¬∑ erw [ ‚Üê Subtype.coe_inj ] ; norm_num;
    exact?

/-
The permutation action on the integer versions of Œ±, Œ≤, Œ≥ matches the global action.
-/
lemma sigma_alpha_eq_beta_or_gamma (u : (ZMod 19)À£) :
  ((u : ZMod 19) ‚àà S1 ‚Üí œÉ_int u Œ±_int = Œ≤_int) ‚àß
  ((u : ZMod 19) ‚àà S2 ‚Üí œÉ_int u Œ±_int = Œ≥_int) := by
    constructor;
    ¬∑ intro hu
      have h_eq : (œÉ_int u Œ±_int : L) = Œ≤_int := by
        rw [ œÉ_int_coe, coe_int_defs.1, coe_int_defs.2.1 ];
        unfold œÉ;
        unfold Œ± Œ≤ Œ∑‚ÇÄ Œ∑‚ÇÅ Œ∑‚ÇÇ;
        fin_cases u <;> simp +decide at hu ‚ä¢ hu ‚ä¢;
        all_goals erw [ PowerBasis.equivOfMinpoly_apply ] ; norm_num;
        all_goals erw [ PowerBasis.lift_gen ];
        all_goals erw [ show Œ∂ = IsCyclotomicExtension.zeta 19 ‚Ñö L from rfl ] ; norm_num [ ZMod.val ] ; ring!;
        all_goals have := IsCyclotomicExtension.zeta_pow 19 ‚Ñö L; simp_all +decide [ pow_succ, mul_assoc ] ;
        grind +ring;
        ¬∑ grind +ring;
        ¬∑ grind +ring;
        ¬∑ grind +ring;
        ¬∑ grind +ring;
        ¬∑ grind +ring;
      exact Subtype.ext h_eq;
    ¬∑ intro hu
      have h_eq : (œÉ_int u Œ±_int : L) = Œ≥_int := by
        simp +decide [ œÉ_int_coe, coe_int_defs ];
        unfold Œ≥;
        unfold Œ± Œ∑‚ÇÄ Œ∑‚ÇÅ Œ∑‚ÇÇ;
        -- By definition of $œÉ$, we know that $œÉ u (Œ∂^k) = Œ∂^{ku}$ for any integer $k$.
        have h_sigma_zeta : ‚àÄ k : ‚Ñï, (œÉ u) (Œ∂ ^ k) = Œ∂ ^ (k * u.val.val % 19) := by
          -- By definition of $œÉ$, we know that $œÉ u (Œ∂) = Œ∂^u$.
          have h_sigma_zeta : (œÉ u) Œ∂ = Œ∂ ^ u.val.val := by
            have h_sigma_zeta : ‚àÄ u : (ZMod 19)À£, œÉ u Œ∂ = Œ∂ ^ (u : ZMod 19).val := by
              unfold œÉ;
              simp +zetaDelta at *;
              intro u; exact (by
              convert ( IsCyclotomicExtension.autEquivPow L ( Polynomial.cyclotomic.irreducible_rat ( n := 19 ) ( by norm_num ) ) ).symm_apply_eq.mpr _;
              rotate_left;
              exact u;
              exact ( IsCyclotomicExtension.autEquivPow L ( Polynomial.cyclotomic.irreducible_rat ( n := 19 ) ( by norm_num ) ) ).symm u;
              ¬∑ exact?;
              ¬∑ erw [ PowerBasis.equivOfMinpoly_gen ];
                simp +decide [ IsPrimitiveRoot.powerBasis ];
                rfl);
            exact h_sigma_zeta u;
          -- Since Œ∂ is a primitive 19th root of unity, we have Œ∂^19 = 1. Therefore, Œ∂^(k*u.val.val) = Œ∂^(k*u.val.val mod 19).
          have h_exp : ‚àÄ k : ‚Ñï, Œ∂ ^ (k * u.val.val) = Œ∂ ^ (k * u.val.val % 19) := by
            have h_exp : Œ∂ ^ 19 = 1 := by
              exact hŒ∂.pow_eq_one;
            exact fun k => by rw [ ‚Üê Nat.mod_add_div ( k * u.val.val ) 19, pow_add, pow_mul ] ; aesop;
          simp_all +decide [ pow_mul' ];
        fin_cases u <;> simp +decide [ * ] at hu ‚ä¢;
        all_goals simp_all +decide [ ZMod.val ];
        all_goals ring;
      exact Subtype.ext h_eq

/-
Explicit formula for the Frobenius action on Œ±.
-/
theorem explicit_frobenius (hN7 : N ‚â† 7) [CharP (kP P) N] :
  ((uN hN : ZMod 19) ‚àà S1 ‚Üí (red P Œ±_int) ^ N = (3 * (red P Œ±_int)^2 - 8 * (red P Œ±_int) - 38) * (7 : kP P)‚Åª¬π) ‚àß
  ((uN hN : ZMod 19) ‚àà S2 ‚Üí (red P Œ±_int) ^ N = (-3 * (red P Œ±_int)^2 + (red P Œ±_int) + 38) * (7 : kP P)‚Åª¬π) := by
    constructor <;> intro h;
    ¬∑ -- By artin_property, (red P Œ±_int)^N = red P (œÉ_int (uN hN) Œ±_int).
      have h1 : (red P Œ±_int) ^ N = red P (œÉ_int (uN hN) Œ±_int) := by
        rw [ ‚Üê artin_property ];
      -- By sigma_alpha_eq_beta_or_gamma, œÉ_int (uN hN) Œ±_int = Œ≤_int.
      have h2 : œÉ_int (uN hN) Œ±_int = Œ≤_int := by
        exact sigma_alpha_eq_beta_or_gamma ( uN hN ) |>.1 h;
      field_simp;
      rw [ h1, h2, eq_div_iff ] <;> norm_num;
      ¬∑ -- By cyclic_relations_int, we have 7 * Œ≤_int = 3 * Œ±_int^2 - 8 * Œ±_int - 38.
        have h3 : 7 * Œ≤_int = 3 * Œ±_int^2 - 8 * Œ±_int - 38 := by
          exact cyclic_relations_int.1;
        convert congr_arg ( red P ) h3 using 1 <;> norm_num ; ring;
        ¬∑ exact?;
        ¬∑ erw [ map_ofNat, map_ofNat, map_ofNat ] ; ring;
      ¬∑ erw [ CharP.cast_eq_zero_iff ( kP P ) N ];
        exact fun h => hN7 <| by have := Nat.le_of_dvd ( by decide ) h; interval_cases N <;> trivial;
    ¬∑ have h_frob_gamma : (red P Œ±_int) ^ N = red P Œ≥_int := by
        have h_frob_gamma : (red P Œ±_int) ^ N = red P (œÉ_int (uN hN) Œ±_int) := by
          rw [ ‚Üê artin_property ];
        convert h_frob_gamma using 1 ; erw [ sigma_alpha_eq_beta_or_gamma _ |>.2 h ] ;
      have h_cyclic_gamma : 7 * red P Œ≥_int = -3 * (red P Œ±_int) ^ 2 + (red P Œ±_int) + 38 := by
        have h_cyclic_gamma : 7 * Œ≥_int = -3 * Œ±_int ^ 2 + Œ±_int + 38 := by
          exact cyclic_relations_int.2;
        convert congr_arg ( red P ) h_cyclic_gamma using 1
      have h_inv_gamma : 7‚Åª¬π * (7 * red P Œ≥_int) = red P Œ≥_int := by
        rw [ ‚Üê mul_assoc, inv_mul_cancel‚ÇÄ, one_mul ];
        intro h; have := CharP.cast_eq_zero_iff ( kP P ) N 7; simp_all +decide ;
        have := Nat.le_of_dvd ( by decide ) this; interval_cases N <;> trivial;
      rw [h_frob_gamma, ‚Üê h_inv_gamma]
      field_simp [h_cyclic_gamma];
      exact congrArg‚ÇÇ _ ( by linear_combination' h_cyclic_gamma ) rfl

def q_val : ‚Ñï := 19
def a_val : ‚Ñï := 7
def s1_val : ZMod 19 := (- (a_val : ZMod 19) - 3) / 6
def s2_val : ZMod 19 := ((a_val : ZMod 19) - 3) / 6
def c_val (N : ‚Ñï) : ZMod 19 := (N : ZMod 19) ^ ((q_val - 1) / 3)

/-
The polynomial f = x^3 - 19x - 19.
-/
def f_poly : Polynomial L := X^3 - 19*X - 19

/-
alpha is a root of f = x^3 - 19x - 19.
-/
theorem alpha_root : (f_poly).eval Œ± = 0 := by
  unfold f_poly;
  unfold Œ±;
  unfold Œ∑‚ÇÇ Œ∑‚ÇÅ;
  -- By definition of $Œ∂$, we know that $Œ∂^19 = 1$ and $Œ∂^k ‚â† 1$ for $1 ‚â§ k < 19$.
  have hŒ∂ : Œ∂ ^ 19 = 1 ‚àß ‚àÄ k : ‚Ñï, 1 ‚â§ k ‚Üí k < 19 ‚Üí Œ∂ ^ k ‚â† 1 := by
    exact ‚ü® hŒ∂.pow_eq_one, fun k hk‚ÇÅ hk‚ÇÇ hk‚ÇÉ => by have := hŒ∂.pow_eq_one_iff_dvd k; interval_cases k <;> simp_all +decide ‚ü©;
  ring_nf at *;
  simp_all +decide [ pow_succ' ];
  grind +ring

/-
alpha + beta + gamma = 0.
-/
theorem sum_zero : Œ± + Œ≤ + Œ≥ = 0 := by
  unfold Œ± Œ≤ Œ≥
  ring

/-
2a beta = 6 alpha^2 - (a+9)alpha - 4q with a=7, q=19.
-/
theorem beta_relation : 2 * 7 * Œ≤ = 6 * Œ±^2 - (7 + 9) * Œ± - 4 * 19 := by
  -- By multiplying both sides of the equation $7 \beta = 3 \alpha^2 - 8 \alpha - 38$ by 2, we get the desired result.
  have h_mul : 2 * 7 * Œ≤ = 2 * (3 * Œ±^2 - 8 * Œ± - 38) := by
    convert congr_arg ( fun x : L => 2 * x ) ( cyclic_relations.left ) using 1 ; ring;
  convert h_mul using 1 ; ring

/-
s1_val is 11 and s2_val is 7 in ZMod 19.
-/
lemma s1_val_eq : s1_val = 11 := by
  native_decide +revert
lemma s2_val_eq : s2_val = 7 := by
  native_decide +revert

/-
N is in S1 iff c_val N = s2_val.
-/
lemma N_in_S1_iff_c_eq_s2 (hN : N ‚â† 19) : (uN hN : ZMod 19) ‚àà S1 ‚Üî c_val N = s2_val := by
  -- By definition of $c_val$, we know that $c_val N = (N : ZMod 19)^6$.
  have hc_val : c_val N = (N : ZMod 19)^6 := by
    exact?;
  simp +decide [ hc_val, s2_val_eq ];
  unfold uN; simp +decide [ S1 ] ;
  grind

/-
N is in S2 iff c_val N = s1_val.
-/
lemma N_in_S2_iff_c_eq_s1 (hN : N ‚â† 19) : (uN hN : ZMod 19) ‚àà S2 ‚Üî c_val N = s1_val := by
  unfold uN S2 c_val s1_val;
  simp +decide [ q_val, a_val ] ; norm_num [ ZMod.natCast_eq_zero_iff ];
  grind

/-
If c = s1, then alpha^N = gamma. If c = s2, then alpha^N = beta.
-/
theorem final_result {N : ‚Ñï} [Fact (Nat.Prime N)] (hN : N ‚â† 19) (P : Ideal ùìûL) [P.IsMaximal] [CharP (kP P) N] (hN7 : N ‚â† 7) :
  (c_val N = s1_val ‚Üí (red P Œ±_int) ^ N = red P Œ≥_int) ‚àß
  (c_val N = s2_val ‚Üí (red P Œ±_int) ^ N = red P Œ≤_int) := by
    constructor <;> intro h;
    ¬∑ have h_sigma_gamma : œÉ_int (uN hN) Œ±_int = Œ≥_int := by
        apply (sigma_alpha_eq_beta_or_gamma (uN hN)).right;
        convert N_in_S2_iff_c_eq_s1 hN |>.2 h using 1;
      rw [ ‚Üê h_sigma_gamma, artin_property ];
    ¬∑ -- By N_in_S1_iff_c_eq_s2, uN hN is in S1.
      have h_S1 : (uN hN : ZMod 19) ‚àà S1 := by
        convert N_in_S1_iff_c_eq_s2 hN |>.2 h using 1;
      rw [ ‚Üê artin_property ];
      rw [ sigma_alpha_eq_beta_or_gamma _ |>.1 h_S1 ];
      assumption

/-
If c = s1, then alpha^N = gamma. If c = s2, then alpha^N = beta.
-/
theorem final_result_proof {N : ‚Ñï} [Fact (Nat.Prime N)] (hN : N ‚â† 19) (P : Ideal ùìûL) [P.IsMaximal] [CharP (kP P) N] (hN7 : N ‚â† 7) :
  (c_val N = s1_val ‚Üí (red P Œ±_int) ^ N = red P Œ≥_int) ‚àß
  (c_val N = s2_val ‚Üí (red P Œ±_int) ^ N = red P Œ≤_int) := by
    convert final_result hN P hN7 using 1

/-
Definitions of constants q=97, a=19, s1, s2, and c for the new problem instance.
-/
def q' : ‚Ñï := 97
def a' : ‚Ñï := 19
def s1' : ZMod 97 := (- (a' : ZMod 97) - 3) * (6 : ZMod 97)‚Åª¬π
def s2' : ZMod 97 := ((a' : ZMod 97) - 3) * (6 : ZMod 97)‚Åª¬π
def c' (N : ‚Ñï) : ZMod 97 := (N : ZMod 97) ^ ((q' - 1) / 3)

/-
Define the cyclotomic field L97 and the primitive root of unity zeta97.
-/
open Polynomial NumberField

def L97 : Type := CyclotomicField 97 ‚Ñö

instance : Field L97 := CyclotomicField.instField 97 ‚Ñö
instance : NumberField L97 := CyclotomicField.instNumberField 97 ‚Ñö
instance : IsCyclotomicExtension {97} ‚Ñö L97 := CyclotomicField.isCyclotomicExtension 97 ‚Ñö

def Œ∂97 : L97 := IsCyclotomicExtension.zeta 97 ‚Ñö L97

instance : Fact (Nat.Prime 97) := ‚ü®by norm_num‚ü©

/-
Define the sets of indices and the Gaussian periods for q=97. Define alpha, beta, gamma.
-/
def S_cubic_res : Finset (ZMod 97) := {x | x ‚â† 0 ‚àß x ^ 32 = 1}
def S_s1 : Finset (ZMod 97) := {x | x ‚â† 0 ‚àß x ^ 32 = s1'}
def S_s2 : Finset (ZMod 97) := {x | x ‚â† 0 ‚àß x ^ 32 = s2'}

def Œ∑‚ÇÄ' : L97 := ‚àë x ‚àà S_cubic_res, Œ∂97 ^ (x.val : ‚Ñï)
def Œ∑‚ÇÅ' : L97 := ‚àë x ‚àà S_s2, Œ∂97 ^ (x.val : ‚Ñï)
def Œ∑‚ÇÇ' : L97 := ‚àë x ‚àà S_s1, Œ∂97 ^ (x.val : ‚Ñï)

def Œ±' : L97 := -(Œ∑‚ÇÇ' - Œ∑‚ÇÅ')
def Œ≤' : L97 := -(Œ∑‚ÇÄ' - Œ∑‚ÇÇ')
def Œ≥' : L97 := -(Œ∑‚ÇÅ' - Œ∑‚ÇÄ')

/-
The sum of alpha, beta, and gamma is zero.
-/
theorem sum_zero' : Œ±' + Œ≤' + Œ≥' = 0 := by
  unfold Œ±' Œ≤' Œ≥' ;
  ring

/-
Definitions of index function, cyclotomic numbers, and period function for q=97.
-/
def ind (x : ZMod 97) : ZMod 3 :=
  if x ‚àà S_cubic_res then 0
  else if x ‚àà S_s1 then 1
  else 2

def cyc_num (i j : ZMod 3) : ‚Ñï :=
  Fintype.card { x : ZMod 97 // x ‚â† 0 ‚àß x ‚â† 1 ‚àß ind x = i ‚àß ind (1 - x) = j }

def period (i : ZMod 3) : L97 :=
  if i = 0 then Œ∑‚ÇÄ'
  else if i = 1 then Œ∑‚ÇÇ'
  else Œ∑‚ÇÅ'

/-
The period function maps 0, 1, 2 to eta0', eta2', eta1' respectively.
-/
lemma period_eq_def : period 0 = Œ∑‚ÇÄ' ‚àß period 1 = Œ∑‚ÇÇ' ‚àß period 2 = Œ∑‚ÇÅ' := by
  aesop

/-
The index function correctly identifies which coset an element belongs to.
-/
lemma ind_spec (x : ZMod 97) (hx : x ‚â† 0) :
  (ind x = 0 ‚Üî x ‚àà S_cubic_res) ‚àß
  (ind x = 1 ‚Üî x ‚àà S_s1) ‚àß
  (ind x = 2 ‚Üî x ‚àà S_s2) := by
    native_decide +revert

/-
Compute the cyclotomic numbers for q=97.
-/
#eval (cyc_num 0 0, cyc_num 0 1, cyc_num 0 2)
#eval (cyc_num 1 0, cyc_num 1 1, cyc_num 1 2)
#eval (cyc_num 2 0, cyc_num 2 1, cyc_num 2 2)

/-
Values of the cyclotomic numbers for q=97.
-/
lemma cyc_num_vals :
  cyc_num 0 0 = 12 ‚àß cyc_num 0 1 = 10 ‚àß cyc_num 0 2 = 9 ‚àß
  cyc_num 1 0 = 10 ‚àß cyc_num 1 1 = 9 ‚àß cyc_num 1 2 = 13 ‚àß
  cyc_num 2 0 = 9 ‚àß cyc_num 2 1 = 13 ‚àß cyc_num 2 2 = 10 := by
  native_decide

/-
Number of solutions to x + y = u with ind x = i and ind y = j.
-/
def N_sol (i j : ZMod 3) (u : ZMod 97) : ‚Ñï :=
  Fintype.card { p : ZMod 97 √ó ZMod 97 // p.1 ‚â† 0 ‚àß p.2 ‚â† 0 ‚àß ind p.1 = i ‚àß ind p.2 = j ‚àß p.1 + p.2 = u }

/-
The index of -1 is 0.
-/
lemma ind_neg_one : ind (-1) = 0 := by
  native_decide

/-
The index function is a homomorphism from the multiplicative group to the additive group Z/3Z.
-/
lemma ind_mul (x y : ZMod 97) (hx : x ‚â† 0) (hy : y ‚â† 0) : ind (x * y) = ind x + ind y := by
  revert x y
  native_decide

/-
The index of the inverse is the negative of the index.
-/
lemma ind_inv (x : ZMod 97) (hx : x ‚â† 0) : ind (x‚Åª¬π) = - ind x := by
  revert x
  native_decide

/-
The number of solutions to x+y=u depends only on the index of u.
-/
lemma N_sol_eq_cyc_num (i j : ZMod 3) (u : ZMod 97) (hu : u ‚â† 0) :
  N_sol i j u = cyc_num (i - ind u) (j - ind u) := by
    refine' Fintype.card_congr _;
    refine' Equiv.ofBijective ( fun x => ‚ü® x.val.1 / u, _, _, _, _ ‚ü© ) ‚ü® _, _ ‚ü©;
    all_goals simp_all +decide [ div_eq_iff, Function.Injective, Function.Surjective ];
    grind;
    ¬∑ grind;
    ¬∑ have := ind_mul ( x.val.1 / u ) u; simp_all +decide [ div_eq_mul_inv ] ;
      grind;
    ¬∑ have h_ind : ind (x.val.2 / u) = ind x.val.2 - ind u := by
        have h_ind : ind (x.val.2 / u) = ind x.val.2 + ind (u‚Åª¬π) := by
          apply ind_mul; exact (by
          exact x.2.2.1); exact (by
          haveI := Fact.mk ( by decide : Nat.Prime 97 ) ; exact inv_ne_zero hu;);
        rw [ h_ind, ind_inv u hu ] ; ring;
      grind;
    ¬∑ aesop;
    ¬∑ native_decide +revert

/-
The cardinalities of the sets S_cubic_res, S_s1, and S_s2 are all 32.
-/
lemma card_S : S_cubic_res.card = 32 ‚àß S_s1.card = 32 ‚àß S_s2.card = 32 := by
  native_decide

/-
Define C_coset to avoid ambiguity and relate it to the period definitions.
-/
def C_coset (i : ZMod 3) : Finset (ZMod 97) := Finset.univ.filter (fun x => x ‚â† 0 ‚àß ind x = i)

lemma C_coset_eq : C_coset 0 = S_cubic_res ‚àß C_coset 1 = S_s1 ‚àß C_coset 2 = S_s2 := by
  native_decide +revert

lemma period_eq_sum_C_coset (i : ZMod 3) : period i = ‚àë x ‚àà C_coset i, Œ∂97 ^ (x.val : ‚Ñï) := by
  rw [ show C_coset i = if i = 0 then S_cubic_res else if i = 1 then S_s1 else S_s2 from ?_ ];
  ¬∑ unfold period; aesop;
  ¬∑ native_decide +revert

/-
Expansion of the product of Gaussian periods in terms of solution counts.
-/
lemma period_mul_eq_sum_N_sol (i j : ZMod 3) :
  period i * period j = (if i = j then 32 else 0) +
  ‚àë u ‚àà Finset.univ.filter (fun x : ZMod 97 => x ‚â† 0), (N_sol i j u : L97) * Œ∂97 ^ (u.val : ‚Ñï) := by
    have h_expand : period i * period j = ‚àë u ‚àà Finset.univ, (if u = 0 then (if i = j then 32 else 0) else (N_sol i j u : L97)) * Œ∂97 ^ u.val := by
      have h_expand : period i * period j = ‚àë x ‚àà C_coset i, ‚àë y ‚àà C_coset j, Œ∂97 ^ (x.val + y.val : ‚Ñï) := by
        rw [ period_eq_sum_C_coset i, period_eq_sum_C_coset j, Finset.sum_mul ];
        simp +decide only [Finset.mul_sum _ _ _, pow_add];
      have h_group : ‚àÄ u : ZMod 97, ‚àë x ‚àà C_coset i, ‚àë y ‚àà C_coset j, (if x + y = u then 1 else 0) * Œ∂97 ^ u.val = (if u = 0 then (if i = j then 32 else 0) else (N_sol i j u : L97)) * Œ∂97 ^ u.val := by
        intro u
        have h_group : ‚àë x ‚àà C_coset i, ‚àë y ‚àà C_coset j, (if x + y = u then 1 else 0) = (if u = 0 then (if i = j then 32 else 0) else (N_sol i j u : ‚Ñï)) := by
          split_ifs <;> simp_all +decide [ N_sol ];
          ¬∑ fin_cases j <;> native_decide;
          ¬∑ intro x hx y hy; contrapose! hy; simp_all +decide [ C_coset ] ;
            intro hy' hy''; have := ind_mul x ( -1 ) ; simp_all +decide [ add_eq_zero_iff_eq_neg ] ;
          ¬∑ rw [ Fintype.card_subtype ];
            rw [ ‚Üê Finset.card_biUnion ];
            ¬∑ refine' Finset.card_bij ( fun x hx => ( u - x, x ) ) _ _ _ <;> simp +decide [ Finset.mem_biUnion, Finset.mem_filter ];
              ¬∑ unfold C_coset at *; aesop;
              ¬∑ unfold C_coset; aesop;
            ¬∑ exact fun x hx y hy hxy => Finset.disjoint_left.mpr fun z hz‚ÇÅ hz‚ÇÇ => hxy <| by aesop;
        convert congr_arg ( ¬∑ * Œ∂97 ^ u.val ) ( show ( ‚àë x ‚àà C_coset i, ‚àë y ‚àà C_coset j, if x + y = u then 1 else 0 : L97 ) = if u = 0 then if i = j then 32 else 0 else N_sol i j u from ?_ ) using 1;
        ¬∑ simp +decide only [Finset.sum_mul _ _ _];
        ¬∑ split_ifs <;> norm_num;
        ¬∑ convert congr_arg ( fun x : ‚Ñï => x : ‚Ñï ‚Üí L97 ) h_group using 1;
          norm_num [ Finset.sum_ite ];
      rw [ ‚Üê Finset.sum_congr rfl fun u hu => h_group u ];
      rw [ h_expand, Finset.sum_comm ];
      rw [ Finset.sum_comm, Finset.sum_congr rfl ];
      rw [ Finset.sum_comm ];
      intro x hx; rw [ Finset.sum_comm ] ; simp +decide [ Finset.sum_ite ] ;
      refine' Finset.sum_congr rfl fun y hy => _;
      have h_exp : Œ∂97 ^ 97 = 1 := by
        exact IsCyclotomicExtension.zeta_pow ( 97 : ‚Ñï ) ‚Ñö L97;
      rw [ ‚Üê Nat.mod_add_div ( x.val + y.val ) 97, pow_add, pow_mul ] ; aesop;
    rw [ h_expand, Finset.sum_eq_add_sum_diff_singleton ( Finset.mem_univ 0 ) ] ; aesop

/-
Multiplication rule for Gaussian periods.
-/
lemma period_mul (i j : ZMod 3) :
  period i * period j = (if i = j then 32 else 0) +
  (cyc_num (i - 0) (j - 0) * period 0 +
   cyc_num (i - 1) (j - 1) * period 1 +
   cyc_num (i - 2) (j - 2) * period 2) := by
     -- Apply Lemma `period_mul_eq_sum_N_sol` to expand the product.
     have h_expand : period i * period j = (if i = j then 32 else 0) +
       ‚àë u ‚àà (Finset.univ.filter (fun x : ZMod 97 => x ‚â† 0)), (cyc_num (i - ind u) (j - ind u) : L97) * Œ∂97 ^ (u.val : ‚Ñï) := by
         rw [ period_mul_eq_sum_N_sol ];
         exact congrArg _ ( Finset.sum_congr rfl fun u hu => by rw [ N_sol_eq_cyc_num i j u ( by simpa using hu ) ] );
     -- Partition the sum over `u != 0` based on `ind u = k` for `k \in {0, 1, 2}`.
     have h_partition : ‚àë u ‚àà (Finset.univ.filter (fun x : ZMod 97 => x ‚â† 0)), (cyc_num (i - ind u) (j - ind u) : L97) * Œ∂97 ^ (u.val : ‚Ñï) =
       ‚àë k ‚àà Finset.univ, (cyc_num (i - k) (j - k) : L97) * ‚àë u ‚àà (Finset.univ.filter (fun x : ZMod 97 => x ‚â† 0 ‚àß ind x = k)), Œ∂97 ^ (u.val : ‚Ñï) := by
         simp +decide only [Finset.sum_filter, Finset.mul_sum _ _ _];
         rw [ Finset.sum_comm, Finset.sum_congr rfl ] ; aesop;
     -- By definition of $C_koset$, we know that $\sum_{u \in C_koset k} \zeta_97^u = \text{period } k$.
     have h_period : ‚àÄ k : ZMod 3, ‚àë u ‚àà (Finset.univ.filter (fun x : ZMod 97 => x ‚â† 0 ‚àß ind x = k)), Œ∂97 ^ (u.val : ‚Ñï) = period k := by
       intro k
       simp [period_eq_sum_C_coset, C_coset];
     simp_all +decide [ Fin.sum_univ_three ];
     erw [ Fin.sum_univ_three ] ; ring!;

/-
alpha' is a root of X^3 - 97X - 97.
-/
theorem alpha_root' : Œ±'^3 - 97*Œ±' - 97 = 0 := by
  unfold Œ±';
  -- By definition of $Œ∑‚ÇÄ'$, $Œ∑‚ÇÅ'$, and $Œ∑‚ÇÇ'$, we know that $Œ∑‚ÇÄ' + Œ∑‚ÇÅ' + Œ∑‚ÇÇ' = -1$.
  have h_sum : Œ∑‚ÇÄ' + Œ∑‚ÇÅ' + Œ∑‚ÇÇ' = -1 := by
    -- The sum of all non-trivial roots of unity in the cyclotomic field is -1.
    have h_sum_roots : ‚àë x ‚àà Finset.univ.filter (fun x : ZMod 97 => x ‚â† 0), Œ∂97 ^ (x.val : ‚Ñï) = -1 := by
      have h_sum : ‚àë x : ZMod 97, (Œ∂97 : L97) ^ (x.val : ‚Ñï) = 0 := by
        have h_geom_sum : ‚àë x ‚àà Finset.range 97, (Œ∂97 : L97) ^ x = 0 := by
          rw [ geom_sum_eq ] <;> norm_num [ IsPrimitiveRoot.ne_one ];
          ¬∑ exact Or.inl ( sub_eq_zero_of_eq <| by exact IsPrimitiveRoot.pow_eq_one <| IsCyclotomicExtension.zeta_spec 97 ‚Ñö L97 );
          ¬∑ have h_order : IsPrimitiveRoot Œ∂97 97 := by
              convert IsCyclotomicExtension.zeta_spec 97 ‚Ñö L97 using 1
              skip
            generalize_proofs at *; exact h_order.ne_one (by norm_num);
        convert h_geom_sum using 1;
      rw [ Finset.sum_eq_add_sum_diff_singleton ( Finset.mem_univ 0 ) ] at h_sum;
      simpa [ Finset.filter_ne' ] using eq_neg_of_add_eq_zero_right h_sum;
    rw [ ‚Üê h_sum_roots, show Œ∑‚ÇÄ' + Œ∑‚ÇÅ' + Œ∑‚ÇÇ' = ‚àë x ‚àà Finset.univ.filter ( fun x : ZMod 97 => x ‚â† 0 ), Œ∂97 ^ x.val from ?_ ];
    rw [ show ( Finset.univ.filter fun x : ZMod 97 => x ‚â† 0 ) = S_cubic_res ‚à™ S_s1 ‚à™ S_s2 from by native_decide, Finset.sum_union, Finset.sum_union ];
    ¬∑ exact?;
    ¬∑ native_decide +revert;
    ¬∑ native_decide +revert;
  have := @period_mul 0 0; ( have := @period_mul 0 1; ( have := @period_mul 0 2; ( have := @period_mul 1 1; ( have := @period_mul 1 2; ( have := @period_mul 2 2; norm_num [ Finset.sum_add_distrib, pow_succ' ] at *; ) ) ) ) );
  simp_all +decide [ period_eq_def ];
  erw [ cyc_num_vals.1, cyc_num_vals.2.1, cyc_num_vals.2.2.1, cyc_num_vals.2.2.2.1, cyc_num_vals.2.2.2.2.1, cyc_num_vals.2.2.2.2.2.1, cyc_num_vals.2.2.2.2.2.2.1, cyc_num_vals.2.2.2.2.2.2.2.1, cyc_num_vals.2.2.2.2.2.2.2.2 ] at * ; norm_num at *;
  grind +ring

/-
Algebraic relation between beta' and alpha'.
-/
theorem beta_relation' : 2 * 19 * Œ≤' = 6 * Œ±'^2 - (19 + 9) * Œ±' - 4 * 97 := by
  unfold Œ≤' Œ±';
  rw [ show Œ∑‚ÇÄ' = period 0 from rfl, show Œ∑‚ÇÅ' = period 2 from rfl, show Œ∑‚ÇÇ' = period 1 from rfl ];
  -- By definition of $period$, we know that $period 0 + period 1 + period 2 = -1$.
  have h_sum : period 0 + period 1 + period 2 = -1 := by
    -- By definition of $period$, we know that $period 0 + period 1 + period 2 = \sum_{x \in \mathbb{Z}/97\mathbb{Z}} \zeta_{97}^x$.
    have h_sum : period 0 + period 1 + period 2 = ‚àë x ‚àà Finset.univ.filter (fun x : ZMod 97 => x ‚â† 0), Œ∂97 ^ (x.val : ‚Ñï) := by
      rw [ period_eq_sum_C_coset, period_eq_sum_C_coset, period_eq_sum_C_coset ];
      rw [ ‚Üê Finset.sum_union, ‚Üê Finset.sum_union ];
      ¬∑ rw [ show C_coset 0 ‚à™ C_coset 1 ‚à™ C_coset 2 = Finset.univ.filter ( fun x : ZMod 97 => x ‚â† 0 ) from ?_ ];
        native_decide +revert;
      ¬∑ native_decide +revert;
      ¬∑ simp +decide [ C_coset, Finset.disjoint_left ];
        grind;
    -- The sum of all powers of $\zeta_{97}$ is zero.
    have h_sum_zero : ‚àë x ‚àà Finset.range 97, Œ∂97 ^ x = 0 := by
      rw [ geom_sum_eq ] <;> norm_num [ hŒ∂ ];
      ¬∑ exact Or.inl ( sub_eq_zero_of_eq <| by exact ( show Œ∂97 ^ 97 = 1 from by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact by rw [ show Œ∂97 = IsCyclotomicExtension.zeta 97 ‚Ñö L97 from rfl ] ; exact? ) ) ) ) ) ) ) ) ) ) ) ) ) );
      ¬∑ have := IsCyclotomicExtension.zeta_spec 97 ‚Ñö L97;
        exact this.ne_one ( by decide );
    rw [ Finset.sum_eq_sum_diff_singleton_add ( Finset.mem_range.mpr ( show 0 < 97 by decide ) ) ] at h_sum_zero;
    convert eq_neg_of_add_eq_zero_left h_sum_zero using 1;
    norm_num;
  -- Substitute the known values of the cyclotomic numbers into the equation.
  have h_cyclotomic : cyc_num 0 0 = 12 ‚àß cyc_num 0 1 = 10 ‚àß cyc_num 0 2 = 9 ‚àß cyc_num 1 0 = 10 ‚àß cyc_num 1 1 = 9 ‚àß cyc_num 1 2 = 13 ‚àß cyc_num 2 0 = 9 ‚àß cyc_num 2 1 = 13 ‚àß cyc_num 2 2 = 10 := by
    exact?;
  rw [ show period 0 = -1 - period 1 - period 2 by linear_combination' h_sum ] ; ring;
  rw [ show period 1 ^ 2 = period 1 * period 1 by ring, show period 2 ^ 2 = period 2 * period 2 by ring ] ; rw [ period_mul 1 1, period_mul 2 2, period_mul 1 2 ] ; simp +decide [ h_cyclotomic ] ; ring;
  rw [ show cyc_num ( -1 ) 0 = 9 by exact h_cyclotomic.2.2.2.2.2.2.1, show cyc_num ( -1 ) ( -1 ) = 10 by exact h_cyclotomic.2.2.2.2.2.2.2.2 ] ; norm_num ; ring;
  rw [ show cyc_num 0 1 = 10 by exact h_cyclotomic.2.1, show cyc_num 1 1 = 9 by exact h_cyclotomic.2.2.2.2.1 ] ; ring ; rw [ show period 0 = -1 - period 1 - period 2 by linear_combination' h_sum ] ; ring

/-
Define the Galois unit and automorphism for q=97.
-/
def gal_unit97 (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 97) : (ZMod 97)À£ := Units.mk0 (N : ZMod 97) (by
  rw [Ne, ZMod.natCast_zmod_eq_zero_iff_dvd]
  intro h
  have hN_prime : Nat.Prime N := Fact.out
  have : 97 = 1 ‚à® 97 = N := (Nat.dvd_prime hN_prime).mp h
  have : 97 = N := this.resolve_left (by norm_num)
  exact hN this.symm)

def sigma97 (u : (ZMod 97)À£) : L97 ‚âÉ‚Çê[‚Ñö] L97 :=
  (IsCyclotomicExtension.autEquivPow L97 (Polynomial.cyclotomic.irreducible_rat (n := 97) (by norm_num))).symm u

/-
The Frobenius automorphism permutes the Gaussian periods by shifting their index by ind(N).
-/
lemma sigma_period (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 97) (i : ZMod 3) :
  sigma97 (gal_unit97 N hN) (period i) = period (i + ind (N : ZMod 97)) := by
    -- By definition of $C_coset$, we know that $C_coset i$ is the set of elements $x$ such that $ind x = i$.
    have hC_coset : ‚àÄ i : ZMod 3, C_coset i = {x : ZMod 97 | x ‚â† 0 ‚àß ind x = i} := by
      unfold C_coset; aesop;
    -- By definition of $sigma97$, we know that it maps $Œ∂97^x$ to $Œ∂97^{Nx}$ for any $x \in \mathbb{Z}/97\mathbb{Z}$.
    have h_sigma_map : ‚àÄ x : ZMod 97, (sigma97 (gal_unit97 N hN)) (Œ∂97 ^ x.val) = Œ∂97 ^ ((N * x).val) := by
      intro x
      have h_sigma_map : (sigma97 (gal_unit97 N hN)) (Œ∂97 ^ x.val) = (sigma97 (gal_unit97 N hN)) (Œ∂97) ^ x.val := by
        exact map_pow _ _ _;
      have h_sigma_map : (sigma97 (gal_unit97 N hN)) Œ∂97 = Œ∂97 ^ (N : ZMod 97).val := by
        unfold sigma97;
        simp +decide [ gal_unit97 ];
        erw [ PowerBasis.equivOfMinpoly_gen ];
        exact?;
      cases N <;> simp_all +decide [ pow_mul ];
      norm_num [ ‚Üê pow_mul, ZMod.val_add, ZMod.val_mul ];
      rw [ ‚Üê Nat.mod_add_div ( ( _ + ZMod.val 1 ) % 97 * x.val ) 97 ] ; norm_num [ pow_add, pow_mul, Nat.mul_mod, Nat.pow_mod ] ;
      have h_zeta_pow : Œ∂97 ^ 97 = 1 := by
        exact IsPrimitiveRoot.pow_eq_one ( IsCyclotomicExtension.zeta_spec 97 ‚Ñö L97 );
      aesop;
    -- By definition of $C_coset$, we know that $C_coset (i + ind N)$ is the set of elements $y$ such that $ind y = i + ind N$.
    have hC_coset_shift : C_coset (i + ind N) = Finset.image (fun x => (N * x : ZMod 97)) (C_coset i) := by
      ext x; simp [hC_coset];
      constructor;
      ¬∑ intro hx
        obtain ‚ü®a, ha‚ü© : ‚àÉ a : ZMod 97, (N * a : ZMod 97) = x := by
          have h_inv : ‚àÉ a : ZMod 97, (N : ZMod 97) * a = 1 := by
            have h_inv : Nat.gcd N 97 = 1 := by
              exact Nat.Coprime.symm ( Nat.Prime.coprime_iff_not_dvd ( by decide ) |>.2 fun h => hN <| by have := Nat.prime_dvd_prime_iff_eq ( by decide : Nat.Prime 97 ) ( Fact.out : Nat.Prime N ) ; tauto );
            have := Nat.exists_mul_emod_eq_one_of_coprime h_inv;
            exact Exists.elim ( this ( by decide ) ) fun m hm => ‚ü® m, by simpa [ ‚Üê ZMod.natCast_eq_zero_iff ] using congr_arg ( fun x : ‚Ñï => x : ‚Ñï ‚Üí ZMod 97 ) hm ‚ü©;
          exact ‚ü® h_inv.choose * x, by linear_combination' h_inv.choose_spec * x ‚ü©;
        use a; simp_all +decide [ Set.ext_iff ] ;
        have h_ind_mul : ind (N * a) = ind N + ind a := by
          have h_ind_mul : ‚àÄ x y : ZMod 97, x ‚â† 0 ‚Üí y ‚â† 0 ‚Üí ind (x * y) = ind x + ind y := by
            exact?;
          apply h_ind_mul; exact (by
          intro h; simp_all +decide [ ZMod.natCast_eq_zero_iff ] ;); exact (by
          grind);
        grind +ring;
      ¬∑ rintro ‚ü® a, ha, rfl ‚ü©;
        have h_ind_mul : ind (N * a) = ind N + ind a := by
          apply ind_mul;
          ¬∑ intro h; have := Fact.out ( p := Nat.Prime N ) ; simp_all +decide [ ZMod.natCast_eq_zero_iff ] ;
            rw [ this.dvd_iff_eq ] at h <;> aesop;
          ¬∑ exact hC_coset i |>.subset ha |>.1;
        simp_all +decide [ add_comm, C_coset ];
        exact?;
    -- By definition of $period$, we know that $period i$ is the sum of $Œ∂97^x$ over $x \in C_coset i$.
    have hperiod_def : ‚àÄ i : ZMod 3, period i = ‚àë x ‚àà C_coset i, Œ∂97 ^ x.val := by
      exact?;
    rw [ hperiod_def, hperiod_def, hC_coset_shift, Finset.sum_image ];
    ¬∑ rw [ map_sum, Finset.sum_congr rfl fun x hx => h_sigma_map x ];
    ¬∑ intro x hx y hy; haveI := Fact.mk ( Fact.out : Nat.Prime N ) ; simp_all +decide [ mul_eq_zero, ZMod.natCast_eq_zero_iff ] ;
      rintro ( rfl | h ) <;> simp_all +decide [ Nat.Prime.dvd_iff_eq Fact.out ]

/-
Integer versions of the periods and roots, and their coercion properties.
-/
def Œ∂97_int : ùìû L97 := IsPrimitiveRoot.toInteger (IsCyclotomicExtension.zeta_spec 97 ‚Ñö L97)

def period_int (i : ZMod 3) : ùìû L97 := ‚àë x ‚àà C_coset i, Œ∂97_int ^ (x.val : ‚Ñï)

def Œ±'_int : ùìû L97 := -(period_int 1 - period_int 2)
def Œ≤'_int : ùìû L97 := -(period_int 0 - period_int 1)
def Œ≥'_int : ùìû L97 := -(period_int 2 - period_int 0)

lemma coe_period_int (i : ZMod 3) : (period_int i : L97) = period i := by
  unfold period_int period;
  unfold Œ∂97_int Œ∑‚ÇÄ' Œ∑‚ÇÅ' Œ∑‚ÇÇ';
  split_ifs <;> simp +decide [ *, Subtype.ext_iff ];
  ¬∑ congr! 1;
    exact C_coset_eq.1;
  ¬∑ congr! 2;
    exact C_coset_eq.2.1;
  ¬∑ congr! 1;
    native_decide +revert

lemma coe_alpha'_int : (Œ±'_int : L97) = Œ±' := by
  unfold Œ±'_int Œ±';
  unfold period_int;
  unfold Œ∑‚ÇÇ' Œ∑‚ÇÅ' C_coset; simp +decide [ Finset.sum_sub_distrib ] ;
  congr! 2;
  ¬∑ native_decide +revert;
  ¬∑ native_decide +revert

lemma coe_beta'_int : (Œ≤'_int : L97) = Œ≤' := by
  unfold Œ≤'_int Œ≤';
  unfold period_int;
  simp +decide [ C_coset_eq, S_s1, S_cubic_res ];
  congr!

lemma coe_gamma'_int : (Œ≥'_int : L97) = Œ≥' := by
  unfold Œ≥'_int Œ≥';
  unfold period_int;
  simp +decide [ C_coset_eq ];
  congr! 2

/-
Relate the index of N to the value of c' N being s1'.
-/
lemma ind_N_eq_1_iff_c_eq_s1 (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 97) :
  ind (N : ZMod 97) = 1 ‚Üî c' N = s1' := by
    unfold ind c' s1';
    unfold S_cubic_res S_s1; simp +decide;
    unfold q' a' s1'; simp +decide ;
    split_ifs <;> simp_all +decide [ ZMod.natCast_eq_zero_iff ];
    ¬∑ native_decide +revert;
    ¬∑ rename_i h‚ÇÅ h‚ÇÇ;
      contrapose! h‚ÇÇ;
      exact ‚ü® fun h => hN <| by have := Nat.prime_dvd_prime_iff_eq ( by decide : Nat.Prime 97 ) ( Fact.out : Nat.Prime N ) ; tauto, h‚ÇÇ ‚ü©

/-
Relate the index of N to the value of c' N being s2'.
-/
lemma ind_N_eq_2_iff_c_eq_s2 (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 97) :
  ind (N : ZMod 97) = 2 ‚Üî c' N = s2' := by
    -- By definition of $c'$ and $ind$, we know that $c' N = s2'$ if and only if $N^{32} = s2'$.
    have h_c'_eq_s2' : c' N = s2' ‚Üî (N : ZMod 97) ^ 32 = s2' := by
      rfl;
    cases eq_or_ne ( N : ZMod 97 ) 0 <;> simp_all +decide [ ind ];
    ¬∑ rw [ ZMod.natCast_eq_zero_iff ] at * ; exact absurd ( Nat.dvd_of_mod_eq_zero ( Nat.mod_eq_zero_of_dvd <| by assumption ) ) ( by rw [ Nat.dvd_prime Fact.out ] ; aesop );
    ¬∑ split_ifs <;> simp_all +decide [ S_cubic_res, S_s1, S_s2 ];
      ¬∑ native_decide +revert;
      ¬∑ native_decide +revert;
      ¬∑ have h_cases : ‚àÄ x : ZMod 97, x ‚â† 0 ‚Üí x ^ 32 = 1 ‚à® x ^ 32 = s1' ‚à® x ^ 32 = s2' := by
          native_decide +revert;
        cases h_cases _ ‚Äπ_‚Ä∫ <;> tauto

/-
Abbreviations for the ring of integers, residue field, and reduction map for q=97.
-/
abbrev ùìûL97 := ùìû L97
def kP97 (P : Ideal ùìûL97) [P.IsMaximal] := ùìûL97 ‚ß∏ P
noncomputable instance (P : Ideal ùìûL97) [P.IsMaximal] : Field (kP97 P) := Ideal.Quotient.field P
def red97 (P : Ideal ùìûL97) [P.IsMaximal] : ùìûL97 ‚Üí+* kP97 P := Ideal.Quotient.mk P

/-
Relate the index of N to the value of c' N being s1'.
-/
lemma ind_N_eq_1_iff_c_eq_s1_new (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 97) :
  ind (N : ZMod 97) = 1 ‚Üî c' N = s1' := by
    convert ind_N_eq_1_iff_c_eq_s1 N hN using 1

/-
Lift the automorphism sigma97 to the ring of integers.
-/
def sigma_int97 (u : (ZMod 97)À£) (x : ùìû L97) : ùìû L97 := ‚ü®sigma97 u x, by
  have h_integral : IsIntegral ‚Ñ§ (x : L97) := x.2
  exact IsIntegral.map (sigma97 u) h_integral‚ü©

/-
The ring of integers is generated by zeta97.
-/
lemma adjoin_zeta_eq_top97 : Algebra.adjoin ‚Ñ§ ({Œ∂97_int} : Set ùìûL97) = ‚ä§ := by
  let hŒ∂ := IsCyclotomicExtension.zeta_spec 97 ‚Ñö L97
  let pb := IsPrimitiveRoot.integralPowerBasis' hŒ∂
  have h_gen : pb.gen = Œ∂97_int := IsPrimitiveRoot.integralPowerBasis'_gen hŒ∂
  rw [‚Üê h_gen]
  exact pb.adjoin_gen_eq_top

/-
The automorphism sigma_N reduces to the Frobenius map modulo P.
-/
theorem artin_property97 {N : ‚Ñï} [Fact (Nat.Prime N)] (hN : N ‚â† 97) (P : Ideal ùìûL97) [P.IsMaximal] [CharP (kP97 P) N] (x : ùìûL97) :
  red97 P (sigma_int97 (gal_unit97 N hN) x) = (red97 P x) ^ N := by
    have h_sigma_int97_zeta : ‚àÄ x : ùìûL97, x ‚àà Algebra.adjoin ‚Ñ§ ({Œ∂97_int} : Set ùìûL97) ‚Üí red97 P (sigma_int97 (gal_unit97 N hN) x) = (red97 P x) ^ N := by
      refine fun x hx => Algebra.adjoin_induction ?_ ?_ ?_ ?_ hx;
      ¬∑ -- Since $\sigma_N(\zeta_{97}) = \zeta_{97}^N$, we have $\sigma_int97(\zeta_{97}) = \zeta_{97}^N$.
        have h_sigma_zeta : sigma_int97 (gal_unit97 N hN) Œ∂97_int = Œ∂97_int ^ N := by
          have h_sigma_zeta : (sigma97 (gal_unit97 N hN) Œ∂97_int : L97) = Œ∂97_int ^ N := by
            have h_sigma_zeta : ‚àÄ (u : (ZMod 97)À£), sigma97 u Œ∂97 = Œ∂97 ^ (u : ZMod 97).val := by
              intro u
              simp [sigma97];
              erw [ PowerBasis.equivOfMinpoly_gen ];
              rfl;
            convert h_sigma_zeta ( gal_unit97 N hN ) using 1;
            simp +decide [ gal_unit97 ];
            rw [ ‚Üê Nat.mod_add_div N 97 ] ; norm_num [ pow_add, pow_mul ] ;
            have h_zeta_97_pow : Œ∂97 ^ 97 = 1 := by
              exact IsPrimitiveRoot.pow_eq_one ( IsCyclotomicExtension.zeta_spec 97 ‚Ñö L97 );
            erw [ show ( Œ∂97_int : L97 ) = Œ∂97 from ?_ ] ; aesop;
            exact?;
          exact?;
        aesop;
      ¬∑ intro r; exact (by
        simp +decide [ red97, sigma_int97 ];
        erw [ Ideal.Quotient.eq ];
        -- Since $P$ is a maximal ideal, it is prime, and thus if $r^N - r$ is in $P$, then either $r$ is in $P$ or $r^{N-1} - 1$ is in $P$.
        have h_prime : ‚àÄ r : ‚Ñ§, (r ^ N - r : ùìûL97) ‚àà P := by
          intro r
          have h_fermat : (r ^ N - r : ‚Ñ§) ‚â° 0 [ZMOD N] := by
            simp +decide [ ‚Üê ZMod.intCast_eq_intCast_iff ];
          obtain ‚ü® k, hk ‚ü© := h_fermat.symm.dvd;
          -- Since $N$ is in $P$, multiplying by $k$ (which is an integer) keeps it in $P$.
          have hN_in_P : (N : ùìûL97) ‚àà P := by
            have hN_in_P : (N : kP97 P) = 0 := by
              exact?;
            exact?;
          convert P.mul_mem_right ( k : ùìûL97 ) hN_in_P using 1 ; norm_cast ; aesop;
        simpa using Submodule.neg_mem _ ( h_prime r ));
      ¬∑ intro x y hx hy hx' hy'; simp +decide [ *, pow_add ] ;
        rw [ show sigma_int97 ( gal_unit97 N hN ) ( x + y ) = sigma_int97 ( gal_unit97 N hN ) x + sigma_int97 ( gal_unit97 N hN ) y from ?_, map_add ];
        ¬∑ rw [ hx', hy', add_pow_char ];
        ¬∑ exact Subtype.ext <| map_add _ _ _;
      ¬∑ simp +contextual [ *, mul_pow ];
        intro x y hx hy hx' hy'; rw [ show sigma_int97 ( gal_unit97 N hN ) ( x * y ) = sigma_int97 ( gal_unit97 N hN ) x * sigma_int97 ( gal_unit97 N hN ) y from ?_ ] ; aesop;
        exact Subtype.ext <| map_mul _ _ _;
    exact h_sigma_int97_zeta x ( by rw [ adjoin_zeta_eq_top97 ] ; exact Algebra.mem_top ) |> fun h => by simpa using h;

/-
If c' N = s1', then sigma_N(alpha') = gamma'.
-/
lemma sigma_alpha_eq_gamma_if_s1 (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 97) (h : c' N = s1') :
  sigma_int97 (gal_unit97 N hN) Œ±'_int = Œ≥'_int := by
    -- We check the equality in the field L97.
    have h_field : sigma97 (gal_unit97 N hN) (Œ±'_int : L97) = (Œ≥'_int : L97) := by
      -- By definition of $c'$, we know that $c' N = s1'$ implies $ind (N : ZMod 97) = 1$.
      have h_ind : ind (N : ZMod 97) = 1 := by
        exact?;
      -- By definition of $sigma97$, we have $sigma97 (gal_unit97 N hN) (Œ±'_int) = sigma97 (gal_unit97 N hN) (period 2 - period 1)$.
      have h_sigma97_def : sigma97 (gal_unit97 N hN) (Œ±'_int : L97) = sigma97 (gal_unit97 N hN) (period 2 - period 1) := by
        rw [ show ( Œ±'_int : L97 ) = period 2 - period 1 from ?_ ];
        convert coe_alpha'_int using 1;
        unfold Œ±';
        exact?;
      -- By definition of $sigma97$, we have $sigma97 (gal_unit97 N hN) (period 2 - period 1) = period (2 + ind (N : ZMod 97)) - period (1 + ind (N : ZMod 97))$.
      have h_sigma97_period : sigma97 (gal_unit97 N hN) (period 2 - period 1) = period (2 + ind (N : ZMod 97)) - period (1 + ind (N : ZMod 97)) := by
        rw [ map_sub, sigma_period, sigma_period ];
      simp_all +decide [ Œ≥'_int ];
      exact congr_arg‚ÇÇ _ ( coe_period_int 0 ‚ñ∏ rfl ) ( coe_period_int 2 ‚ñ∏ rfl );
    convert h_field using 1;
    -- Since the ring of integers is a subalgebra of the field, the elements are equal in the ring if and only if they are equal in the field.
    have h_subalgebra : ‚àÄ (x y : ùìû L97), x = y ‚Üî (x : L97) = (y : L97) := by
      exact?;
    convert h_subalgebra _ _ using 1

/-
If c' N = s2', then sigma_N(alpha') = beta'.
-/
lemma sigma_alpha_eq_beta_if_s2 (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 97) (h : c' N = s2') :
  sigma_int97 (gal_unit97 N hN) Œ±'_int = Œ≤'_int := by
    -- Since $c' N = s2'$, we have $ind N = 2$.
    have h_ind : ind (N : ZMod 97) = 2 := by
      exact?;
    -- Since $\sigma_N(\alpha') = \beta'$ in $L97$, we have $\sigma_N(\alpha'_int) = \beta'_int$ in $\mathcal{O}_{L97}$.
    have h_sigma_alpha_int_eq_beta_int : (sigma97 (gal_unit97 N hN) Œ±' : L97) = Œ≤' := by
      -- Since $c' N = s2'$, we have $ind N = 2$. Therefore, $\sigma_N(\alpha') = \beta'$.
      have h_sigma_beta : (sigma97 (gal_unit97 N hN)) (period 2 - period 1) = period 1 - period 0 := by
        have := sigma_period N hN 2; have := sigma_period N hN 1; aesop;
      generalize_proofs at *; (
      unfold Œ±' Œ≤'; aesop;)
    generalize_proofs at *; (
    convert h_sigma_alpha_int_eq_beta_int using 1
    generalize_proofs at *; (
    constructor <;> intro h <;> simp_all +decide [ ‚Üê coe_alpha'_int, ‚Üê coe_beta'_int, ‚Üê coe_gamma'_int ] ;
    exact Subtype.ext h_sigma_alpha_int_eq_beta_int
    skip))

/-
Final result for q=97: Frobenius action on alpha depends on c' N.
-/
theorem final_result_97 {N : ‚Ñï} [Fact (Nat.Prime N)] (hN : N ‚â† 97) (hN19 : N ‚â† 19) (P : Ideal ùìûL97) [P.IsMaximal] [CharP (kP97 P) N] :
  (c' N = s1' ‚Üí (red97 P Œ±'_int) ^ N = red97 P Œ≥'_int) ‚àß
  (c' N = s2' ‚Üí (red97 P Œ±'_int) ^ N = red97 P Œ≤'_int) := by
  constructor
  ¬∑ intro h
    rw [‚Üê artin_property97 hN P Œ±'_int]
    rw [sigma_alpha_eq_gamma_if_s1 N hN h]
  ¬∑ intro h
    rw [‚Üê artin_property97 hN P Œ±'_int]
    rw [sigma_alpha_eq_beta_if_s2 N hN h]

/-
Definitions of constants q=313, a=35, s1, s2, and c for the new problem instance. Also define the cyclotomic field L313 and the primitive root of unity zeta313.
-/
def q'' : ‚Ñï := 313
def a'' : ‚Ñï := 35
def s1'' : ZMod 313 := (- (a'' : ZMod 313) - 3) * (6 : ZMod 313)‚Åª¬π
def s2'' : ZMod 313 := ((a'' : ZMod 313) - 3) * (6 : ZMod 313)‚Åª¬π
def c'' (N : ‚Ñï) : ZMod 313 := (N : ZMod 313) ^ ((q'' - 1) / 3)

open Polynomial NumberField

def L313 : Type := CyclotomicField 313 ‚Ñö

instance : Field L313 := CyclotomicField.instField 313 ‚Ñö
instance : NumberField L313 := CyclotomicField.instNumberField 313 ‚Ñö
instance : IsCyclotomicExtension {313} ‚Ñö L313 := CyclotomicField.isCyclotomicExtension 313 ‚Ñö

def Œ∂313 : L313 := IsCyclotomicExtension.zeta 313 ‚Ñö L313

instance : Fact (Nat.Prime 313) := ‚ü®by norm_num‚ü©

/-
Define the sets of indices and the Gaussian periods for q=313. Define alpha, beta, gamma. Prove their sum is zero.
-/
def S_cubic_res'' : Finset (ZMod 313) := {x | x ‚â† 0 ‚àß x ^ 104 = 1}
def S_s1'' : Finset (ZMod 313) := {x | x ‚â† 0 ‚àß x ^ 104 = s1''}
def S_s2'' : Finset (ZMod 313) := {x | x ‚â† 0 ‚àß x ^ 104 = s2''}

def Œ∑‚ÇÄ'' : L313 := ‚àë x ‚àà S_cubic_res'', Œ∂313 ^ (x.val : ‚Ñï)
def Œ∑‚ÇÅ'' : L313 := ‚àë x ‚àà S_s2'', Œ∂313 ^ (x.val : ‚Ñï)
def Œ∑‚ÇÇ'' : L313 := ‚àë x ‚àà S_s1'', Œ∂313 ^ (x.val : ‚Ñï)

def Œ±'' : L313 := -(Œ∑‚ÇÇ'' - Œ∑‚ÇÅ'')
def Œ≤'' : L313 := -(Œ∑‚ÇÄ'' - Œ∑‚ÇÇ'')
def Œ≥'' : L313 := -(Œ∑‚ÇÅ'' - Œ∑‚ÇÄ'')

theorem sum_zero'' : Œ±'' + Œ≤'' + Œ≥'' = 0 := by
  unfold Œ±'' Œ≤'' Œ≥'';
  ring

/-
Definitions of index function, cyclotomic numbers, and period function for q=313.
-/
def ind'' (x : ZMod 313) : ZMod 3 :=
  if x ‚àà S_cubic_res'' then 0
  else if x ‚àà S_s1'' then 1
  else 2

def cyc_num'' (i j : ZMod 3) : ‚Ñï :=
  Fintype.card { x : ZMod 313 // x ‚â† 0 ‚àß x ‚â† 1 ‚àß ind'' x = i ‚àß ind'' (1 - x) = j }

def period'' (i : ZMod 3) : L313 :=
  if i = 0 then Œ∑‚ÇÄ''
  else if i = 1 then Œ∑‚ÇÇ''
  else Œ∑‚ÇÅ''

/-
The period function maps 0, 1, 2 to eta0'', eta2'', eta1'' respectively.
-/
lemma period_eq_def'' : period'' 0 = Œ∑‚ÇÄ'' ‚àß period'' 1 = Œ∑‚ÇÇ'' ‚àß period'' 2 = Œ∑‚ÇÅ'' := by
  exact ‚ü® rfl, rfl, rfl ‚ü©

/-
The index function correctly identifies which coset an element belongs to.
-/
lemma ind_spec'' (x : ZMod 313) (hx : x ‚â† 0) :
  (ind'' x = 0 ‚Üî x ‚àà S_cubic_res'') ‚àß
  (ind'' x = 1 ‚Üî x ‚àà S_s1'') ‚àß
  (ind'' x = 2 ‚Üî x ‚àà S_s2'') := by
    native_decide +revert

/-
Define the polynomial f for q=313.
-/
def f_poly'' : Polynomial L313 := X^3 - 313*X - 313

/-
Compute the cyclotomic numbers for q=313.
-/
#eval (cyc_num'' 0 0, cyc_num'' 0 1, cyc_num'' 0 2)
#eval (cyc_num'' 1 0, cyc_num'' 1 1, cyc_num'' 1 2)
#eval (cyc_num'' 2 0, cyc_num'' 2 1, cyc_num'' 2 2)

/-
Values of the cyclotomic numbers for q=313.
-/
lemma cyc_num_vals'' :
  cyc_num'' 0 0 = 30 ‚àß cyc_num'' 0 1 = 36 ‚àß cyc_num'' 0 2 = 37 ‚àß
  cyc_num'' 1 0 = 36 ‚àß cyc_num'' 1 1 = 37 ‚àß cyc_num'' 1 2 = 31 ‚àß
  cyc_num'' 2 0 = 37 ‚àß cyc_num'' 2 1 = 31 ‚àß cyc_num'' 2 2 = 36 := by
    native_decide +revert

/-
Number of solutions to x + y = u with ind x = i and ind y = j for q=313.
-/
def N_sol'' (i j : ZMod 3) (u : ZMod 313) : ‚Ñï :=
  Fintype.card { p : ZMod 313 √ó ZMod 313 // p.1 ‚â† 0 ‚àß p.2 ‚â† 0 ‚àß ind'' p.1 = i ‚àß ind'' p.2 = j ‚àß p.1 + p.2 = u }

/-
The index of -1 is 0 for q=313.
-/
lemma ind_neg_one'' : ind'' (-1) = 0 := by
  native_decide +revert

/-
The index function is a homomorphism for q=313.
-/
lemma ind_mul'' (x y : ZMod 313) (hx : x ‚â† 0) (hy : y ‚â† 0) : ind'' (x * y) = ind'' x + ind'' y := by
  native_decide +revert

/-
The index of the inverse is the negative of the index for q=313.
-/
lemma ind_inv'' (x : ZMod 313) (hx : x ‚â† 0) : ind'' (x‚Åª¬π) = - ind'' x := by
  native_decide +revert

/-
The number of solutions to x+y=u depends only on the index of u for q=313. Hint: use the substitution x' = x/u.
-/
lemma N_sol_eq_cyc_num'' (i j : ZMod 3) (u : ZMod 313) (hu : u ‚â† 0) :
  N_sol'' i j u = cyc_num'' (i - ind'' u) (j - ind'' u) := by
    convert Set.ext_iff.mp ?_ ( u, 1 - u ) using 1;
    any_goals exact { p : ZMod 313 √ó ZMod 313 | p.1 ‚â† 0 ‚àß p.2 ‚â† 0 ‚àß ind'' p.1 = i ‚àß ind'' p.2 = j ‚àß p.1 + p.2 = u };
    ¬∑ unfold N_sol'' cyc_num''; simp +decide [ Fintype.card_subtype ] ;
      refine' Finset.card_bij ( fun x hx => x.1 / u ) _ _ _;
      ¬∑ simp +decide [ hu, div_eq_iff ];
        intro a b ha hb ha' hb' hab; rw [ show a / u = a / ( a + b ) by rw [ hab ] ] ; rw [ show 1 - a / ( a + b ) = b / ( a + b ) by
                                                                                              rw [ one_sub_div ] <;> aesop ] ;
        have h_ind_div : ‚àÄ x y : ZMod 313, x ‚â† 0 ‚Üí y ‚â† 0 ‚Üí ind'' (x / y) = ind'' x - ind'' y := by
          native_decide +revert;
        grind;
      ¬∑ grind;
      ¬∑ intro b hb; use ( b * u, ( 1 - b ) * u ) ; simp_all +decide [ sub_mul, mul_div_cancel‚ÇÄ ] ;
        have h_ind_mul : ind'' (b * u) = ind'' b + ind'' u := by
          exact ind_mul'' b u hb.1 hu
        have h_ind_sub : ind'' (u - b * u) = ind'' (1 - b) + ind'' u := by
          have h_ind_sub : ind'' (u * (1 - b)) = ind'' u + ind'' (1 - b) := by
            exact ind_mul'' _ _ hu ( sub_ne_zero_of_ne <| Ne.symm hb.2.1 ) ‚ñ∏ rfl;
          grind;
        grind +ring;
    ¬∑ grind

/-
Expansion of the product of Gaussian periods in terms of solution counts for q=313. The constant term comes from x+y=0, and the sum comes from x+y=u!=0.
-/
lemma period_mul_eq_sum_N_sol'' (i j : ZMod 3) :
  period'' i * period'' j = (if i = j then 104 else 0) +
  ‚àë u ‚àà Finset.univ.filter (fun x : ZMod 313 => x ‚â† 0), (N_sol'' i j u : L313) * Œ∂313 ^ (u.val : ‚Ñï) := by
    rw [ show period'' i = ‚àë x ‚àà Finset.filter ( fun x => x ‚â† 0 ‚àß ind'' x = i ) Finset.univ, Œ∂313 ^ x.val from ?_, show period'' j = ‚àë x ‚àà Finset.filter ( fun x => x ‚â† 0 ‚àß ind'' x = j ) Finset.univ, Œ∂313 ^ x.val from ?_ ];
    ¬∑ -- Let's simplify the expression by separating the sum into two parts: one where $x + y = 0$ and one where $x + y \neq 0$.
      have h_split_sum : (‚àë x ‚àà Finset.filter (fun x => x ‚â† 0 ‚àß ind'' x = i) (Finset.univ : Finset (ZMod 313)), Œ∂313 ^ x.val) * (‚àë y ‚àà Finset.filter (fun y => y ‚â† 0 ‚àß ind'' y = j) (Finset.univ : Finset (ZMod 313)), Œ∂313 ^ y.val) =
        ‚àë u ‚àà Finset.filter (fun u => u ‚â† 0) (Finset.univ : Finset (ZMod 313)), ‚àë x ‚àà Finset.filter (fun x => x ‚â† 0 ‚àß ind'' x = i) (Finset.univ : Finset (ZMod 313)), ‚àë y ‚àà Finset.filter (fun y => y ‚â† 0 ‚àß ind'' y = j) (Finset.univ : Finset (ZMod 313)), (if x + y = u then Œ∂313 ^ u.val else 0) +
        ‚àë x ‚àà Finset.filter (fun x => x ‚â† 0 ‚àß ind'' x = i) (Finset.univ : Finset (ZMod 313)), ‚àë y ‚àà Finset.filter (fun y => y ‚â† 0 ‚àß ind'' y = j) (Finset.univ : Finset (ZMod 313)), (if x + y = 0 then Œ∂313 ^ 0 else 0) := by
          have h_split_sum : ‚àÄ x y : ZMod 313, x ‚â† 0 ‚àß ind'' x = i ‚Üí y ‚â† 0 ‚àß ind'' y = j ‚Üí Œ∂313 ^ x.val * Œ∂313 ^ y.val = ‚àë u ‚àà Finset.filter (fun u => u ‚â† 0) (Finset.univ : Finset (ZMod 313)), (if x + y = u then Œ∂313 ^ u.val else 0) + (if x + y = 0 then Œ∂313 ^ 0 else 0) := by
            intro x y hx hy
            have h_exp : Œ∂313 ^ x.val * Œ∂313 ^ y.val = Œ∂313 ^ ((x + y).val) := by
              have h_exp : Œ∂313 ^ (x.val + y.val) = Œ∂313 ^ ((x + y).val) := by
                have h_exp : Œ∂313 ^ 313 = 1 := by
                  convert IsPrimitiveRoot.pow_eq_one ( IsCyclotomicExtension.zeta_spec 313 ‚Ñö L313 );
                rw [ ‚Üê Nat.mod_add_div ( x.val + y.val ) 313, pow_add, pow_mul ] ; aesop;
              rw [ ‚Üê h_exp, pow_add ];
            by_cases h : x + y = 0 <;> simp +decide [ h, h_exp ];
          simp +contextual only [Finset.sum_mul _ _ _, Finset.mul_sum];
          rw [ Finset.sum_congr rfl fun x hx => Finset.sum_congr rfl fun y hy => h_split_sum x y ( by simpa using hx ) ( by simpa using hy ) ];
          simp +contextual only [Finset.sum_add_distrib, Finset.sum_sigma'];
          refine' congrArg‚ÇÇ ( ¬∑ + ¬∑ ) _ rfl;
          apply Finset.sum_bij (fun x _ => ‚ü®x.snd.snd, x.fst, x.snd.fst‚ü©);
          ¬∑ simp +contextual [ Sigma.ext_iff ];
          ¬∑ simp +contextual [ Sigma.ext_iff ];
          ¬∑ simp +contextual [ Sigma.ext_iff ];
          ¬∑ grind;
      -- The inner sum where $x + y = 0$ contributes either $104$ if $i = j$ or $0$ otherwise.
      have h_inner_sum : ‚àë x ‚àà Finset.filter (fun x => x ‚â† 0 ‚àß ind'' x = i) (Finset.univ : Finset (ZMod 313)), ‚àë y ‚àà Finset.filter (fun y => y ‚â† 0 ‚àß ind'' y = j) (Finset.univ : Finset (ZMod 313)), (if x + y = 0 then Œ∂313 ^ 0 else 0) = if i = j then 104 else 0 := by
        have h_inner_sum : ‚àÄ x ‚àà Finset.filter (fun x => x ‚â† 0 ‚àß ind'' x = i) (Finset.univ : Finset (ZMod 313)), ‚àë y ‚àà Finset.filter (fun y => y ‚â† 0 ‚àß ind'' y = j) (Finset.univ : Finset (ZMod 313)), (if x + y = 0 then 1 else 0) = if i = j then 1 else 0 := by
          intros x hx
          have h_inner_sum : ‚àë y ‚àà Finset.filter (fun y => y ‚â† 0 ‚àß ind'' y = j) (Finset.univ : Finset (ZMod 313)), (if x + y = 0 then 1 else 0) = if ‚àÉ y ‚àà Finset.filter (fun y => y ‚â† 0 ‚àß ind'' y = j) (Finset.univ : Finset (ZMod 313)), x + y = 0 then 1 else 0 := by
            split_ifs <;> simp_all +decide [ Finset.sum_ite ];
            rw [ Finset.card_eq_one ];
            obtain ‚ü® y, hy‚ÇÅ, hy‚ÇÇ ‚ü© := ‚Äπ_‚Ä∫; use y; ext; simp +decide [ ‚Üê eq_sub_iff_add_eq' ] at *; aesop;
          split_ifs at * <;> simp_all +decide only [Finset.mem_filter, Finset.mem_univ, true_and];
          ¬∑ rename_i h‚ÇÅ h‚ÇÇ;
            contrapose! h‚ÇÇ;
            use -x;
            simp +decide [ hx, ind_mul'' ];
            rw [ ‚Üê hx.2, show ind'' ( -x ) = ind'' x + ind'' ( -1 ) from ?_, ind_neg_one'' ] ; simp +decide [ hx.2 ];
            convert ind_mul'' x ( -1 ) hx.1 ( by decide ) using 1;
            rw [ mul_neg_one ];
          ¬∑ obtain ‚ü® y, hy, hy' ‚ü© := ‚Äπ‚àÉ y, ( y ‚â† 0 ‚àß ind'' y = j ) ‚àß x + y = 0‚Ä∫; simp_all +decide [ add_eq_zero_iff_eq_neg ] ;
            have h_ind_neg : ind'' (-1) = 0 := by
              native_decide +revert;
            have h_ind_neg : ind'' (-y) = ind'' (-1) + ind'' y := by
              have h_ind_neg : ‚àÄ x y : ZMod 313, x ‚â† 0 ‚Üí y ‚â† 0 ‚Üí ind'' (x * y) = ind'' x + ind'' y := by
                native_decide +revert;
              simpa using h_ind_neg ( -1 ) y ( by decide ) hy.1;
            grind;
        have h_card : Finset.card (Finset.filter (fun x => x ‚â† 0 ‚àß ind'' x = i) (Finset.univ : Finset (ZMod 313))) = if i = 0 then 104 else if i = 1 then 104 else 104 := by
          fin_cases i <;> native_decide;
        convert congr_arg ( fun x : ‚Ñï => x : ‚Ñï ‚Üí L313 ) ( Finset.sum_congr rfl fun x hx => h_inner_sum x hx ) using 1 ; norm_num [ h_card ];
        split_ifs <;> simp_all +decide [ Finset.sum_ite ];
      rw [ h_split_sum, h_inner_sum, add_comm ];
      refine' congr rfl ( Finset.sum_congr rfl fun u hu => _ );
      rw [ show N_sol'' i j u = Finset.card ( Finset.filter ( fun p : ZMod 313 √ó ZMod 313 => p.1 ‚â† 0 ‚àß p.2 ‚â† 0 ‚àß ind'' p.1 = i ‚àß ind'' p.2 = j ‚àß p.1 + p.2 = u ) ( Finset.univ : Finset ( ZMod 313 √ó ZMod 313 ) ) ) from ?_ ];
      ¬∑ simp +decide [ Finset.sum_ite, Finset.filter_filter ];
        rw [ show ( Finset.filter ( fun p : ZMod 313 √ó ZMod 313 => ¬¨p.1 = 0 ‚àß ¬¨p.2 = 0 ‚àß ind'' p.1 = i ‚àß ind'' p.2 = j ‚àß p.1 + p.2 = u ) Finset.univ ) = Finset.biUnion ( Finset.filter ( fun x : ZMod 313 => ¬¨x = 0 ‚àß ind'' x = i ) Finset.univ ) ( fun x => Finset.image ( fun y => ( x, y ) ) ( Finset.filter ( fun y : ZMod 313 => ¬¨y = 0 ‚àß ind'' y = j ‚àß x + y = u ) Finset.univ ) ) from ?_, Finset.card_biUnion ];
        ¬∑ simp +decide [ Finset.card_image_of_injective, Function.Injective, Finset.sum_mul _ _ _ ];
          simp +decide only [and_assoc];
        ¬∑ exact fun x hx y hy hxy => Finset.disjoint_left.mpr fun z => by contrapose! hxy; aesop;
        ¬∑ ext ‚ü®x, y‚ü©; simp [Finset.mem_biUnion, Finset.mem_image];
          tauto;
      ¬∑ rw [ ‚Üê Fintype.card_subtype ];
        exact?;
    ¬∑ unfold period''; fin_cases j <;> simp +decide [ Finset.sum_filter ] ;
      ¬∑ unfold Œ∑‚ÇÄ''; simp +decide [ Finset.sum_ite ] ;
        congr with x ; simp +decide [ ind'' ];
        native_decide +revert;
      ¬∑ unfold Œ∑‚ÇÇ''; simp +decide [ Finset.sum_ite ] ;
        congr! 1;
        native_decide +revert;
      ¬∑ unfold Œ∑‚ÇÅ''; simp +decide [ Finset.sum_ite ] ;
        rw [ show S_s2'' = Finset.filter ( fun x => ¬¨x = 0 ‚àß ind'' x = 2 ) Finset.univ from ?_ ];
        ¬∑ grind;
        ¬∑ native_decide +revert;
    ¬∑ unfold period'';
      split_ifs <;> simp_all +decide [ Finset.sum_filter ];
      ¬∑ unfold Œ∑‚ÇÄ''; simp +decide [ Finset.sum_ite ] ;
        congr! 1;
        native_decide +revert;
      ¬∑ unfold Œ∑‚ÇÇ''; simp +decide [ Finset.sum_ite ] ;
        congr! 1;
        native_decide +revert;
      ¬∑ unfold Œ∑‚ÇÅ''; simp +decide [ Finset.sum_ite ] ;
        congr! 1;
        native_decide +revert

/-
Multiplication rule for Gaussian periods for q=313. Hint: group the terms in the sum by their index.
-/
lemma period_mul'' (i j : ZMod 3) :
  period'' i * period'' j = (if i = j then 104 else 0) +
  (cyc_num'' (i - 0) (j - 0) * period'' 0 +
   cyc_num'' (i - 1) (j - 1) * period'' 1 +
   cyc_num'' (i - 2) (j - 2) * period'' 2) := by
     convert period_mul_eq_sum_N_sol'' i j using 1;
     -- By grouping terms based on the index of $u$, we can rewrite the sum.
     have h_group : ‚àë u ‚àà Finset.univ.filter (fun x : ZMod 313 => x ‚â† 0), (N_sol'' i j u : L313) * Œ∂313 ^ (u.val : ‚Ñï) =
                    ‚àë k : ZMod 3, ‚àë u ‚àà Finset.univ.filter (fun x : ZMod 313 => x ‚â† 0 ‚àß ind'' x = k), (cyc_num'' (i - k) (j - k) : L313) * Œ∂313 ^ (u.val : ‚Ñï) := by
                      have h_group : ‚àÄ u : ZMod 313, u ‚â† 0 ‚Üí (N_sol'' i j u : L313) = cyc_num'' (i - ind'' u) (j - ind'' u) := by
                        exact fun u hu => mod_cast N_sol_eq_cyc_num'' i j u hu;
                      have h_group : ‚àë u ‚àà Finset.univ.filter (fun x : ZMod 313 => x ‚â† 0), (N_sol'' i j u : L313) * Œ∂313 ^ (u.val : ‚Ñï) =
                                     ‚àë k : ZMod 3, ‚àë u ‚àà Finset.univ.filter (fun x : ZMod 313 => x ‚â† 0 ‚àß ind'' x = k), (N_sol'' i j u : L313) * Œ∂313 ^ (u.val : ‚Ñï) := by
                                       rw [ ‚Üê Finset.sum_biUnion ];
                                       ¬∑ rcongr x ; simp +decide [ Finset.mem_biUnion ];
                                       ¬∑ exact fun x _ y _ hxy => Finset.disjoint_left.mpr fun z hz‚ÇÅ hz‚ÇÇ => hxy <| by aesop;
                      exact h_group.trans ( Finset.sum_congr rfl fun k hk => Finset.sum_congr rfl fun u hu => by rw [ ‚Äπ‚àÄ u : ZMod 313, u ‚â† 0 ‚Üí ( N_sol'' i j u : L313 ) = cyc_num'' ( i - ind'' u ) ( j - ind'' u ) ‚Ä∫ u ( by aesop ) ] ; aesop );
     rw [ h_group, Finset.sum_congr rfl fun x hx => by rw [ ‚Üê Finset.mul_sum _ _ _ ] ];
     rw [ show ( Finset.univ : Finset ( ZMod 3 ) ) = { 0, 1, 2 } by decide ] ; simp +decide [ Finset.sum_add_distrib, Finset.mul_sum _ _ _, Finset.sum_mul ] ;
     rw [ show period'' 0 = ‚àë x ‚àà Finset.univ.filter ( fun x : ZMod 313 => x ‚â† 0 ‚àß ind'' x = 0 ), Œ∂313 ^ ( x.val : ‚Ñï ) from ?_, show period'' 1 = ‚àë x ‚àà Finset.univ.filter ( fun x : ZMod 313 => x ‚â† 0 ‚àß ind'' x = 1 ), Œ∂313 ^ ( x.val : ‚Ñï ) from ?_, show period'' 2 = ‚àë x ‚àà Finset.univ.filter ( fun x : ZMod 313 => x ‚â† 0 ‚àß ind'' x = 2 ), Œ∂313 ^ ( x.val : ‚Ñï ) from ?_ ];
     ¬∑ rw [ Finset.mul_sum _ _ _, Finset.mul_sum _ _ _, Finset.mul_sum _ _ _ ] ; ring;
     ¬∑ unfold period''; simp +decide [ Finset.sum_filter ] ;
       unfold Œ∑‚ÇÅ''; simp +decide [ Finset.sum_ite ] ;
       congr! 1;
       native_decide +revert;
     ¬∑ unfold period''; simp +decide [ Finset.sum_filter ] ;
       unfold Œ∑‚ÇÇ''; simp +decide [ Finset.sum_ite ] ;
       refine' Finset.sum_bij ( fun x hx => x ) _ _ _ _ <;> simp +decide [ S_s1'' ];
       ¬∑ native_decide +revert;
       ¬∑ native_decide +revert;
     ¬∑ -- By definition of $S_cubic_res''$, we have $S_cubic_res'' = \{ x \in \mathbb{Z}/313\mathbb{Z} \mid x \neq 0 \land x^{104} = 1 \}$.
       have h_S_cubic_res'' : S_cubic_res'' = Finset.filter (fun x : ZMod 313 => x ‚â† 0 ‚àß ind'' x = 0) Finset.univ := by
         ext x; simp [S_cubic_res'', ind''];
         grind;
       exact h_S_cubic_res''.symm ‚ñ∏ rfl

/-
Formula for eta0''^2 for q=313.
-/
lemma eta_sq_0 : Œ∑‚ÇÄ'' ^ 2 = 104 + 30 * Œ∑‚ÇÄ'' + 37 * Œ∑‚ÇÅ'' + 36 * Œ∑‚ÇÇ'' := by
  -- Apply the multiplication rule for Gaussian periods with i = 0 and j = 0.
  have h_period_mul : period'' 0 * period'' 0 = (if 0 = 0 then 104 else 0) + (cyc_num'' (0 - 0) (0 - 0) * period'' 0 + cyc_num'' (0 - 1) (0 - 1) * period'' 1 + cyc_num'' (0 - 2) (0 - 2) * period'' 2) := by
    convert period_mul'' 0 0 using 1;
  convert h_period_mul using 1 <;> norm_num [ sq, cyc_num_vals'' ] ; ring!;
  rw [ show ( -1 : ZMod 3 ) = 2 by decide, show ( -2 : ZMod 3 ) = 1 by decide ] ; norm_num [ cyc_num_vals'' ] ; ring!;

/-
Formula for eta1''^2 for q=313. Corrected coefficients: 30 for eta1'' and 37 for eta2''.
-/
lemma eta_sq_1 : Œ∑‚ÇÅ'' ^ 2 = 104 + 36 * Œ∑‚ÇÄ'' + 30 * Œ∑‚ÇÅ'' + 37 * Œ∑‚ÇÇ'' := by
  have := @period_mul'' 2 2; simp_all +decide [ pow_two, sub_eq_iff_eq_add ] ;
  rw [ show cyc_num'' 2 2 = 36 by exact cyc_num_vals''.2.2.2.2.2.2.2.2, show cyc_num'' ( 2 - 1 ) ( 2 - 1 ) = 37 by exact cyc_num_vals''.2.2.2.2.1, show cyc_num'' 0 0 = 30 by exact cyc_num_vals''.1 ] at this; rw [ show period'' 0 = Œ∑‚ÇÄ'' by rfl, show period'' 1 = Œ∑‚ÇÇ'' by rfl, show period'' 2 = Œ∑‚ÇÅ'' by rfl ] at this; ring_nf at this;
  linear_combination' this

/-
Formula for eta2''^2 for q=313. Coefficients: 37 for eta0'', 36 for eta1'', 30 for eta2''.
-/
lemma eta_sq_2 : Œ∑‚ÇÇ'' ^ 2 = 104 + 37 * Œ∑‚ÇÄ'' + 36 * Œ∑‚ÇÅ'' + 30 * Œ∑‚ÇÇ'' := by
  have := period_mul'' 1 1; simp_all +decide [ Finset.sum_add_distrib, mul_assoc, pow_succ' ] ;
  convert this using 1 ; norm_num [ cyc_num_vals'' ] ; ring!;
  erw [ show cyc_num'' ( -1 ) ( -1 ) = 36 by native_decide ] ; norm_num

/-
Formula for eta0'' * eta1'' for q=313. Coefficients: 37 for eta0'', 36 for eta1'', 31 for eta2''.
-/
lemma eta_mul_01 : Œ∑‚ÇÄ'' * Œ∑‚ÇÅ'' = 37 * Œ∑‚ÇÄ'' + 36 * Œ∑‚ÇÅ'' + 31 * Œ∑‚ÇÇ'' := by
  convert period_mul'' 0 2 using 1 ; ring!;
  rw [ show cyc_num'' 0 2 = 37 by native_decide, show cyc_num'' ( -2 ) 0 = 36 by native_decide, show cyc_num'' ( -1 ) 1 = 31 by native_decide ] ; norm_num;
  decide +kernel

/-
Formula for eta0'' * eta2'' for q=313. Coefficients: 36 for eta0'', 31 for eta1'', 37 for eta2''.
-/
lemma eta_mul_02 : Œ∑‚ÇÄ'' * Œ∑‚ÇÇ'' = 36 * Œ∑‚ÇÄ'' + 31 * Œ∑‚ÇÅ'' + 37 * Œ∑‚ÇÇ'' := by
  convert period_mul'' 0 1 using 1 ; norm_num [ cyc_num_vals'' ];
  rw [ show ( -1 : ZMod 3 ) = 2 by decide, show ( -2 : ZMod 3 ) = 1 by decide ] ; norm_cast; simp +decide [ cyc_num_vals'' ] ;
  rw [ show period'' 0 = Œ∑‚ÇÄ'' by exact if_pos rfl, show period'' 1 = Œ∑‚ÇÇ'' by exact if_neg ( by decide ) |> fun h => h.trans ( if_pos rfl ), show period'' 2 = Œ∑‚ÇÅ'' by exact if_neg ( by decide ) |> fun h => h.trans ( if_neg ( by decide ) ) ] ; ring

/-
Check if eta2'' - eta1'' is a root of f''. Hint: use the eta_sq and eta_mul lemmas.
-/
theorem alpha_root_check : (f_poly'').eval (Œ∑‚ÇÇ'' - Œ∑‚ÇÅ'') = 0 := by
  unfold f_poly''; norm_num [ sub_eq_iff_eq_add ] ;
  have h_sum : Œ∑‚ÇÄ'' + Œ∑‚ÇÅ'' + Œ∑‚ÇÇ'' = -1 := by
    -- The sum of all roots of unity of order 313 is zero.
    have h_sum_all : ‚àë x ‚àà Finset.univ.filter (fun x : ZMod 313 => x ‚â† 0), Œ∂313 ^ (x.val : ‚Ñï) = -1 := by
      have h_sum : ‚àë x : ZMod 313, Œ∂313 ^ (x.val : ‚Ñï) = 0 := by
        have h_sum_roots : ‚àë x ‚àà Finset.range 313, Œ∂313 ^ x = 0 := by
          rw [ geom_sum_eq ] <;> norm_num [ IsPrimitiveRoot.iff_def ];
          ¬∑ exact Or.inl ( by rw [ sub_eq_zero ] ; exact ( IsCyclotomicExtension.zeta_pow _ _ _ ) );
          ¬∑ have h_primitive : IsPrimitiveRoot Œ∂313 313 := by
              convert IsCyclotomicExtension.zeta_spec 313 ‚Ñö L313 using 1;
            exact h_primitive.ne_one ( by decide );
        rw [ ‚Üê h_sum_roots, eq_comm ];
        refine' Finset.sum_bij ( fun x hx => x ) _ _ _ _ <;> norm_num;
        ¬∑ native_decide +revert;
        ¬∑ native_decide +revert;
        ¬∑ exact fun a ha => by rw [ Nat.mod_eq_of_lt ha ] ;
      exact eq_neg_of_add_eq_zero_right ( by simpa [ Finset.filter_ne' ] using h_sum );
    rw [ ‚Üê h_sum_all, show ( Finset.univ.filter fun x : ZMod 313 => ¬¨x = 0 ) = S_cubic_res'' ‚à™ S_s1'' ‚à™ S_s2'' from ?_, Finset.sum_union, Finset.sum_union ] <;> norm_num [ S_cubic_res'', S_s1'', S_s2'' ];
    ¬∑ exact?;
    ¬∑ native_decide +revert;
    ¬∑ native_decide +revert;
    ¬∑ native_decide +revert;
  rw [ ‚Üê eq_sub_iff_add_eq' ] at h_sum;
  rw [ h_sum ] ; ring;
  rw [ show Œ∑‚ÇÄ'' ^ 3 = Œ∑‚ÇÄ'' * Œ∑‚ÇÄ'' ^ 2 by ring, show Œ∑‚ÇÅ'' ^ 3 = Œ∑‚ÇÅ'' * Œ∑‚ÇÅ'' ^ 2 by ring, eta_sq_0, eta_sq_1 ] ; ring;
  rw [ h_sum ] ; ring;
  rw [ show Œ∑‚ÇÄ'' ^ 2 = 104 + 30 * Œ∑‚ÇÄ'' + 37 * Œ∑‚ÇÅ'' + 36 * Œ∑‚ÇÇ'' by exact? ] ; rw [ show Œ∑‚ÇÅ'' ^ 2 = 104 + 36 * Œ∑‚ÇÄ'' + 30 * Œ∑‚ÇÅ'' + 37 * Œ∑‚ÇÇ'' by exact? ] ; rw [ h_sum ] ; ring;
  rw [ show Œ∑‚ÇÄ'' * Œ∑‚ÇÅ'' = 37 * Œ∑‚ÇÄ'' + 36 * Œ∑‚ÇÅ'' + 31 * Œ∑‚ÇÇ'' by exact? ] ; rw [ h_sum ] ; ring;

/-
Define the correct roots alpha_true, beta_true, gamma_true for q=313. Prove alpha_true is a root of f'' and their sum is zero.
-/
def Œ±_true : L313 := Œ∑‚ÇÇ'' - Œ∑‚ÇÅ''
def Œ≤_true : L313 := Œ∑‚ÇÄ'' - Œ∑‚ÇÇ''
def Œ≥_true : L313 := Œ∑‚ÇÅ'' - Œ∑‚ÇÄ''

theorem alpha_true_root : (f_poly'').eval Œ±_true = 0 := by
  exact alpha_root_check

theorem sum_zero_true : Œ±_true + Œ≤_true + Œ≥_true = 0 := by
  unfold Œ±_true Œ≤_true Œ≥_true; ring

/-
Define the Galois unit and automorphism for q=313.
-/
def gal_unit313 (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 313) : (ZMod 313)À£ := Units.mk0 (N : ZMod 313) (by
  rw [Ne, ZMod.natCast_zmod_eq_zero_iff_dvd]
  intro h
  have hN_prime : Nat.Prime N := Fact.out
  have : 313 = 1 ‚à® 313 = N := (Nat.dvd_prime hN_prime).mp h
  have : 313 = N := this.resolve_left (by norm_num)
  exact hN this.symm)

def sigma313 (u : (ZMod 313)À£) : L313 ‚âÉ‚Çê[‚Ñö] L313 :=
  (IsCyclotomicExtension.autEquivPow L313 (Polynomial.cyclotomic.irreducible_rat (n := 313) (by norm_num))).symm u

/-
Integer versions of the periods and roots for q=313.
-/
def Œ∂313_int : ùìû L313 := IsPrimitiveRoot.toInteger (IsCyclotomicExtension.zeta_spec 313 ‚Ñö L313)

def period_int313 (i : ZMod 3) : ùìû L313 := ‚àë x ‚àà Finset.univ.filter (fun x : ZMod 313 => x ‚â† 0 ‚àß ind'' x = i), Œ∂313_int ^ (x.val : ‚Ñï)

def Œ±_true_int : ùìû L313 := period_int313 1 - period_int313 2
def Œ≤_true_int : ùìû L313 := period_int313 0 - period_int313 1
def Œ≥_true_int : ùìû L313 := period_int313 2 - period_int313 0

/-
The integer version of the period coerces to the field version for q=313.
-/
lemma coe_period_int313 (i : ZMod 3) : (period_int313 i : L313) = period'' i := by
  unfold period_int313 period''; simp +decide [ Finset.sum_mul ] ;
  unfold Œ∑‚ÇÄ'' Œ∑‚ÇÅ'' Œ∑‚ÇÇ''; split_ifs <;> simp +decide [ *, Finset.sum_filter ] ;
  ¬∑ rw [ ‚Üê Finset.sum_filter ];
    refine' Finset.sum_bij ( fun x hx => x ) _ _ _ _ <;> simp +contextual [ * ];
    ¬∑ native_decide +revert;
    ¬∑ native_decide +revert;
    ¬∑ unfold Œ∂313_int; aesop;
  ¬∑ -- Since the sums are over the same set of elements, they are equal.
    have h_sum_eq : ‚àë x : ZMod 313, (if ¬¨x = 0 ‚àß ind'' x = 1 then (algebraMap (ùìû L313) L313) Œ∂313_int ^ x.val else 0) = ‚àë x ‚àà S_s1'', (algebraMap (ùìû L313) L313) Œ∂313_int ^ x.val := by
      rw [ ‚Üê Finset.sum_filter ];
      refine' Finset.sum_bij ( fun x hx => x ) _ _ _ _ <;> simp +contextual [ ind_spec'' ];
      native_decide +revert;
    convert h_sum_eq using 1;
  ¬∑ rw [ show S_s2'' = Finset.filter ( fun x : ZMod 313 => ¬¨x = 0 ‚àß ind'' x = 2 ) Finset.univ from ?_ ];
    ¬∑ rw [ show i = 2 from by fin_cases i <;> trivial ];
      rw [ Finset.sum_filter ];
      congr! 2;
    ¬∑ native_decide +revert

/-
The integer version of alpha_true coerces to the field version for q=313.
-/
lemma coe_alpha_true_int : (Œ±_true_int : L313) = Œ±_true := by
  convert congr_arg‚ÇÇ ( ¬∑ - ¬∑ ) ( coe_period_int313 1 ) ( coe_period_int313 2 ) using 1

/-
The integer version of beta_true coerces to the field version for q=313.
-/
lemma coe_beta_true_int : (Œ≤_true_int : L313) = Œ≤_true := by
  convert congr_arg‚ÇÇ ( ¬∑ - ¬∑ ) ( coe_period_int313 0 ) ( coe_period_int313 1 ) using 1

/-
The integer version of gamma_true coerces to the field version for q=313.
-/
lemma coe_gamma_true_int : (Œ≥_true_int : L313) = Œ≥_true := by
  convert congr_arg‚ÇÇ ( ¬∑ - ¬∑ ) ( coe_period_int313 2 ) ( coe_period_int313 0 ) using 1

/-
Relation between beta_true and alpha_true for q=313. 70*beta = 6*alpha^2 - 44*alpha - 1252.
-/
theorem beta_relation_true : 70 * Œ≤_true = 6 * Œ±_true^2 - 44 * Œ±_true - 1252 := by
  unfold Œ≤_true Œ±_true;
  rw [ show ( Œ∑‚ÇÇ'' - Œ∑‚ÇÅ'' ) ^ 2 = ( Œ∑‚ÇÇ'' ^ 2 ) - 2 * Œ∑‚ÇÇ'' * Œ∑‚ÇÅ'' + Œ∑‚ÇÅ'' ^ 2 by ring, eta_sq_2, eta_sq_1 ] ; ring;
  rw [ show Œ∑‚ÇÇ'' * Œ∑‚ÇÅ'' = 31 * Œ∑‚ÇÄ'' + 37 * Œ∑‚ÇÅ'' + 36 * Œ∑‚ÇÇ'' by
        have := period_mul'' 1 2; simp_all +decide ; ring;
        convert this using 1 ; ring!;
        erw [ show cyc_num'' 0 1 = 36 by native_decide, show cyc_num'' ( -1 ) 0 = 37 by native_decide, show cyc_num'' 1 2 = 31 by native_decide ] ; ring!; ] ; ring;
  -- Using the fact that the sum of the periods is -1, we can express Œ∑‚ÇÄ'' in terms of Œ∑‚ÇÅ'' and Œ∑‚ÇÇ''.
  have h_sum : Œ∑‚ÇÄ'' = -1 - Œ∑‚ÇÅ'' - Œ∑‚ÇÇ'' := by
    have h_sum : Œ∑‚ÇÄ'' + Œ∑‚ÇÅ'' + Œ∑‚ÇÇ'' = -1 := by
      have h_sum : ‚àë x ‚àà Finset.univ.filter (fun x : ZMod 313 => x ‚â† 0), Œ∂313 ^ (x.val : ‚Ñï) = -1 := by
        have h_sum : ‚àë x : ZMod 313, Œ∂313 ^ (x.val : ‚Ñï) = 0 := by
          have h_geom_sum : ‚àë x ‚àà Finset.range 313, Œ∂313 ^ x = 0 := by
            have h_geom_sum : Œ∂313 ^ 313 = 1 ‚àß Œ∂313 ‚â† 1 := by
              have h_zeta : IsPrimitiveRoot Œ∂313 313 := by
                convert IsCyclotomicExtension.zeta_spec 313 ‚Ñö L313;
              exact ‚ü® h_zeta.pow_eq_one, h_zeta.ne_one <| by decide ‚ü©;
            rw [ geom_sum_eq ] <;> aesop;
          exact?;
        exact eq_neg_of_add_eq_zero_right ( by simpa [ Finset.filter_ne' ] using h_sum );
      rw [ ‚Üê h_sum, show ( Finset.univ.filter fun x : ZMod 313 => ¬¨x = 0 ) = S_cubic_res'' ‚à™ S_s1'' ‚à™ S_s2'' from by native_decide, Finset.sum_union, Finset.sum_union ] <;> norm_num [ Finset.disjoint_left ];
      ¬∑ exact?;
      ¬∑ native_decide +revert;
      ¬∑ native_decide +revert;
    linear_combination' h_sum;
  rw [h_sum]
  ring

/-
Relate the index of N to the value of c'' N being s1'' for q=313.
-/
lemma ind_N_eq_1_iff_c_eq_s1'' (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 313) :
  ind'' (N : ZMod 313) = 1 ‚Üî c'' N = s1'' := by
    constructor <;> intro h;
    ¬∑ unfold ind'' at h;
      split_ifs at h ; simp_all +decide [ S_s1'', S_s2'' ];
      ¬∑ unfold S_s1'' at *; aesop;
      ¬∑ cases h;
    ¬∑ have h_index : ind'' (N : ZMod 313) = 1 := by
        have h_c_eq_s1 : c'' N = s1'' := h
        have h_index_eq : ‚àÄ x : ZMod 313, x ‚â† 0 ‚Üí (x ^ 104 = s1'' ‚Üî ind'' x = 1) := by
          native_decide +revert
        convert h_index_eq ( N : ZMod 313 ) _ |>.1 _;
        ¬∑ exact?;
        ¬∑ convert h_c_eq_s1 using 1;
      exact h_index

/-
Define residue field, reduction map, and integer automorphism for q=313.
-/
abbrev ùìûL313 := ùìû L313
def kP313 (P : Ideal ùìûL313) [P.IsMaximal] := ùìûL313 ‚ß∏ P
noncomputable instance (P : Ideal ùìûL313) [P.IsMaximal] : Field (kP313 P) := Ideal.Quotient.field P
def red313 (P : Ideal ùìûL313) [P.IsMaximal] : ùìûL313 ‚Üí+* kP313 P := Ideal.Quotient.mk P

def sigma_int313 (u : (ZMod 313)À£) (x : ùìû L313) : ùìû L313 := ‚ü®sigma313 u x, by
  have h_integral : IsIntegral ‚Ñ§ (x : L313) := x.2
  exact IsIntegral.map (sigma313 u) h_integral‚ü©

/-
The index of N is 2 iff c'' N is s2''.
-/
lemma ind_N_eq_2_iff_c_eq_s2'' (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 313) :
  ind'' (N : ZMod 313) = 2 ‚Üî c'' N = s2'' := by
    -- By definition of $ind''$, we know that $ind'' (N : ZMod 313) = 2$ if and only if $(N : ZMod 313) ^ 104 = s2''$.
    have h_ind''_def : ind'' (N : ZMod 313) = 2 ‚Üî (N : ZMod 313) ^ 104 = s2'' := by
      by_cases hN' : ( N : ZMod 313 ) = 0 <;> simp_all +decide [ ind'' ];
      ¬∑ rw [ ZMod.natCast_eq_zero_iff ] at hN';
        rw [ Nat.dvd_prime Fact.out ] at hN' ; aesop_cat;
      ¬∑ split_ifs <;> simp_all +decide [ S_cubic_res'', S_s1'', S_s2'' ];
        ¬∑ native_decide +revert;
        ¬∑ native_decide +revert;
        ¬∑ have h_order : ‚àÄ x : ZMod 313, x ‚â† 0 ‚Üí x ^ 104 = 1 ‚à® x ^ 104 = s1'' ‚à® x ^ 104 = s2'' := by
            native_decide +revert;
          grind;
    convert h_ind''_def using 1

/-
The automorphism sigma_N maps zeta313 to zeta313^N.
-/
lemma sigma_zeta313 {N : ‚Ñï} [Fact (Nat.Prime N)] (hN : N ‚â† 313) :
  sigma_int313 (gal_unit313 N hN) Œ∂313_int = Œ∂313_int ^ N := by
    have h_sigma_int_zeta : sigma313 (gal_unit313 N hN) (Œ∂313 : L313) = Œ∂313 ^ N := by
      unfold sigma313 gal_unit313;
      erw [ IsCyclotomicExtension.autEquivPow_symm_apply ];
      erw [ PowerBasis.equivOfMinpoly_gen ];
      simp +decide [ IsPrimitiveRoot.powerBasis ];
      rw [ ‚Üê Nat.mod_add_div N 313, pow_add, pow_mul ] ; norm_num;
      erw [ IsCyclotomicExtension.zeta_pow ] ; norm_num;
      rfl;
    exact?

/-
The Frobenius automorphism permutes the Gaussian periods by shifting their index by ind(N) for q=313.
-/
lemma sigma_period313 (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 313) (i : ZMod 3) :
  sigma313 (gal_unit313 N hN) (period'' i) = period'' (i + ind'' (N : ZMod 313)) := by
    -- By definition of $gal_unit313$, we know that $gal_unit313 N hN$ is a unit in $(ZMod 313)À£$.
    set u : (ZMod 313)À£ := gal_unit313 N hN
    have hu_unit : IsUnit (u : ZMod 313) := by
      exact Units.isUnit u;
    -- By definition of $sigma313$, we know that $sigma313 u (Œ∂313) = Œ∂313^u$.
    have h_sigma_zeta : ‚àÄ (u : (ZMod 313)À£), sigma313 u (Œ∂313) = Œ∂313 ^ (u : ZMod 313).val := by
      intro u
      simp [sigma313];
      simp +decide [ PowerBasis.equivOfMinpoly ];
      simp +decide [ PowerBasis.equivOfRoot ];
      erw [ PowerBasis.lift_gen ];
      rfl;
    -- By definition of $period''$, we know that $period'' i = \sum_{x \in C_i} \zeta313^x$.
    have h_period_def : ‚àÄ (i : ZMod 3), period'' i = ‚àë x ‚àà Finset.univ.filter (fun x : ZMod 313 => x ‚â† 0 ‚àß ind'' x = i), Œ∂313 ^ (x.val : ‚Ñï) := by
      intro i
      unfold period'';
      split_ifs <;> simp +decide [ *, Finset.sum_filter ];
      ¬∑ rw [ ‚Üê Finset.sum_filter ];
        refine' Finset.sum_bij ( fun x hx => x ) _ _ _ _ <;> simp +contextual [ * ];
        ¬∑ native_decide +revert;
        ¬∑ exact fun x hx hx' => by rw [ ind_spec'' x hx |>.1 ] at hx'; exact hx';
      ¬∑ unfold Œ∑‚ÇÇ''; simp +decide [ Finset.sum_ite ] ;
        congr! 1;
        native_decide +revert;
      ¬∑ rw [ show i = 2 by fin_cases i <;> trivial ] ; simp +decide [ Finset.sum_ite ] ;
        refine' Finset.sum_bij ( fun x hx => x ) _ _ _ _ <;> simp +contextual [ * ];
        ¬∑ native_decide +revert;
        ¬∑ native_decide +revert;
    -- By definition of $C_i$, we know that $C_i = \{ x \in \mathbb{F}_{313}^\times \mid \text{ind}(x) = i \}$.
    have h_C_def : ‚àÄ (i : ZMod 3), Finset.univ.filter (fun x : ZMod 313 => x ‚â† 0 ‚àß ind'' x = i) = Finset.image (fun x : ZMod 313 => x) (Finset.filter (fun x : ZMod 313 => ind'' x = i) (Finset.filter (fun x : ZMod 313 => x ‚â† 0) Finset.univ)) := by
      simp +contextual [ Finset.ext_iff ];
    -- By definition of $C_i$, we know that $C_i = \{ x \in \mathbb{F}_{313}^\times \mid \text{ind}(x) = i \}$ and $C_{i + \text{ind}(N)} = \{ x \in \mathbb{F}_{313}^\times \mid \text{ind}(x) = i + \text{ind}(N) \}$.
    have h_C_image : Finset.image (fun x : ZMod 313 => x * (u : ZMod 313).val) (Finset.filter (fun x : ZMod 313 => ind'' x = i) (Finset.filter (fun x : ZMod 313 => x ‚â† 0) Finset.univ)) = Finset.filter (fun x : ZMod 313 => ind'' x = i + ind'' (N : ZMod 313)) (Finset.filter (fun x : ZMod 313 => x ‚â† 0) Finset.univ) := by
      ext x; simp [h_C_def, Finset.mem_image];
      constructor;
      ¬∑ rintro ‚ü® a, ‚ü® ha‚ÇÅ, ha‚ÇÇ ‚ü©, rfl ‚ü©;
        have h_ind_mul : ‚àÄ (x y : ZMod 313), x ‚â† 0 ‚Üí y ‚â† 0 ‚Üí ind'' (x * y) = ind'' x + ind'' y := by
          exact?;
        have h_ind_N : ind'' (N : ZMod 313) = ind'' (u : ZMod 313) := by
          simp +zetaDelta at *;
          unfold gal_unit313; aesop;
        exact ‚ü® mul_ne_zero ha‚ÇÅ ( Units.ne_zero _ ), by rw [ h_ind_mul _ _ ha‚ÇÅ ( Units.ne_zero _ ), ha‚ÇÇ, h_ind_N ] ‚ü©;
      ¬∑ intro hx
        obtain ‚ü®a, ha‚ü© : ‚àÉ a : ZMod 313, a * (u : ZMod 313).val = x := by
          have h_inv : ‚àÉ a : ZMod 313, a * (u : ZMod 313).val = 1 := by
            haveI := Fact.mk ( by norm_num : Nat.Prime 313 ) ; exact ‚ü® _, inv_mul_cancel‚ÇÄ <| by aesop ‚ü© ;
          exact ‚ü® h_inv.choose * x, by linear_combination' h_inv.choose_spec * x ‚ü©;
        have h_ind_mul : ind'' (a * (u : ZMod 313).val) = ind'' a + ind'' (u : ZMod 313).val := by
          by_cases ha0 : a = 0 <;> by_cases hu0 : ( u : ZMod 313 ).val = 0 <;> simp +decide [ ha0, hu0, ind_mul'' ] at hx ‚ä¢;
          ¬∑ grind;
          ¬∑ aesop;
          ¬∑ exact absurd hu0 ( by have := hu_unit.exists_left_inv; obtain ‚ü® v, hv ‚ü© := this; replace hv := congr_arg ( fun x : ZMod 313 => x.val ) hv; simp_all +decide [ ZMod.val_natCast ] );
        simp +zetaDelta at *;
        simp_all +decide [ gal_unit313 ];
        grind;
    have h_sigma_period : sigma313 u (‚àë x ‚àà Finset.univ.filter (fun x : ZMod 313 => x ‚â† 0 ‚àß ind'' x = i), Œ∂313 ^ (x.val : ‚Ñï)) = ‚àë x ‚àà Finset.univ.filter (fun x : ZMod 313 => x ‚â† 0 ‚àß ind'' x = i), Œ∂313 ^ ((x * (u : ZMod 313).val).val : ‚Ñï) := by
      have h_sigma_period : ‚àÄ (x : ZMod 313), sigma313 u (Œ∂313 ^ (x.val : ‚Ñï)) = Œ∂313 ^ ((x * (u : ZMod 313).val).val : ‚Ñï) := by
        intro x
        have h_sigma_period : sigma313 u (Œ∂313 ^ (x.val : ‚Ñï)) = (sigma313 u Œ∂313) ^ (x.val : ‚Ñï) := by
          exact map_pow _ _ _;
        rw [ h_sigma_period, h_sigma_zeta ];
        rw [ ‚Üê pow_mul, mul_comm ];
        norm_num [ ZMod.val_mul ];
        rw [ ‚Üê Nat.mod_add_div ( x.val * ( u : ZMod 313 ).val ) 313, pow_add, pow_mul ] ; norm_num [ IsPrimitiveRoot.pow_eq_one ];
        have h_zeta313_pow : Œ∂313 ^ 313 = 1 := by
          exact IsPrimitiveRoot.pow_eq_one ( IsCyclotomicExtension.zeta_spec 313 ‚Ñö L313 );
        rw [ h_zeta313_pow, one_pow, mul_one ];
      rw [ map_sum, Finset.sum_congr rfl fun x hx => h_sigma_period x ];
    have h_sigma_period : ‚àë x ‚àà Finset.univ.filter (fun x : ZMod 313 => x ‚â† 0 ‚àß ind'' x = i), Œ∂313 ^ ((x * (u : ZMod 313).val).val : ‚Ñï) = ‚àë x ‚àà Finset.univ.filter (fun x : ZMod 313 => x ‚â† 0 ‚àß ind'' x = i + ind'' (N : ZMod 313)), Œ∂313 ^ (x.val : ‚Ñï) := by
      simp_all +decide [ Finset.ext_iff ];
      refine' Finset.sum_bij ( fun x hx => x * u ) _ _ _ _ <;> simp_all +decide [ Finset.mem_filter ];
      exact fun x hx hx' => h_C_image _ |>.1 ‚ü® x, ‚ü® hx, hx' ‚ü©, rfl ‚ü© |>.2;
    grind

/-
The index of N is 1 iff c'' N is s1''.
-/
lemma ind_N_eq_1_iff_c_eq_s1''_proven (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 313) :
  ind'' (N : ZMod 313) = 1 ‚Üî c'' N = s1'' := by
    convert ind_N_eq_1_iff_c_eq_s1'' N hN using 1

/-
If c' N = s1', then sigma_N(alpha') = gamma'.
-/
lemma sigma_alpha_eq_gamma_if_s1'' (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 313) (h : c'' N = s1'') :
  sigma_int313 (gal_unit313 N hN) Œ±_true_int = Œ≥_true_int := by
    -- By definition of $sigma_int313$, we know that $sigma_int313 (gal_unit313 N hN) (period_int313 i) = period_int313 (i + ind'' (N : ZMod 313))$.
    have h_sigma_period : ‚àÄ i : ZMod 3, sigma_int313 (gal_unit313 N hN) (period_int313 i) = period_int313 (i + ind'' (N : ZMod 313)) := by
      intros i
      have h_sigma_period : sigma313 (gal_unit313 N hN) (period'' i) = period'' (i + ind'' (N : ZMod 313)) := by
        exact?;
      refine' Subtype.ext _;
      convert h_sigma_period using 1;
      ¬∑ exact coe_period_int313 i ‚ñ∏ rfl;
      ¬∑ exact coe_period_int313 _;
    -- By definition of $ind''$, we know that $ind'' (N : ZMod 313) = 1$ if $c'' N = s1''$.
    have h_ind : ind'' (N : ZMod 313) = 1 := by
      exact ind_N_eq_1_iff_c_eq_s1''_proven N hN |>.2 h;
    convert congr_arg‚ÇÇ ( ¬∑ - ¬∑ ) ( h_sigma_period 1 ) ( h_sigma_period 2 ) using 1 ; ring;
    ¬∑ unfold Œ±_true_int; norm_num [ h_sigma_period ] ; ring;
      convert congr_arg‚ÇÇ ( ¬∑ - ¬∑ ) ( h_sigma_period 1 ) ( h_sigma_period 2 ) using 1 ; ring;
      unfold sigma_int313; norm_num;
      exact?;
    ¬∑ simp +decide [ h_ind, Œ≥_true_int ];
      rfl

/-
If c' N = s2', then sigma_N(alpha') = beta'.
-/
lemma sigma_alpha_eq_beta_if_s2'' (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 313) (h : c'' N = s2'') :
  sigma_int313 (gal_unit313 N hN) Œ±_true_int = Œ≤_true_int := by
    have h_ind : ind'' (N : ZMod 313) = 2 := by
      exact?
    have h_sigma : sigma313 (gal_unit313 N hN) Œ±_true = Œ≤_true := by
      unfold Œ±_true Œ≤_true; simp +decide [ h_ind ] ;
      convert congr_arg‚ÇÇ ( ¬∑ - ¬∑ ) ( sigma_period313 N hN 1 ) ( sigma_period313 N hN 2 ) using 1 ; norm_num [ h_ind ];
      exact?
    exact (by
    have h_sigma_int : (sigma_int313 (gal_unit313 N hN) Œ±_true_int : L313) = Œ≤_true := by
      convert h_sigma using 1;
      convert congr_arg ( sigma313 ( gal_unit313 N hN ) ) ( coe_alpha_true_int ) using 1;
    exact Subtype.ext <| h_sigma_int.trans <| coe_beta_true_int.symm ‚ñ∏ rfl)

/-
The automorphism sigma_N acts as the Frobenius map on alpha'' modulo P.
-/
lemma frobenius_alpha313 (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 313) (P : Ideal ùìûL313) [P.IsMaximal] [CharP (kP313 P) N] :
  red313 P (sigma_int313 (gal_unit313 N hN) Œ±_true_int) = (red313 P Œ±_true_int) ^ N := by
    have h_sigma_zeta : sigma_int313 (gal_unit313 N hN) Œ∂313_int = Œ∂313_int ^ N := by
      exact?;
    -- By definition of $period_int313$, we know that its reduction modulo $P$ is the same as the reduction of the corresponding sum of powers of $\zeta_{313}$.
    have h_period_int313 : ‚àÄ i : ZMod 3, (red313 P) (period_int313 i) = ‚àë x ‚àà Finset.univ.filter (fun x : ZMod 313 => x ‚â† 0 ‚àß ind'' x = i), (red313 P Œ∂313_int) ^ (x.val : ‚Ñï) := by
      intro i
      simp [period_int313];
    have h_period_int313 : ‚àÄ i : ZMod 3, (red313 P) (period_int313 i) ^ N = ‚àë x ‚àà Finset.univ.filter (fun x : ZMod 313 => x ‚â† 0 ‚àß ind'' x = i), (red313 P Œ∂313_int) ^ (x.val * N) := by
      intro i; rw [ h_period_int313 i ] ; simp +decide [ pow_mul ] ;
      exact?;
    have h_period_int313 : ‚àÄ i : ZMod 3, (red313 P) (sigma_int313 (gal_unit313 N hN) (period_int313 i)) = ‚àë x ‚àà Finset.univ.filter (fun x : ZMod 313 => x ‚â† 0 ‚àß ind'' x = i), (red313 P Œ∂313_int) ^ (x.val * N) := by
      intros i
      have h_sigma_period : sigma_int313 (gal_unit313 N hN) (period_int313 i) = ‚àë x ‚àà Finset.univ.filter (fun x : ZMod 313 => x ‚â† 0 ‚àß ind'' x = i), (sigma_int313 (gal_unit313 N hN) Œ∂313_int) ^ (x.val : ‚Ñï) := by
        simp +decide [ period_int313 ];
        unfold sigma_int313; aesop;
      simp_all +decide [ pow_mul' ];
    convert congr_arg‚ÇÇ ( ¬∑ - ¬∑ ) ( h_period_int313 1 ) ( h_period_int313 2 ) using 1;
    ¬∑ unfold Œ±_true_int; simp +decide [ sub_eq_add_neg ] ;
      unfold sigma_int313; simp +decide [ map_add, map_neg ] ;
      exact?;
    ¬∑ rw [ ‚Üê ‚Äπ‚àÄ i : ZMod 3, ( red313 P ) ( period_int313 i ) ^ N = ‚àë x with x ‚â† 0 ‚àß ind'' x = i, ( red313 P ) Œ∂313_int ^ ( x.val * N ) ‚Ä∫ 1, ‚Üê ‚Äπ‚àÄ i : ZMod 3, ( red313 P ) ( period_int313 i ) ^ N = ‚àë x with x ‚â† 0 ‚àß ind'' x = i, ( red313 P ) Œ∂313_int ^ ( x.val * N ) ‚Ä∫ 2 ];
      rw [ show Œ±_true_int = period_int313 1 - period_int313 2 from rfl, map_sub ];
      exact?

/-
Final result for q=313: Frobenius action on alpha depends on c'' N.
-/
theorem final_result_313 {N : ‚Ñï} [Fact (Nat.Prime N)] (hN : N ‚â† 313) (P : Ideal ùìûL313) [P.IsMaximal] [CharP (kP313 P) N] :
  (c'' N = s1'' ‚Üí (red313 P Œ±_true_int) ^ N = red313 P Œ≥_true_int) ‚àß
  (c'' N = s2'' ‚Üí (red313 P Œ±_true_int) ^ N = red313 P Œ≤_true_int) := by
    exact ‚ü® fun h => by erw [ ‚Üê frobenius_alpha313 N hN P, sigma_alpha_eq_gamma_if_s1'' N hN h ], fun h => by erw [ ‚Üê frobenius_alpha313 N hN P, sigma_alpha_eq_beta_if_s2'' N hN h ] ‚ü©
