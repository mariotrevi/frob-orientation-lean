/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f1e85200-2efb-4b56-a019-1c5b75f4b05f

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Proof of the Dream Theorem for q = 937.

We define the cyclotomic field K = Q(zeta_937), its ring of integers Ok, and the Gaussian periods.
We identify a generator g = 7 for which the cubic character values match the s1/s2 definitions.
We prove the Artin property for the extension K/Q.
We prove the main theorem `dream_theorem_937` which states that for a prime N != 937:
- If c(N) = s1, then alpha^N = gamma mod P.
- If c(N) = s2, then alpha^N = beta mod P.
This assumes the period equation `alpha^3 = 937*alpha + 937`.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: b08f138a-15ed-40a2-a0c0-b8f4ce6443e1

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We define the cyclotomic field K for q = 877 and the Gaussian periods. We prove the Dream Theorem for q = 877, which states that the Frobenius automorphism maps the period difference α to β or γ depending on the cubic character of the prime N modulo 877. The proof relies on the Artin property of the Frobenius map and the explicit calculation of the Galois action on the periods.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f1f9f2e4-1b7a-4d8c-ad24-d62d489ea7c9

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: a7add749-96ca-48e2-a89d-fbb216918bc3

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 22a1ac83-9054-4f97-9a50-f0ea72bded01

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: e6ee589a-f550-42ef-89e5-1fd2afd7fa5e

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We defined the constants s1, s2, and the value c(N). We proved lemmas characterizing the cosets C1 and C2 in terms of the 12th power residue symbol (which relates to c(N)). Finally, we proved the main theorem `final_result` which establishes the Frobenius action on alpha (i.e., alpha^N) in terms of beta and gamma, depending on the value of c(N). The proof utilizes the `explicit_frobenius` theorem and the algebraic relations between alpha, beta, and gamma.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 939f55fb-68a7-4ef0-bca3-475f675055ca

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
This module formalizes the proof of the Frobenius Orientation conjecture for q=37.
It defines the cyclotomic field K = Q(zeta_37), the Gaussian periods, and the cubic roots.
It proves the cyclic algebraic relations between these roots and establishes the global Galois action.
It descends to the residue field modulo a prime P lying over N != 37, proving the Artin property.
Finally, it derives the explicit Frobenius action on the reduction of alpha modulo P.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section






















/-
Definitions for q = 937: Field K, zeta, generator g=5 (user said "Let g be a generator", 5 is a primitive root mod 937), cosets H, C1, C2, periods eta0, eta1, eta2, differences alpha, beta, gamma with sign convention, and constants s1, s2, c(N).
-/
abbrev K937 := CyclotomicField 937 ℚ

noncomputable def zeta937 : K937 := IsCyclotomicExtension.zeta 937 ℚ K937

def g937 : ZMod 937 := 5

def H937 : Finset (ZMod 937) := ((Finset.univ : Finset (ZMod 937)).filter (fun x => x ≠ 0)).image (fun x => x^3)

def C1_937 : Finset (ZMod 937) := H937.image (fun x => g937 * x)

def C2_937 : Finset (ZMod 937) := H937.image (fun x => g937^2 * x)

noncomputable def eta937 (S : Finset (ZMod 937)) : K937 := ∑ x ∈ S, zeta937^(x.val)

noncomputable def eta0_937 := eta937 H937
noncomputable def eta1_937 := eta937 C1_937
noncomputable def eta2_937 := eta937 C2_937

noncomputable def alpha_prime_937 := eta0_937 - eta1_937
noncomputable def beta_prime_937 := eta1_937 - eta2_937
noncomputable def gamma_prime_937 := eta2_937 - eta0_937

noncomputable def alpha937 := if alpha_prime_937 * beta_prime_937 * gamma_prime_937 = 937 then alpha_prime_937 else -alpha_prime_937
noncomputable def beta937 := if alpha_prime_937 * beta_prime_937 * gamma_prime_937 = 937 then beta_prime_937 else -beta_prime_937
noncomputable def gamma937 := if alpha_prime_937 * beta_prime_937 * gamma_prime_937 = 937 then gamma_prime_937 else -gamma_prime_937

def s1_937 : ZMod 937 := 614
def s2_937 : ZMod 937 := 322
def c937 (N : ℕ) : ZMod 937 := (N : ZMod 937)^312

/-
Define the ring of integers Ok937 and state the irreducibility of the 937th cyclotomic polynomial.
-/
open scoped BigOperators
open Classical

abbrev Ok937 := NumberField.RingOfIntegers K937

theorem h_irr_937 : Irreducible (Polynomial.cyclotomic 937 ℚ) := by
  exact Polynomial.cyclotomic.irreducible_rat ( by norm_num )

/-
Define the Galois automorphism sigma937.
-/
noncomputable def sigma937 (n : (ZMod 937)ˣ) : K937 ≃ₐ[ℚ] K937 :=
  (IsCyclotomicExtension.autEquivPow K937 h_irr_937).symm n

/-
zeta is integral, and zeta_int is zeta in Ok.
-/
theorem zeta_isIntegral_937 : IsIntegral ℤ zeta937 := by
  refine' ⟨ Polynomial.X ^ 937 - 1, _, _ ⟩;
  · exact Polynomial.monic_X_pow_sub_C _ ( by norm_num );
  · simp +decide [ IsCyclotomicExtension.zeta_spec ];
    unfold zeta937; exact sub_eq_zero_of_eq <| by exact?;

def zeta_int937 : Ok937 := ⟨zeta937, zeta_isIntegral_937⟩

/-
Definitions for integer periods and sign-corrected roots for q=937.
-/
noncomputable def sigma_int937 (n : (ZMod 937)ˣ) : Ok937 ≃ₐ[ℤ] Ok937 :=
  (NumberField.RingOfIntegers.mapAlgEquiv (sigma937 n)).restrictScalars ℤ

noncomputable def eta_int937 (S : Finset (ZMod 937)) : Ok937 := ∑ x ∈ S, zeta_int937^(x.val)

noncomputable def eta0_int937 := eta_int937 H937
noncomputable def eta1_int937 := eta_int937 C1_937
noncomputable def eta2_int937 := eta_int937 C2_937

noncomputable def alpha_prime_int937 := eta0_int937 - eta1_int937
noncomputable def beta_prime_int937 := eta1_int937 - eta2_int937
noncomputable def gamma_prime_int937 := eta2_int937 - eta0_int937

noncomputable def sign_937 : ℤ :=
  if alpha_prime_int937 * beta_prime_int937 * gamma_prime_int937 = (937 : Ok937) then 1 else -1

noncomputable def alpha_int937 := (sign_937 : Ok937) * alpha_prime_int937
noncomputable def beta_int937 := (sign_937 : Ok937) * beta_prime_int937
noncomputable def gamma_int937 := (sign_937 : Ok937) * gamma_prime_int937

noncomputable def alpha937_field : K937 := alpha_int937
noncomputable def beta937_field : K937 := beta_int937
noncomputable def gamma937_field : K937 := gamma_int937

/-
Compute the coefficients for the algebraic relations of beta and gamma in terms of alpha for q=937.
-/
def find_coeffs_937 : IO Unit := do
  let q := 937
  let a := 61
  -- Find p = k*q + 1
  let mut p := 0
  for k in [2:200] do
    let cand := k * q + 1
    if Nat.Prime cand then
      p := cand
      break
  
  if p == 0 then
    IO.println "No prime found"
    return

  IO.println s!"Using prime p = {p}"

  -- Find element of order q
  let mut g_p := 0
  for g in [2:p] do
    let zeta := (g : Nat) ^ ((p - 1) / q) % p
    if zeta != 1 then
      g_p := g
      break
  
  let zeta := (g_p : Nat) ^ ((p - 1) / q) % p
  IO.println s!"zeta = {zeta}"

  -- Cosets of cubic residues mod q
  -- g_q = 5
  let g_q := 5
  let mut H : List Nat := []
  let mut x := 1
  let g_q_3 := (g_q * g_q * g_q) % q
  for _ in [0:(q-1)/3] do
    H := x :: H
    x := (x * g_q_3) % q
  
  let C1 := H.map (fun h => (h * g_q) % q)
  let C2 := H.map (fun h => (h * g_q * g_q) % q)

  -- Periods mod p
  let sum_zeta (S : List Nat) : Nat :=
    S.foldl (fun acc h => (acc + (zeta ^ h) % p) % p) 0
  
  let eta0 := sum_zeta H
  let eta1 := sum_zeta C1
  let eta2 := sum_zeta C2

  -- Differences
  let alpha_prime := (eta0 + p - eta1) % p
  let beta_prime := (eta1 + p - eta2) % p
  let gamma_prime := (eta2 + p - eta0) % p

  -- Check sign convention
  let prod := (alpha_prime * beta_prime) % p * gamma_prime % p
  let q_mod_p := q % p
  
  let mut alpha := 0
  let mut beta := 0
  let mut gamma := 0

  if prod == q_mod_p then
    alpha := alpha_prime
    beta := beta_prime
    gamma := gamma_prime
    IO.println "Sign convention: positive"
  else
    alpha := (p - alpha_prime) % p
    beta := (p - beta_prime) % p
    gamma := (p - gamma_prime) % p
    IO.println "Sign convention: negative"

  -- Solve 61 * beta = c0 + c1 * alpha + c2 * alpha^2 mod p
  let sub (x y : Nat) := (x + p - y) % p
  let mul (x y : Nat) := (x * y) % p
  let add (x y : Nat) := (x + y) % p
  let pow (x n : Nat) := x ^ n % p
  let inv (x : Nat) := x ^ (p - 2) % p

  let det := mul (sub beta alpha) (mul (sub gamma alpha) (sub gamma beta))
  let det_inv := inv det

  let rhs0 := mul 61 beta
  let rhs1 := mul 61 gamma
  let rhs2 := mul 61 alpha

  -- Solve for c0, c1, c2
  -- c0
  let term0 := mul rhs0 (sub (mul beta (mul gamma gamma)) (mul gamma (mul beta beta)))
  let term1 := mul rhs1 (sub (mul gamma (mul alpha alpha)) (mul alpha (mul gamma gamma)))
  let term2 := mul rhs2 (sub (mul alpha (mul beta beta)) (mul beta (mul alpha alpha)))
  let c0 := mul (add term0 (add term1 term2)) det_inv

  -- c1
  let term0_1 := mul 1 (sub (mul rhs1 (mul gamma gamma)) (mul rhs2 (mul beta beta)))
  let term1_1 := mul 1 (sub (mul rhs2 (mul alpha alpha)) (mul rhs0 (mul gamma gamma)))
  let term2_1 := mul 1 (sub (mul rhs0 (mul beta beta)) (mul rhs1 (mul alpha alpha)))
  let c1 := mul (add term0_1 (add term1_1 term2_1)) det_inv

  -- c2
  let term0_2 := mul 1 (sub (mul beta rhs2) (mul gamma rhs1))
  let term1_2 := mul 1 (sub (mul gamma rhs0) (mul alpha rhs2))
  let term2_2 := mul 1 (sub (mul alpha rhs1) (mul beta rhs0))
  let c2 := mul (add term0_2 (add term1_2 term2_2)) det_inv

  let to_signed (x : Nat) : Int :=
    if x > p / 2 then (x : Int) - p else x

  IO.println s!"Coefficients for beta: c0={to_signed c0}, c1={to_signed c1}, c2={to_signed c2}"
  
  -- Also for gamma
  let rhs0_g := mul 61 gamma
  let rhs1_g := mul 61 alpha
  let rhs2_g := mul 61 beta

  let term0_g := mul rhs0_g (sub (mul beta (mul gamma gamma)) (mul gamma (mul beta beta)))
  let term1_g := mul rhs1_g (sub (mul gamma (mul alpha alpha)) (mul alpha (mul gamma gamma)))
  let term2_g := mul rhs2_g (sub (mul alpha (mul beta beta)) (mul beta (mul alpha alpha)))
  let d0 := mul (add term0_g (add term1_g term2_g)) det_inv

  let term0_1g := mul 1 (sub (mul rhs1_g (mul gamma gamma)) (mul rhs2_g (mul beta beta)))
  let term1_1g := mul 1 (sub (mul rhs2_g (mul alpha alpha)) (mul rhs0_g (mul gamma gamma)))
  let term2_1g := mul 1 (sub (mul rhs0_g (mul beta beta)) (mul rhs1_g (mul alpha alpha)))
  let d1 := mul (add term0_1g (add term1_1g term2_1g)) det_inv

  let term0_2g := mul 1 (sub (mul beta rhs2_g) (mul gamma rhs1_g))
  let term1_2g := mul 1 (sub (mul gamma rhs0_g) (mul alpha rhs2_g))
  let term2_2g := mul 1 (sub (mul alpha rhs1_g) (mul beta rhs0_g))
  let d2 := mul (add term0_2g (add term1_2g term2_2g)) det_inv

  IO.println s!"Coefficients for gamma: d0={to_signed d0}, d1={to_signed d1}, d2={to_signed d2}"

#eval find_coeffs_937

/-
Define the assumptions for the Dream Theorem: the period equation and the product of roots.
-/
def DreamAssumptions_937 : Prop :=
  alpha_int937^3 = 937 * alpha_int937 + 937 ∧
  alpha_int937 * beta_int937 * gamma_int937 = 937

/-
Check which s-value corresponds to C1 (beta) and C2 (gamma).
-/
def check_s_values_937 : IO Unit := do
  let q := 937
  let g := 5
  let s1 := 614
  let s2 := 322
  let c (n : Nat) := (n : Nat) ^ ((q - 1) / 3) % q
  
  let cg := c g
  let cg2 := c (g * g)
  
  IO.println s!"c(g) = {cg}"
  IO.println s!"c(g^2) = {cg2}"
  
  if cg == s1 then IO.println "s1 corresponds to C1 (beta)"
  else if cg == s2 then IO.println "s2 corresponds to C1 (beta)"
  else IO.println "s1/s2 do not match C1"

  if cg2 == s1 then IO.println "s1 corresponds to C2 (gamma)"
  else if cg2 == s2 then IO.println "s2 corresponds to C2 (gamma)"
  else IO.println "s1/s2 do not match C2"

#eval check_s_values_937

/-
Full assumptions for the Dream Theorem, including the period equation, product of roots, and the algebraic relations for beta and gamma derived from computation.
-/
def DreamAssumptions_937_Full : Prop :=
  alpha_int937^3 = 937 * alpha_int937 + 937 ∧
  alpha_int937 * beta_int937 * gamma_int937 = 937 ∧
  61 * beta_int937 = 1874 - 26 * alpha_int937 - 3 * alpha_int937^2 ∧
  61 * gamma_int937 = -1874 - 35 * alpha_int937 + 3 * alpha_int937^2

/-
Define N as a unit in ZMod 937.
-/
def N_mod_937 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 937) : (ZMod 937)ˣ :=
  ZMod.unitOfCoprime N (Nat.Coprime.symm ((Nat.coprime_primes (by norm_num) (Fact.out)).mpr hN.symm))

/-
Lemma: sigma_int n maps zeta_int to zeta_int^(n.val).
-/
lemma sigma_int_zeta_pow_937 (n : (ZMod 937)ˣ) :
  sigma_int937 n zeta_int937 = zeta_int937 ^ (n : ZMod 937).val := by
    have h_sigma_zeta : (sigma937 n) zeta937 = zeta937 ^ (n : ZMod 937).val := by
      have h_sigma_def : sigma937 n = (IsCyclotomicExtension.autEquivPow K937 h_irr_937).symm n := by
        rfl
      simp +decide [ h_sigma_def, IsCyclotomicExtension.autEquivPow ];
      erw [ PowerBasis.equivOfMinpoly_gen ];
      rfl;
    exact Subtype.ext h_sigma_zeta

/-
zeta_int^937 = 1.
-/
lemma zeta_int_pow_card_eq_one_937 : zeta_int937 ^ 937 = 1 := by
  have h_zeta_pow : zeta937 ^ 937 = 1 := by
    have h_root : IsPrimitiveRoot zeta937 937 := by
      convert IsCyclotomicExtension.zeta_spec 937 ℚ K937 using 1
    exact h_root.pow_eq_one
  generalize_proofs at *; (
  exact Subtype.ext h_zeta_pow)

/-
zeta_int^n depends only on n mod 937.
-/
lemma zeta_int_pow_eq_pow_mod_937 (n : ℕ) : zeta_int937 ^ n = zeta_int937 ^ (n % 937) := by
  have h_mod : zeta_int937 ^ 937 = 1 := by
    exact?;
  rw [ ← Nat.mod_add_div n 937, pow_add, pow_mul ] ; aesop

/-
The value of N_mod_937 is N % 937.
-/
lemma N_mod_937_val (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 937) :
  (N_mod_937 N hN : ZMod 937).val = N % 937 := by
    exact?

/-
The Artin property holds for the generator zeta: sigma_N(zeta) = zeta^N mod P.
-/
theorem artin_property_zeta_937 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 937) (P : Ideal Ok937) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  Ideal.Quotient.mk P (sigma_int937 (N_mod_937 N hN) zeta_int937) = (Ideal.Quotient.mk P zeta_int937)^N := by
    -- The LHS is `sigma_int937 (N_mod_937 N hN) zeta_int937` modulo P.
    -- By `sigma_int_zeta_pow_937`, this is `zeta_int937 ^ (N_mod_937 N hN).val`.
    -- By `N_mod_937_val`, `(N_mod_937 N hN).val = N % 937`.
    -- So LHS is `zeta_int937 ^ (N % 937)` modulo P.
    have h_lhs : (Ideal.Quotient.mk P) ((sigma_int937 (N_mod_937 N hN)) zeta_int937) = (Ideal.Quotient.mk P) (zeta_int937 ^ (N % 937)) := by
      rw [ sigma_int_zeta_pow_937, N_mod_937_val ];
    -- The RHS is `(zeta_int937 modulo P)^N`, which is `(zeta_int937 ^ N) modulo P`.
    -- By `zeta_int_pow_eq_pow_mod_937`, `zeta_int937 ^ N = zeta_int937 ^ (N % 937)`.
    have h_rhs : (Ideal.Quotient.mk P) zeta_int937 ^ N = (Ideal.Quotient.mk P) (zeta_int937 ^ (N % 937)) := by
      have h_rhs : zeta_int937 ^ N = zeta_int937 ^ (N % 937) := by
        exact zeta_int_pow_eq_pow_mod_937 N;
      rw [ ← h_rhs, map_pow ];
    rw [h_lhs, h_rhs]

/-
The characteristic of Ok937/P is N.
-/
lemma char_Ok937_quot_P (N : ℕ) [Fact (Nat.Prime N)] (P : Ideal Ok937) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  CharP (Ok937 ⧸ P) N := by
    -- Since P lies over N, N is in P. Therefore, when we take the quotient, N becomes zero. Hence, the characteristic of Ok937/P is N.
    have h_char : (Ideal.Quotient.mk P (N : Ok937)) = 0 := by
      rw [ Ideal.Quotient.eq_zero_iff_mem ];
      convert hP.1 using 1;
      constructor <;> intro h;
      · exact hP.1;
      · exact Ideal.mem_comap.mp ( h ▸ Ideal.mem_span_singleton_self _ );
    -- Since $N$ is in $P$, we have $N \equiv 0 \pmod{P}$.
    have hN_zero : (N : Ok937 ⧸ P) = 0 := by
      exact h_char;
    refine' ⟨ fun n => _ ⟩;
    -- If $n = 0$ in the quotient ring, then $n$ is in $P$. Since $P$ lies over $(N)$, $n$ must be a multiple of $N$.
    have h_div : ∀ n : ℕ, (n : Ok937 ⧸ P) = 0 → N ∣ n := by
      intro n hn_zero
      have h_div : (n : ℤ) ∈ P.comap (algebraMap ℤ Ok937) := by
        erw [ Ideal.Quotient.eq_zero_iff_mem ] at hn_zero ; aesop;
      have h_div : (n : ℤ) ∈ Ideal.span {(N : ℤ)} := by
        exact hP.1 ▸ h_div;
      exact Int.natCast_dvd_natCast.mp ( Ideal.mem_span_singleton.mp h_div );
    exact ⟨ h_div n, fun h => by obtain ⟨ k, rfl ⟩ := h; simp +decide [ hN_zero ] ⟩

/-
zeta_int is a primitive 937th root of unity.
-/
lemma zeta_int_isPrimitiveRoot_937 : IsPrimitiveRoot zeta_int937 937 := by
  have h_primitive : IsPrimitiveRoot zeta937 937 := by
    convert IsCyclotomicExtension.zeta_spec 937 ℚ K937 using 11;
  rw [ IsPrimitiveRoot.iff_def ] at *;
  convert h_primitive;
  · bound;
  · erw [ Subtype.mk_eq_mk ] ; aesop

/-
The ring of integers Ok937 is generated by zeta_int937.
-/
theorem Ok937_eq_adjoin : (⊤ : Subalgebra ℤ Ok937) = Algebra.adjoin ℤ {zeta_int937} := by
  have h_integral_closure : IsIntegralClosure (Algebra.adjoin ℤ {zeta937}) ℤ K937 := by
    have h_integral_closure : IsIntegralClosure (Algebra.adjoin ℤ {zeta937}) ℤ (CyclotomicField 937 ℚ) := by
      have h_cyclotomic : IsCyclotomicExtension {937} ℚ (CyclotomicField 937 ℚ) := by
        infer_instance
      have := @IsCyclotomicExtension.Rat.isIntegralClosure_adjoin_singleton_of_prime;
      convert this ( show IsPrimitiveRoot zeta937 937 from ?_ );
      · exact ⟨ by norm_num ⟩;
      · convert h_cyclotomic.zeta_spec;
    exact h_integral_closure;
  have h_integral_closure_eq : ∀ (x : Ok937), x ∈ Algebra.adjoin ℤ {zeta_int937} := by
    have h_integral_closure_eq : ∀ (x : K937), IsIntegral ℤ x → x ∈ Algebra.adjoin ℤ {zeta937} := by
      intro x hx;
      have := h_integral_closure.isIntegral_iff.mp hx;
      obtain ⟨ y, rfl ⟩ := this; exact y.2;
    intro x
    have hx : IsIntegral ℤ (x : K937) := by
      exact x.2;
    have hx_eq : ↑x ∈ Algebra.adjoin ℤ {zeta937} := by
      exact h_integral_closure_eq _ hx;
    rw [ Algebra.adjoin_singleton_eq_range_aeval ] at *;
    obtain ⟨ p, hp ⟩ := hx_eq;
    use p;
    erw [ Polynomial.aeval_def, Polynomial.eval₂_eq_sum_range ] at * ; aesop;
  exact SetLike.ext fun x => by aesop;

/-
The Artin property holds for all elements of Ok937: sigma_N(x) = x^N mod P.
-/
theorem artin_property_937 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 937) (P : Ideal Ok937) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) (x : Ok937) :
  Ideal.Quotient.mk P (sigma_int937 (N_mod_937 N hN) x) = (Ideal.Quotient.mk P x)^N := by
    -- By definition of $Ok937$, we know that $Ok937 = \mathbb{Z}[zeta_int937]$.
    have hOk937_eq_adjoin : (⊤ : Subalgebra ℤ Ok937) = Algebra.adjoin ℤ {zeta_int937} := by
      exact?;
    -- Since $Ok937$ is generated by $zeta_int937$, and the two maps agree on $zeta_int937$, they must be equal on all of $Ok937$.
    have h_maps_eq : ∀ x ∈ Algebra.adjoin ℤ {zeta_int937}, (Ideal.Quotient.mk P) (sigma_int937 (N_mod_937 N hN) x) = (Ideal.Quotient.mk P x)^N := by
      intro x hx
      induction' hx using Algebra.adjoin_induction with x hx ihx;
      · convert artin_property_zeta_937 N hN P hP using 1;
        · grind;
        · grind;
      · -- Since the algebra map is just the inclusion of ℤ into Ok937, and sigma_int937 is the identity on ℤ, we have:
        have h_sigma_int_id : sigma_int937 (N_mod_937 N hN) (algebraMap ℤ Ok937 ihx) = algebraMap ℤ Ok937 ihx := by
          unfold sigma_int937; aesop;
        have h_char : ∀ x : ℤ, (Ideal.Quotient.mk P (algebraMap ℤ Ok937 x))^N = Ideal.Quotient.mk P (algebraMap ℤ Ok937 x) := by
          intro x
          have h_char : (Ideal.Quotient.mk P (algebraMap ℤ Ok937 x)) ^ N = Ideal.Quotient.mk P (algebraMap ℤ Ok937 (x ^ N)) := by
            simp +decide [ ← map_pow ];
            exact?
          generalize_proofs at *; (
          have h_char : x ^ N ≡ x [ZMOD N] := by
            haveI := Fact.mk ( Fact.out : Nat.Prime N ) ; simp +decide [ ← ZMod.intCast_eq_intCast_iff ] ;
          generalize_proofs at *; (
          obtain ⟨ k, hk ⟩ := h_char.symm.dvd; simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ] ;
          have h_char : (Ideal.Quotient.mk P (algebraMap ℤ Ok937 (x ^ N))) = (Ideal.Quotient.mk P (algebraMap ℤ Ok937 x)) := by
            have h_char : (algebraMap ℤ Ok937 (x ^ N)) - (algebraMap ℤ Ok937 x) ∈ P := by
              have h_char : (algebraMap ℤ Ok937 (x ^ N)) - (algebraMap ℤ Ok937 x) = (algebraMap ℤ Ok937 N) * (algebraMap ℤ Ok937 k) := by
                simpa using congr_arg ( algebraMap ℤ Ok937 ) hk
                skip
              generalize_proofs at *; (
              have h_char : (algebraMap ℤ Ok937 N) ∈ P := by
                have h_char : (Ideal.span {(N : ℤ)}) ≤ P.comap (algebraMap ℤ Ok937) := by
                  exact hP.1.le
                generalize_proofs at *; (
                exact h_char <| Ideal.mem_span_singleton_self _)
              generalize_proofs at *; (
              exact ‹ ( algebraMap ℤ Ok937 ) ( x ^ N ) - ( algebraMap ℤ Ok937 ) x = ( algebraMap ℤ Ok937 ) ↑N * ( algebraMap ℤ Ok937 ) k › ▸ P.mul_mem_right _ h_char))
            exact Ideal.Quotient.eq.2 h_char
          generalize_proofs at *; (
          convert h_char using 1
          generalize_proofs at *; (
          exact Eq.symm ( by erw [ map_pow ] ; rfl )))));
        rw [ h_sigma_int_id, h_char ];
      · rename_i hx hy ihx ihy;
        convert congr_arg₂ ( · + · ) ihx ihy using 1 ; ring;
        · exact congr_arg _ ( map_add _ _ _ );
        · have h_char : ∀ (x y : Ok937 ⧸ P), (x + y) ^ N = x ^ N + y ^ N := by
            have h_char : CharP (Ok937 ⧸ P) N := by
              exact?;
            exact?;
          convert h_char _ _ using 1;
          exact?;
      · simp_all +decide [ mul_pow, map_mul ];
    exact h_maps_eq x <| hOk937_eq_adjoin ▸ Algebra.mem_top

/-
The automorphism sigma_n permutes the Gaussian periods by multiplying the set S by n.
-/
lemma sigma_eta_937 (n : (ZMod 937)ˣ) (S : Finset (ZMod 937)) :
  sigma_int937 n (eta_int937 S) = eta_int937 (S.image (fun x => (n : ZMod 937) * x)) := by
    -- By definition of sigma_int937, we have sigma_int937 n (zeta_int937 ^ x) = zeta_int937 ^ (n * x).
    have h_sigma_int_zeta : ∀ x : ZMod 937, sigma_int937 n (zeta_int937 ^ x.val) = zeta_int937 ^ ((n : ZMod 937) * x).val := by
      -- By definition of sigma_int937, we have sigma_int937 n (zeta_int937 ^ x.val) = (sigma_int937 n zeta_int937) ^ x.val.
      intro x
      have h_sigma_int_zeta : sigma_int937 n (zeta_int937 ^ x.val) = (sigma_int937 n zeta_int937) ^ x.val := by
        induction x.val <;> simp_all +decide [ pow_succ ];
      rw [ h_sigma_int_zeta, sigma_int_zeta_pow_937 ];
      rw [ ← pow_mul, ZMod.val_mul ];
      rw [ ← Nat.mod_add_div ( ( n : ZMod 937 ).val * x.val ) 937, pow_add, pow_mul ] ; norm_num [ zeta_int_pow_card_eq_one_937 ];
    unfold eta_int937; aesop;

/-
Multiplication by an element of H permutes the cosets trivially.
-/
lemma action_H_937 (n : ZMod 937) (hn : n ∈ H937) :
  H937.image (fun x => n * x) = H937 ∧
  C1_937.image (fun x => n * x) = C1_937 ∧
  C2_937.image (fun x => n * x) = C2_937 := by
    have h_subgroup : ∀ x ∈ H937, ∀ y ∈ H937, x * y ∈ H937 := by
      native_decide +revert;
    have h_subgroup : ∀ x ∈ H937, ∃ y ∈ H937, x * y = 1 := by
      native_decide +revert;
    have h_subgroup : ∀ x ∈ H937, ∀ y ∈ H937, x * y ∈ H937 ∧ ∀ x ∈ H937, ∃ y ∈ H937, x * y = 1 := by
      exact fun x hx y hy => ⟨ by solve_by_elim, h_subgroup ⟩;
    native_decide +revert

/-
Multiplication by an element of C1 permutes the cosets cyclically (H->C1->C2->H).
-/
lemma action_C1_937 (n : ZMod 937) (hn : n ∈ C1_937) :
  H937.image (fun x => n * x) = C1_937 ∧
  C1_937.image (fun x => n * x) = C2_937 ∧
  C2_937.image (fun x => n * x) = H937 := by
    native_decide +revert

/-
Multiplication by an element of C2 permutes the cosets cyclically (H->C2->C1->H).
-/
lemma action_C2_937 (n : ZMod 937) (hn : n ∈ C2_937) :
  H937.image (fun x => n * x) = C2_937 ∧
  C1_937.image (fun x => n * x) = H937 ∧
  C2_937.image (fun x => n * x) = C1_937 := by
    native_decide +revert

/-
The Galois automorphism sigma_n permutes alpha, beta, gamma according to the coset of n.
-/
theorem global_permutation_937 (n : (ZMod 937)ˣ) :
  ((n : ZMod 937) ∈ C1_937 → sigma_int937 n alpha_int937 = beta_int937) ∧
  ((n : ZMod 937) ∈ C2_937 → sigma_int937 n alpha_int937 = gamma_int937) ∧
  ((n : ZMod 937) ∈ H937 → sigma_int937 n alpha_int937 = alpha_int937) := by
    refine' ⟨ fun hn => _, fun hn => _, fun hn => _ ⟩;
    · -- By definition of $alpha_int937$, we have $sigma_int937 n alpha_int937 = (sign_937 : Ok937) * sigma_int937 n alpha_prime_int937$.
      simp [alpha_int937];
      -- By definition of $alpha_prime_int937$, we have $sigma_int937 n alpha_prime_int937 = eta0_int937 (n*H) - eta0_int937 (n*C1)$.
      have h_sigma_alpha_prime : sigma_int937 n alpha_prime_int937 = eta_int937 (H937.image (fun x => (n : ZMod 937) * x)) - eta_int937 (C1_937.image (fun x => (n : ZMod 937) * x)) := by
        convert congr_arg₂ ( · - · ) ( sigma_eta_937 n H937 ) ( sigma_eta_937 n C1_937 ) using 1;
        exact map_sub _ _ _;
      rw [ h_sigma_alpha_prime, action_C1_937 _ hn |>.1, action_C1_937 _ hn |>.2.1 ];
      rfl;
    · -- By definition of $alpha_int937$, we know that $sigma_int937 n (alpha_int937) = sigma_int937 n (sign * (eta0_int937 - eta1_int937))$.
      simp [alpha_int937];
      unfold alpha_prime_int937 gamma_int937;
      unfold eta0_int937 eta1_int937 gamma_prime_int937;
      rw [ map_sub ]; simp +decide [ Finset.mul_sum _ _ _, Finset.sum_mul _ _ _, Finset.sum_add_distrib, Finset.sum_sub_distrib, mul_sub, sub_mul, mul_assoc, mul_comm, mul_left_comm, Finset.sum_image, Finset.sum_const_zero, zero_add, add_zero, sub_self, MulZeroClass.mul_zero, MulZeroClass.zero_mul, eq_self_iff_true, true_and, sub_eq_add_neg, add_assoc, add_left_comm, add_comm ] ;
      rw [ sigma_eta_937, sigma_eta_937 ];
      rw [ action_C2_937 _ hn |>.1, action_C2_937 _ hn |>.2.1 ] ; aesop;
    · -- By definition of $alpha_int937$, we know that $sigma_int937 n (alpha_int937) = alpha_int937$ if $n \in H937$.
      have h_sigma_alpha : sigma_int937 n (eta0_int937) = eta0_int937 ∧ sigma_int937 n (eta1_int937) = eta1_int937 ∧ sigma_int937 n (eta2_int937) = eta2_int937 := by
        have := action_H_937 n hn;
        exact ⟨ by simpa [ this ] using sigma_eta_937 n H937, by simpa [ this ] using sigma_eta_937 n C1_937, by simpa [ this ] using sigma_eta_937 n C2_937 ⟩;
      unfold alpha_int937;
      unfold alpha_prime_int937; simp +decide [ *, map_mul ] ;

/-
Check if artin_property_937 is defined.
-/
#check artin_property_937

/-
Find a primitive root g such that c(g) = s2.
-/
def find_correct_g : IO Unit := do
  let q := 937
  let s2 := 322
  let c (n : Nat) := (n : Nat) ^ ((q - 1) / 3) % q
  
  for g in [2:q] do
    -- Check if primitive root
    let mut is_prim := true
    let factors := [2, 3, 13] -- factors of 936 = 8 * 9 * 13
    for f in factors do
      if (g : Nat) ^ (936 / f) % q == 1 then
        is_prim := false
        break
    
    if is_prim then
      if c g == s2 then
        IO.println s!"Found good generator: {g}"
        return
  
  IO.println "No generator found"

#eval find_correct_g

/-
c(5) equals s1.
-/
lemma c_val_s1_937 : c937 5 = s1_937 := by
  native_decide +revert

/-
Define the final roots (permuted to match the user's theorem) and their algebraic relations.
-/
noncomputable def alpha_final_937 := gamma_int937
noncomputable def beta_final_937 := beta_int937
noncomputable def gamma_final_937 := alpha_int937

def DreamAssumptions_Final_937 : Prop :=
  alpha_final_937^3 = 937 * alpha_final_937 + 937 ∧
  alpha_final_937 * beta_final_937 * gamma_final_937 = 937 ∧
  61 * beta_final_937 = -1874 - 35 * alpha_final_937 + 3 * alpha_final_937^2 ∧
  61 * gamma_final_937 = 1874 - 26 * alpha_final_937 - 3 * alpha_final_937^2

/-
Define the periods and roots using the generator g=7, which aligns with the user's theorem statement.
-/
def g7 : ZMod 937 := 7

def C1_7 : Finset (ZMod 937) := H937.image (fun x => g7 * x)
def C2_7 : Finset (ZMod 937) := H937.image (fun x => g7^2 * x)

noncomputable def eta1_int_7 := eta_int937 C1_7
noncomputable def eta2_int_7 := eta_int937 C2_7

noncomputable def alpha_prime_int_7 := eta0_int937 - eta1_int_7
noncomputable def beta_prime_int_7 := eta1_int_7 - eta2_int_7
noncomputable def gamma_prime_int_7 := eta2_int_7 - eta0_int937

noncomputable def sign_7 : ℤ :=
  if alpha_prime_int_7 * beta_prime_int_7 * gamma_prime_int_7 = (937 : Ok937) then 1 else -1

noncomputable def alpha_int_7 := (sign_7 : Ok937) * alpha_prime_int_7
noncomputable def beta_int_7 := (sign_7 : Ok937) * beta_prime_int_7
noncomputable def gamma_int_7 := (sign_7 : Ok937) * gamma_prime_int_7

/-
Compute coefficients for g=7.
-/
def find_coeffs_7 : IO Unit := do
  let q := 937
  let a := 61
  -- Find p = k*q + 1
  let mut p := 0
  for k in [2:200] do
    let cand := k * q + 1
    if Nat.Prime cand then
      p := cand
      break
  
  if p == 0 then
    IO.println "No prime found"
    return

  IO.println s!"Using prime p = {p}"

  -- Find element of order q
  let mut g_p := 0
  for g in [2:p] do
    let zeta := (g : Nat) ^ ((p - 1) / q) % p
    if zeta != 1 then
      g_p := g
      break
  
  let zeta := (g_p : Nat) ^ ((p - 1) / q) % p
  IO.println s!"zeta = {zeta}"

  -- Cosets of cubic residues mod q
  -- g_q = 7 (using the good generator)
  let g_q := 7
  let mut H : List Nat := []
  let mut x := 1
  let g_q_3 := (g_q * g_q * g_q) % q
  for _ in [0:(q-1)/3] do
    H := x :: H
    x := (x * g_q_3) % q
  
  let C1 := H.map (fun h => (h * g_q) % q)
  let C2 := H.map (fun h => (h * g_q * g_q) % q)

  -- Periods mod p
  let sum_zeta (S : List Nat) : Nat :=
    S.foldl (fun acc h => (acc + (zeta ^ h) % p) % p) 0
  
  let eta0 := sum_zeta H
  let eta1 := sum_zeta C1
  let eta2 := sum_zeta C2

  -- Differences
  let alpha_prime := (eta0 + p - eta1) % p
  let beta_prime := (eta1 + p - eta2) % p
  let gamma_prime := (eta2 + p - eta0) % p

  -- Check sign convention
  let prod := (alpha_prime * beta_prime) % p * gamma_prime % p
  let q_mod_p := q % p
  
  let mut alpha := 0
  let mut beta := 0
  let mut gamma := 0

  if prod == q_mod_p then
    alpha := alpha_prime
    beta := beta_prime
    gamma := gamma_prime
    IO.println "Sign convention: positive"
  else
    alpha := (p - alpha_prime) % p
    beta := (p - beta_prime) % p
    gamma := (p - gamma_prime) % p
    IO.println "Sign convention: negative"

  -- Solve 61 * beta = c0 + c1 * alpha + c2 * alpha^2 mod p
  let sub (x y : Nat) := (x + p - y) % p
  let mul (x y : Nat) := (x * y) % p
  let add (x y : Nat) := (x + y) % p
  let pow (x n : Nat) := x ^ n % p
  let inv (x : Nat) := x ^ (p - 2) % p

  let det := mul (sub beta alpha) (mul (sub gamma alpha) (sub gamma beta))
  let det_inv := inv det

  let rhs0 := mul 61 beta
  let rhs1 := mul 61 gamma
  let rhs2 := mul 61 alpha

  -- Solve for c0, c1, c2
  -- c0
  let term0 := mul rhs0 (sub (mul beta (mul gamma gamma)) (mul gamma (mul beta beta)))
  let term1 := mul rhs1 (sub (mul gamma (mul alpha alpha)) (mul alpha (mul gamma gamma)))
  let term2 := mul rhs2 (sub (mul alpha (mul beta beta)) (mul beta (mul alpha alpha)))
  let c0 := mul (add term0 (add term1 term2)) det_inv

  -- c1
  let term0_1 := mul 1 (sub (mul rhs1 (mul gamma gamma)) (mul rhs2 (mul beta beta)))
  let term1_1 := mul 1 (sub (mul rhs2 (mul alpha alpha)) (mul rhs0 (mul gamma gamma)))
  let term2_1 := mul 1 (sub (mul rhs0 (mul beta beta)) (mul rhs1 (mul alpha alpha)))
  let c1 := mul (add term0_1 (add term1_1 term2_1)) det_inv

  -- c2
  let term0_2 := mul 1 (sub (mul beta rhs2) (mul gamma rhs1))
  let term1_2 := mul 1 (sub (mul gamma rhs0) (mul alpha rhs2))
  let term2_2 := mul 1 (sub (mul alpha rhs1) (mul beta rhs0))
  let c2 := mul (add term0_2 (add term1_2 term2_2)) det_inv

  let to_signed (x : Nat) : Int :=
    if x > p / 2 then (x : Int) - p else x

  IO.println s!"Coefficients for beta: c0={to_signed c0}, c1={to_signed c1}, c2={to_signed c2}"
  
  -- Also for gamma
  let rhs0_g := mul 61 gamma
  let rhs1_g := mul 61 alpha
  let rhs2_g := mul 61 beta

  let term0_g := mul rhs0_g (sub (mul beta (mul gamma gamma)) (mul gamma (mul beta beta)))
  let term1_g := mul rhs1_g (sub (mul gamma (mul alpha alpha)) (mul alpha (mul gamma gamma)))
  let term2_g := mul rhs2_g (sub (mul alpha (mul beta beta)) (mul beta (mul alpha alpha)))
  let d0 := mul (add term0_g (add term1_g term2_g)) det_inv

  let term0_1g := mul 1 (sub (mul rhs1_g (mul gamma gamma)) (mul rhs2_g (mul beta beta)))
  let term1_1g := mul 1 (sub (mul rhs2_g (mul alpha alpha)) (mul rhs0_g (mul gamma gamma)))
  let term2_1g := mul 1 (sub (mul rhs0_g (mul beta beta)) (mul rhs1_g (mul alpha alpha)))
  let d1 := mul (add term0_1g (add term1_1g term2_1g)) det_inv

  let term0_2g := mul 1 (sub (mul beta rhs2_g) (mul gamma rhs1_g))
  let term1_2g := mul 1 (sub (mul gamma rhs0_g) (mul alpha rhs2_g))
  let term2_2g := mul 1 (sub (mul alpha rhs1_g) (mul beta rhs0_g))
  let d2 := mul (add term0_2g (add term1_2g term2_2g)) det_inv

  IO.println s!"Coefficients for gamma: d0={to_signed d0}, d1={to_signed d1}, d2={to_signed d2}"

#eval find_coeffs_7

/-
Action of H on cosets for g=7.
-/
lemma action_H_7 (n : ZMod 937) (hn : n ∈ H937) :
  H937.image (fun x => n * x) = H937 ∧
  C1_7.image (fun x => n * x) = C1_7 ∧
  C2_7.image (fun x => n * x) = C2_7 := by
    native_decide +revert

/-
Action of C1 on cosets for g=7 (using native_decide).
-/
lemma action_C1_7 (n : ZMod 937) (hn : n ∈ C1_7) :
  H937.image (fun x => n * x) = C1_7 ∧
  C1_7.image (fun x => n * x) = C2_7 ∧
  C2_7.image (fun x => n * x) = H937 := by
  native_decide +revert

/-
Action of C2 on cosets for g=7 (using native_decide).
-/
lemma action_C2_7 (n : ZMod 937) (hn : n ∈ C2_7) :
  H937.image (fun x => n * x) = C2_7 ∧
  C1_7.image (fun x => n * x) = H937 ∧
  C2_7.image (fun x => n * x) = C1_7 := by
  native_decide +revert

/-
The sum of the roots alpha, beta, gamma is 0.
-/
lemma sum_roots_7 : alpha_int_7 + beta_int_7 + gamma_int_7 = 0 := by
  unfold alpha_int_7 beta_int_7 gamma_int_7
  unfold alpha_prime_int_7 beta_prime_int_7 gamma_prime_int_7
  ring

/-
Galois action on alpha_prime for g=7.
-/
lemma sigma_alpha_prime_7 (n : (ZMod 937)ˣ) :
  ((n : ZMod 937) ∈ C1_7 → sigma_int937 n alpha_prime_int_7 = beta_prime_int_7) ∧
  ((n : ZMod 937) ∈ C2_7 → sigma_int937 n alpha_prime_int_7 = gamma_prime_int_7) ∧
  ((n : ZMod 937) ∈ H937 → sigma_int937 n alpha_prime_int_7 = alpha_prime_int_7) := by
    apply Classical.byContradiction
    intro h_contra;
    obtain ⟨h_not_in_C1, h_not_in_C2, h_not_in_H⟩ : (n : ZMod 937) ∉ C1_7 ∧ (n : ZMod 937) ∉ C2_7 ∧ (n : ZMod 937) ∉ H937 := by
      have h_not_in_C1 : (n : ZMod 937) ∉ C1_7 := by
        intro h
        have h_sigma : (sigma_int937 n) alpha_prime_int_7 = beta_prime_int_7 := by
          have h_sigma : (sigma_int937 n) eta0_int937 = eta1_int_7 ∧ (sigma_int937 n) eta1_int_7 = eta2_int_7 ∧ (sigma_int937 n) eta2_int_7 = eta0_int937 := by
            have h_sigma : (sigma_int937 n) eta0_int937 = eta_int937 (H937.image (fun x => (n : ZMod 937) * x)) ∧ (sigma_int937 n) eta1_int_7 = eta_int937 (C1_7.image (fun x => (n : ZMod 937) * x)) ∧ (sigma_int937 n) eta2_int_7 = eta_int937 (C2_7.image (fun x => (n : ZMod 937) * x)) := by
              exact ⟨ sigma_eta_937 n H937, sigma_eta_937 n C1_7, sigma_eta_937 n C2_7 ⟩
              skip
            generalize_proofs at *; (
            have := action_C1_7 n h; simp_all +decide [ Finset.ext_iff ] ;
            exact ⟨ rfl, rfl, rfl ⟩)
          generalize_proofs at *; (
          unfold alpha_prime_int_7 beta_prime_int_7; simp +decide [ h_sigma ] ;)
        generalize_proofs at *; (
        exact h_contra ⟨ fun _ => h_sigma, fun _ => by
          have h_contra : Disjoint C1_7 C2_7 := by
            native_decide +revert
            skip
          generalize_proofs at *; (
          exact False.elim <| Finset.disjoint_left.mp h_contra h ‹_›), fun _ => by
          exact absurd ( Finset.disjoint_left.mp ( show Disjoint C1_7 H937 from by native_decide ) h ‹_› ) ( by decide ) ⟩
        skip)
      have h_not_in_C2 : (n : ZMod 937) ∉ C2_7 := by
        have h_not_in_C2 : (n : ZMod 937) ∉ C2_7 := by
          intro h_in_C2
          have h_sigma : (sigma_int937 n) alpha_prime_int_7 = gamma_prime_int_7 := by
            apply Classical.byContradiction
            intro h_contra;
            have h_sigma : (sigma_int937 n) alpha_prime_int_7 = gamma_prime_int_7 := by
              have h_perm : (sigma_int937 n) alpha_prime_int_7 = (sigma_int937 n) (eta0_int937 - eta1_int_7) := by
                exact?
              have h_perm : (sigma_int937 n) (eta0_int937 - eta1_int_7) = eta_int937 (H937.image (fun x => (n : ZMod 937) * x)) - eta_int937 (C1_7.image (fun x => (n : ZMod 937) * x)) := by
                have h_perm : (sigma_int937 n) eta0_int937 = eta_int937 (H937.image (fun x => (n : ZMod 937) * x)) ∧ (sigma_int937 n) eta1_int_7 = eta_int937 (C1_7.image (fun x => (n : ZMod 937) * x)) := by
                  exact ⟨ sigma_eta_937 n H937, sigma_eta_937 n C1_7 ⟩;
                rw [ map_sub, h_perm.1, h_perm.2 ];
              have h_perm : (Finset.image (fun x => (n : ZMod 937) * x) H937) = C2_7 ∧ (Finset.image (fun x => (n : ZMod 937) * x) C1_7) = H937 := by
                exact ⟨ by simpa using action_C2_7 _ h_in_C2 |>.1, by simpa using action_C2_7 _ h_in_C2 |>.2.1 ⟩;
              simp_all +decide only [sub_eq_iff_eq_add];
              exact h_contra ( by rw [ show gamma_prime_int_7 = eta2_int_7 - eta0_int937 from rfl ] ; rw [ show eta2_int_7 = eta_int937 C2_7 from rfl ] ; rw [ show eta0_int937 = eta_int937 H937 from rfl ] ; abel1 );
            grind
          have h_sigma_in_H : (n : ZMod 937) ∈ H937 → (sigma_int937 n) alpha_prime_int_7 = alpha_prime_int_7 := by
            intro h_in_H
            have h_sigma_in_H : (sigma_int937 n) alpha_prime_int_7 = alpha_prime_int_7 := by
              have h_sigma_in_H : ∀ x ∈ H937, (sigma_int937 n) (eta_int937 H937) = eta_int937 H937 ∧ (sigma_int937 n) (eta_int937 C1_7) = eta_int937 C1_7 ∧ (sigma_int937 n) (eta_int937 C2_7) = eta_int937 C2_7 := by
                intros x hx
                have h_sigma_in_H : (sigma_int937 n) (eta_int937 H937) = eta_int937 (H937.image (fun x => (n : ZMod 937) * x)) ∧ (sigma_int937 n) (eta_int937 C1_7) = eta_int937 (C1_7.image (fun x => (n : ZMod 937) * x)) ∧ (sigma_int937 n) (eta_int937 C2_7) = eta_int937 (C2_7.image (fun x => (n : ZMod 937) * x)) := by
                  exact ⟨ sigma_eta_937 n H937, sigma_eta_937 n C1_7, sigma_eta_937 n C2_7 ⟩;
                exact ⟨ by rw [ h_sigma_in_H.1, action_H_7 _ h_in_H |>.1 ], by rw [ h_sigma_in_H.2.1, action_H_7 _ h_in_H |>.2.1 ], by rw [ h_sigma_in_H.2.2, action_H_7 _ h_in_H |>.2.2 ] ⟩;
              simp +decide [ alpha_prime_int_7, h_sigma_in_H _ h_in_H ];
              exact congr_arg₂ _ ( h_sigma_in_H _ h_in_H |>.1 ) ( h_sigma_in_H _ h_in_H |>.2.1 )
            exact h_sigma_in_H;
          grind;
        exact h_not_in_C2
      have h_not_in_H : (n : ZMod 937) ∉ H937 := by
        intro h_not_in_H
        simp [h_not_in_H] at h_contra;
        apply h_contra;
        · exact fun h => False.elim <| h_not_in_C1 h;
        · exact fun h => False.elim <| h_not_in_C2 h;
        · rw [ show alpha_prime_int_7 = eta0_int937 - eta1_int_7 from rfl, show eta0_int937 = eta_int937 H937 from rfl, show eta1_int_7 = eta_int937 C1_7 from rfl ];
          rw [ map_sub, sigma_eta_937, sigma_eta_937 ];
          rw [ action_H_7 _ h_not_in_H |> And.left, action_H_7 _ h_not_in_H |> And.right |> And.left ]
      exact ⟨h_not_in_C1, h_not_in_C2, h_not_in_H⟩;
    grind

/-
Check s-values for g=7.
-/
def check_s_values_7 : IO Unit := do
  let q := 937
  let g := 7
  let s1 := 614
  let s2 := 322
  let c (n : Nat) := (n : Nat) ^ ((q - 1) / 3) % q
  
  let cg := c g
  let cg2 := c (g * g)
  
  IO.println s!"c(g) = {cg}"
  IO.println s!"c(g^2) = {cg2}"
  
  if cg == s1 then IO.println "s1 corresponds to C1 (beta)"
  else if cg == s2 then IO.println "s2 corresponds to C1 (beta)"
  else IO.println "s1/s2 do not match C1"

  if cg2 == s1 then IO.println "s1 corresponds to C2 (gamma)"
  else if cg2 == s2 then IO.println "s2 corresponds to C2 (gamma)"
  else IO.println "s1/s2 do not match C2"

#eval check_s_values_7

/-
Check if sigma_alpha_prime_7 is defined.
-/
#check sigma_alpha_prime_7

/-
Characterization of cosets by the cubic character c.
-/
lemma c_map_C1_7 (x : ZMod 937) (hx : x ∈ C1_7) : c937 x.val = s2_937 := by
  obtain ⟨h, hh, rfl⟩ := Finset.mem_image.mp hx
  have h_c_mul : c937 (g7 * h).val = c937 g7.val * c937 h.val := by
    native_decide +revert
  have h_c_g : c937 g7.val = s2_937 := by
    native_decide +revert
  have h_c_h : c937 h.val = 1 := by
    native_decide +revert
  rw [h_c_mul, h_c_g, h_c_h, mul_one]

lemma c_map_C2_7 (x : ZMod 937) (hx : x ∈ C2_7) : c937 x.val = s1_937 := by
  obtain ⟨h, hh, rfl⟩ := Finset.mem_image.mp hx
  have h_c_mul : c937 (g7^2 * h).val = c937 (g7^2).val * c937 h.val := by
    native_decide +revert
  have h_c_g2 : c937 (g7^2).val = s1_937 := by
    native_decide +revert
  have h_c_h : c937 h.val = 1 := by
    native_decide +revert
  rw [h_c_mul, h_c_g2, h_c_h, mul_one]

/-
Check if action lemmas are available.
-/
#check action_H_7
#check action_C1_7
#check action_C2_7

/-
Lemmas: if c(n) = s2 then n in C1, if c(n) = s1 then n in C2.
-/
lemma mem_C1_of_c_eq_s2_7 (n : ZMod 937) (hn : n ≠ 0) : c937 n.val = s2_937 → n ∈ C1_7 := by
  intro h
  have h_or : n ∈ H937 ∨ n ∈ C1_7 ∨ n ∈ C2_7 := by
    native_decide +revert
  rcases h_or with hH | hC1 | hC2
  · have hc : c937 n.val = 1 := by native_decide +revert
    rw [hc] at h
    have h_neq : 1 ≠ s2_937 := by native_decide
    contradiction
  · exact hC1
  · have hc : c937 n.val = s1_937 := by
      apply c_map_C2_7 n hC2
    rw [hc] at h
    have h_neq : s1_937 ≠ s2_937 := by native_decide
    contradiction

lemma mem_C2_of_c_eq_s1_7 (n : ZMod 937) (hn : n ≠ 0) : c937 n.val = s1_937 → n ∈ C2_7 := by
  intro h
  have h_or : n ∈ H937 ∨ n ∈ C1_7 ∨ n ∈ C2_7 := by
    native_decide +revert
  rcases h_or with hH | hC1 | hC2
  · have hc : c937 n.val = 1 := by native_decide +revert
    rw [hc] at h
    have h_neq : 1 ≠ s1_937 := by native_decide
    contradiction
  · have hc : c937 n.val = s2_937 := by
      apply c_map_C1_7 n hC1
    rw [hc] at h
    have h_neq : s2_937 ≠ s1_937 := by native_decide
    contradiction
  · exact hC2

/-
The Dream Theorem for q=937.
-/
theorem final_result_937 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 937)
  (P : Ideal Ok937) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  let alpha_bar := Ideal.Quotient.mk P alpha_int_7
  let beta_bar := Ideal.Quotient.mk P beta_int_7
  let gamma_bar := Ideal.Quotient.mk P gamma_int_7
  (c937 N = s1_937 → alpha_bar ^ N = gamma_bar) ∧
  (c937 N = s2_937 → alpha_bar ^ N = beta_bar) := by
    norm_num +zetaDelta at *;
    apply And.intro;
    · intro h
      have h_coset : (N_mod_937 N hN : ZMod 937) ∈ C2_7 := by
        convert mem_C2_of_c_eq_s1_7 _ _ _;
        · have h_unit : (N_mod_937 N hN : ZMod 937).val ≠ 0 := by
            have h_not_div : ¬(937 ∣ N) := by
              exact fun h => hN <| by have := Nat.prime_dvd_prime_iff_eq ( by norm_num : Nat.Prime 937 ) ( Fact.out : Nat.Prime N ) ; tauto;
            simp_all +decide [ ZMod.val_natCast, Nat.dvd_iff_mod_eq_zero ];
            erw [ ZMod.natCast_eq_zero_iff ] ; exact fun h => h_not_div <| Nat.mod_eq_zero_of_dvd h;
          aesop;
        · unfold c937 at *; aesop;
      have h_galois : sigma_int937 (N_mod_937 N hN) alpha_int_7 = gamma_int_7 := by
        apply (sigma_alpha_prime_7 (N_mod_937 N hN)).2.1 h_coset |> fun h => ?_;
        unfold alpha_int_7 gamma_int_7 alpha_prime_int_7 gamma_prime_int_7 at * ; aesop ;
      have := artin_property_937 N hN P hP alpha_int_7; aesop;
    · intro hc
      have hN_in_C1 : (N_mod_937 N hN : ZMod 937) ∈ C1_7 := by
        convert mem_C1_of_c_eq_s2_7 _ _ _;
        · have h_unit : IsUnit (N : ZMod 937) := by
            have h_unit : Nat.gcd N 937 = 1 := by
              exact Nat.Coprime.symm ( Nat.Prime.coprime_iff_not_dvd ( by norm_num : Nat.Prime 937 ) |>.2 fun h => hN <| by have := Nat.prime_dvd_prime_iff_eq ( by norm_num : Nat.Prime 937 ) ( Fact.out : Nat.Prime N ) ; aesop );
            exact?
          generalize_proofs at *;
          convert h_unit.ne_zero using 1;
          exact ⟨ 0, 1, by decide ⟩;
        · unfold c937 at *; aesop;
      -- By the Galois action, we have $\sigma_{N_mod_937 N hN}(\alpha_int_7) = \beta_int_7$.
      have h_galois_action : sigma_int937 (N_mod_937 N hN) alpha_int_7 = beta_int_7 := by
        apply (sigma_alpha_prime_7 (N_mod_937 N hN)).left hN_in_C1 |> fun h => by
          unfold alpha_int_7 beta_int_7 alpha_prime_int_7 beta_prime_int_7 at * ; aesop ;
      rw [ ← h_galois_action, ← artin_property_937 N hN P hP ]

/-
The global permutation of roots for g=7.
-/
lemma global_permutation_7 (n : (ZMod 937)ˣ) :
  ((n : ZMod 937) ∈ C1_7 → sigma_int937 n alpha_int_7 = beta_int_7) ∧
  ((n : ZMod 937) ∈ C2_7 → sigma_int937 n alpha_int_7 = gamma_int_7) ∧
  ((n : ZMod 937) ∈ H937 → sigma_int937 n alpha_int_7 = alpha_int_7) := by
  have h_sign : sigma_int937 n (sign_7 : Ok937) = sign_7 := by
    exact AlgEquiv.commutes (sigma_int937 n) sign_7
  refine' ⟨ fun hn => _, fun hn => _, fun hn => _ ⟩
  · unfold alpha_int_7 beta_int_7
    rw [map_mul, h_sign]
    rw [(sigma_alpha_prime_7 n).1 hn]
  · unfold alpha_int_7 gamma_int_7
    rw [map_mul, h_sign]
    rw [(sigma_alpha_prime_7 n).2.1 hn]
  · unfold alpha_int_7
    rw [map_mul, h_sign]
    rw [(sigma_alpha_prime_7 n).2.2 hn]

/-
The Dream Theorem for q=937 (proven, assuming period equation).
-/
theorem dream_theorem_937 (h_period : alpha_int_7^3 = 937 * alpha_int_7 + 937)
  (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 937)
  (P : Ideal Ok937) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  let alpha_bar := Ideal.Quotient.mk P alpha_int_7
  let beta_bar := Ideal.Quotient.mk P beta_int_7
  let gamma_bar := Ideal.Quotient.mk P gamma_int_7
  (c937 N = s1_937 → alpha_bar ^ N = gamma_bar) ∧
  (c937 N = s2_937 → alpha_bar ^ N = beta_bar) := by
    -- Apply the global permutation lemma to rewrite the Galois action in terms of the cosets.
    apply final_result_937 N hN P hP