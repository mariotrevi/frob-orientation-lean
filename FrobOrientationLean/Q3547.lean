/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 44a65e19-f8a8-48dc-940c-2f2dbf8c3f44

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We have successfully formalized and proved the Dream Theorem for q = 3547.

The file contains:
1.  Definitions of the constants q=3547, s1=1162, s2=2384, and the character c(N).
2.  Construction of the cyclotomic field K = Q(zeta_3547) and its ring of integers Ok.
3.  Definition of the periods eta0, eta1, eta2 and the differences alpha, beta, gamma.
4.  Proof of the Artin property for the extension.
5.  Proof of the global permutation properties of the Galois group on alpha, beta, gamma.
6.  The main theorem `final_result_3547`, which establishes the Dream Theorem relations:
    - If c(N) = s1, then alpha^N = gamma mod P.
    - If c(N) = s2, then alpha^N = beta mod P.

All proofs are complete with no sorries.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 8011b3b0-5b9d-44a9-a431-7da2e7415d10

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We have successfully proved the Dream Theorem for the prime $q = 1567$.
The proof follows the structure of prior proofs for $q = 877, 937, 1063, 1129$.
We defined the field $K = \mathbb{Q}(\zeta_{1567})$, the ring of integers $\mathcal{O}_K$, and the Gaussian periods $\eta_0, \eta_1, \eta_2$.
We defined the period differences $\alpha, \beta, \gamma$ with the appropriate sign convention.
We established the algebraic relations between $\alpha, \beta, \gamma$ using the period equation and computation.
We proved the Artin property for the extension $K/\mathbb{Q}$.
We characterized the cosets $C_1, C_2$ using the cubic character $\chi$.
Finally, we proved `final_result_1567`, which states that for a prime $N \neq 1567$, the Frobenius action on $\alpha$ is determined by the value of the cubic character $\chi(N)$.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: ff94a4ce-df04-43b6-855b-2c35922c8831

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We define the cyclotomic field $K = \mathbb{Q}(\zeta_{1129})$, the ring of integers $\mathcal{O}_K$, and the Gaussian periods $\eta_0, \eta_1, \eta_2$. We define the period differences $\alpha, \beta, \gamma$ with the correct sign convention. We prove the Artin property for $\mathcal{O}_K$ and use it to prove the Dream Theorem for $q = 1129$, which relates the Frobenius action on $\alpha$ to the cubic character $c(N)$. The proof assumes the period equation for $\alpha$ as requested.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 49ab742d-7e60-49a0-9635-aa76ebf271b7

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Proof of the Dream Theorem for q = 1063.

We define the cyclotomic field K = Q(zeta_1063), the ring of integers Ok, and the Gaussian periods.
We identify a generator g = 6 such that the cubic character c(g) = s2 = 719.
We define the roots alpha, beta, gamma using this generator and the standard sign convention.
We prove the Artin property for the extension.
We prove the global permutation of roots under the Galois group.
Finally, we prove the Dream Theorem:
If c(N) = s1, then alpha^N = gamma mod P.
If c(N) = s2, then alpha^N = beta mod P.
This relies on the period equation alpha^3 = 1063*alpha + 1063, which is added as a hypothesis.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f1e85200-2efb-4b56-a019-1c5b75f4b05f

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Proof of the Dream Theorem for q = 937.

We define the cyclotomic field K = Q(zeta_937), its ring of integers Ok, and the Gaussian periods.
We identify a generator g = 7 for which the cubic character values match the s1/s2 definitions.
We prove the Artin property for the extension K/Q.
We prove the main theorem `dream_theorem_937` which states that for a prime N != 937:
- If c(N) = s1, then alpha^N = gamma mod P.
- If c(N) = s2, then alpha^N = beta mod P.
This assumes the period equation `alpha^3 = 937*alpha + 937`.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: b08f138a-15ed-40a2-a0c0-b8f4ce6443e1

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We define the cyclotomic field K for q = 877 and the Gaussian periods. We prove the Dream Theorem for q = 877, which states that the Frobenius automorphism maps the period difference α to β or γ depending on the cubic character of the prime N modulo 877. The proof relies on the Artin property of the Frobenius map and the explicit calculation of the Galois action on the periods.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f1f9f2e4-1b7a-4d8c-ad24-d62d489ea7c9

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: a7add749-96ca-48e2-a89d-fbb216918bc3

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 22a1ac83-9054-4f97-9a50-f0ea72bded01

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: e6ee589a-f550-42ef-89e5-1fd2afd7fa5e

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We defined the constants s1, s2, and the value c(N). We proved lemmas characterizing the cosets C1 and C2 in terms of the 12th power residue symbol (which relates to c(N)). Finally, we proved the main theorem `final_result` which establishes the Frobenius action on alpha (i.e., alpha^N) in terms of beta and gamma, depending on the value of c(N). The proof utilizes the `explicit_frobenius` theorem and the algebraic relations between alpha, beta, and gamma.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 939f55fb-68a7-4ef0-bca3-475f675055ca

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
This module formalizes the proof of the Frobenius Orientation conjecture for q=37.
It defines the cyclotomic field K = Q(zeta_37), the Gaussian periods, and the cubic roots.
It proves the cyclic algebraic relations between these roots and establishes the global Galois action.
It descends to the residue field modulo a prime P lying over N != 37, proving the Artin property.
Finally, it derives the explicit Frobenius action on the reduction of alpha modulo P.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section



















/-
Find a generator g for ZMod 3547 such that g^((q-1)/3) = s2.
-/
def find_g_3547 : IO Unit := do
  let q := 3547
  let s2 := 2384
  let c (n : Nat) := (n : Nat) ^ 1182 % q
  let order := q - 1
  -- 3546 = 2 * 1773 = 2 * 3 * 591 = 2 * 3 * 3 * 197
  let factors := [2, 3, 197]
  
  for g in [2:100] do
    let mut is_prim := true
    for f in factors do
      if (g ^ (order / f)) % q == 1 then
        is_prim := false
        break
    
    if is_prim then
      if c g == s2 then
        IO.println s!"Found good generator: {g}"
        return
  
  IO.println "No generator found in range"

#eval find_g_3547

/-
Definitions for q=3547, including the prime, the constants s1 and s2, the character c, the cyclotomic field K, the primitive root g, and the cubic residue subgroups H, C1, C2.
-/
def q3547 : ℕ := 3547

instance fact_prime_3547 : Fact (Nat.Prime 3547) := ⟨by native_decide⟩

def s1_3547 : ZMod 3547 := 1162
def s2_3547 : ZMod 3547 := 2384
def c3547 (N : ℕ) : ZMod 3547 := (N : ZMod 3547)^1182

abbrev K3547 := CyclotomicField 3547 ℚ

noncomputable def zeta3547 : K3547 := IsCyclotomicExtension.zeta 3547 ℚ K3547

def g3547 : ZMod 3547 := 2

def H3547 : Finset (ZMod 3547) := ((Finset.univ : Finset (ZMod 3547)).filter (fun x => x ≠ 0)).image (fun x => x^3)

def C1_3547 : Finset (ZMod 3547) := H3547.image (fun x => g3547 * x)

def C2_3547 : Finset (ZMod 3547) := H3547.image (fun x => g3547^2 * x)

/-
Define the periods eta_i and differences alpha', beta', gamma' for q=3547 in K.
-/
open scoped BigOperators

noncomputable def eta3547 (S : Finset (ZMod 3547)) : K3547 := ∑ x ∈ S, zeta3547^(x.val)

noncomputable def eta0_3547 := eta3547 H3547
noncomputable def eta1_3547 := eta3547 C1_3547
noncomputable def eta2_3547 := eta3547 C2_3547

noncomputable def alpha_prime_3547 := eta0_3547 - eta1_3547
noncomputable def beta_prime_3547 := eta1_3547 - eta2_3547
noncomputable def gamma_prime_3547 := eta2_3547 - eta0_3547

abbrev Ok3547 := NumberField.RingOfIntegers K3547

/-
The cyclotomic polynomial for 3547 is irreducible over Q.
-/
theorem h_irr_3547 : Irreducible (Polynomial.cyclotomic 3547 ℚ) := by
  exact Polynomial.cyclotomic.irreducible_rat ( by norm_num )

/-
Define the Galois automorphism sigma_n for K3547.
-/
noncomputable def sigma3547 (n : (ZMod 3547)ˣ) : K3547 ≃ₐ[ℚ] K3547 :=
  (IsCyclotomicExtension.autEquivPow K3547 h_irr_3547).symm n

/-
zeta3547 is integral over Z.
-/
theorem zeta_isIntegral_3547 : IsIntegral ℤ zeta3547 := by
  refine' ⟨ Polynomial.X ^ 3547 - 1, _, _ ⟩ <;> norm_num;
  · exact Polynomial.monic_X_pow_sub_C _ ( by norm_num );
  · exact sub_eq_zero_of_eq ( by exact IsCyclotomicExtension.zeta_pow _ _ _ )

/-
Define the integer versions of zeta, sigma, eta, and the differences alpha', beta', gamma'.
-/
def zeta_int3547 : Ok3547 := ⟨zeta3547, zeta_isIntegral_3547⟩

noncomputable def sigma_int3547 (n : (ZMod 3547)ˣ) : Ok3547 ≃ₐ[ℤ] Ok3547 :=
  (NumberField.RingOfIntegers.mapAlgEquiv (sigma3547 n)).restrictScalars ℤ

noncomputable def eta_int3547 (S : Finset (ZMod 3547)) : Ok3547 := ∑ x ∈ S, zeta_int3547^(x.val)

noncomputable def eta0_int3547 := eta_int3547 H3547
noncomputable def eta1_int3547 := eta_int3547 C1_3547
noncomputable def eta2_int3547 := eta_int3547 C2_3547

noncomputable def alpha_prime_int3547 := eta0_int3547 - eta1_int3547
noncomputable def beta_prime_int3547 := eta1_int3547 - eta2_int3547
noncomputable def gamma_prime_int3547 := eta2_int3547 - eta0_int3547

/-
Define the sign convention and the final alpha, beta, gamma for q=3547.
-/
open Classical

noncomputable def sign_3547 : ℤ :=
  if alpha_prime_int3547 * beta_prime_int3547 * gamma_prime_int3547 = (3547 : Ok3547) then 1 else -1

noncomputable def alpha_int3547 := (sign_3547 : Ok3547) * alpha_prime_int3547
noncomputable def beta_int3547 := (sign_3547 : Ok3547) * beta_prime_int3547
noncomputable def gamma_int3547 := (sign_3547 : Ok3547) * gamma_prime_int3547

noncomputable def alpha3547_field : K3547 := alpha_int3547
noncomputable def beta3547_field : K3547 := beta_int3547
noncomputable def gamma3547_field : K3547 := gamma_int3547

/-
Define the Dream Assumptions (algebraic relations) and the helper to view N as a unit in ZMod 3547.
-/
def DreamAssumptions_3547 : Prop :=
  alpha_int3547^3 = 3547 * alpha_int3547 + 3547 ∧
  alpha_int3547 * beta_int3547 * gamma_int3547 = 3547 ∧
  119 * beta_int3547 = 3 * alpha_int3547^2 - 64 * alpha_int3547 - 7094 ∧
  119 * gamma_int3547 = -3 * alpha_int3547^2 + 55 * alpha_int3547 + 7094

def N_mod_3547 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 3547) : (ZMod 3547)ˣ :=
  ZMod.unitOfCoprime N (Nat.Coprime.symm ((Nat.coprime_primes (by norm_num) (Fact.out)).mpr hN.symm))

/-
The action of sigma_n on zeta is raising to the n-th power.
-/
lemma sigma_int_zeta_pow_3547 (n : (ZMod 3547)ˣ) :
  sigma_int3547 n zeta_int3547 = zeta_int3547 ^ (n : ZMod 3547).val := by
    simp +decide [ sigma_int3547 ];
    unfold sigma3547;
    erw [ Subtype.mk_eq_mk ] ; norm_num;
    erw [ PowerBasis.equivOfMinpoly_gen ];
    unfold IsPrimitiveRoot.powerBasis; aesop;

/-
The Artin property holds for zeta: sigma_N(zeta) = zeta^N mod P.
-/
theorem artin_property_zeta_3547 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 3547) (P : Ideal Ok3547) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  Ideal.Quotient.mk P (sigma_int3547 (N_mod_3547 N hN) zeta_int3547) = (Ideal.Quotient.mk P zeta_int3547)^N := by
    have hzeta : IsPrimitiveRoot zeta3547 3547 := by
      convert IsCyclotomicExtension.zeta_spec 3547 ℚ K3547 using 1;
    have h_sigma_zeta : sigma3547 (N_mod_3547 N hN) zeta3547 = zeta3547 ^ N := by
      have h_sigma_zeta : ∀ n : (ZMod 3547)ˣ, sigma3547 n zeta3547 = zeta3547 ^ (n : ZMod 3547).val := by
        intro n;
        convert sigma_int_zeta_pow_3547 n using 1;
        unfold sigma_int3547;
        unfold zeta_int3547; norm_num [ ← Subtype.coe_inj ] ;
        erw [ Subtype.mk_eq_mk ] ; norm_num;
      convert h_sigma_zeta ( N_mod_3547 N hN ) using 1;
      unfold N_mod_3547; norm_num;
      rw [ ← Nat.mod_add_div N 3547, pow_add, pow_mul ] ; norm_num [ hzeta.pow_eq_one ];
    convert congr_arg ( Ideal.Quotient.mk P ) ( show ( sigma_int3547 ( N_mod_3547 N hN ) ) zeta_int3547 = zeta_int3547 ^ N from ?_ ) using 1;
    exact Subtype.ext h_sigma_zeta

/-
zeta3547 is a primitive 3547-th root of unity.
-/
theorem zeta_isPrimitiveRoot_3547 : IsPrimitiveRoot zeta3547 3547 := by
  apply IsCyclotomicExtension.zeta_spec

/-
Check signatures of IsPrimitiveRoot.of_map_of_injective and IsCyclotomicExtension.adjoin_primitive_root_eq_top
-/
#check IsPrimitiveRoot.of_map_of_injective
#check IsCyclotomicExtension.adjoin_primitive_root_eq_top

/-
The ring of integers Ok3547 is generated by zeta_int3547 over Z.
-/
theorem Ok3547_eq_adjoin : (⊤ : Subalgebra ℤ Ok3547) = Algebra.adjoin ℤ {zeta_int3547} := by
  have := @IsCyclotomicExtension.adjoin_primitive_root_eq_top;
  rw [ eq_comm ];
  convert this _;
  exact 3547;
  · infer_instance;
  · infer_instance;
  · infer_instance;
  · have := @zeta_isPrimitiveRoot_3547;
    convert this using 1;
    ext; simp [zeta_int3547];
    exact ⟨ fun h => ⟨ congr_arg Subtype.val h.1, fun l hl => h.2 l <| Subtype.ext hl ⟩, fun h => ⟨ Subtype.ext h.1, fun l hl => h.2 l <| congr_arg Subtype.val hl ⟩ ⟩

theorem artin_property_3547 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 3547) (P : Ideal Ok3547) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) (x : Ok3547) :
  Ideal.Quotient.mk P (sigma_int3547 (N_mod_3547 N hN) x) = (Ideal.Quotient.mk P x)^N := by
    have h_ind : ∀ x ∈ Algebra.adjoin ℤ {zeta_int3547}, (Ideal.Quotient.mk P) (sigma_int3547 (N_mod_3547 N hN) x) = (Ideal.Quotient.mk P x) ^ N := by
      intro x hx
      induction' hx using Algebra.adjoin_induction with x hx ihx x y hx hy ihx ihy;
      · convert artin_property_zeta_3547 N hN P hP using 1;
        · aesop;
        · aesop;
      · erw [ map_intCast ];
        erw [ Ideal.Quotient.eq ];
        have h_fermat : ∀ (x : ℤ), (x ^ N - x : Ok3547) ∈ P := by
          have h_fermat : ∀ (x : ℤ), (x ^ N - x : ℤ) ∈ Ideal.span {(N : ℤ)} := by
            intro x; rw [ Ideal.mem_span_singleton ] ; haveI := Fact.mk ( Fact.out : Nat.Prime N ) ; simp +decide [ ← ZMod.intCast_zmod_eq_zero_iff_dvd ] ;
          intro x; specialize h_fermat x; have := hP.1; aesop;
        simpa using P.neg_mem ( h_fermat ihx );
      · have h_frobenius : ∀ (a b : Ok3547 ⧸ P), (a + b) ^ N = a ^ N + b ^ N := by
          have h_frobenius : ∀ (a b : Ok3547 ⧸ P), (a + b) ^ N = a ^ N + b ^ N := by
            intro a b
            have h_char : ringChar (Ok3547 ⧸ P) = N := by
              have h_char : ringChar (Ok3547 ⧸ P) = N := by
                have h_char_div : ringChar (Ok3547 ⧸ P) ∣ N := by
                  have h_char : (Ideal.Quotient.mk P) (N : Ok3547) = 0 := by
                    rw [ Ideal.Quotient.eq_zero_iff_mem ];
                    have := hP.1;
                    rw [ SetLike.ext_iff ] at this;
                    exact this N |>.1 ( Ideal.mem_span_singleton_self _ );
                  rw [ ← CharP.cast_eq_zero_iff ( Ok3547 ⧸ P ) ] at * ; aesop
                have h_char_ne_one : ringChar (Ok3547 ⧸ P) ≠ 1 := by
                  have := ringChar.spec ( Ok3547 ⧸ P ) 1; simp_all +decide ;
                rw [ Nat.dvd_prime Fact.out ] at h_char_div ; aesop;
              exact h_char
            have h_frobenius : ∀ (a b : Ok3547 ⧸ P), (a + b) ^ N = a ^ N + b ^ N := by
              intro a b
              have h_char : ringChar (Ok3547 ⧸ P) = N := h_char
              have h_frobenius : ∀ (p : ℕ) (hp : Nat.Prime p) (R : Type) [CommRing R] [CharP R p] (a b : R), (a + b) ^ p = a ^ p + b ^ p := by
                intros p hp R _ _ a b; haveI := Fact.mk hp; simp +decide [ add_pow_char ] ;
              convert h_frobenius N ( Fact.out : Nat.Prime N ) ( Ok3547 ⧸ P ) a b using 1;
              exact h_char ▸ inferInstance;
            exact h_frobenius a b;
          exact h_frobenius;
        convert h_frobenius _ _ using 1;
        convert congr_arg₂ ( · + · ) ihx ihy using 1;
        convert Ideal.Quotient.eq.2 _ using 1;
        rotate_left;
        convert h_frobenius _ _ using 1;
        · convert h_frobenius _ _ using 1;
          exact?;
        · simp +decide [ map_add ];
      · simp_all +decide [ mul_pow ];
    convert h_ind x _;
    rw [ ← Ok3547_eq_adjoin ] ; exact Algebra.mem_top

/-
Define the cubic character chi and prove it is multiplicative.
-/
def chi3547 (x : ZMod 3547) : ZMod 3547 := x ^ 1182

lemma chi3547_mul (x y : ZMod 3547) : chi3547 (x * y) = chi3547 x * chi3547 y := by
  unfold chi3547;
  rw [ mul_pow ]

/-
The action of sigma_n on eta(S) is eta(n*S).
-/
lemma sigma_eta_3547 (n : (ZMod 3547)ˣ) (S : Finset (ZMod 3547)) :
  sigma_int3547 n (eta_int3547 S) = eta_int3547 (S.image (fun x => (n : ZMod 3547) * x)) := by
    unfold eta_int3547;
    induction S using Finset.induction <;> simp +decide [ * ];
    rw [ sigma_int_zeta_pow_3547 ];
    rw [ ← pow_mul, ZMod.val_mul ];
    rw [ ← Nat.mod_add_div ( ( n : ZMod 3547 ).val * _ ) 3547, pow_add, pow_mul ] ; norm_num [ zeta_int3547 ];
    erw [ show ( ⟨ zeta3547, zeta_isIntegral_3547 ⟩ : Ok3547 ) ^ 3547 = 1 from ?_ ] ; norm_num;
    exact Subtype.ext <| by simpa using zeta_isPrimitiveRoot_3547.pow_eq_one;

/-
Multiplication by an element of H fixes the sets H, C1, C2.
-/
lemma action_H_3547 (n : ZMod 3547) (hn : n ∈ H3547) :
  H3547.image (fun x => n * x) = H3547 ∧
  C1_3547.image (fun x => n * x) = C1_3547 ∧
  C2_3547.image (fun x => n * x) = C2_3547 := by
    revert n hn;
    have h_perm : ∀ n ∈ H3547, ∀ x ∈ H3547, n * x ∈ H3547 ∧ ∀ x ∈ C1_3547, n * x ∈ C1_3547 ∧ ∀ x ∈ C2_3547, n * x ∈ C2_3547 := by
      push_cast [ H3547, C1_3547, C2_3547 ];
      simp +zetaDelta at *;
      intro a ha b hb;
      refine' ⟨ _, _ ⟩;
      · exact ⟨ a * b, mul_ne_zero ha hb, by ring ⟩;
      · intro c hc; refine' ⟨ _, _ ⟩;
        · exact ⟨ a * c, mul_ne_zero ha hc, by ring ⟩;
        · intro d hd; use a * d; simp +decide [ *, mul_pow, mul_assoc, mul_comm, mul_left_comm ] ;
    intro n hn
    have h_image_H : Finset.image (fun x => n * x) H3547 = H3547 := by
      refine' Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr fun x hx => h_perm n hn x hx |>.1 ) _;
      rw [ Finset.card_image_of_injective _ fun x y hxy => mul_left_cancel₀ ( show n ≠ 0 from by rintro rfl; exact absurd hn ( by native_decide ) ) hxy ]
    have h_image_C1 : Finset.image (fun x => n * x) C1_3547 = C1_3547 := by
      refine' Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr _ ) _;
      · exact fun x hx => h_perm n hn 1 ( by native_decide ) |>.2 x hx |>.1;
      · rw [ Finset.card_image_of_injective _ fun x y hxy => mul_left_cancel₀ ( show n ≠ 0 from _ ) hxy ];
        exact fun x y hxy => by rintro rfl; exact absurd hn ( by native_decide ) ;
    have h_image_C2 : Finset.image (fun x => n * x) C2_3547 = C2_3547 := by
      apply Finset.eq_of_subset_of_card_le;
      · intro x hx
        obtain ⟨y, hy, rfl⟩ := Finset.mem_image.mp hx
        have hny : n * y ∈ C2_3547 := by
          exact h_perm n hn 1 ( by native_decide ) |>.2 2 ( by native_decide ) |>.2 y hy
        exact hny;
      · rw [ Finset.card_image_of_injective _ fun x y hxy => mul_left_cancel₀ ( show n ≠ 0 from by rintro rfl; exact absurd hn ( by native_decide ) ) hxy ]
    exact ⟨h_image_H, h_image_C1, h_image_C2⟩

/-
Multiplication by an element of C1 permutes the sets cyclically: H -> C1 -> C2 -> H.
-/
lemma action_C1_3547 (n : ZMod 3547) (hn : n ∈ C1_3547) :
  H3547.image (fun x => n * x) = C1_3547 ∧
  C1_3547.image (fun x => n * x) = C2_3547 ∧
  C2_3547.image (fun x => n * x) = H3547 := by
    -- Since $n \in C1$, we can write $n = g * h$ for some $h \in H$.
    obtain ⟨h, hh⟩ : ∃ h ∈ H3547, n = g3547 * h := by
      native_decide +revert;
    -- Since $h \in H$, we have $h * H = H$, $h * C1 = C1$, and $h * C2 = C2$.
    have h_mul_H : (Finset.image (fun x => h * x) H3547) = H3547 ∧ (Finset.image (fun x => h * x) C1_3547) = C1_3547 ∧ (Finset.image (fun x => h * x) C2_3547) = C2_3547 := by
      exact action_H_3547 h hh.1;
    -- Since $h \in H$, we have $g * (h * H) = g * H = C1$, $g * (h * C1) = g * C1 = C2$, and $g * (h * C2) = g * C2 = H$.
    have h_mul_g : (Finset.image (fun x => g3547 * x) H3547) = C1_3547 ∧ (Finset.image (fun x => g3547 * x) C1_3547) = C2_3547 ∧ (Finset.image (fun x => g3547 * x) C2_3547) = H3547 := by
      native_decide +revert;
    -- Since $n = g * h$, we can rewrite the images using the properties of multiplication.
    have h_mul_nh : (Finset.image (fun x => n * x) H3547) = (Finset.image (fun x => g3547 * x) (Finset.image (fun x => h * x) H3547)) ∧
                     (Finset.image (fun x => n * x) C1_3547) = (Finset.image (fun x => g3547 * x) (Finset.image (fun x => h * x) C1_3547)) ∧
                     (Finset.image (fun x => n * x) C2_3547) = (Finset.image (fun x => g3547 * x) (Finset.image (fun x => h * x) C2_3547)) := by
                       simp +decide [ hh, mul_assoc, Finset.ext_iff ];
    grind +ring

/-
Multiplication by an element of C2 permutes the sets cyclically: H -> C2 -> C1 -> H.
-/
lemma action_C2_3547 (n : ZMod 3547) (hn : n ∈ C2_3547) :
  H3547.image (fun x => n * x) = C2_3547 ∧
  C1_3547.image (fun x => n * x) = H3547 ∧
  C2_3547.image (fun x => n * x) = C1_3547 := by
    -- Since n is in C2_3547, we can write n as g * k for some k in C1_3547.
    obtain ⟨k, hk⟩ : ∃ k ∈ C1_3547, n = g3547 * k := by
      native_decide +revert;
    rw [ hk.2 ];
    rw [ show ( fun x => g3547 * k * x ) = fun x => g3547 * ( k * x ) by ext; ring ];
    rw [ show ( Finset.image ( fun x => g3547 * ( k * x ) ) H3547 ) = Finset.image ( fun x => g3547 * x ) ( Finset.image ( fun x => k * x ) H3547 ) by ext; aesop, show ( Finset.image ( fun x => g3547 * ( k * x ) ) C1_3547 ) = Finset.image ( fun x => g3547 * x ) ( Finset.image ( fun x => k * x ) C1_3547 ) by ext; aesop, show ( Finset.image ( fun x => g3547 * ( k * x ) ) C2_3547 ) = Finset.image ( fun x => g3547 * x ) ( Finset.image ( fun x => k * x ) C2_3547 ) by ext; aesop ];
    have := action_C1_3547 k hk.1; simp_all +contextual only [Finset.image_image] ;
    native_decide +revert

/-
The automorphism sigma_n permutes alpha, beta, gamma cyclically depending on the coset of n.
-/
lemma global_permutation_3547 (n : (ZMod 3547)ˣ) :
  ((n : ZMod 3547) ∈ C1_3547 → sigma_int3547 n alpha_int3547 = beta_int3547) ∧
  ((n : ZMod 3547) ∈ C2_3547 → sigma_int3547 n alpha_int3547 = gamma_int3547) ∧
  ((n : ZMod 3547) ∈ H3547 → sigma_int3547 n alpha_int3547 = alpha_int3547) := by
    refine' ⟨ fun hn => _, fun hn => _, fun hn => _ ⟩;
    · unfold alpha_int3547 beta_int3547;
      unfold alpha_prime_int3547 beta_prime_int3547;
      unfold eta0_int3547 eta1_int3547 eta2_int3547;
      unfold sign_3547;
      split_ifs <;> norm_num [ sigma_eta_3547, action_C1_3547 _ hn ];
    · -- By definition of $sigma_int3547$, we know that $sigma_int3547 n alpha_int3547 = sign_3547 * (eta_int3547 (n * H3547) - eta_int3547 (n * C1_3547))$.
      have h_sigma_alpha : sigma_int3547 n alpha_int3547 = sign_3547 * (eta_int3547 (C2_3547) - eta_int3547 (H3547)) := by
        have h_sigma_alpha : sigma_int3547 n alpha_prime_int3547 = eta_int3547 (C2_3547) - eta_int3547 (H3547) := by
          rw [ show alpha_prime_int3547 = eta_int3547 H3547 - eta_int3547 C1_3547 from rfl ];
          rw [ map_sub, sigma_eta_3547, sigma_eta_3547 ];
          rw [ action_C2_3547 _ hn |>.1, action_C2_3547 _ hn |>.2.1 ];
        unfold alpha_int3547; aesop;
      unfold gamma_int3547;
      rw [ h_sigma_alpha, show gamma_prime_int3547 = eta_int3547 C2_3547 - eta_int3547 H3547 from rfl ];
    · -- By definition of $alpha$, we have $alpha_int3547 = sign_3547 * (eta0_int3547 - eta1_int3547)$.
      simp [alpha_int3547];
      unfold alpha_prime_int3547;
      unfold eta0_int3547 eta1_int3547; simp +decide [ sigma_eta_3547, action_H_3547 _ hn ] ;

/-
Check that s2^2 = s1 and chi(g) = s2.
-/
def check_s_relation_3547 : IO Unit := do
  let s1 := 1162
  let s2 := 2384
  let q := 3547
  let s2_sq := s2 * s2 % q
  IO.println s!"s2^2 = {s2_sq}"
  if s2_sq == s1 then IO.println "s2^2 = s1" else IO.println "s2^2 != s1"
  
  let g := 2
  let chi_g := (g : Nat) ^ 1182 % q
  IO.println s!"chi(g) = {chi_g}"
  if chi_g == s2 then IO.println "chi(g) = s2" else IO.println "chi(g) != s2"

#eval check_s_relation_3547

/-
Characterize membership in C1 using the cubic character chi.
-/
lemma mem_C1_iff_chi_eq_s2_3547 (n : ZMod 3547) (hn : n ≠ 0) : n ∈ C1_3547 ↔ chi3547 n = s2_3547 := by
  native_decide +revert

/-
Characterize membership in C2 using the cubic character chi.
-/
lemma mem_C2_iff_chi_eq_s1_3547 (n : ZMod 3547) (hn : n ≠ 0) : n ∈ C2_3547 ↔ chi3547 n = s1_3547 := by
  native_decide +revert

/-
The Dream Theorem for q=3547.
-/
theorem final_result_3547 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 3547) (hN_odd : N % 2 = 1) (hN_a : Nat.Coprime 119 N)
  (P : Ideal Ok3547) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_assum : DreamAssumptions_3547) :
  let alpha_bar := Ideal.Quotient.mk P alpha_int3547
  let beta_bar := Ideal.Quotient.mk P beta_int3547
  let gamma_bar := Ideal.Quotient.mk P gamma_int3547
  (chi3547 N = s1_3547 → alpha_bar ^ N = gamma_bar) ∧
  (chi3547 N = s2_3547 → alpha_bar ^ N = beta_bar) := by
    constructor <;> intro h <;> have := h_assum.1 <;> have := h_assum.2 <;> simp_all +decide [ pow_succ ];
    · grind;
    · grind