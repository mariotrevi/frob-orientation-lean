/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f8a1efac-e2ef-4610-afb7-5ba5f35261f9

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Formalized the Dream Theorem for q = 1489. Defined the cyclotomic field K, the ring of integers Ok, and the Gaussian periods. Defined the sign-corrected roots alpha, beta, gamma. Stated the assumptions (period equation and algebraic relations) in `DreamAssumptions_1489_Final`. Proved the characterization of cosets C1 and C2 by the cubic character c(N). Proved the explicit Frobenius action on alpha in `explicit_frobenius_1489_corrected`. Finally, proved the Dream Theorem in `DreamTheorem_1489_Correct`, showing that the Frobenius automorphism maps alpha to gamma if c(N) = s1, and to beta if c(N) = s2, for any odd prime N != 1489 coprime to 77.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: b4ce42e8-b55b-4115-9e5d-a72c48b2b9f3

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: ff94a4ce-df04-43b6-855b-2c35922c8831

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We define the cyclotomic field $K = \mathbb{Q}(\zeta_{1129})$, the ring of integers $\mathcal{O}_K$, and the Gaussian periods $\eta_0, \eta_1, \eta_2$. We define the period differences $\alpha, \beta, \gamma$ with the correct sign convention. We prove the Artin property for $\mathcal{O}_K$ and use it to prove the Dream Theorem for $q = 1129$, which relates the Frobenius action on $\alpha$ to the cubic character $c(N)$. The proof assumes the period equation for $\alpha$ as requested.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 49ab742d-7e60-49a0-9635-aa76ebf271b7

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Proof of the Dream Theorem for q = 1063.

We define the cyclotomic field K = Q(zeta_1063), the ring of integers Ok, and the Gaussian periods.
We identify a generator g = 6 such that the cubic character c(g) = s2 = 719.
We define the roots alpha, beta, gamma using this generator and the standard sign convention.
We prove the Artin property for the extension.
We prove the global permutation of roots under the Galois group.
Finally, we prove the Dream Theorem:
If c(N) = s1, then alpha^N = gamma mod P.
If c(N) = s2, then alpha^N = beta mod P.
This relies on the period equation alpha^3 = 1063*alpha + 1063, which is added as a hypothesis.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f1e85200-2efb-4b56-a019-1c5b75f4b05f

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Proof of the Dream Theorem for q = 937.

We define the cyclotomic field K = Q(zeta_937), its ring of integers Ok, and the Gaussian periods.
We identify a generator g = 7 for which the cubic character values match the s1/s2 definitions.
We prove the Artin property for the extension K/Q.
We prove the main theorem `dream_theorem_937` which states that for a prime N != 937:
- If c(N) = s1, then alpha^N = gamma mod P.
- If c(N) = s2, then alpha^N = beta mod P.
This assumes the period equation `alpha^3 = 937*alpha + 937`.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: b08f138a-15ed-40a2-a0c0-b8f4ce6443e1

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We define the cyclotomic field K for q = 877 and the Gaussian periods. We prove the Dream Theorem for q = 877, which states that the Frobenius automorphism maps the period difference α to β or γ depending on the cubic character of the prime N modulo 877. The proof relies on the Artin property of the Frobenius map and the explicit calculation of the Galois action on the periods.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f1f9f2e4-1b7a-4d8c-ad24-d62d489ea7c9

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: a7add749-96ca-48e2-a89d-fbb216918bc3

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 22a1ac83-9054-4f97-9a50-f0ea72bded01

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: e6ee589a-f550-42ef-89e5-1fd2afd7fa5e

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We defined the constants s1, s2, and the value c(N). We proved lemmas characterizing the cosets C1 and C2 in terms of the 12th power residue symbol (which relates to c(N)). Finally, we proved the main theorem `final_result` which establishes the Frobenius action on alpha (i.e., alpha^N) in terms of beta and gamma, depending on the value of c(N). The proof utilizes the `explicit_frobenius` theorem and the algebraic relations between alpha, beta, and gamma.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 939f55fb-68a7-4ef0-bca3-475f675055ca

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
This module formalizes the proof of the Frobenius Orientation conjecture for q=37.
It defines the cyclotomic field K = Q(zeta_37), the Gaussian periods, and the cubic roots.
It proves the cyclic algebraic relations between these roots and establishes the global Galois action.
It descends to the residue field modulo a prime P lying over N != 37, proving the Artin property.
Finally, it derives the explicit Frobenius action on the reduction of alpha modulo P.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section


































/-
Definitions for q=1129, s1, s2, and c(N).
-/
def q1129 : ℕ := 1129

instance fact_prime_1129 : Fact (Nat.Prime 1129) := ⟨by native_decide⟩

def s1_1129 : ZMod 1129 := 741
def s2_1129 : ZMod 1129 := 387

def c1129 (N : ℕ) : ZMod 1129 := (N : ZMod 1129) ^ 376

/-
Definitions of the cyclotomic field K, zeta, and the ring of integers Ok for q=1129.
-/
abbrev K1129 := CyclotomicField 1129 ℚ
noncomputable def zeta1129 : K1129 := IsCyclotomicExtension.zeta 1129 ℚ K1129
abbrev Ok1129 := NumberField.RingOfIntegers K1129

/-
Check for primitive roots modulo 1129.
-/
def check_prim_1129 (n : ℕ) : Bool :=
  let p := 1129
  let order := p - 1
  let factors := [2, 3, 47]
  factors.all fun f => (n ^ (order / f)) % p != 1

#eval check_prim_1129 2
#eval check_prim_1129 3
#eval check_prim_1129 5
#eval check_prim_1129 7

/-
Find a primitive root modulo 1129.
-/
def find_g_1129 : IO Unit := do
  let p := 1129
  let order := p - 1
  let factors := [2, 3, 47]
  for g in [2:100] do
    let mut is_prim := true
    for f in factors do
      if (g ^ (order / f)) % p == 1 then
        is_prim := false
        break
    if is_prim then
      IO.println s!"Found primitive root: {g}"
      return
  IO.println "No primitive root found in range"

#eval find_g_1129

/-
Definitions of generator g and cosets H, C1, C2 for q=1129.
-/
def g1129 : ZMod 1129 := 11

def H1129 : Finset (ZMod 1129) := ((Finset.univ : Finset (ZMod 1129)).filter (fun x => x ≠ 0)).image (fun x => x^3)

def C1_1129 : Finset (ZMod 1129) := H1129.image (fun x => g1129 * x)

def C2_1129 : Finset (ZMod 1129) := H1129.image (fun x => g1129^2 * x)

/-
Definitions of Gaussian periods and period differences (alpha', beta', gamma') for q=1129.
-/
open scoped BigOperators

noncomputable def eta1129 (S : Finset (ZMod 1129)) : K1129 := ∑ x ∈ S, zeta1129^(x.val)

noncomputable def eta0_1129 := eta1129 H1129
noncomputable def eta1_1129 := eta1129 C1_1129
noncomputable def eta2_1129 := eta1129 C2_1129

noncomputable def alpha_prime_1129 := eta0_1129 - eta1_1129
noncomputable def beta_prime_1129 := eta1_1129 - eta2_1129
noncomputable def gamma_prime_1129 := eta2_1129 - eta0_1129

/-
The 1129th cyclotomic polynomial is irreducible over Q.
-/
theorem h_irr_1129 : Irreducible (Polynomial.cyclotomic 1129 ℚ) := by
  exact Polynomial.cyclotomic.irreducible_rat <| by decide;

/-
Definitions of Galois automorphisms sigma and sigma_int for q=1129.
-/
noncomputable def sigma1129 (n : (ZMod 1129)ˣ) : K1129 ≃ₐ[ℚ] K1129 :=
  (IsCyclotomicExtension.autEquivPow K1129 h_irr_1129).symm n

noncomputable def sigma_int1129 (n : (ZMod 1129)ˣ) : Ok1129 ≃ₐ[ℤ] Ok1129 :=
  (NumberField.RingOfIntegers.mapAlgEquiv (sigma1129 n)).restrictScalars ℤ

/-
zeta1129 is an algebraic integer.
-/
theorem zeta_isIntegral_1129 : IsIntegral ℤ zeta1129 := by
  -- By definition, $zeta_{1129}$ is a root of the monic polynomial $x^{1129} - 1$ over $\mathbb{Z}$.
  use Polynomial.X ^ 1129 - 1;
  -- Since $zeta_{1129}$ is a root of unity, we have $zeta_{1129}^{1129} = 1$.
  have h_root : zeta1129 ^ 1129 = 1 := by
    convert IsCyclotomicExtension.zeta_pow 1129 ℚ K1129;
  exact ⟨ Polynomial.monic_X_pow_sub_C _ ( by norm_num ), by simp +decide [ h_root ] ⟩

/-
Definitions of integral periods and differences for q=1129.
-/
def zeta_int1129 : Ok1129 := ⟨zeta1129, zeta_isIntegral_1129⟩

noncomputable def eta_int1129 (S : Finset (ZMod 1129)) : Ok1129 := ∑ x ∈ S, zeta_int1129^(x.val)

noncomputable def eta0_int1129 := eta_int1129 H1129
noncomputable def eta1_int1129 := eta_int1129 C1_1129
noncomputable def eta2_int1129 := eta_int1129 C2_1129

noncomputable def alpha_prime_int1129 := eta0_int1129 - eta1_int1129
noncomputable def beta_prime_int1129 := eta1_int1129 - eta2_int1129
noncomputable def gamma_prime_int1129 := eta2_int1129 - eta0_int1129

/-
Definitions of sign-corrected roots alpha, beta, gamma for q=1129.
-/
noncomputable def sign_1129 : ℤ :=
  if alpha_prime_int1129 * beta_prime_int1129 * gamma_prime_int1129 = (1129 : Ok1129) then 1 else -1

noncomputable def alpha_int1129 := (sign_1129 : Ok1129) * alpha_prime_int1129
noncomputable def beta_int1129 := (sign_1129 : Ok1129) * beta_prime_int1129
noncomputable def gamma_int1129 := (sign_1129 : Ok1129) * gamma_prime_int1129

noncomputable def alpha1129_field : K1129 := alpha_int1129
noncomputable def beta1129_field : K1129 := beta_int1129
noncomputable def gamma1129_field : K1129 := gamma_int1129

/-
Compute coefficients for the algebraic relations of beta and gamma in terms of alpha for q=1129.
-/
def find_coeffs_1129 : IO Unit := do
  let q := 1129
  let a := 67
  -- Find p = k*q + 1
  let mut p := 0
  for k in [2:200] do
    let cand := k * q + 1
    if Nat.Prime cand then
      p := cand
      break
  
  if p == 0 then
    IO.println "No prime found"
    return

  IO.println s!"Using prime p = {p}"

  -- Find element of order q
  let mut g_p := 0
  for g in [2:p] do
    let zeta := (g : Nat) ^ ((p - 1) / q) % p
    if zeta != 1 then
      g_p := g
      break
  
  let zeta := (g_p : Nat) ^ ((p - 1) / q) % p
  IO.println s!"zeta = {zeta}"

  -- Cosets of cubic residues mod q
  -- g_q = 11
  let g_q := 11
  let mut H : List Nat := []
  let mut x := 1
  let g_q_3 := (g_q * g_q * g_q) % q
  for _ in [0:(q-1)/3] do
    H := x :: H
    x := (x * g_q_3) % q
  
  let C1 := H.map (fun h => (h * g_q) % q)
  let C2 := H.map (fun h => (h * g_q * g_q) % q)

  -- Periods mod p
  let sum_zeta (S : List Nat) : Nat :=
    S.foldl (fun acc h => (acc + (zeta ^ h) % p) % p) 0
  
  let eta0 := sum_zeta H
  let eta1 := sum_zeta C1
  let eta2 := sum_zeta C2

  -- Differences
  let alpha_prime := (eta0 + p - eta1) % p
  let beta_prime := (eta1 + p - eta2) % p
  let gamma_prime := (eta2 + p - eta0) % p

  -- Check sign convention
  let prod := (alpha_prime * beta_prime) % p * gamma_prime % p
  let q_mod_p := q % p
  
  let mut alpha := 0
  let mut beta := 0
  let mut gamma := 0

  if prod == q_mod_p then
    alpha := alpha_prime
    beta := beta_prime
    gamma := gamma_prime
    IO.println "Sign convention: positive"
  else
    alpha := (p - alpha_prime) % p
    beta := (p - beta_prime) % p
    gamma := (p - gamma_prime) % p
    IO.println "Sign convention: negative"

  -- Solve 67 * beta = c0 + c1 * alpha + c2 * alpha^2 mod p
  let sub (x y : Nat) := (x + p - y) % p
  let mul (x y : Nat) := (x * y) % p
  let add (x y : Nat) := (x + y) % p
  let pow (x n : Nat) := x ^ n % p
  let inv (x : Nat) := x ^ (p - 2) % p

  let det := mul (sub beta alpha) (mul (sub gamma alpha) (sub gamma beta))
  let det_inv := inv det

  let rhs0 := mul 67 beta
  let rhs1 := mul 67 gamma
  let rhs2 := mul 67 alpha

  -- Solve for c0, c1, c2
  -- c0
  let term0 := mul rhs0 (sub (mul beta (mul gamma gamma)) (mul gamma (mul beta beta)))
  let term1 := mul rhs1 (sub (mul gamma (mul alpha alpha)) (mul alpha (mul gamma gamma)))
  let term2 := mul rhs2 (sub (mul alpha (mul beta beta)) (mul beta (mul alpha alpha)))
  let c0 := mul (add term0 (add term1 term2)) det_inv

  -- c1
  let term0_1 := mul 1 (sub (mul rhs1 (mul gamma gamma)) (mul rhs2 (mul beta beta)))
  let term1_1 := mul 1 (sub (mul rhs2 (mul alpha alpha)) (mul rhs0 (mul gamma gamma)))
  let term2_1 := mul 1 (sub (mul rhs0 (mul beta beta)) (mul rhs1 (mul alpha alpha)))
  let c1 := mul (add term0_1 (add term1_1 term2_1)) det_inv

  -- c2
  let term0_2 := mul 1 (sub (mul beta rhs2) (mul gamma rhs1))
  let term1_2 := mul 1 (sub (mul gamma rhs0) (mul alpha rhs2))
  let term2_2 := mul 1 (sub (mul alpha rhs1) (mul beta rhs0))
  let c2 := mul (add term0_2 (add term1_2 term2_2)) det_inv

  let to_signed (x : Nat) : Int :=
    if x > p / 2 then (x : Int) - p else x

  IO.println s!"Coefficients for beta: c0={to_signed c0}, c1={to_signed c1}, c2={to_signed c2}"
  
  -- Also for gamma
  let rhs0_g := mul 67 gamma
  let rhs1_g := mul 67 alpha
  let rhs2_g := mul 67 beta

  let term0_g := mul rhs0_g (sub (mul beta (mul gamma gamma)) (mul gamma (mul beta beta)))
  let term1_g := mul rhs1_g (sub (mul gamma (mul alpha alpha)) (mul alpha (mul gamma gamma)))
  let term2_g := mul rhs2_g (sub (mul alpha (mul beta beta)) (mul beta (mul alpha alpha)))
  let d0 := mul (add term0_g (add term1_g term2_g)) det_inv

  let term0_1g := mul 1 (sub (mul rhs1_g (mul gamma gamma)) (mul rhs2_g (mul beta beta)))
  let term1_1g := mul 1 (sub (mul rhs2_g (mul alpha alpha)) (mul rhs0_g (mul gamma gamma)))
  let term2_1g := mul 1 (sub (mul rhs0_g (mul beta beta)) (mul rhs1_g (mul alpha alpha)))
  let d1 := mul (add term0_1g (add term1_1g term2_1g)) det_inv

  let term0_2g := mul 1 (sub (mul beta rhs2_g) (mul gamma rhs1_g))
  let term1_2g := mul 1 (sub (mul gamma rhs0_g) (mul alpha rhs2_g))
  let term2_2g := mul 1 (sub (mul alpha rhs1_g) (mul beta rhs0_g))
  let d2 := mul (add term0_2g (add term1_2g term2_2g)) det_inv

  IO.println s!"Coefficients for gamma: d0={to_signed d0}, d1={to_signed d1}, d2={to_signed d2}"

#eval find_coeffs_1129

/-
Assumptions for the Dream Theorem for q=1129: period equation, product of roots, and algebraic relations.
-/
def DreamAssumptions_1129 : Prop :=
  alpha_int1129^3 = 1129 * alpha_int1129 + 1129 ∧
  alpha_int1129 * beta_int1129 * gamma_int1129 = 1129 ∧
  67 * beta_int1129 = 3 * alpha_int1129^2 - 38 * alpha_int1129 - 2258 ∧
  67 * gamma_int1129 = -3 * alpha_int1129^2 - 29 * alpha_int1129 + 2258

/-
Define N as a unit mod 1129 and prove sigma maps zeta to zeta^n.
-/
def N_mod_1129 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 1129) : (ZMod 1129)ˣ :=
  ZMod.unitOfCoprime N (Nat.Coprime.symm ((Nat.coprime_primes (by norm_num) (Fact.out)).mpr hN.symm))

lemma sigma_int_zeta_pow_1129 (n : (ZMod 1129)ˣ) :
  sigma_int1129 n zeta_int1129 = zeta_int1129 ^ (n : ZMod 1129).val := by
    unfold sigma_int1129;
    simp +decide [ sigma1129 ];
    erw [ Subtype.mk_eq_mk ];
    erw [ PowerBasis.equivOfMinpoly_gen ];
    exact?

/-
The Artin property holds for zeta: sigma_N(zeta) = zeta^N mod P.
-/
theorem artin_property_zeta_1129 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 1129) (P : Ideal Ok1129) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  Ideal.Quotient.mk P (sigma_int1129 (N_mod_1129 N hN) zeta_int1129) = (Ideal.Quotient.mk P zeta_int1129)^N := by
    rw [sigma_int_zeta_pow_1129];
    -- Since $N \equiv N \mod 1129 \pmod{1129}$, we have $zeta_int1129^N \equiv zeta_int1129^{N \mod 1129} \pmod{P}$.
    have h_cong : zeta_int1129 ^ N = zeta_int1129 ^ (N % 1129) := by
      have h_cong : zeta_int1129 ^ 1129 = 1 := by
        -- Since $zeta_{1129}$ is a primitive 1129th   root  of unity, we have $zeta_{1129}^{1129} = 1$.
        have h_zeta_pow : zeta1129 ^ 1129 = 1 := by
          exact IsPrimitiveRoot.pow_eq_one ( show IsPrimitiveRoot zeta1129 1129 from by exact ( IsCyclotomicExtension.zeta_spec 1129 ℚ K1129 ) )
        generalize_proofs at *; (
        exact Subtype.ext h_zeta_pow);
      rw [ ← Nat.mod_add_div N 1129, pow_add, pow_mul ] ; aesop;
    convert congr_arg ( Ideal.Quotient.mk P ) h_cong.symm using 1

/-
zeta_int1129 is a primitive 1129th root of unity.
-/
lemma zeta_int_isPrimitiveRoot_1129 : IsPrimitiveRoot zeta_int1129 1129 := by
  have h_zeta_prim : IsPrimitiveRoot (IsCyclotomicExtension.zeta 1129 ℚ K1129) 1129 := by
    exact?;
  simp_all +decide [ IsPrimitiveRoot.iff_def ];
  convert h_zeta_prim using 1;
  · erw [ ← Subtype.coe_inj ] ; simp +decide [ zeta_int1129 ];
    erw [ Subtype.mk_eq_mk ] ; norm_num [ zeta1129 ];
  · constructor <;> intro h l hl <;> simp_all +decide [ ← Subtype.coe_inj ];
    convert h l _;
    convert congr_arg Subtype.val hl using 1

theorem Ok1129_eq_adjoin : (⊤ : Subalgebra ℤ Ok1129) = Algebra.adjoin ℤ {zeta_int1129} := by
  apply le_antisymm;
  · have := @IsCyclotomicExtension.Rat.isIntegralClosure_adjoin_singleton_of_prime;
    specialize this ( show IsPrimitiveRoot zeta1129 1129 from ?_ );
    · convert IsCyclotomicExtension.zeta_spec 1129 ℚ K1129;
    · intro x hx;
      have := this.isIntegral_iff.mp ( show IsIntegral ℤ ( x : K1129 ) from by
                                        exact x.2 );
      obtain ⟨ y, hy ⟩ := this;
      rcases y with ⟨ y, hy ⟩;
      rw [ Algebra.adjoin_singleton_eq_range_aeval ] at *;
      obtain ⟨ p, rfl ⟩ := ‹y ∈ ( Polynomial.aeval zeta1129 ).range›;
      use p;
      ext; simp_all +decide [ Polynomial.aeval_def, Polynomial.eval₂_eq_sum_range ] ;
      convert hy using 1;
  · exact le_top

/-
The Artin property holds for all elements of Ok1129: sigma_N(x) = x^N mod P.
-/
theorem artin_property_1129 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 1129) (P : Ideal Ok1129) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) (x : Ok1129) :
  Ideal.Quotient.mk P (sigma_int1129 (N_mod_1129 N hN) x) = (Ideal.Quotient.mk P x)^N := by
    have h_ind : ∀ x ∈ Algebra.adjoin ℤ {zeta_int1129}, Ideal.Quotient.mk P (sigma_int1129 (N_mod_1129 N hN) x) = (Ideal.Quotient.mk P x)^N := by
      intro x hx
      induction' hx using Algebra.adjoin_induction with x hx ih
      generalize_proofs at *; (
      convert artin_property_zeta_1129 N hN P hP using 1 ; aesop
      skip;
      cases hx ; aesop
      skip);
      · -- Since $P$ lies over $N$, we have $N \in P$, which implies that $N \cdot ih \equiv 0 \pmod{P}$ for any integer $ih$.
        have hN_in_P : (N : Ok1129) ∈ P := by
          have := hP.1; simp_all +decide [ Ideal.mem_span_singleton ] ;
          exact Ideal.mem_comap.mp ( this ▸ Ideal.mem_span_singleton_self _ )
        generalize_proofs at *; (
        erw [ Ideal.Quotient.eq ] ; simp_all +decide [ ← ZMod.intCast_eq_intCast_iff ] ;
        have h_fermat : ∀ (ih : ℤ), (ih : Ok1129) ^ N - ih ∈ P := by
          intro ih
          have h_fermat : (ih : ℤ) ^ N - ih ≡ 0 [ZMOD N] := by
            haveI := Fact.mk ( Fact.out : Nat.Prime N ) ; simp +decide [ ← ZMod.intCast_eq_intCast_iff ] ;
          generalize_proofs at *; (
          obtain ⟨ k, hk ⟩ := h_fermat.symm.dvd
          generalize_proofs at *; (
          convert P.mul_mem_right ( k : Ok1129 ) hN_in_P using 1 ; norm_cast ; aesop;))
        generalize_proofs at *; (
        simpa using P.neg_mem ( h_fermat ih ) |> fun h => by simpa using h;));
      · have h_frobenius : ∀ (x y : Ok1129 ⧸ P), (x + y)^N = x^N + y^N := by
          intro x y
          have h_char : CharP (Ok1129 ⧸ P) N := by
            have := hP.1; simp_all +decide [ Ideal.Quotient.eq_zero_iff_mem ] ;
            rw [ eq_comm ] at this;
            rw [ Ideal.ext_iff ] at this;
            refine' ⟨ fun n => _ ⟩;
            erw [ Ideal.Quotient.eq_zero_iff_mem ] ; specialize this n ; simp_all +decide [ Ideal.mem_span_singleton ] ;
            norm_cast
          exact?
        generalize_proofs at *; (
        simp_all +decide [ RingHom.map_add ]);
      · simp_all +decide [ mul_pow ]
    generalize_proofs at *; (
    have := Ok1129_eq_adjoin.symm ▸ Algebra.mem_top ( x := x ) ; aesop;)

/-
The Galois automorphism sigma_n permutes the Gaussian periods by multiplying the set S by n.
-/
lemma sigma_eta_1129 (n : (ZMod 1129)ˣ) (S : Finset (ZMod 1129)) :
  sigma_int1129 n (eta_int1129 S) = eta_int1129 (S.image (fun x => (n : ZMod 1129) * x)) := by
    unfold eta_int1129;
    simp +zetaDelta at *;
    refine' Finset.sum_congr rfl fun x hx => _;
    convert congr_arg ( · ^ x.val ) ( sigma_int_zeta_pow_1129 n ) using 1;
    rw [ ← pow_mul, ZMod.val_mul ];
    rw [ ← Nat.mod_add_div ( ( n : ZMod 1129 ).val * x.val ) 1129, pow_add, pow_mul ] ; norm_num [ zeta_int_isPrimitiveRoot_1129.pow_eq_one ]

/-
Multiplication by an element of H permutes the cosets trivially.
-/
lemma action_H_1129 (n : ZMod 1129) (hn : n ∈ H1129) :
  H1129.image (fun x => n * x) = H1129 ∧
  C1_1129.image (fun x => n * x) = C1_1129 ∧
  C2_1129.image (fun x => n * x) = C2_1129 := by
    native_decide +revert

/-
Multiplication by an element of C1 permutes the cosets cyclically (H->C1->C2->H).
-/
lemma action_C1_1129 (n : ZMod 1129) (hn : n ∈ C1_1129) :
  H1129.image (fun x => n * x) = C1_1129 ∧
  C1_1129.image (fun x => n * x) = C2_1129 ∧
  C2_1129.image (fun x => n * x) = H1129 := by
    refine' ⟨ _, _, _ ⟩;
    · native_decide +revert;
    · native_decide +revert;
    · native_decide +revert

/-
Multiplication by an element of C2 permutes the cosets cyclically (H->C2->C1->H).
-/
lemma action_C2_1129 (n : ZMod 1129) (hn : n ∈ C2_1129) :
  H1129.image (fun x => n * x) = C2_1129 ∧
  C1_1129.image (fun x => n * x) = H1129 ∧
  C2_1129.image (fun x => n * x) = C1_1129 := by
    refine' ⟨ _, _, _ ⟩;
    · native_decide +revert;
    · native_decide +revert;
    · native_decide +revert

/-
The Galois automorphism sigma_n permutes alpha, beta, gamma according to the coset of n.
-/
theorem global_permutation_1129 (n : (ZMod 1129)ˣ) :
  ((n : ZMod 1129) ∈ C1_1129 → sigma_int1129 n alpha_int1129 = beta_int1129) ∧
  ((n : ZMod 1129) ∈ C2_1129 → sigma_int1129 n alpha_int1129 = gamma_int1129) ∧
  ((n : ZMod 1129) ∈ H1129 → sigma_int1129 n alpha_int1129 = alpha_int1129) := by
    refine' ⟨ fun hn => _, fun hn => _, fun hn => _ ⟩;
    · -- By definition of $sigma_int1129$, we know that $sigma_int1129 n alpha_prime_int1129 = beta_prime_int1129$.
      have h_sigma_alpha : sigma_int1129 n alpha_prime_int1129 = beta_prime_int1129 := by
        unfold alpha_prime_int1129 beta_prime_int1129 eta0_int1129 eta1_int1129 eta2_int1129;
        rw [ map_sub, sigma_eta_1129, sigma_eta_1129 ];
        rw [ action_C1_1129 _ hn |>.1, action_C1_1129 _ hn |>.2.1 ];
      unfold alpha_int1129 beta_int1129; aesop;
    · unfold alpha_int1129 gamma_int1129;
      unfold alpha_prime_int1129 gamma_prime_int1129; simp +decide [ mul_assoc, map_mul ] ;
      unfold eta0_int1129 eta1_int1129 eta2_int1129; rw [ sigma_eta_1129, sigma_eta_1129 ] ;
      rw [ action_C2_1129 _ hn |>.1, action_C2_1129 _ hn |>.2.1 ] ; norm_num;
    · -- By definition of $alpha_prime_int1129$, we have $sigma_int1129 n alpha_prime_int1129 = alpha_prime_int1129$.
      have h_sigma_alpha_prime : sigma_int1129 n alpha_prime_int1129 = alpha_prime_int1129 := by
        unfold alpha_prime_int1129;
        unfold eta0_int1129 eta1_int1129; rw [ map_sub ] ;
        rw [ sigma_eta_1129, sigma_eta_1129 ];
        rw [ action_H_1129 _ hn |>.1, action_H_1129 _ hn |>.2.1 ];
      unfold alpha_int1129; aesop;

/-
Check the value of c(g) for q=1129.
-/
def check_c_val_1129 : IO Unit := do
  let q := 1129
  let c (n : Nat) := (n : Nat) ^ 376 % q
  let s1 := 741
  let s2 := 387
  let g := 11
  let cg := c g
  IO.println s!"c(g) = {cg}"
  if cg == s1 then IO.println "c(g) = s1 (so s1 <-> C1)"
  else if cg == s2 then IO.println "c(g) = s2 (so s2 <-> C1)"
  else IO.println "c(g) is neither"

#eval check_c_val_1129

/-
Definition of the cubic character chi1129.
-/
def chi1129 (x : ZMod 1129) : ZMod 1129 := x ^ 376

/-
Multiplicativity of the cubic character chi1129.
-/
lemma chi1129_mul (x y : ZMod 1129) : chi1129 (x * y) = chi1129 x * chi1129 y := by
  unfold chi1129; ring;

/-
The cubic character is 1 on H.
-/
lemma chi1129_val_H (x : ZMod 1129) (hx : x ∈ H1129) : chi1129 x = 1 := by
  native_decide +revert

/-
The cubic character is s2 on C1.
-/
lemma chi1129_val_C1 (x : ZMod 1129) (hx : x ∈ C1_1129) : chi1129 x = s2_1129 := by
  native_decide +revert

/-
The cubic character is s1 on C2.
-/
lemma chi1129_val_C2 (x : ZMod 1129) (hx : x ∈ C2_1129) : chi1129 x = s1_1129 := by
  native_decide +revert

/-
s1 is not equal to s2 mod 1129.
-/
lemma s1_ne_s2_1129 : s1_1129 ≠ s2_1129 := by native_decide

/-
Characterization of C1 by chi values.
-/
lemma mem_C1_iff_chi_eq_s2_1129 (n : ZMod 1129) (hn : n ≠ 0) : n ∈ C1_1129 ↔ chi1129 n = s2_1129 := by
  native_decide +revert

/-
Characterization of C2 by chi values.
-/
lemma mem_C2_iff_chi_eq_s1_1129 (n : ZMod 1129) (hn : n ≠ 0) : n ∈ C2_1129 ↔ chi1129 n = s1_1129 := by
  native_decide +revert

/-
The Dream Theorem for q=1129.
-/
theorem final_result_1129 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 1129) (hN_odd : N % 2 = 1) (hN_a : Nat.Coprime 67 N)
  (P : Ideal Ok1129) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_assum : DreamAssumptions_1129) :
  let alpha_bar := Ideal.Quotient.mk P alpha_int1129
  let beta_bar := Ideal.Quotient.mk P beta_int1129
  let gamma_bar := Ideal.Quotient.mk P gamma_int1129
  (chi1129 N = s1_1129 → alpha_bar ^ N = gamma_bar) ∧
  (chi1129 N = s2_1129 → alpha_bar ^ N = beta_bar) := by
    -- Let $\sigma_N$ be the Frobenius automorphism. By the Artin property, $\bar{\alpha}^N = \overline{\sigma_N(\alpha)}$. If $\chi(N) = s_1$, then $N \in C_2$. By global permutation, $\sigma_N(\alpha) = \gamma$. So $\bar{\alpha}^N = \bar{\gamma}$. If $\chi(N) = s_2$, then $N \in C_1$. By global permutation, $\sigma_N(\alpha) = \beta$. So $\bar{\alpha}^N = \bar{\beta}$.
    apply And.intro (by
    intro hchi1;
    rw [ ← artin_property_1129 ];
    rw [ global_permutation_1129 _ |>.2.1 ];
    any_goals assumption;
    apply (mem_C2_iff_chi_eq_s1_1129 _ _).mpr hchi1;
    intro h; simp_all +decide [ ZMod.natCast_eq_zero_iff ] ;) (by
    intro hchi;
    -- By the Artin property, $\bar{\alpha}^N = \overline{\sigma_N(\alpha)}$.
    have h_artin : (Ideal.Quotient.mk P (sigma_int1129 (N_mod_1129 N hN) alpha_int1129)) = (Ideal.Quotient.mk P alpha_int1129) ^ N := by
      apply artin_property_1129 N hN P hP alpha_int1129;
    rw [ ← h_artin, global_permutation_1129 _ |>.1 ];
    convert mem_C1_iff_chi_eq_s2_1129 _ _ |>.2 hchi;
    intro h; simp_all +decide [ ZMod.natCast_eq_zero_iff ] ;)

/-
Define q=1489, prove it is prime, and define constants s1, s2, and the cubic character c(N).
-/
def q1489 : ℕ := 1489

instance fact_prime_1489 : Fact (Nat.Prime 1489) := ⟨by native_decide⟩

def s1_1489 : ZMod 1489 := 483
def s2_1489 : ZMod 1489 := 1005

def c1489 (N : ℕ) : ZMod 1489 := (N : ZMod 1489) ^ 496

/-
Define the field K1489, zeta1489, Ok1489, and find a primitive root modulo 1489.
-/
abbrev K1489 := CyclotomicField 1489 ℚ
noncomputable def zeta1489 : K1489 := IsCyclotomicExtension.zeta 1489 ℚ K1489
abbrev Ok1489 := NumberField.RingOfIntegers K1489

def find_g_1489 : IO Unit := do
  let p := 1489
  let order := p - 1
  let factors := [2, 3, 31]
  for g in [2:100] do
    let mut is_prim := true
    for f in factors do
      if (g ^ (order / f)) % p == 1 then
        is_prim := false
        break
    if is_prim then
      IO.println s!"Found primitive root: {g}"
      return
  IO.println "No primitive root found in range"

#eval find_g_1489

/-
Define generator and cosets for q=1489.
-/
def g1489 : ZMod 1489 := 14

def H1489 : Finset (ZMod 1489) := ((Finset.univ : Finset (ZMod 1489)).filter (fun x => x ≠ 0)).image (fun x => x^3)

def C1_1489 : Finset (ZMod 1489) := H1489.image (fun x => g1489 * x)

def C2_1489 : Finset (ZMod 1489) := H1489.image (fun x => g1489^2 * x)

/-
Define Gaussian periods and differences for q=1489.
-/
open scoped BigOperators

noncomputable def eta1489 (S : Finset (ZMod 1489)) : K1489 := ∑ x ∈ S, zeta1489^(x.val)

noncomputable def eta0_1489 := eta1489 H1489
noncomputable def eta1_1489 := eta1489 C1_1489
noncomputable def eta2_1489 := eta1489 C2_1489

noncomputable def alpha_prime_1489 := eta0_1489 - eta1_1489
noncomputable def beta_prime_1489 := eta1_1489 - eta2_1489
noncomputable def gamma_prime_1489 := eta2_1489 - eta0_1489

/-
Define irreducibility and Galois automorphism for q=1489.
-/
theorem h_irr_1489 : Irreducible (Polynomial.cyclotomic 1489 ℚ) := by
  exact Polynomial.cyclotomic.irreducible_rat ( by norm_num )

noncomputable def sigma1489 (n : (ZMod 1489)ˣ) : K1489 ≃ₐ[ℚ] K1489 :=
  (IsCyclotomicExtension.autEquivPow K1489 h_irr_1489).symm n

/-
Prove zeta is integral and define zeta_int.
-/
theorem zeta_isIntegral_1489 : IsIntegral ℤ zeta1489 := by
  refine' ⟨ Polynomial.X ^ 1489 - 1, _, _ ⟩;
  · exact Polynomial.monic_X_pow_sub_C _ ( by norm_num );
  · simp +zetaDelta at *;
    exact sub_eq_zero_of_eq <| IsCyclotomicExtension.zeta_pow 1489 ℚ K1489

def zeta_int1489 : Ok1489 := ⟨zeta1489, zeta_isIntegral_1489⟩

/-
Define integral Galois automorphism and integral periods/differences.
-/
noncomputable def sigma_int1489 (n : (ZMod 1489)ˣ) : Ok1489 ≃ₐ[ℤ] Ok1489 :=
  (NumberField.RingOfIntegers.mapAlgEquiv (sigma1489 n)).restrictScalars ℤ

noncomputable def eta_int1489 (S : Finset (ZMod 1489)) : Ok1489 := ∑ x ∈ S, zeta_int1489^(x.val)

noncomputable def eta0_int1489 := eta_int1489 H1489
noncomputable def eta1_int1489 := eta_int1489 C1_1489
noncomputable def eta2_int1489 := eta_int1489 C2_1489

noncomputable def alpha_prime_int1489 := eta0_int1489 - eta1_int1489
noncomputable def beta_prime_int1489 := eta1_int1489 - eta2_int1489
noncomputable def gamma_prime_int1489 := eta2_int1489 - eta0_int1489

/-
Define sign-corrected roots for q=1489.
-/
noncomputable def sign_1489 : ℤ :=
  if alpha_prime_int1489 * beta_prime_int1489 * gamma_prime_int1489 = (1489 : Ok1489) then 1 else -1

noncomputable def alpha_int1489 := (sign_1489 : Ok1489) * alpha_prime_int1489
noncomputable def beta_int1489 := (sign_1489 : Ok1489) * beta_prime_int1489
noncomputable def gamma_int1489 := (sign_1489 : Ok1489) * gamma_prime_int1489

noncomputable def alpha1489_field : K1489 := alpha_int1489
noncomputable def beta1489_field : K1489 := beta_int1489
noncomputable def gamma1489_field : K1489 := gamma_int1489

/-
Compute coefficients for algebraic relations for q=1489.
-/
def find_coeffs_1489 : IO Unit := do
  let q := 1489
  let a := 77
  -- Find p = k*q + 1
  let mut p := 0
  for k in [2:200] do
    let cand := k * q + 1
    if Nat.Prime cand then
      p := cand
      break
  
  if p == 0 then
    IO.println "No prime found"
    return

  IO.println s!"Using prime p = {p}"

  -- Find element of order q
  let mut g_p := 0
  for g in [2:p] do
    let zeta := (g : Nat) ^ ((p - 1) / q) % p
    if zeta != 1 then
      g_p := g
      break
  
  let zeta := (g_p : Nat) ^ ((p - 1) / q) % p
  IO.println s!"zeta = {zeta}"

  -- Cosets of cubic residues mod q
  -- g_q = 14
  let g_q := 14
  let mut H : List Nat := []
  let mut x := 1
  let g_q_3 := (g_q * g_q * g_q) % q
  for _ in [0:(q-1)/3] do
    H := x :: H
    x := (x * g_q_3) % q
  
  let C1 := H.map (fun h => (h * g_q) % q)
  let C2 := H.map (fun h => (h * g_q * g_q) % q)

  -- Periods mod p
  let sum_zeta (S : List Nat) : Nat :=
    S.foldl (fun acc h => (acc + (zeta ^ h) % p) % p) 0
  
  let eta0 := sum_zeta H
  let eta1 := sum_zeta C1
  let eta2 := sum_zeta C2

  -- Differences
  let alpha_prime := (eta0 + p - eta1) % p
  let beta_prime := (eta1 + p - eta2) % p
  let gamma_prime := (eta2 + p - eta0) % p

  -- Check sign convention
  let prod := (alpha_prime * beta_prime) % p * gamma_prime % p
  let q_mod_p := q % p
  
  let mut alpha := 0
  let mut beta := 0
  let mut gamma := 0

  if prod == q_mod_p then
    alpha := alpha_prime
    beta := beta_prime
    gamma := gamma_prime
    IO.println "Sign convention: positive"
  else
    alpha := (p - alpha_prime) % p
    beta := (p - beta_prime) % p
    gamma := (p - gamma_prime) % p
    IO.println "Sign convention: negative"

  -- Solve 77 * beta = c0 + c1 * alpha + c2 * alpha^2 mod p
  let sub (x y : Nat) := (x + p - y) % p
  let mul (x y : Nat) := (x * y) % p
  let add (x y : Nat) := (x + y) % p
  let pow (x n : Nat) := x ^ n % p
  let inv (x : Nat) := x ^ (p - 2) % p

  let det := mul (sub beta alpha) (mul (sub gamma alpha) (sub gamma beta))
  let det_inv := inv det

  let rhs0 := mul 77 beta
  let rhs1 := mul 77 gamma
  let rhs2 := mul 77 alpha

  -- Solve for c0, c1, c2
  -- c0
  let term0 := mul rhs0 (sub (mul beta (mul gamma gamma)) (mul gamma (mul beta beta)))
  let term1 := mul rhs1 (sub (mul gamma (mul alpha alpha)) (mul alpha (mul gamma gamma)))
  let term2 := mul rhs2 (sub (mul alpha (mul beta beta)) (mul beta (mul alpha alpha)))
  let c0 := mul (add term0 (add term1 term2)) det_inv

  -- c1
  let term0_1 := mul 1 (sub (mul rhs1 (mul gamma gamma)) (mul rhs2 (mul beta beta)))
  let term1_1 := mul 1 (sub (mul rhs2 (mul alpha alpha)) (mul rhs0 (mul gamma gamma)))
  let term2_1 := mul 1 (sub (mul rhs0 (mul beta beta)) (mul rhs1 (mul alpha alpha)))
  let c1 := mul (add term0_1 (add term1_1 term2_1)) det_inv

  -- c2
  let term0_2 := mul 1 (sub (mul beta rhs2) (mul gamma rhs1))
  let term1_2 := mul 1 (sub (mul gamma rhs0) (mul alpha rhs2))
  let term2_2 := mul 1 (sub (mul alpha rhs1) (mul beta rhs0))
  let c2 := mul (add term0_2 (add term1_2 term2_2)) det_inv

  let to_signed (x : Nat) : Int :=
    if x > p / 2 then (x : Int) - p else x

  IO.println s!"Coefficients for beta: c0={to_signed c0}, c1={to_signed c1}, c2={to_signed c2}"
  
  -- Also for gamma
  let rhs0_g := mul 77 gamma
  let rhs1_g := mul 77 alpha
  let rhs2_g := mul 77 beta

  let term0_g := mul rhs0_g (sub (mul beta (mul gamma gamma)) (mul gamma (mul beta beta)))
  let term1_g := mul rhs1_g (sub (mul gamma (mul alpha alpha)) (mul alpha (mul gamma gamma)))
  let term2_g := mul rhs2_g (sub (mul alpha (mul beta beta)) (mul beta (mul alpha alpha)))
  let d0 := mul (add term0_g (add term1_g term2_g)) det_inv

  let term0_1g := mul 1 (sub (mul rhs1_g (mul gamma gamma)) (mul rhs2_g (mul beta beta)))
  let term1_1g := mul 1 (sub (mul rhs2_g (mul alpha alpha)) (mul rhs0_g (mul gamma gamma)))
  let term2_1g := mul 1 (sub (mul rhs0_g (mul beta beta)) (mul rhs1_g (mul alpha alpha)))
  let d1 := mul (add term0_1g (add term1_1g term2_1g)) det_inv

  let term0_2g := mul 1 (sub (mul beta rhs2_g) (mul gamma rhs1_g))
  let term1_2g := mul 1 (sub (mul gamma rhs0_g) (mul alpha rhs2_g))
  let term2_2g := mul 1 (sub (mul alpha rhs1_g) (mul beta rhs0_g))
  let d2 := mul (add term0_2g (add term1_2g term2_2g)) det_inv

  IO.println s!"Coefficients for gamma: d0={to_signed d0}, d1={to_signed d1}, d2={to_signed d2}"

#eval find_coeffs_1489

/-
Check c(g) and define DreamAssumptions with computed coefficients.
-/
def check_c_val_1489 : IO Unit := do
  let q := 1489
  let s1 := 483
  let s2 := 1005
  let g := 14
  let c (n : Nat) := (n : Nat) ^ 496 % q
  let cg := c g
  IO.println s!"c(g) = {cg}"
  if cg == s1 then IO.println "c(g) = s1"
  else if cg == s2 then IO.println "c(g) = s2"
  else IO.println "c(g) is neither"

#eval check_c_val_1489

def DreamAssumptions_1489 : Prop :=
  alpha_int1489^3 = 1489 * alpha_int1489 + 1489 ∧
  alpha_int1489 * beta_int1489 * gamma_int1489 = 1489 ∧
  77 * beta_int1489 = -3 * alpha_int1489^2 - 34 * alpha_int1489 + 2978 ∧
  77 * gamma_int1489 = 3 * alpha_int1489^2 - 43 * alpha_int1489 - 2978

/-
Define N as a unit mod 1489.
-/
def N_mod_1489 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 1489) : (ZMod 1489)ˣ :=
  ZMod.unitOfCoprime N (Nat.Coprime.symm ((Nat.coprime_primes (by norm_num) (Fact.out)).mpr hN.symm))

/-
State the Artin property for zeta.
-/
theorem artin_property_zeta_1489 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 1489) (P : Ideal Ok1489) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  Ideal.Quotient.mk P (sigma_int1489 (N_mod_1489 N hN) zeta_int1489) = (Ideal.Quotient.mk P zeta_int1489)^N := by
    -- Since $\zeta$ is a primitive $1489$-th root of unity, we have $\sigma_N(\zeta) = \zeta^N$.
    have h_sigma_zeta : (sigma1489 (N_mod_1489 N hN)) (zeta1489) = zeta1489 ^ N := by
      have h_order : IsPrimitiveRoot zeta1489 1489 := by
        have h_order : IsPrimitiveRoot (IsCyclotomicExtension.zeta 1489 ℚ (CyclotomicField 1489 ℚ)) 1489 := by
          have h_order : IsCyclotomicExtension {1489} ℚ (CyclotomicField 1489 ℚ) := by
            infer_instance
          exact?;
        exact h_order
      unfold sigma1489;
      simp +decide [ IsCyclotomicExtension.autEquivPow, N_mod_1489 ];
      erw [ PowerBasis.equivOfMinpoly_gen ];
      simp +decide [ IsPrimitiveRoot.powerBasis ];
      rw [ ← Nat.mod_add_div N 1489, pow_add, pow_mul ] ; norm_num [ h_order.pow_eq_one ];
      rfl;
    erw [ ← map_pow ];
    congr;
    exact Subtype.ext h_sigma_zeta

/-
Prove that Ok1489 is generated by zeta using the library theorem.
-/
theorem Ok1489_eq_adjoin : (⊤ : Subalgebra ℤ Ok1489) = Algebra.adjoin ℤ {zeta_int1489} := by
  have h_root_of_unity : IsPrimitiveRoot zeta_int1489 1489 := by
    have h_root_of_unity : IsPrimitiveRoot (zeta1489 : K1489) 1489 := by
      convert IsCyclotomicExtension.zeta_spec 1489 ℚ K1489 using 1;
    rw [ IsPrimitiveRoot.iff_def ] at *;
    convert h_root_of_unity;
    · exact iff_of_true ( Subtype.ext h_root_of_unity.1 ) h_root_of_unity.1;
    · erw [ Subtype.ext_iff ] ; norm_num;
      exact?;
  have h_root_of_unity : IsCyclotomicExtension {1489} ℤ Ok1489 := by
    exact?;
  have := h_root_of_unity;
  have := this.adjoin_primitive_root_eq_top ( show IsPrimitiveRoot zeta_int1489 1489 from by assumption ) ; aesop;

/-
Prove the Artin property for all elements of Ok1489.
-/
theorem artin_property_1489 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 1489) (P : Ideal Ok1489) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) (x : Ok1489) :
  Ideal.Quotient.mk P (sigma_int1489 (N_mod_1489 N hN) x) = (Ideal.Quotient.mk P x)^N := by
    have h_gen : ∀ x : Ok1489, Ideal.Quotient.mk P (sigma_int1489 (N_mod_1489 N hN) x) = (Ideal.Quotient.mk P x)^N := by
      intro x
      have h_gen : ∀ x ∈ Algebra.adjoin ℤ {zeta_int1489}, Ideal.Quotient.mk P (sigma_int1489 (N_mod_1489 N hN) x) = (Ideal.Quotient.mk P x)^N := by
        intro x hx
        induction' hx using Algebra.adjoin_induction with x hx ihx x hx ihx
        all_goals generalize_proofs at *;
        · have := artin_property_zeta_1489 N hN P hP; aesop;
        · erw [ Ideal.Quotient.eq ];
          have := hP.1;
          replace this := SetLike.ext_iff.mp this ( ihx ^ N - ihx ) ; simp_all +decide [ ← ZMod.intCast_zmod_eq_zero_iff_dvd, Ideal.mem_span_singleton ] ;
          simpa using P.neg_mem this;
        · rename_i h₁ h₂;
          convert congr_arg₂ ( · + · ) h₁ h₂ using 1;
          · exact congr_arg _ ( map_add _ _ _ );
          · erw [ Ideal.Quotient.eq ];
            have h_expand : (x + hx)^N - x^N - hx^N ∈ P := by
              have h_expand : (x + hx)^N - x^N - hx^N = ∑ k ∈ Finset.Ico 1 N, Nat.choose N k * x^k * hx^(N-k) := by
                rw [ add_pow ];
                rw [ Finset.sum_Ico_eq_sub _ ] <;> norm_num [ mul_assoc, mul_comm, mul_left_comm, Finset.sum_range_succ ];
                exact Nat.Prime.pos Fact.out
              have h_div : ∀ k ∈ Finset.Ico 1 N, (N.choose k : ℤ) ∈ Ideal.span {(N : ℤ)} := by
                exact fun k hk => Ideal.mem_span_singleton.mpr <| mod_cast Nat.dvd_of_mod_eq_zero <| by rw [ Nat.mod_eq_zero_of_dvd ] ; exact Nat.Prime.dvd_choose_self ( Fact.out : Nat.Prime N ) ( by linarith [ Finset.mem_Ico.mp hk ] ) ( by linarith [ Finset.mem_Ico.mp hk ] ) ;
              generalize_proofs at *;
              exact h_expand.symm ▸ Ideal.sum_mem _ fun k hk => Ideal.mul_mem_right _ _ ( Ideal.mul_mem_right _ _ ( hP.1.le ( h_div k hk ) ) )
            generalize_proofs at *;
            simpa only [ sub_add_eq_sub_sub ] using h_expand;
        · simp_all +decide [ mul_pow ]
      convert h_gen x _;
      rw [ ← Ok1489_eq_adjoin ];
      trivial;
    exact h_gen x

/-
Prove the Artin property for all elements of Ok1489 (v2).
-/
theorem artin_property_1489_v2 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 1489) (P : Ideal Ok1489) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) (x : Ok1489) :
  Ideal.Quotient.mk P (sigma_int1489 (N_mod_1489 N hN) x) = (Ideal.Quotient.mk P x)^N := by
    convert artin_property_1489 N hN P hP x using 1

/-
Prove the Artin property for all elements of Ok1489 (proven).
-/
theorem artin_property_1489_proven (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 1489) (P : Ideal Ok1489) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) (x : Ok1489) :
  Ideal.Quotient.mk P (sigma_int1489 (N_mod_1489 N hN) x) = (Ideal.Quotient.mk P x)^N := by
    convert artin_property_1489_v2 N hN P hP x using 1

/-
Prove the Artin property for all elements of Ok1489 (final).
-/
theorem artin_property_1489_final (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 1489) (P : Ideal Ok1489) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) (x : Ok1489) :
  Ideal.Quotient.mk P (sigma_int1489 (N_mod_1489 N hN) x) = (Ideal.Quotient.mk P x)^N := by
    convert artin_property_1489_proven N hN P hP x using 1

/-
Prove that sigma_n permutes the Gaussian periods.
-/
lemma sigma_eta_1489 (n : (ZMod 1489)ˣ) (S : Finset (ZMod 1489)) :
  sigma_int1489 n (eta_int1489 S) = eta_int1489 (S.image (fun x => (n : ZMod 1489) * x)) := by
    have h_sigma_int_zeta : sigma_int1489 n zeta_int1489 = zeta_int1489 ^ (n : ZMod 1489).val := by
      have h_sigma_zeta : ∀ n : (ZMod 1489)ˣ, (sigma1489 n) zeta1489 = zeta1489 ^ (n : ZMod 1489).val := by
        intro n
        unfold sigma1489
        simp [mul_comm, mul_assoc, pow_succ'];
        erw [ PowerBasis.equivOfMinpoly_gen ];
        rfl;
      unfold zeta_int1489; aesop;
    unfold eta_int1489;
    simp +zetaDelta at *;
    refine' Finset.sum_congr rfl fun x hx => _;
    rw [ h_sigma_int_zeta, ← pow_mul, ZMod.val_mul ];
    have h_order : zeta_int1489 ^ 1489 = 1 := by
      have h_zeta_pow : zeta1489 ^ 1489 = 1 := by
        exact IsCyclotomicExtension.zeta_pow _ _ _;
      exact Subtype.ext h_zeta_pow;
    rw [ ← Nat.mod_add_div ( ( n : ZMod 1489 ).val * x.val ) 1489, pow_add, pow_mul ] ; aesop

/-
Prove action of H on cosets using algebraic properties.
-/
lemma action_H_1489 (n : ZMod 1489) (hn : n ∈ H1489) :
  H1489.image (fun x => n * x) = H1489 ∧
  C1_1489.image (fun x => n * x) = C1_1489 ∧
  C2_1489.image (fun x => n * x) = C2_1489 := by
    revert n hn;
    -- Since $n \in H1489$, multiplying by $n$ preserves the set $H1489$.
    have hH : ∀ n ∈ H1489, Finset.image (fun x => n * x) H1489 = H1489 := by
      native_decide;
    exact fun n hn => ⟨ hH n hn, by
      native_decide +revert, by
      native_decide +revert ⟩

/-
Find generator g with c(g) = s2.
-/
def find_correct_g_1489 : IO Unit := do
  let q := 1489
  let s2 := 1005
  let c (n : Nat) := (n : Nat) ^ 496 % q
  let order := q - 1
  let factors := [2, 3, 31]
  
  for g in [2:q] do
    -- Check if primitive root
    let mut is_prim := true
    for f in factors do
      if (g : Nat) ^ (order / f) % q == 1 then
        is_prim := false
        break
    
    if is_prim then
      if c g == s2 then
        IO.println s!"Found good generator: {g}"
        return
  
  IO.println "No generator found"

#eval find_correct_g_1489

/-
Prove action of H on cosets (v2).
-/
lemma action_H_1489_v2 (n : ZMod 1489) (hn : n ∈ H1489) :
  H1489.image (fun x => n * x) = H1489 ∧
  C1_1489.image (fun x => n * x) = C1_1489 ∧
  C2_1489.image (fun x => n * x) = C2_1489 := by
    exact?

/-
Check if action_H_1489 exists.
-/
#check action_H_1489

/-
Prove action of C1 and C2 on cosets.
-/
lemma action_C1_1489 (n : ZMod 1489) (hn : n ∈ C1_1489) :
  H1489.image (fun x => n * x) = C1_1489 ∧
  C1_1489.image (fun x => n * x) = C2_1489 ∧
  C2_1489.image (fun x => n * x) = H1489 := by
    revert n hn;
    -- By definition of $C1$, we know that $n \in C1$ implies $n = g1489 * h$ for some $h \in H$.
    intro n hn
    obtain ⟨h, hh⟩ : ∃ h ∈ H1489, n = g1489 * h := by
      native_decide +revert;
    simp +decide [ hh, mul_left_comm, mul_assoc, Finset.image_image ];
    have h_perm : Finset.image (fun x => h * x) H1489 = H1489 ∧ Finset.image (fun x => h * x) C1_1489 = C1_1489 ∧ Finset.image (fun x => h * x) C2_1489 = C2_1489 := by
      exact action_H_1489 h hh.1;
    have h_perm : Finset.image (fun x => g1489 * x) H1489 = C1_1489 ∧ Finset.image (fun x => g1489 * x) C1_1489 = C2_1489 ∧ Finset.image (fun x => g1489 * x) C2_1489 = H1489 := by
      native_decide +revert;
    have h_perm : Finset.image (fun x => h * (g1489 * x)) H1489 = Finset.image (fun x => h * x) (Finset.image (fun x => g1489 * x) H1489) ∧ Finset.image (fun x => h * (g1489 * x)) C1_1489 = Finset.image (fun x => h * x) (Finset.image (fun x => g1489 * x) C1_1489) ∧ Finset.image (fun x => h * (g1489 * x)) C2_1489 = Finset.image (fun x => h * x) (Finset.image (fun x => g1489 * x) C2_1489) := by
      simp +decide [ Finset.ext_iff ];
    aesop

lemma action_C2_1489 (n : ZMod 1489) (hn : n ∈ C2_1489) :
  H1489.image (fun x => n * x) = C2_1489 ∧
  C1_1489.image (fun x => n * x) = H1489 ∧
  C2_1489.image (fun x => n * x) = C1_1489 := by
    -- Since $n \in C2_1489$, we can write $n = g1489^2 * h$ for some $h \in H1489$.
    obtain ⟨h, hh⟩ : ∃ h ∈ H1489, n = g1489^2 * h := by
      native_decide +revert;
    have h_mul : Finset.image (fun x => h * x) H1489 = H1489 ∧ Finset.image (fun x => h * x) C1_1489 = C1_1489 ∧ Finset.image (fun x => h * x) C2_1489 = C2_1489 := by
      have := action_H_1489 h hh.1; aesop;
    have h_mul_g : Finset.image (fun x => g1489^2 * x) H1489 = C2_1489 ∧ Finset.image (fun x => g1489^2 * x) C1_1489 = H1489 ∧ Finset.image (fun x => g1489^2 * x) C2_1489 = C1_1489 := by
      native_decide +revert;
    have h_mul_g : Finset.image (fun x => g1489^2 * h * x) H1489 = Finset.image (fun x => g1489^2 * x) (Finset.image (fun x => h * x) H1489) ∧ Finset.image (fun x => g1489^2 * h * x) C1_1489 = Finset.image (fun x => g1489^2 * x) (Finset.image (fun x => h * x) C1_1489) ∧ Finset.image (fun x => g1489^2 * h * x) C2_1489 = Finset.image (fun x => g1489^2 * x) (Finset.image (fun x => h * x) C2_1489) := by
      simp +decide [ mul_assoc, Finset.ext_iff ];
    aesop

/-
Check if action_C1_1489 and action_C2_1489 exist.
-/
#check action_C1_1489
#check action_C2_1489

/-
Prove global permutation of roots for q=1489.
-/
theorem global_permutation_1489 (n : (ZMod 1489)ˣ) :
  ((n : ZMod 1489) ∈ C1_1489 → sigma_int1489 n alpha_int1489 = beta_int1489) ∧
  ((n : ZMod 1489) ∈ C2_1489 → sigma_int1489 n alpha_int1489 = gamma_int1489) ∧
  ((n : ZMod 1489) ∈ H1489 → sigma_int1489 n alpha_int1489 = alpha_int1489) := by
  have h_sign : sigma_int1489 n (sign_1489 : Ok1489) = (sign_1489 : Ok1489) := by
    exact AlgEquiv.commutes (sigma_int1489 n) sign_1489
  
  have h_sigma_alpha' : sigma_int1489 n alpha_prime_int1489 = 
    eta_int1489 (H1489.image (fun x => (n : ZMod 1489) * x)) - 
    eta_int1489 (C1_1489.image (fun x => (n : ZMod 1489) * x)) := by
    simp only [alpha_prime_int1489, map_sub, eta0_int1489, eta1_int1489]
    rw [sigma_eta_1489, sigma_eta_1489]
  
  constructor
  · intro hn
    rw [alpha_int1489, beta_int1489, map_mul, h_sign, h_sigma_alpha']
    have h_act := action_C1_1489 n hn
    rw [h_act.1, h_act.2.1]
    simp only [beta_prime_int1489, eta1_int1489, eta2_int1489]
  
  constructor
  · intro hn
    rw [alpha_int1489, gamma_int1489, map_mul, h_sign, h_sigma_alpha']
    have h_act := action_C2_1489 n hn
    rw [h_act.1, h_act.2.1]
    simp only [gamma_prime_int1489, eta2_int1489, eta0_int1489]
  
  · intro hn
    rw [alpha_int1489, map_mul, h_sign, h_sigma_alpha']
    have h_act := action_H_1489 n hn
    rw [h_act.1, h_act.2.1]
    simp only [alpha_prime_int1489, eta0_int1489, eta1_int1489]

/-
Define final generator, cosets, periods, and roots. Verify c(g) = s2.
-/
def g_final : ZMod 1489 := 28

def C1_final : Finset (ZMod 1489) := H1489.image (fun x => g_final * x)
def C2_final : Finset (ZMod 1489) := H1489.image (fun x => g_final^2 * x)

noncomputable def eta1_final := eta_int1489 C1_final
noncomputable def eta2_final := eta_int1489 C2_final

noncomputable def alpha_prime_final := eta0_int1489 - eta1_final
noncomputable def beta_prime_final := eta1_final - eta2_final
noncomputable def gamma_prime_final := eta2_final - eta0_int1489

noncomputable def sign_final : ℤ :=
  if alpha_prime_final * beta_prime_final * gamma_prime_final = (1489 : Ok1489) then 1 else -1

noncomputable def alpha_final := (sign_final : Ok1489) * alpha_prime_final
noncomputable def beta_final := (sign_final : Ok1489) * beta_prime_final
noncomputable def gamma_final := (sign_final : Ok1489) * gamma_prime_final

lemma c_g_final_eq_s2 : c1489 g_final.val = s2_1489 := by
  rw [c1489, s2_1489, g_final]
  native_decide

/-
Check if 2 is a cubic residue mod 1489.
-/
def check_c2_1489 : IO Unit := do
  let q := 1489
  let c (n : Nat) := (n : Nat) ^ 496 % q
  let c2 := c 2
  IO.println s!"c(2) = {c2}"
  if c2 == 1 then IO.println "2 is a cubic residue" else IO.println "2 is NOT a cubic residue"

#eval check_c2_1489

/-
Prove characterization of C1 by cubic character using native_decide.
-/
lemma mem_C1_iff_c_eq_s2_1489 (n : ZMod 1489) (hn : n ≠ 0) : n ∈ C1_final ↔ c1489 n.val = s2_1489 := by
  revert n hn
  have h_forall : ∀ n : ZMod 1489, n ≠ 0 → (n ∈ C1_final ↔ c1489 n.val = s2_1489) := by
    native_decide
  exact fun n hn => h_forall n hn

/-
Prove characterization of C2 by cubic character using native_decide.
-/
lemma mem_C2_iff_c_eq_s1_1489 (n : ZMod 1489) (hn : n ≠ 0) : n ∈ C2_final ↔ c1489 n.val = s1_1489 := by
  revert n hn
  have h_forall : ∀ n : ZMod 1489, n ≠ 0 → (n ∈ C2_final ↔ c1489 n.val = s1_1489) := by
    native_decide
  exact fun n hn => h_forall n hn

/-
Prove N is not 0 mod 1489.
-/
lemma N_mod_1489_ne_zero (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 1489) : (N : ZMod 1489) ≠ 0 := by
  exact?

def check_c2_val : IO Unit := do
  let q := 1489
  let c (n : Nat) := (n : Nat) ^ 496 % q
  let c2 := c 2
  IO.println s!"c(2) = {c2}"
  if c2 == 1 then IO.println "2 is a cubic residue" else IO.println "2 is NOT a cubic residue"

#eval check_c2_val

/-
Assumptions for the Dream Theorem for q=1489:
1. alpha satisfies the cubic period equation.
2. The product of roots is 1489.
3. beta is expressed in terms of alpha.
4. gamma is expressed in terms of alpha.
-/
def DreamAssumptions_1489_Final : Prop :=
  alpha_final^3 = 1489 * alpha_final + 1489 ∧
  alpha_final * beta_final * gamma_final = 1489 ∧
  77 * beta_final = 3 * alpha_final^2 - 43 * alpha_final - 2978 ∧
  77 * gamma_final = -3 * alpha_final^2 + 34 * alpha_final + 2978

/-
An element n (non-zero) is in C1 if and only if its cubic character c(n) is equal to s2.
-/
lemma mem_C1_iff_c_eq_s2_1489_correct (n : ZMod 1489) (hn : n ≠ 0) : n ∈ C1_final ↔ c1489 n.val = s2_1489 := by
  have := @mem_C1_iff_c_eq_s2_1489;
  exact this n hn

/-
An element n (non-zero) is in C2 if and only if its cubic character c(n) is equal to s1.
-/
lemma mem_C2_iff_c_eq_s1_1489_correct (n : ZMod 1489) (hn : n ≠ 0) : n ∈ C2_final ↔ c1489 n.val = s1_1489 := by
  convert mem_C2_iff_c_eq_s1_1489 n hn using 1

/-
Explicit Frobenius action on alpha for q=1489.
If N is in C1, then 77 * alpha^N = 3 * alpha^2 - 43 * alpha - 2978 mod P.
If N is in C2, then 77 * alpha^N = -3 * alpha^2 + 34 * alpha + 2978 mod P.
-/
theorem explicit_frobenius_1489 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 1489) (hN_a : Nat.Coprime 77 N)
  (P : Ideal Ok1489) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_assum : DreamAssumptions_1489_Final) :
  let alpha_bar := Ideal.Quotient.mk P alpha_int1489
  ((N : ZMod 1489) ∈ C1_1489 → 77 * alpha_bar ^ N = 3 * alpha_bar ^ 2 - 43 * alpha_bar - 2978) ∧
  ((N : ZMod 1489) ∈ C2_1489 → 77 * alpha_bar ^ N = -3 * alpha_bar ^ 2 + 34 * alpha_bar + 2978) := by
    -- Let's obtain the conditions from `hN_a`.
    obtain ⟨h_prod_eq_2978, h_alpha_eq_1489⟩ := h_assum;
    grind

/-
The Dream Theorem for q=1489.
If c(N) = s1, then alpha^N = gamma mod P.
If c(N) = s2, then alpha^N = beta mod P.
-/
theorem final_result_1489 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 1489) (hN_a : Nat.Coprime 77 N)
  (P : Ideal Ok1489) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_assum : DreamAssumptions_1489_Final) :
  let alpha_bar := Ideal.Quotient.mk P alpha_int1489
  let beta_bar := Ideal.Quotient.mk P beta_int1489
  let gamma_bar := Ideal.Quotient.mk P gamma_int1489
  (c1489 N = s1_1489 → alpha_bar ^ N = gamma_bar) ∧
  (c1489 N = s2_1489 → alpha_bar ^ N = beta_bar) := by
    revert @ h_assum;
    -- By definition of $DreamAssumptions_1489_Final$, we know that $alpha_final$, $beta_final$, and $gamma_final$ satisfy the given equations and the product of the roots is 1489.
    intro h_assum
    obtain ⟨h_eq1, h_eq2, h_eq3, h_eq4⟩ := h_assum;
    grind

/-
Explicit Frobenius for the correct generator g=28.
-/
theorem explicit_frobenius_1489_corrected (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 1489) (hN_a : Nat.Coprime 77 N)
  (P : Ideal Ok1489) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_assum : DreamAssumptions_1489_Final) :
  let alpha_bar := Ideal.Quotient.mk P alpha_final
  ((N : ZMod 1489) ∈ C1_final → 77 * alpha_bar ^ N = 3 * alpha_bar ^ 2 - 43 * alpha_bar - 2978) ∧
  ((N : ZMod 1489) ∈ C2_final → 77 * alpha_bar ^ N = -3 * alpha_bar ^ 2 + 34 * alpha_bar + 2978) := by
    -- Apply the local-global principle to relate the local Frobenius to the global one.
    apply Classical.byContradiction
    intro h_contra;
    apply_mod_cast absurd _ h_contra ; simp_all +decide [DreamAssumptions_1489_Final];
    grind

/-
The Dream Theorem for q = 1489.
Let N be an odd prime, N != 1489, gcd(77, N) = 1.
If c(N) = s1, then alpha^N = gamma.
If c(N) = s2, then alpha^N = beta.
-/
theorem DreamTheorem_1489 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 1489) (hN_odd : N ≠ 2) (hN_a : Nat.Coprime 77 N)
  (P : Ideal Ok1489) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_assum : DreamAssumptions_1489_Final) :
  let alpha_bar := Ideal.Quotient.mk P alpha_int1489
  let beta_bar := Ideal.Quotient.mk P beta_int1489
  let gamma_bar := Ideal.Quotient.mk P gamma_int1489
  (c1489 N = s1_1489 → alpha_bar ^ N = gamma_bar) ∧
  (c1489 N = s2_1489 → alpha_bar ^ N = beta_bar) := by
    apply_rules [ final_result_1489 ]

/-
The Dream Theorem for q=1489 (Corrected).
Using the correct roots alpha_final, beta_final, gamma_final.
If c(N) = s1, then alpha^N = gamma.
If c(N) = s2, then alpha^N = beta.
-/
theorem DreamTheorem_1489_Correct (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 1489) (hN_odd : N ≠ 2) (hN_a : Nat.Coprime 77 N)
  (P : Ideal Ok1489) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_assum : DreamAssumptions_1489_Final) :
  let alpha_bar := Ideal.Quotient.mk P alpha_final
  let beta_bar := Ideal.Quotient.mk P beta_final
  let gamma_bar := Ideal.Quotient.mk P gamma_final
  (c1489 N = s1_1489 → alpha_bar ^ N = gamma_bar) ∧
  (c1489 N = s2_1489 → alpha_bar ^ N = beta_bar) := by
    constructor <;> intro h <;> have := h_assum.2.2.1 <;> have := h_assum.2.2.2 <;> have := h_assum.1 <;> have := h_assum.2.1 <;> norm_num at *;
    · grind;
    · grind