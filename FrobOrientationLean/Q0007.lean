/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 4b956492-22b0-4b56-9fb4-b4478653c500

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We have formally verified the sketch of the proof for the Frobenius Orientation conjecture in the case q=7.
We defined the cyclotomic field L = Q(zeta_7) and the Gaussian periods eta_0, eta_1, eta_2.
We defined the roots alpha, beta, gamma and verified their cyclic relations.
We proved the Global Permutation Theorem describing the action of the Galois automorphism sigma_N on alpha.
We defined the ring of integers OL and the reduction map to the residue field.
We proved the Artin symbol property relating sigma_N to the Frobenius endomorphism modulo P.
Finally, we combined these results to prove the Explicit Frobenius Action on the root alpha in the finite field F_{N^3}.
-/

import Mathlib

namespace Q0007


set_option linter.mathlibStandardSet false
set_option linter.unusedSimpArgs false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of the primitive 7th root of unity in the cyclotomic field L.
-/
def zeta7 (L : Type*) [Field L] [Algebra ℚ L] [IsCyclotomicExtension {7} ℚ L] : L :=
  IsCyclotomicExtension.zeta 7 ℚ L

/-
Definitions of the Gaussian periods eta_0, eta_1, eta_2.
-/
def eta_0 {L : Type*} [Field L] [Algebra ℚ L] [IsCyclotomicExtension {7} ℚ L] : L :=
  zeta7 L + (zeta7 L)^6

def eta_1 {L : Type*} [Field L] [Algebra ℚ L] [IsCyclotomicExtension {7} ℚ L] : L :=
  (zeta7 L)^3 + (zeta7 L)^4

def eta_2 {L : Type*} [Field L] [Algebra ℚ L] [IsCyclotomicExtension {7} ℚ L] : L :=
  (zeta7 L)^2 + (zeta7 L)^5

/-
Definitions of the roots alpha, beta, gamma.
-/
def alpha {L : Type*} [Field L] [Algebra ℚ L] [IsCyclotomicExtension {7} ℚ L] : L :=
  -(eta_2 - eta_1)

def beta {L : Type*} [Field L] [Algebra ℚ L] [IsCyclotomicExtension {7} ℚ L] : L :=
  -(eta_0 - eta_2)

def gamma {L : Type*} [Field L] [Algebra ℚ L] [IsCyclotomicExtension {7} ℚ L] : L :=
  -(eta_1 - eta_0)

/-
Cyclic relation expressing beta in terms of alpha.
-/
theorem cyclic_relation_beta {L : Type*} [Field L] [Algebra ℚ L] [IsCyclotomicExtension {7} ℚ L] :
  beta (L := L) = 3 * alpha (L := L)^2 - 5 * alpha (L := L) - 14 := by
    -- Let's first prove that $(zeta7 L)^6 + (zeta7 L)^3 + (zeta7 L)^2 + (zeta7 L)^4 + (zeta7 L) + 1 = 0$.
    have h_cyclotomic : (zeta7 L : L) ^ 6 + (zeta7 L : L) ^ 5 + (zeta7 L : L) ^ 4 + (zeta7 L : L) ^ 3 + (zeta7 L : L) ^ 2 + (zeta7 L : L) + 1 = 0 := by
      -- By definition of $zeta7$, we know that $zeta7^7 = 1$.
      have hzeta7_7 : zeta7 L ^ 7 = 1 := by
        convert IsPrimitiveRoot.pow_eq_one ( IsCyclotomicExtension.zeta_spec 7 ℚ L );
      have h_primitive : zeta7 L ≠ 1 := by
        have h_order : IsPrimitiveRoot (zeta7 L) 7 := by
          convert IsCyclotomicExtension.zeta_spec 7 ℚ L using 1;
        exact h_order.ne_one ( by decide );
      exact mul_left_cancel₀ ( sub_ne_zero_of_ne h_primitive ) ( by linear_combination' hzeta7_7 );
    unfold alpha beta eta_0 eta_1 eta_2;
    grind +ring

/-
Cyclic relation expressing gamma in terms of alpha.
-/
theorem cyclic_relation_gamma {L : Type*} [Field L] [Algebra ℚ L] [IsCyclotomicExtension {7} ℚ L] :
  gamma (L := L) = -3 * alpha (L := L)^2 + 4 * alpha (L := L) + 14 := by
    -- By definition of $zeta7$, we know that $zeta7^7 = 1$.
    have hzeta7_7 : (zeta7 L)^7 = 1 := by
      convert IsPrimitiveRoot.pow_eq_one ( IsCyclotomicExtension.zeta_spec 7 ℚ L );
    unfold alpha gamma eta_0 eta_1 eta_2;
    refine' mul_left_cancel₀ ( sub_ne_zero_of_ne ( show zeta7 L ≠ 1 from _ ) ) _;
    · intro h; simp_all +decide [ pow_succ ] ;
      -- Since $zeta7 L = 1$, this contradicts the fact that $zeta7$ is a primitive 7th root of unity.
      have h_contra : IsPrimitiveRoot (zeta7 L) 7 := by
        convert IsCyclotomicExtension.zeta_spec 7 ℚ L;
      exact absurd ( h_contra.eq_orderOf ) ( by simp +decide [ h ] );
    · grind

/-
Definition of the Galois automorphism sigma_N sending zeta to zeta^N.
-/
def sigma_N {L : Type*} [Field L] [Algebra ℚ L] [IsCyclotomicExtension {7} ℚ L]
  (N : ℕ) (hN : N.Coprime 7) : L ≃ₐ[ℚ] L :=
  let h_zeta := IsCyclotomicExtension.zeta_spec 7 ℚ L
  let h_zeta_pow := IsPrimitiveRoot.pow_of_coprime h_zeta N hN
  IsCyclotomicExtension.fromZetaAut h_zeta_pow (Polynomial.cyclotomic.irreducible_rat (by norm_num : 0 < 7))

/-
Global Permutation Theorem Case 1: If N = 3, 4 mod 7, then sigma_N(alpha) = beta.
-/
theorem global_permutation_case1 {L : Type*} [Field L] [Algebra ℚ L] [IsCyclotomicExtension {7} ℚ L]
  (N : ℕ) (hN : N.Coprime 7) (h_mod : N % 7 = 3 ∨ N % 7 = 4) :
  sigma_N N hN (alpha (L := L)) = beta (L := L) := by
    cases h_mod <;> simp_all +decide [ alpha, beta ];
    · unfold eta_0 eta_1 eta_2;
      -- Since $zeta7$ is a primitive 7th root of unity, we have $sigma_N(zeta7) = zeta7^N$.
      have h_sigma_zeta : sigma_N N hN (zeta7 L) = zeta7 L ^ N := by
        unfold sigma_N zeta7;
        exact?;
      -- Since $N \equiv 3 \pmod{7}$, we have $N = 7k + 3$ for some integer $k$.
      obtain ⟨k, rfl⟩ : ∃ k, N = 7 * k + 3 := by
        exact ⟨ N / 7, by linarith [ Nat.mod_add_div N 7 ] ⟩;
      -- Since $zeta7$ is a primitive 7th root of unity, we have $zeta7^7 = 1$.
      have h_zeta7_pow : zeta7 L ^ 7 = 1 := by
        exact IsPrimitiveRoot.pow_eq_one ( IsCyclotomicExtension.zeta_spec 7 ℚ L );
      simp_all +decide [ pow_add, pow_mul ];
      grind +ring;
    · unfold eta_0 eta_1 eta_2;
      -- By definition of $sigma_N$, we know that $sigma_N(zeta7) = zeta7^N$.
      have h_sigma_zeta : (sigma_N N hN) (zeta7 L) = zeta7 L ^ N := by
        unfold sigma_N;
        simp +decide [ zeta7 ];
        exact?;
      -- Since $N \equiv 4 \pmod{7}$, we have $zeta7 L ^ N = zeta7 L ^ 4$.
      have h_zeta_pow : zeta7 L ^ N = zeta7 L ^ 4 := by
        -- Since $zeta7$ is a primitive 7th root of unity, we have $zeta7^7 = 1$.
        have h_zeta7_pow : zeta7 L ^ 7 = 1 := by
          exact IsPrimitiveRoot.pow_eq_one ( IsCyclotomicExtension.zeta_spec 7 ℚ L );
        rw [ ← Nat.mod_add_div N 7, ‹N % 7 = _› ] ; norm_num [ pow_add, pow_mul, h_zeta7_pow ] ;
      simp_all +decide [ pow_succ, ← mul_assoc ];
      have h_zeta_pow : zeta7 L ^ 7 = 1 := by
        exact IsPrimitiveRoot.pow_eq_one ( IsCyclotomicExtension.zeta_spec 7 ℚ L );
      grind

/-
Global Permutation Theorem Case 2: If N = 2, 5 mod 7, then sigma_N(alpha) = gamma.
-/
theorem global_permutation_case2 {L : Type*} [Field L] [Algebra ℚ L] [IsCyclotomicExtension {7} ℚ L]
  (N : ℕ) (hN : N.Coprime 7) (h_mod : N % 7 = 2 ∨ N % 7 = 5) :
  sigma_N N hN (alpha (L := L)) = gamma (L := L) := by
    -- Using the definition of $\sigma_N$, we know that $\sigma_N(\zeta_7^k) = \zeta_7^{kN}$.
    have h_sigma_zeta : ∀ k : ℕ, (sigma_N N hN (zeta7 L ^ k)) = zeta7 L ^ (k * N % 7) := by
      intro k
      have h_sigma_zeta : (sigma_N N hN (zeta7 L)) = zeta7 L ^ N := by
        unfold sigma_N zeta7;
        exact?;
      -- Since $\zeta_7^7 = 1$, we have $\zeta_7^{kN} = \zeta_7^{kN \mod 7}$.
      have h_zeta_mod : zeta7 L ^ (k * N) = zeta7 L ^ (k * N % 7) := by
        have h_zeta_mod : zeta7 L ^ 7 = 1 := by
          exact IsPrimitiveRoot.pow_eq_one ( IsCyclotomicExtension.zeta_spec 7 ℚ L );
        rw [ ← Nat.mod_add_div ( k * N ) 7, pow_add, pow_mul ] ; aesop;
      simp +decide [ ← h_zeta_mod, h_sigma_zeta, pow_mul' ];
    simp_all +decide [ alpha, beta, gamma, eta_0, eta_1, eta_2 ];
    rcases h_mod with ( h | h ) <;> norm_num [ Nat.mul_mod, h ];
    ring

/-
Definition of the ring of integers of L.
-/
variable {L : Type*} [Field L] [NumberField L] [IsCyclotomicExtension {7} ℚ L]

def OL (L : Type*) [Field L] [NumberField L] := NumberField.RingOfIntegers L

/-
Definition of alpha as an algebraic integer.
-/
def alpha_int {L : Type*} [Field L] [NumberField L] [IsCyclotomicExtension {7} ℚ L] : OL L :=
  ⟨alpha (L := L), by
    -- Since $\zeta_7$ is a primitive 7th root of unity, it is an algebraic integer.
    have h_zeta7_int : IsIntegral ℤ (zeta7 L) := by
      refine' ⟨ Polynomial.X ^ 7 - 1, _, _ ⟩ <;> norm_num
      all_goals generalize_proofs at *;
      · exact Polynomial.monic_X_pow_sub_C _ ( by norm_num );
      · exact sub_eq_zero_of_eq ( by exact IsCyclotomicExtension.zeta_spec 7 ℚ L |> fun h => h.pow_eq_one )
    generalize_proofs at *; (
    exact IsIntegral.neg ( IsIntegral.sub ( IsIntegral.add ( h_zeta7_int.pow 2 ) ( h_zeta7_int.pow 5 ) ) ( IsIntegral.add ( h_zeta7_int.pow 3 ) ( h_zeta7_int.pow 4 ) ) ))⟩

/-
Definition of beta as an algebraic integer.
-/
def beta_int {L : Type*} [Field L] [NumberField L] [IsCyclotomicExtension {7} ℚ L] : OL L :=
  ⟨beta (L := L), by
    -- By definition of $beta$, we know that it is an algebraic integer.
    have h_beta_int : IsIntegral ℤ (beta (L := L)) := by
      have h_eta0 : IsIntegral ℤ (eta_0 (L := L)) := by
        -- Since $\zeta_7$ is a root of unity, it is integral over $\mathbb{Z}$.
        have h_zeta_integral : IsIntegral ℤ (zeta7 L) := by
          refine' ⟨ Polynomial.X ^ 7 - 1, _, _ ⟩ <;> norm_num [ zeta7 ];
          · erw [ Polynomial.Monic, Polynomial.leadingCoeff_X_pow_sub_C ] ; norm_num;
          · rw [ sub_eq_zero, IsCyclotomicExtension.zeta_pow ];
        exact IsIntegral.add h_zeta_integral ( h_zeta_integral.pow 6 )
      have h_eta2 : IsIntegral ℤ (eta_2 (L := L)) := by
        refine' IsIntegral.add _ _;
        · refine' IsIntegral.pow _ _;
          refine' ⟨ Polynomial.X ^ 7 - 1, _, _ ⟩;
          · erw [ Polynomial.Monic, Polynomial.leadingCoeff_X_pow_sub_C ] ; norm_num;
          · simp +decide [ zeta7 ];
            rw [ sub_eq_zero, IsCyclotomicExtension.zeta_pow ];
        · have h_zeta_int : IsIntegral ℤ (zeta7 L) := by
            refine' ⟨ Polynomial.X ^ 7 - 1, _, _ ⟩;
            · erw [ Polynomial.Monic, Polynomial.leadingCoeff_X_pow_sub_C ] ; norm_num;
            · have h_zeta_pow : zeta7 L ^ 7 = 1 := by
                exact IsPrimitiveRoot.pow_eq_one ( IsCyclotomicExtension.zeta_spec 7 ℚ L );
              aesop;
          exact h_zeta_int.pow 5
      -- Since eta_0 and eta_2 are algebraic integers, their difference is also an algebraic integer.
      have h_diff : IsIntegral ℤ (eta_0 (L := L) - eta_2 (L := L)) := by
        exact IsIntegral.sub h_eta0 h_eta2;
      convert h_diff.neg using 1;
    exact h_beta_int⟩

/-
Definition of gamma as an algebraic integer.
-/
def gamma_int {L : Type*} [Field L] [NumberField L] [IsCyclotomicExtension {7} ℚ L] : OL L :=
  ⟨gamma (L := L), by
    -- Since $\zeta_7$ is a root of unity, it is integral over $\mathbb{Z}$.
    have h_zeta_integral : IsIntegral ℤ (zeta7 L) := by
      refine' ⟨ Polynomial.X ^ 7 - 1, _, _ ⟩;
      · exact Polynomial.monic_X_pow_sub_C _ ( by norm_num );
      · simp +decide [ zeta7 ];
        rw [ sub_eq_zero, IsCyclotomicExtension.zeta_pow ];
    -- Since $\eta_1$ and $\eta_0$ are sums of powers of $\zeta_7$, they are also integral over $\mathbb{Z}$.
    have h_eta1_integral : IsIntegral ℤ (eta_1 (L := L)) := by
      exact IsIntegral.add ( h_zeta_integral.pow 3 ) ( h_zeta_integral.pow 4 )
    have h_eta0_integral : IsIntegral ℤ (eta_0 (L := L)) := by
      exact IsIntegral.add ( h_zeta_integral ) ( h_zeta_integral.pow 6 );
    convert IsIntegral.sub ( h_eta1_integral ) ( h_eta0_integral ) |> IsIntegral.neg using 1⟩

/-
Restriction of the Galois automorphism sigma_N to the ring of integers.
-/
def sigma_N_int {L : Type*} [Field L] [NumberField L] [IsCyclotomicExtension {7} ℚ L]
  (N : ℕ) (hN : N.Coprime 7) : NumberField.RingOfIntegers L ≃+* NumberField.RingOfIntegers L :=
  (NumberField.RingOfIntegers.mapAlgEquiv (sigma_N N hN)).toRingEquiv

/-
The canonical reduction homomorphism from the ring of integers to the residue field.
-/
def reduction {L : Type*} [Field L] [NumberField L] [IsCyclotomicExtension {7} ℚ L]
  (P : Ideal (NumberField.RingOfIntegers L)) :
  NumberField.RingOfIntegers L →+* (NumberField.RingOfIntegers L) ⧸ P :=
  Ideal.Quotient.mk P

/-
Definition of zeta as an algebraic integer.
-/
def zeta_int {L : Type*} [Field L] [NumberField L] [IsCyclotomicExtension {7} ℚ L] : NumberField.RingOfIntegers L :=
  ⟨zeta7 L, by
    refine' ⟨ Polynomial.X ^ 7 - 1, _, _ ⟩ <;> norm_num
    · exact Polynomial.monic_X_pow_sub_C _ ( by norm_num )
    · exact sub_eq_zero_of_eq ( by exact IsCyclotomicExtension.zeta_spec 7 ℚ L |> fun h => h.pow_eq_one )⟩

/-
The action of sigma_N on the integer zeta is raising to the N-th power.
-/
theorem sigma_N_zeta_int {L : Type*} [Field L] [NumberField L] [IsCyclotomicExtension {7} ℚ L]
  (N : ℕ) (hN : N.Coprime 7) :
  sigma_N_int N hN (zeta_int (L := L)) = (zeta_int (L := L)) ^ N := by
    -- By definition of $sigma_N$, we know that $\sigma_N(zeta) = zeta^N$.
    have h_sigma_zeta : (sigma_N N hN) (zeta7 L) = (zeta7 L) ^ N := by
      unfold zeta7 sigma_N;
      exact?;
    simp_all +decide [ NumberField.RingOfIntegers ];
    exact?

/-
The ring of integers (integral closure) of L is the subalgebra generated by zeta.
-/
theorem integralClosure_eq_adjoin_zeta {L : Type*} [Field L] [NumberField L] [IsCyclotomicExtension {7} ℚ L] :
  integralClosure ℤ L = Algebra.adjoin ℤ ({zeta7 L} : Set L) := by
    have h_integral_closure : IsIntegralClosure (Algebra.adjoin ℤ {zeta7 L}) ℤ L := by
      -- Apply the theorem that states the integral closure of ℤ in a cyclotomic extension is ℤ[ζ_p] for a prime p.
      have h_integral_closure : ∀ (p : ℕ), Nat.Prime p → IsIntegralClosure (Algebra.adjoin ℤ {zeta7 L}) ℤ L := by
        intro p hp;
        have := @IsCyclotomicExtension.Rat.isIntegralClosure_adjoin_singleton_of_prime;
        convert this ( show IsPrimitiveRoot ( zeta7 L ) 7 from ?_ );
        · exact ⟨ by norm_num ⟩;
        · exact IsCyclotomicExtension.zeta_spec 7 ℚ L;
      exact h_integral_closure 7 ( by norm_num );
    have h_integral_closure_eq : ∀ (S : Subalgebra ℤ L), IsIntegralClosure S ℤ L → S = integralClosure ℤ L := by
      intro S hS;
      ext x;
      exact ⟨ fun hx => hS.isIntegral_iff.mpr ⟨ ⟨ x, hx ⟩, rfl ⟩, fun hx => hS.isIntegral_iff.mp hx |> fun ⟨ y, hy ⟩ => hy ▸ y.2 ⟩;
    exact Eq.symm ( h_integral_closure_eq _ h_integral_closure )

/-
Every algebraic integer in L is a polynomial in zeta with integer coefficients.
-/
theorem exists_poly_of_mem_ringOfIntegers {L : Type*} [Field L] [NumberField L] [IsCyclotomicExtension {7} ℚ L]
  (x : NumberField.RingOfIntegers L) :
  ∃ P : Polynomial ℤ, x = Polynomial.aeval (zeta_int (L := L)) P := by
    -- By definition of $zeta_int$, we know that $x$ is in the range of the adjoin of $zeta_int$.
    have hx_in_adjoin : x.val ∈ Algebra.adjoin ℤ ({zeta7 L} : Set L) := by
      have hx_in_adjoin : x.val ∈ integralClosure ℤ L := by
        exact x.2;
      rw [ integralClosure_eq_adjoin_zeta ] at hx_in_adjoin ; exact hx_in_adjoin;
    rw [ Algebra.adjoin_singleton_eq_range_aeval ] at hx_in_adjoin;
    obtain ⟨ P, hP ⟩ := hx_in_adjoin; use P; ext; simp_all +decide [ Polynomial.aeval_def ] ;
    convert hP.symm using 1

/-
The Artin symbol property: sigma_N reduces to the Frobenius map x |-> x^N modulo P.
-/
theorem artin_property {L : Type*} [Field L] [NumberField L] [IsCyclotomicExtension {7} ℚ L]
  (N : ℕ) [Fact (Nat.Prime N)] (hN : N.Coprime 7) (P : Ideal (NumberField.RingOfIntegers L)) [P.IsPrime]
  (hP_over_N : (N : NumberField.RingOfIntegers L) ∈ P) :
  ∀ x : NumberField.RingOfIntegers L, reduction P (sigma_N_int N hN x) = (reduction P x) ^ N := by
    intro x
    obtain ⟨Q, hQ⟩ : ∃ Q : Polynomial ℤ, x = Polynomial.aeval (zeta_int (L := L)) Q := by
      exact?;
    -- Then $\sigma_N(x) = Q(\zeta^N)$.
    have h_sigma_N : sigma_N_int N hN x = Polynomial.aeval (R := ℤ) ((zeta_int (L := L)) ^ N) Q := by
      have h_sigma_N : sigma_N_int N hN (zeta_int (L := L)) = (zeta_int (L := L)) ^ N := by
        convert sigma_N_zeta_int N hN;
      simp +decide [ ← h_sigma_N, hQ, Polynomial.aeval_def ];
      simp +decide [ Polynomial.eval₂_eq_sum_range ];
    -- Reducing modulo $P$, we have $\overline{\sigma_N(x)} = \overline{Q(\zeta^N)} = Q(\overline{\zeta}^N)$.
    have h_reduction : (reduction P) (Polynomial.aeval (R := ℤ) ((zeta_int (L := L)) ^ N) Q) = Polynomial.eval₂ (reduction P) ((reduction P) (zeta_int (L := L))) (Polynomial.map (Int.castRingHom (NumberField.RingOfIntegers L)) Q) ^ N := by
      simp +decide [ Polynomial.aeval_def, Polynomial.eval₂_map ];
      rw [ Polynomial.eval₂_eq_sum_range, Polynomial.eval₂_eq_sum_range ];
      have h_frobenius : ∀ (x y : NumberField.RingOfIntegers L ⧸ P), (x + y) ^ N = x ^ N + y ^ N := by
        intro x y; rw [ add_pow ] ;
        rw [ Finset.sum_range_succ ] ; simp +decide [ Finset.sum_range_succ', Nat.choose_succ_succ ];
        rw [ add_comm, Finset.sum_eq_single 0 ] <;> simp +decide [ Nat.choose_eq_zero_of_lt ];
        · intro b hb hb'; right; exact (by
          have h_choose : N ∣ Nat.choose N b := by
            exact Nat.Prime.dvd_choose_self ( Fact.out : Nat.Prime N ) ( by aesop ) ( by aesop );
          obtain ⟨ k, hk ⟩ := h_choose; simp +decide [ hk ] ;
          exact Or.inl ( Ideal.Quotient.eq_zero_iff_mem.mpr hP_over_N ));
        · exact fun h => absurd h ( Nat.Prime.ne_zero Fact.out );
      induction' ( Finset.range ( Q.natDegree + 1 ) ) using Finset.induction <;> simp_all +decide [ pow_succ, mul_assoc, Finset.sum_range_succ ];
      · rw [ zero_pow ( Nat.Prime.ne_zero Fact.out ) ];
      · simp +decide [ mul_pow, pow_right_comm ];
        -- Since $N$ is prime, by Fermat's little theorem, we have $x^N \equiv x \pmod{N}$ for any integer $x$.
        have h_fermat : ∀ (x : ℤ), x ^ N ≡ x [ZMOD N] := by
          exact fun x => by haveI := Fact.mk ( Fact.out : Nat.Prime N ) ; simp +decide [ ← ZMod.intCast_eq_intCast_iff ] ;
        obtain ⟨ k, hk ⟩ := h_fermat ( Q.coeff ‹_› ) |> Int.ModEq.symm |> Int.ModEq.dvd;
        replace hk := congr_arg ( fun x : ℤ => x : ℤ → NumberField.RingOfIntegers L ⧸ P ) hk ; simp_all +decide [ sub_eq_iff_eq_add ];
        exact Or.inl <| Or.inl <| Ideal.Quotient.eq_zero_iff_mem.mpr hP_over_N;
    simp_all +decide [ Polynomial.aeval_def, Polynomial.eval₂_map ];
    simp +decide [ Polynomial.eval₂_eq_sum_range ]

/-
Explicit Frobenius Action Case 1: If N = 3, 4 mod 7, then alpha^N = 3*alpha^2 - 5*alpha - 14 in the residue field.
-/
theorem explicit_frobenius_case1 {L : Type*} [Field L] [NumberField L] [IsCyclotomicExtension {7} ℚ L]
  (N : ℕ) [Fact (Nat.Prime N)] (hN : N.Coprime 7) (P : Ideal (NumberField.RingOfIntegers L)) [P.IsPrime]
  (hP_over_N : (N : NumberField.RingOfIntegers L) ∈ P)
  (h_mod : N % 7 = 3 ∨ N % 7 = 4) :
  (reduction (L := L) P (alpha_int (L := L))) ^ N = 3 * (reduction (L := L) P (alpha_int (L := L))) ^ 2 - 5 * (reduction (L := L) P (alpha_int (L := L))) - 14 := by
    -- By `artin_property`, `(reduction (L := L) P (alpha_int (L := L)))^N = reduction P (sigma_N_int N hN alpha_int)`.
    have h_red : (reduction (L := L) P) (alpha_int (L := L)) ^ N = (reduction (L := L) P) (sigma_N_int (L := L) N hN (alpha_int (L := L))) := by
      -- use the Artin property for x = alpha_int
      simpa using (artin_property (L := L) N hN P hP_over_N (alpha_int (L := L))).symm
    -- By `global_permutation_case1`, `sigma_N N hN alpha = beta`.
    have h_sigma_beta : sigma_N N hN (alpha (L := L)) = beta (L := L) := by
      exact global_permutation_case1 N hN h_mod;
    -- By `cyclic_relation_beta`, `beta = 3 * alpha^2 - 5 * alpha - 14`.
    have h_beta : beta (L := L) = 3 * alpha (L := L) ^ 2 - 5 * alpha (L := L) - 14 := by
      simpa using (cyclic_relation_beta (L := L))
    -- Substitute `beta = 3 * alpha^2 - 5 * alpha - 14` into the goal.
    have h_subst : sigma_N_int N hN (alpha_int (L := L)) = beta_int (L := L) := by
      exact Subtype.ext h_sigma_beta;
    unfold beta_int at *; aesop;

/-
Explicit Frobenius Action Case 2: If N = 2, 5 mod 7, then alpha^N = -3*alpha^2 + 4*alpha + 14 in the residue field.
-/
theorem explicit_frobenius_case2 {L : Type*} [Field L] [NumberField L] [IsCyclotomicExtension {7} ℚ L]
  (N : ℕ) [Fact (Nat.Prime N)] (hN : N.Coprime 7) (P : Ideal (NumberField.RingOfIntegers L)) [P.IsPrime]
  (hP_over_N : (N : NumberField.RingOfIntegers L) ∈ P)
  (h_mod : N % 7 = 2 ∨ N % 7 = 5) :
  (reduction (L := L) P (alpha_int (L := L))) ^ N = -3 * (reduction (L := L) P (alpha_int (L := L))) ^ 2 + 4 * (reduction (L := L) P (alpha_int (L := L))) + 14 := by
    -- By `artin_property`, `(reduction (L := L) P (alpha_int (L := L)))^N = reduction P (sigma_N_int N hN alpha_int)`.
    have h_artin : (reduction (L := L) P (alpha_int (L := L))) ^ N = reduction (L := L) P (sigma_N_int (L := L) N hN (alpha_int (L := L))) := by
      -- use the Artin property for x = alpha_int
      simpa using (artin_property (L := L) N hN P hP_over_N (alpha_int (L := L))).symm
    -- By `global_permutation_case2`, `sigma_N N hN alpha = gamma`.
    have h_global : sigma_N N hN (alpha (L := L)) = gamma (L := L) := by
      exact global_permutation_case2 N hN h_mod;
    -- By `cyclic_relation_gamma`, `gamma = -3 * alpha^2 + 4 * alpha + 14`.
    have h_gamma : gamma (L := L) = -3 * (alpha (L := L)) ^ 2 + 4 * (alpha (L := L)) + 14 := by
      simpa using (cyclic_relation_gamma (L := L))
    -- Substitute `gamma` with `-3 * alpha^2 + 4 * alpha + 14` in the goal.
    have h_subst : sigma_N_int (L := L) N hN (alpha_int (L := L)) = gamma_int (L := L) := by
      exact Subtype.ext h_global
    convert congr_arg (reduction (L := L) P) h_subst using 1;
    unfold gamma_int; aesop;

/-
Checking if CharP is available.
-/
#check CharP

/-
Every algebraic integer in L is a polynomial in zeta with integer coefficients.
-/
theorem exists_poly_of_mem_ringOfIntegers' {L : Type*} [Field L] [NumberField L] [IsCyclotomicExtension {7} ℚ L]
  (x : NumberField.RingOfIntegers L) :
  ∃ P : Polynomial ℤ, x = Polynomial.aeval (zeta_int (L := L)) P := by
    convert exists_poly_of_mem_ringOfIntegers x

/-
Every algebraic integer in L is a polynomial in zeta with integer coefficients.
-/
theorem exists_poly_of_mem_ringOfIntegers_v2 {L : Type*} [Field L] [NumberField L] [IsCyclotomicExtension {7} ℚ L]
  (x : NumberField.RingOfIntegers L) :
  ∃ P : Polynomial ℤ, x = Polynomial.aeval (zeta_int (L := L)) P := by
    convert exists_poly_of_mem_ringOfIntegers' x

/-
Every algebraic integer in L is in the subalgebra generated by zeta.
-/
theorem mem_adjoin_of_mem_ringOfIntegers {L : Type*} [Field L] [NumberField L] [IsCyclotomicExtension {7} ℚ L]
  (x : NumberField.RingOfIntegers L) :
  (x : L) ∈ Algebra.adjoin ℤ ({zeta7 L} : Set L) := by
    convert integralClosure_eq_adjoin_zeta using 1;
    any_goals assumption;
    constructor <;> intro h;
    · exact?;
    · exact h ▸ x.2
end
end Q0007
