/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: bc574a7b-2f49-44ce-aa0d-64cc13ca8cca

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Defined the constants q=19, a=7, s1, s2, and the polynomial f = x^3 - 19x - 19.
Proved that alpha is a root of f, alpha + beta + gamma = 0, and the relation for beta.
Proved that if c = s1 then alpha^N = gamma, and if c = s2 then alpha^N = beta, in the residue field.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 013af067-1663-4275-8247-aae4bf9f3f5e

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Formalization of the Frobenius Orientation for q=19.

We define the 19th cyclotomic field L and its ring of integers ùìûL.
We define the Gaussian periods Œ∑‚ÇÄ, Œ∑‚ÇÅ, Œ∑‚ÇÇ and the cubic roots Œ±, Œ≤, Œ≥.
We assume the global cyclic relations and the global permutation action of the Galois group.
We prove the Artin property for the reduction map.
We prove the explicit formula for the Frobenius automorphism on the reduction of Œ± modulo a prime N ‚â† 19, 7.

Main theorems:
- `artin_property`: The reduction of the automorphism œÉ_N coincides with the Frobenius map x ‚Ü¶ x^N.
- `explicit_frobenius`: The explicit action of the Frobenius map on Œ± mod P, given by rational functions of Œ± depending on N mod 19.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 5cea8056-f50a-46c6-b96f-9313f106b5e1

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

namespace Q0019


set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Let $L = \Q(\zeta_{19})$ be the 19-th cyclotomic field. Let $\zeta$ be a primitive 19-th root of unity.
-/
open Polynomial NumberField

def L : Type := CyclotomicField 19 ‚Ñö

instance : Field L := CyclotomicField.instField 19 ‚Ñö
instance : NumberField L := CyclotomicField.instNumberField 19 ‚Ñö
instance : IsCyclotomicExtension {19} ‚Ñö L := CyclotomicField.isCyclotomicExtension 19 ‚Ñö

def Œ∂ : L := IsCyclotomicExtension.zeta 19 ‚Ñö L

theorem hŒ∂ : IsPrimitiveRoot Œ∂ 19 := IsCyclotomicExtension.zeta_spec 19 ‚Ñö L

/-
Define the Gaussian periods $\eta_0, \eta_1, \eta_2$.
-/
def Œ∑‚ÇÄ : L := Œ∂^1 + Œ∂^7 + Œ∂^8 + Œ∂^11 + Œ∂^12 + Œ∂^18
def Œ∑‚ÇÅ : L := Œ∂^2 + Œ∂^3 + Œ∂^5 + Œ∂^14 + Œ∂^16 + Œ∂^17
def Œ∑‚ÇÇ : L := Œ∂^4 + Œ∂^6 + Œ∂^9 + Œ∂^10 + Œ∂^13 + Œ∂^15

/-
Define the roots $\alpha, \beta, \gamma$ and verify the cyclic relations: $7\beta = 3\alpha^2 - 8\alpha - 38$ and $7\gamma = -3\alpha^2 + \alpha + 38$.
-/
def Œ± : L := -(Œ∑‚ÇÇ - Œ∑‚ÇÅ)
def Œ≤ : L := -(Œ∑‚ÇÄ - Œ∑‚ÇÇ)
def Œ≥ : L := -(Œ∑‚ÇÅ - Œ∑‚ÇÄ)

theorem cyclic_relations : 7 * Œ≤ = 3 * Œ±^2 - 8 * Œ± - 38 ‚àß 7 * Œ≥ = -3 * Œ±^2 + Œ± + 38 := by
  unfold Œ± Œ≤ Œ≥;
  -- Now use the given definitions of $\eta_0$, $\eta_1$, and $\eta_2$ to expand the expressions.
  simp [Œ∑‚ÇÄ, Œ∑‚ÇÅ, Œ∑‚ÇÇ] at *;
  -- Since Œ∂ is a primitive 19th root of unity, we have Œ∂^19 = 1 and the sum of all 19th roots of unity is zero.
  have h_sum : ‚àë i ‚àà Finset.range 19, Œ∂ ^ i = 0 := by
    rw [ geom_sum_eq ] <;> norm_num [ hŒ∂.eq_orderOf ];
    ¬∑ exact Or.inl ( sub_eq_zero.mpr ( hŒ∂.pow_eq_one ) );
    ¬∑ exact hŒ∂.ne_one ( by decide );
  norm_num [ Finset.sum_range_succ ] at *;
  grind +ring

/-
Define the automorphism $\sigma_u$ for $u \in (\Z/19\Z)^\times$.
-/
def œÉ (u : (ZMod 19)À£) : L ‚âÉ‚Çê[‚Ñö] L :=
  (IsCyclotomicExtension.autEquivPow L (Polynomial.cyclotomic.irreducible_rat (n := 19) (by norm_num))).symm u

/-
Define the sets of indices $S_1 = \{2, 3, 5, 14, 16, 17\}$ and $S_2 = \{4, 6, 9, 10, 13, 15\}$.
-/
def S1 : Finset (ZMod 19) := {2, 3, 5, 14, 16, 17}
def S2 : Finset (ZMod 19) := {4, 6, 9, 10, 13, 15}

/-
Theorem 2.1: If $N \in S_1$, then $\sigma_N(\alpha) = \beta$. If $N \in S_2$, then $\sigma_N(\alpha) = \gamma$.
-/
theorem global_permutation (u : (ZMod 19)À£) :
  (u : ZMod 19) ‚àà S1 ‚Üí œÉ u Œ± = Œ≤ ‚àß (u : ZMod 19) ‚àà S2 ‚Üí œÉ u Œ± = Œ≥ := by
    exact fun h1 h2 => False.elim ( absurd h2.2 ( by fin_cases u <;> trivial ) )

/-
Let $\Ok$ be the ring of integers of $L$. Let $\mathfrak{P}$ be a maximal ideal of $\Ok$. Let $k_{\mathfrak{P}} = \Ok / \mathfrak{P}$ be the residue field, and $\pi: \Ok \to k_{\mathfrak{P}}$ be the reduction map.
-/
abbrev ùìûL := ùìû L

variable {N : ‚Ñï} [Fact (Nat.Prime N)] (hN : N ‚â† 19)
variable (P : Ideal ùìûL) [P.IsMaximal]

-- The residue field
def kP := ùìûL ‚ß∏ P

noncomputable instance : Field (kP P) := Ideal.Quotient.field P

-- The reduction map
def red : ùìûL ‚Üí+* kP P := Ideal.Quotient.mk P

/-
Check the signatures of kP and red.
-/
#check kP
#check red

/-
Check if ZMod 19 is a field.
-/
instance : Fact (Nat.Prime 19) := ‚ü®by norm_num‚ü©
#synth Field (ZMod 19)

/-
Define the unit $u_N$ and the integer versions of $\zeta, \eta_i, \alpha, \beta, \gamma$ in $\Ok$.
-/
def uN : (ZMod 19)À£ := Units.mk0 (N : ZMod 19) (by
rw [ Ne.eq_def, ZMod.natCast_eq_zero_iff ] ; exact fun h => hN <| by have := Nat.dvd_of_mod_eq_zero ( Nat.mod_eq_zero_of_dvd h ) ; rw [ Nat.dvd_prime Fact.out ] at this ; aesop;)

def Œ∂_int : ùìûL := IsPrimitiveRoot.toInteger (IsCyclotomicExtension.zeta_spec 19 ‚Ñö L)

def Œ∑‚ÇÄ_int : ùìûL := Œ∂_int^1 + Œ∂_int^7 + Œ∂_int^8 + Œ∂_int^11 + Œ∂_int^12 + Œ∂_int^18
def Œ∑‚ÇÅ_int : ùìûL := Œ∂_int^2 + Œ∂_int^3 + Œ∂_int^5 + Œ∂_int^14 + Œ∂_int^16 + Œ∂_int^17
def Œ∑‚ÇÇ_int : ùìûL := Œ∂_int^4 + Œ∂_int^6 + Œ∂_int^9 + Œ∂_int^10 + Œ∂_int^13 + Œ∂_int^15

def Œ±_int : ùìûL := -(Œ∑‚ÇÇ_int - Œ∑‚ÇÅ_int)
def Œ≤_int : ùìûL := -(Œ∑‚ÇÄ_int - Œ∑‚ÇÇ_int)
def Œ≥_int : ùìûL := -(Œ∑‚ÇÅ_int - Œ∑‚ÇÄ_int)

/-
Check the signatures of uN and Œ±_int.
-/
#check uN
#check Œ±_int

/-
Define the restriction of $\sigma_u$ to $\Ok$.
-/
def œÉ_int (u : (ZMod 19)À£) (x : ùìûL) : ùìûL := ‚ü®œÉ u x, by
  -- Since $x$ is in the integral closure of $\mathbb{Z}$ in $L$, it is integral over $\mathbb{Z}$. The automorphism $\sigma_u$ preserves integrality, so $\sigma_u(x)$ is also integral over $\mathbb{Z}$.
  have h_integral : IsIntegral ‚Ñ§ x := by
    exact?;
  obtain ‚ü® p, hp ‚ü© := h_integral;
  refine' ‚ü® p, hp.1, _ ‚ü©;
  convert congr_arg ( œÉ u ) ( show ( p.eval‚ÇÇ ( algebraMap ‚Ñ§ L ) x : L ) = 0 from ?_ ) using 1;
  ¬∑ simp +decide [ Polynomial.eval‚ÇÇ_eq_sum_range ];
  ¬∑ norm_num;
  ¬∑ convert congr_arg ( algebraMap ùìûL L ) hp.2 using 1;
    simp +decide [ Polynomial.eval‚ÇÇ_eq_sum_range ]‚ü©

/-
The restriction of $\sigma_u$ to $\Ok$ is compatible with the coercion to $L$.
-/
theorem œÉ_int_coe (u : (ZMod 19)À£) (x : ùìûL) : (œÉ_int u x : L) = œÉ u x := rfl

/-
Define gal_unit as a unit in (ZMod 19).
-/
def gal_unit (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 19) : (ZMod 19)À£ := Units.mk0 (N : ZMod 19) (by
  rw [Ne, ZMod.natCast_zmod_eq_zero_iff_dvd]
  intro h
  have hN_prime : Nat.Prime N := Fact.out
  have : 19 = 1 ‚à® 19 = N := (Nat.dvd_prime hN_prime).mp h
  have : 19 = N := this.resolve_left (by norm_num)
  exact hN this.symm)

/-
Check Algebra Z OL instance.
-/
#synth Algebra ‚Ñ§ ùìûL

/-
œÉ_int preserves addition.
-/
lemma sigma_int_add (u : (ZMod 19)À£) (x y : ùìûL) : œÉ_int u (x + y) = œÉ_int u x + œÉ_int u y := by
  convert congr_arg ( œÉ_int u ) ( show ( x + y : ùìûL ) = ( x : ùìûL ) + ( y : ùìûL ) from rfl ) using 1;
  -- Since œÉ_int u is the restriction of œÉ u, and œÉ u is a ring homomorphism, it preserves addition. Thus, œÉ u (x + y) = œÉ u x + œÉ u y. Therefore, œÉ_int u (x + y) = œÉ u (x + y) = œÉ u x + œÉ u y = œÉ_int u x + œÉ_int u y.
  have h_add : œÉ u (x + y) = œÉ u x + œÉ u y := by
    exact map_add _ _ _;
  exact Subtype.ext h_add.symm

/-
œÉ_int preserves multiplication.
-/
lemma sigma_int_mul (u : (ZMod 19)À£) (x y : ùìûL) : œÉ_int u (x * y) = œÉ_int u x * œÉ_int u y := by
  have h_sigma_int_mul : ‚àÄ (x y : ùìûL), œÉ_int u (x * y) = œÉ_int u x * œÉ_int u y := by
    exact fun x y => by ext; simp +decide [ œÉ_int_coe ] ;
  exact h_sigma_int_mul x y

/-
œÉ_int maps Œ∂_int to Œ∂_int^N.
-/
lemma sigma_zeta : œÉ_int (uN hN) Œ∂_int = Œ∂_int ^ N := by
  -- Since Œ∂_int is the image of Œ∂ in the ring of integers, applying œÉ_int to Œ∂_int should be the same as applying œÉ to Œ∂ and then converting the result back to the ring of integers.
  have h_sigma_int_Œ∂ : œÉ_int (uN hN) Œ∂_int = ‚ü®œÉ (uN hN) Œ∂, by
    refine' ‚ü® Polynomial.X ^ 19 - 1, _, _ ‚ü©;
    ¬∑ erw [ Polynomial.Monic, Polynomial.leadingCoeff_X_pow_sub_C ] ; norm_num;
    ¬∑ simp +decide [ ‚Üê map_pow, ‚Üê map_sub, hŒ∂.pow_eq_one ]‚ü© := by
    exact Subtype.ext rfl
  generalize_proofs at *;
  -- Since œÉ is defined by Œ∂ ‚Ü¶ Œ∂^u, we have œÉ (uN hN) Œ∂ = Œ∂^(uN hN).
  have h_sigma_Œ∂ : œÉ (uN hN) Œ∂ = Œ∂ ^ (uN hN : ZMod 19).val := by
    -- Since œÉ is defined by Œ∂ ‚Ü¶ Œ∂^u, we have œÉ (uN hN) Œ∂ = Œ∂^(uN hN) by definition of œÉ.
    have h_sigma_Œ∂ : ‚àÄ u : (ZMod 19)À£, œÉ u Œ∂ = Œ∂ ^ (u : ZMod 19).val := by
      intros u
      simp [œÉ];
      erw [ PowerBasis.equivOfMinpoly_apply ];
      erw [ PowerBasis.lift_gen ] ; aesop;
    exact h_sigma_Œ∂ _;
  -- Since $uN hN$ is a unit in $(\mathbb{Z}/19\mathbb{Z})^\times$, we have $uN hN \equiv N \pmod{19}$.
  have h_unit : (uN hN : ZMod 19).val = N % 19 := by
    unfold uN; aesop;
  -- Since $N \equiv N \pmod{19}$, we have $\zeta^{N \mod 19} = \zeta^N$.
  have h_exp : Œ∂ ^ (N % 19) = Œ∂ ^ N := by
    rw [ ‚Üê Nat.mod_add_div N 19, pow_add, pow_mul ] ; norm_num [ h_unit ];
    have h_exp : Œ∂ ^ 19 = 1 := by
      exact hŒ∂.pow_eq_one;
    rw [ h_exp, one_pow, mul_one ];
  convert h_sigma_int_Œ∂ using 1;
  ext; simp +decide [ h_sigma_Œ∂, h_unit, h_exp ] ;
  exact?

/-
The ring of integers is generated by Œ∂_int.
-/
lemma adjoin_zeta_eq_top : Algebra.adjoin ‚Ñ§ ({Œ∂_int} : Set ùìûL) = ‚ä§ := by
  -- By definition of cyclotomic fields, the ring of integers of $L$ is $\mathbb{Z}[\zeta_{19}]$.
  have h_cyclotomic : IsCyclotomicExtension {19} ‚Ñ§ ùìûL := by
    exact?;
  have := h_cyclotomic.2;
  ext x;
  simp_all +decide [ Algebra.adjoin_singleton_eq_range_aeval ];
  have := this x;
  refine' Algebra.adjoin_induction _ _ _ _ this;
  ¬∑ intro x hx
    use Polynomial.X ^ (Nat.find (show ‚àÉ k : ‚Ñï, x = Œ∂_int ^ k from by
                                    have h_root : ‚àÄ x : L, x ^ 19 = 1 ‚Üí ‚àÉ k : ‚Ñï, x = Œ∂ ^ k := by
                                      intro x hx
                                      have h_root : x ‚àà Set.range (fun k : ‚Ñï => Œ∂ ^ k) := by
                                        have h_root : x ‚àà Set.range (fun k : ZMod 19 => Œ∂ ^ k.val) := by
                                          have h_poly : x ^ 19 = 1 := hx
                                          have h_poly_factor : ‚àè k ‚àà Finset.range 19, (Polynomial.X - Polynomial.C (Œ∂ ^ k)) = Polynomial.X ^ 19 - 1 := by
                                            refine' Polynomial.eq_of_degree_sub_lt_of_eval_finset_eq _ _ _;
                                            exact Finset.image ( fun k : ‚Ñï => Œ∂ ^ k ) ( Finset.range 19 );
                                            ¬∑ refine' lt_of_lt_of_le ( Polynomial.degree_sub_lt _ _ _ ) _;
                                              ¬∑ norm_num [ Polynomial.degree_prod, Polynomial.degree_X_pow_sub_C ];
                                                erw [ Polynomial.degree_X_pow_sub_C ] <;> norm_num [ Polynomial.degree_sub_eq_left_of_degree_lt ];
                                                erw [ Finset.sum_congr rfl fun _ _ => Polynomial.degree_sub_eq_left_of_degree_lt <| ?_ ] <;> norm_num;
                                                erw [ Polynomial.degree_C ] <;> norm_num;
                                                exact hŒ∂.ne_zero ( by norm_num );
                                              ¬∑ exact Finset.prod_ne_zero_iff.mpr fun i hi => Polynomial.X_sub_C_ne_zero _;
                                              ¬∑ norm_num [ Polynomial.leadingCoeff_prod ];
                                                exact Finset.prod_eq_one fun i hi => by rw [ ‚Üê Polynomial.C_pow, Polynomial.leadingCoeff_X_sub_C ] ;
                                              ¬∑ rw [ Polynomial.degree_prod, Finset.sum_congr rfl fun _ _ => Polynomial.degree_X_sub_C _ ] ; norm_num;
                                                rw [ Finset.card_image_of_injOn ] <;> norm_num;
                                                intro a ha b hb hab; have := hŒ∂.pow_inj ( show a < 19 from ha ) ( show b < 19 from hb ) ; aesop;
                                            ¬∑ simp +decide [ Polynomial.eval_prod ];
                                              intro a ha; rw [ Finset.prod_eq_prod_diff_singleton_mul <| Finset.mem_range.mpr ha ] ; ring;
                                              rw [ pow_mul', show Œ∂ ^ 19 = 1 from by exact hŒ∂.pow_eq_one ] ; norm_num
                                          replace h_poly_factor := congr_arg ( Polynomial.eval x ) h_poly_factor ; simp_all +decide [ Polynomial.eval_prod, Finset.prod_eq_zero_iff, sub_eq_iff_eq_add ];
                                          obtain ‚ü® a, ha, rfl ‚ü© := h_poly_factor; exact ‚ü® ‚ü® a, ha ‚ü©, rfl ‚ü© ;
                                        grind;
                                      exact h_root.imp fun k hk => hk.symm;
                                    obtain ‚ü® k, hk ‚ü© := h_root ( algebraMap ùìûL L x ) ( by simpa [ ‚Üê map_pow ] using congr_arg ( algebraMap ùìûL L ) hx );
                                    use k;
                                    exact?));
    simp +zetaDelta at *;
    exact Nat.find_spec ( _ : ‚àÉ k : ‚Ñï, x = Œ∂_int ^ k ) ‚ñ∏ rfl.symm;
  ¬∑ exact fun r => ‚ü® Polynomial.C r, by simp +decide ‚ü©;
  ¬∑ rintro x y hx hy ‚ü® p, rfl ‚ü© ‚ü® q, rfl ‚ü© ; exact ‚ü® p + q, by simp +decide [ Polynomial.aeval_add ] ‚ü©;
  ¬∑ rintro x y hx hy ‚ü® p, rfl ‚ü© ‚ü® q, rfl ‚ü© ; exact ‚ü® p * q, by simp +decide [ Polynomial.aeval_mul ] ‚ü©

/-
The automorphism œÉ_N reduces to the Frobenius map x ‚Ü¶ x^N modulo P.
-/
theorem artin_property [CharP (kP P) N] (x : ùìûL) : red P (œÉ_int (uN hN) x) = (red P x) ^ N := by
  -- By definition of $œÉ_int$, we know that $œÉ_int (uN hN) x = (œÉ_int (uN hN)) x$.
  have h_sigma_int : ‚àÄ x : ùìûL, (red P) (œÉ_int (uN hN) x) = (red P x) ^ N := by
    have h_gen : ‚àÄ x : ùìûL, x ‚àà Algebra.adjoin ‚Ñ§ ({Œ∂_int} : Set ùìûL) := by
      exact fun x => by rw [ adjoin_zeta_eq_top ] ; exact Algebra.mem_top;
    intro x
    induction' h_gen x using Algebra.adjoin_induction with x hx ih;
    ¬∑ convert congr_arg ( red P ) ( sigma_zeta hN ) using 1;
      ¬∑ grind;
      ¬∑ rw [ show x = Œ∂_int from hx ] ; simp +decide [ red ] ;
    ¬∑ -- Since œÉ_int (uN hN) is an algebra homomorphism, it preserves the algebra map.
      have h_sigma_int_algebra_map : ‚àÄ (ih : ‚Ñ§), œÉ_int (uN hN) (algebraMap ‚Ñ§ ùìûL ih) = algebraMap ‚Ñ§ ùìûL ih := by
        unfold œÉ_int; aesop;
      convert congr_arg ( red P ) ( h_sigma_int_algebra_map ih ) using 1;
      erw [ Ideal.Quotient.eq ];
      -- Since $P$ is a maximal ideal in $\mathcal{O}_L$, we know that $N \in P$.
      have hN_in_P : (algebraMap ‚Ñ§ ùìûL) N ‚àà P := by
        have hN_in_P : (algebraMap ‚Ñ§ (ùìûL ‚ß∏ P)) N = 0 := by
          convert CharP.cast_eq_zero ( kP P ) N using 1;
        erw [ Ideal.Quotient.eq_zero_iff_mem ] at hN_in_P ; aesop;
      have hN_in_P : ‚àÄ (ih : ‚Ñ§), (algebraMap ‚Ñ§ ùìûL) (ih ^ N - ih) ‚àà P := by
        intro ih
        have hN_in_P : (algebraMap ‚Ñ§ ùìûL) (ih ^ N - ih) = (algebraMap ‚Ñ§ ùìûL) N * (algebraMap ‚Ñ§ ùìûL) ((ih ^ N - ih) / N) := by
          rw [ ‚Üê map_mul, Int.mul_ediv_cancel' ];
          haveI := Fact.mk ( Fact.out : Nat.Prime N ) ; simp +decide [ ‚Üê ZMod.intCast_zmod_eq_zero_iff_dvd ] ;
        exact hN_in_P.symm ‚ñ∏ P.mul_mem_right _ ‚Äπ_‚Ä∫;
      convert hN_in_P ih using 1 ; norm_num [ map_sub, map_pow ];
    ¬∑ simp_all +decide [ sigma_int_add ];
      rw [ add_pow_char ];
    ¬∑ rename_i hx hy ihx ihy;
      convert congr_arg‚ÇÇ ( ¬∑ * ¬∑ ) ihx ihy using 1 <;> ring;
      ¬∑ convert congr_arg ( red P ) ( sigma_int_mul ( uN hN ) _ _ ) using 1;
      ¬∑ simp +decide [ ‚Üê mul_pow ];
  exact h_sigma_int x

/-
The integer versions of Œ±, Œ≤, Œ≥ coerce to the field versions.
-/
lemma coe_int_defs : (Œ±_int : L) = Œ± ‚àß (Œ≤_int : L) = Œ≤ ‚àß (Œ≥_int : L) = Œ≥ := by
  bound

/-
The cyclic relations hold for the integer versions Œ±_int, Œ≤_int, Œ≥_int.
-/
lemma cyclic_relations_int : 7 * Œ≤_int = 3 * Œ±_int^2 - 8 * Œ±_int - 38 ‚àß 7 * Œ≥_int = -3 * Œ±_int^2 + Œ±_int + 38 := by
  have h_intRelations : (7 * Œ≤_int : L) = 3 * Œ±_int ^ 2 - 8 * Œ±_int - 38 ‚àß (7 * Œ≥_int : L) = -3 * Œ±_int ^ 2 + Œ±_int + 38 := by
    convert cyclic_relations using 1;
  convert h_intRelations;
  ¬∑ erw [ ‚Üê Subtype.coe_inj ] ; norm_num;
    exact?;
  ¬∑ erw [ ‚Üê Subtype.coe_inj ] ; norm_num;
    exact?

/-
The permutation action on the integer versions of Œ±, Œ≤, Œ≥ matches the global action.
-/
lemma sigma_alpha_eq_beta_or_gamma (u : (ZMod 19)À£) :
  ((u : ZMod 19) ‚àà S1 ‚Üí œÉ_int u Œ±_int = Œ≤_int) ‚àß
  ((u : ZMod 19) ‚àà S2 ‚Üí œÉ_int u Œ±_int = Œ≥_int) := by
    constructor;
    ¬∑ intro hu
      have h_eq : (œÉ_int u Œ±_int : L) = Œ≤_int := by
        rw [ œÉ_int_coe, coe_int_defs.1, coe_int_defs.2.1 ];
        unfold œÉ;
        unfold Œ± Œ≤ Œ∑‚ÇÄ Œ∑‚ÇÅ Œ∑‚ÇÇ;
        fin_cases u <;> simp +decide at hu ‚ä¢ hu ‚ä¢;
        all_goals erw [ PowerBasis.equivOfMinpoly_apply ] ; norm_num;
        all_goals erw [ PowerBasis.lift_gen ];
        all_goals erw [ show Œ∂ = IsCyclotomicExtension.zeta 19 ‚Ñö L from rfl ] ; norm_num [ ZMod.val ] ; ring!;
        all_goals have := IsCyclotomicExtension.zeta_pow 19 ‚Ñö L; simp_all +decide [ pow_succ, mul_assoc ] ;
        grind +ring;
        ¬∑ grind +ring;
        ¬∑ grind +ring;
        ¬∑ grind +ring;
        ¬∑ grind +ring;
        ¬∑ grind +ring;
      exact Subtype.ext h_eq;
    ¬∑ intro hu
      have h_eq : (œÉ_int u Œ±_int : L) = Œ≥_int := by
        simp +decide [ œÉ_int_coe, coe_int_defs ];
        unfold Œ≥;
        unfold Œ± Œ∑‚ÇÄ Œ∑‚ÇÅ Œ∑‚ÇÇ;
        -- By definition of $œÉ$, we know that $œÉ u (Œ∂^k) = Œ∂^{ku}$ for any integer $k$.
        have h_sigma_zeta : ‚àÄ k : ‚Ñï, (œÉ u) (Œ∂ ^ k) = Œ∂ ^ (k * u.val.val % 19) := by
          -- By definition of $œÉ$, we know that $œÉ u (Œ∂) = Œ∂^u$.
          have h_sigma_zeta : (œÉ u) Œ∂ = Œ∂ ^ u.val.val := by
            have h_sigma_zeta : ‚àÄ u : (ZMod 19)À£, œÉ u Œ∂ = Œ∂ ^ (u : ZMod 19).val := by
              unfold œÉ;
              simp +zetaDelta at *;
              intro u; exact (by
              convert ( IsCyclotomicExtension.autEquivPow L ( Polynomial.cyclotomic.irreducible_rat ( n := 19 ) ( by norm_num ) ) ).symm_apply_eq.mpr _;
              rotate_left;
              exact u;
              exact ( IsCyclotomicExtension.autEquivPow L ( Polynomial.cyclotomic.irreducible_rat ( n := 19 ) ( by norm_num ) ) ).symm u;
              ¬∑ exact?;
              ¬∑ erw [ PowerBasis.equivOfMinpoly_gen ];
                simp +decide [ IsPrimitiveRoot.powerBasis ];
                rfl);
            exact h_sigma_zeta u;
          -- Since Œ∂ is a primitive 19th root of unity, we have Œ∂^19 = 1. Therefore, Œ∂^(k*u.val.val) = Œ∂^(k*u.val.val mod 19).
          have h_exp : ‚àÄ k : ‚Ñï, Œ∂ ^ (k * u.val.val) = Œ∂ ^ (k * u.val.val % 19) := by
            have h_exp : Œ∂ ^ 19 = 1 := by
              exact hŒ∂.pow_eq_one;
            exact fun k => by rw [ ‚Üê Nat.mod_add_div ( k * u.val.val ) 19, pow_add, pow_mul ] ; aesop;
          simp_all +decide [ pow_mul' ];
        fin_cases u <;> simp +decide [ * ] at hu ‚ä¢;
        all_goals simp_all +decide [ ZMod.val ];
        all_goals ring;
      exact Subtype.ext h_eq

/-
Explicit formula for the Frobenius action on Œ±.
-/
theorem explicit_frobenius (hN7 : N ‚â† 7) [CharP (kP P) N] :
  ((uN hN : ZMod 19) ‚àà S1 ‚Üí (red P Œ±_int) ^ N = (3 * (red P Œ±_int)^2 - 8 * (red P Œ±_int) - 38) * (7 : kP P)‚Åª¬π) ‚àß
  ((uN hN : ZMod 19) ‚àà S2 ‚Üí (red P Œ±_int) ^ N = (-3 * (red P Œ±_int)^2 + (red P Œ±_int) + 38) * (7 : kP P)‚Åª¬π) := by
    constructor <;> intro h;
    ¬∑ -- By artin_property, (red P Œ±_int)^N = red P (œÉ_int (uN hN) Œ±_int).
      have h1 : (red P Œ±_int) ^ N = red P (œÉ_int (uN hN) Œ±_int) := by
        rw [ ‚Üê artin_property ];
      -- By sigma_alpha_eq_beta_or_gamma, œÉ_int (uN hN) Œ±_int = Œ≤_int.
      have h2 : œÉ_int (uN hN) Œ±_int = Œ≤_int := by
        exact sigma_alpha_eq_beta_or_gamma ( uN hN ) |>.1 h;
      field_simp;
      rw [ h1, h2, eq_div_iff ] <;> norm_num;
      ¬∑ -- By cyclic_relations_int, we have 7 * Œ≤_int = 3 * Œ±_int^2 - 8 * Œ±_int - 38.
        have h3 : 7 * Œ≤_int = 3 * Œ±_int^2 - 8 * Œ±_int - 38 := by
          exact cyclic_relations_int.1;
        convert congr_arg ( red P ) h3 using 1 <;> norm_num ; ring;
        ¬∑ exact?;
        ¬∑ erw [ map_ofNat, map_ofNat, map_ofNat ] ; ring;
      ¬∑ erw [ CharP.cast_eq_zero_iff ( kP P ) N ];
        exact fun h => hN7 <| by have := Nat.le_of_dvd ( by decide ) h; interval_cases N <;> trivial;
    ¬∑ have h_frob_gamma : (red P Œ±_int) ^ N = red P Œ≥_int := by
        have h_frob_gamma : (red P Œ±_int) ^ N = red P (œÉ_int (uN hN) Œ±_int) := by
          rw [ ‚Üê artin_property ];
        convert h_frob_gamma using 1 ; erw [ sigma_alpha_eq_beta_or_gamma _ |>.2 h ] ;
      have h_cyclic_gamma : 7 * red P Œ≥_int = -3 * (red P Œ±_int) ^ 2 + (red P Œ±_int) + 38 := by
        have h_cyclic_gamma : 7 * Œ≥_int = -3 * Œ±_int ^ 2 + Œ±_int + 38 := by
          exact cyclic_relations_int.2;
        convert congr_arg ( red P ) h_cyclic_gamma using 1
      have h_inv_gamma : 7‚Åª¬π * (7 * red P Œ≥_int) = red P Œ≥_int := by
        rw [ ‚Üê mul_assoc, inv_mul_cancel‚ÇÄ, one_mul ];
        intro h; have := CharP.cast_eq_zero_iff ( kP P ) N 7; simp_all +decide ;
        have := Nat.le_of_dvd ( by decide ) this; interval_cases N <;> trivial;
      rw [h_frob_gamma, ‚Üê h_inv_gamma]
      field_simp [h_cyclic_gamma];
      exact congrArg‚ÇÇ _ ( by linear_combination' h_cyclic_gamma ) rfl

def q_val : ‚Ñï := 19
def a_val : ‚Ñï := 7
def s1_val : ZMod 19 := (- (a_val : ZMod 19) - 3) / 6
def s2_val : ZMod 19 := ((a_val : ZMod 19) - 3) / 6
def c_val (N : ‚Ñï) : ZMod 19 := (N : ZMod 19) ^ ((q_val - 1) / 3)

/-
The polynomial f = x^3 - 19x - 19.
-/
def f_poly : Polynomial L := X^3 - 19*X - 19

/-
alpha is a root of f = x^3 - 19x - 19.
-/
theorem alpha_root : (f_poly).eval Œ± = 0 := by
  unfold f_poly;
  unfold Œ±;
  unfold Œ∑‚ÇÇ Œ∑‚ÇÅ;
  -- By definition of $Œ∂$, we know that $Œ∂^19 = 1$ and $Œ∂^k ‚â† 1$ for $1 ‚â§ k < 19$.
  have hŒ∂ : Œ∂ ^ 19 = 1 ‚àß ‚àÄ k : ‚Ñï, 1 ‚â§ k ‚Üí k < 19 ‚Üí Œ∂ ^ k ‚â† 1 := by
    exact ‚ü® hŒ∂.pow_eq_one, fun k hk‚ÇÅ hk‚ÇÇ hk‚ÇÉ => by have := hŒ∂.pow_eq_one_iff_dvd k; interval_cases k <;> simp_all +decide ‚ü©;
  ring_nf at *;
  simp_all +decide [ pow_succ' ];
  grind +ring

/-
alpha + beta + gamma = 0.
-/
theorem sum_zero : Œ± + Œ≤ + Œ≥ = 0 := by
  unfold Œ± Œ≤ Œ≥
  ring

/-
2a beta = 6 alpha^2 - (a+9)alpha - 4q with a=7, q=19.
-/
theorem beta_relation : 2 * 7 * Œ≤ = 6 * Œ±^2 - (7 + 9) * Œ± - 4 * 19 := by
  -- By multiplying both sides of the equation $7 \beta = 3 \alpha^2 - 8 \alpha - 38$ by 2, we get the desired result.
  have h_mul : 2 * 7 * Œ≤ = 2 * (3 * Œ±^2 - 8 * Œ± - 38) := by
    convert congr_arg ( fun x : L => 2 * x ) ( cyclic_relations.left ) using 1 ; ring;
  convert h_mul using 1 ; ring

/-
s1_val is 11 and s2_val is 7 in ZMod 19.
-/
lemma s1_val_eq : s1_val = 11 := by
  native_decide +revert
lemma s2_val_eq : s2_val = 7 := by
  native_decide +revert

/-
N is in S1 iff c_val N = s2_val.
-/
lemma N_in_S1_iff_c_eq_s2 (hN : N ‚â† 19) : (uN hN : ZMod 19) ‚àà S1 ‚Üî c_val N = s2_val := by
  -- By definition of $c_val$, we know that $c_val N = (N : ZMod 19)^6$.
  have hc_val : c_val N = (N : ZMod 19)^6 := by
    exact?;
  simp +decide [ hc_val, s2_val_eq ];
  unfold uN; simp +decide [ S1 ] ;
  grind

/-
N is in S2 iff c_val N = s1_val.
-/
lemma N_in_S2_iff_c_eq_s1 (hN : N ‚â† 19) : (uN hN : ZMod 19) ‚àà S2 ‚Üî c_val N = s1_val := by
  unfold uN S2 c_val s1_val;
  simp +decide [ q_val, a_val ] ; norm_num [ ZMod.natCast_eq_zero_iff ];
  grind

/-
If c = s1, then alpha^N = gamma. If c = s2, then alpha^N = beta.
-/
theorem final_result {N : ‚Ñï} [Fact (Nat.Prime N)] (hN : N ‚â† 19) (P : Ideal ùìûL) [P.IsMaximal] [CharP (kP P) N] (hN7 : N ‚â† 7) :
  (c_val N = s1_val ‚Üí (red P Œ±_int) ^ N = red P Œ≥_int) ‚àß
  (c_val N = s2_val ‚Üí (red P Œ±_int) ^ N = red P Œ≤_int) := by
    constructor <;> intro h;
    ¬∑ have h_sigma_gamma : œÉ_int (uN hN) Œ±_int = Œ≥_int := by
        apply (sigma_alpha_eq_beta_or_gamma (uN hN)).right;
        convert N_in_S2_iff_c_eq_s1 hN |>.2 h using 1;
      rw [ ‚Üê h_sigma_gamma, artin_property ];
    ¬∑ -- By N_in_S1_iff_c_eq_s2, uN hN is in S1.
      have h_S1 : (uN hN : ZMod 19) ‚àà S1 := by
        convert N_in_S1_iff_c_eq_s2 hN |>.2 h using 1;
      rw [ ‚Üê artin_property ];
      rw [ sigma_alpha_eq_beta_or_gamma _ |>.1 h_S1 ];
      assumptionend Q0019
