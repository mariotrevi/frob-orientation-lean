/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 2951153d-a415-4833-ae52-b95161350424

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We defined the cyclotomic field $L = \mathbb{Q}(\zeta_{877})$ and the Gaussian periods $\eta_0, \eta_1, \eta_2$. We defined the roots $\alpha, \beta, \gamma$ of the cubic polynomial $f = x^3 - 877x - 877$ in terms of these periods. We proved that the Frobenius automorphism $\sigma_N$ permutes the periods based on the index of $N$ modulo the cubic residues. Specifically, we showed that if $c \equiv s_1 \pmod{877}$, then $\sigma_N(\alpha) = \gamma$, and if $c \equiv s_2 \pmod{877}$, then $\sigma_N(\alpha) = \beta$. Using the Artin map property, we deduced the corresponding congruences for $\alpha^N$ modulo a prime ideal $P$ lying over $N$.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 6b741252-ab1b-42b6-a454-99c3ececd4d7

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: c4b15c1b-62c1-4487-bfce-2f7c4d630c6d

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We defined the cyclotomic field L349 and the constants q=349, a=37. We defined the Gaussian periods and the roots alpha, beta, gamma. We proved the algebraic relations between them, including the sum being zero and the relation involving beta and alpha^2. We established the multiplication table for the periods. Finally, we proved the main result describing the action of the Frobenius automorphism on alpha modulo a prime ideal P, showing that alpha^N reduces to gamma or beta depending on the value of c = N^((q-1)/3) modulo q.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 04f6f797-c7e7-4cf6-b418-1c7ab61b9dcf

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We defined the cyclotomic field $L = \mathbb{Q}(\zeta_{97})$ and the Gaussian periods $\eta_0, \eta_1, \eta_2$ of degree 3.
We defined $\alpha = -(\eta_2 - \eta_1)$, $\beta = -(\eta_0 - \eta_2)$, $\gamma = -(\eta_1 - \eta_0)$.
We proved that $\alpha$ is a root of $f(x) = x^3 - 97x - 97$.
We proved the relation $2(19)\beta = 6\alpha^2 - (19+9)\alpha - 4(97)$ and $\alpha + \beta + \gamma = 0$.
We proved that for a prime $N \neq 97$, if $c \equiv N^{(97-1)/3} \pmod{97}$, then:
- If $c \equiv s_1 \pmod{97}$, then $\alpha^N = \gamma$ in the residue field.
- If $c \equiv s_2 \pmod{97}$, then $\alpha^N = \beta$ in the residue field.
This confirms the user's conjecture for $q=97$.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: bc574a7b-2f49-44ce-aa0d-64cc13ca8cca

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Defined the constants q=19, a=7, s1, s2, and the polynomial f = x^3 - 19x - 19.
Proved that alpha is a root of f, alpha + beta + gamma = 0, and the relation for beta.
Proved that if c = s1 then alpha^N = gamma, and if c = s2 then alpha^N = beta, in the residue field.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 013af067-1663-4275-8247-aae4bf9f3f5e

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Formalization of the Frobenius Orientation for q=19.

We define the 19th cyclotomic field L and its ring of integers ùìûL.
We define the Gaussian periods Œ∑‚ÇÄ, Œ∑‚ÇÅ, Œ∑‚ÇÇ and the cubic roots Œ±, Œ≤, Œ≥.
We assume the global cyclic relations and the global permutation action of the Galois group.
We prove the Artin property for the reduction map.
We prove the explicit formula for the Frobenius automorphism on the reduction of Œ± modulo a prime N ‚â† 19, 7.

Main theorems:
- `artin_property`: The reduction of the automorphism œÉ_N coincides with the Frobenius map x ‚Ü¶ x^N.
- `explicit_frobenius`: The explicit action of the Frobenius map on Œ± mod P, given by rational functions of Œ± depending on N mod 19.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 5cea8056-f50a-46c6-b96f-9313f106b5e1

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Let $L = \Q(\zeta_{19})$ be the 19-th cyclotomic field. Let $\zeta$ be a primitive 19-th root of unity.
-/
open Polynomial NumberField

def L : Type := CyclotomicField 19 ‚Ñö

instance : Field L := CyclotomicField.instField 19 ‚Ñö
instance : NumberField L := CyclotomicField.instNumberField 19 ‚Ñö
instance : IsCyclotomicExtension {19} ‚Ñö L := CyclotomicField.isCyclotomicExtension 19 ‚Ñö

def Œ∂ : L := IsCyclotomicExtension.zeta 19 ‚Ñö L

theorem hŒ∂ : IsPrimitiveRoot Œ∂ 19 := IsCyclotomicExtension.zeta_spec 19 ‚Ñö L

/-
Define the Gaussian periods $\eta_0, \eta_1, \eta_2$.
-/
def Œ∑‚ÇÄ : L := Œ∂^1 + Œ∂^7 + Œ∂^8 + Œ∂^11 + Œ∂^12 + Œ∂^18
def Œ∑‚ÇÅ : L := Œ∂^2 + Œ∂^3 + Œ∂^5 + Œ∂^14 + Œ∂^16 + Œ∂^17
def Œ∑‚ÇÇ : L := Œ∂^4 + Œ∂^6 + Œ∂^9 + Œ∂^10 + Œ∂^13 + Œ∂^15

/-
Define the roots $\alpha, \beta, \gamma$ and verify the cyclic relations: $7\beta = 3\alpha^2 - 8\alpha - 38$ and $7\gamma = -3\alpha^2 + \alpha + 38$.
-/
def Œ± : L := -(Œ∑‚ÇÇ - Œ∑‚ÇÅ)
def Œ≤ : L := -(Œ∑‚ÇÄ - Œ∑‚ÇÇ)
def Œ≥ : L := -(Œ∑‚ÇÅ - Œ∑‚ÇÄ)

theorem cyclic_relations : 7 * Œ≤ = 3 * Œ±^2 - 8 * Œ± - 38 ‚àß 7 * Œ≥ = -3 * Œ±^2 + Œ± + 38 := by
  unfold Œ± Œ≤ Œ≥;
  -- Now use the given definitions of $\eta_0$, $\eta_1$, and $\eta_2$ to expand the expressions.
  simp [Œ∑‚ÇÄ, Œ∑‚ÇÅ, Œ∑‚ÇÇ] at *;
  -- Since Œ∂ is a primitive 19th root of unity, we have Œ∂^19 = 1 and the sum of all 19th roots of unity is zero.
  have h_sum : ‚àë i ‚àà Finset.range 19, Œ∂ ^ i = 0 := by
    rw [ geom_sum_eq ] <;> norm_num [ hŒ∂.eq_orderOf ];
    ¬∑ exact Or.inl ( sub_eq_zero.mpr ( hŒ∂.pow_eq_one ) );
    ¬∑ exact hŒ∂.ne_one ( by decide );
  norm_num [ Finset.sum_range_succ ] at *;
  grind +ring

/-
Define the automorphism $\sigma_u$ for $u \in (\Z/19\Z)^\times$.
-/
def œÉ (u : (ZMod 19)À£) : L ‚âÉ‚Çê[‚Ñö] L :=
  (IsCyclotomicExtension.autEquivPow L (Polynomial.cyclotomic.irreducible_rat (n := 19) (by norm_num))).symm u

/-
Define the sets of indices $S_1 = \{2, 3, 5, 14, 16, 17\}$ and $S_2 = \{4, 6, 9, 10, 13, 15\}$.
-/
def S1 : Finset (ZMod 19) := {2, 3, 5, 14, 16, 17}
def S2 : Finset (ZMod 19) := {4, 6, 9, 10, 13, 15}

/-
Theorem 2.1: If $N \in S_1$, then $\sigma_N(\alpha) = \beta$. If $N \in S_2$, then $\sigma_N(\alpha) = \gamma$.
-/
theorem global_permutation (u : (ZMod 19)À£) :
  (u : ZMod 19) ‚àà S1 ‚Üí œÉ u Œ± = Œ≤ ‚àß (u : ZMod 19) ‚àà S2 ‚Üí œÉ u Œ± = Œ≥ := by
    exact fun h1 h2 => False.elim ( absurd h2.2 ( by fin_cases u <;> trivial ) )

/-
Let $\Ok$ be the ring of integers of $L$. Let $\mathfrak{P}$ be a maximal ideal of $\Ok$. Let $k_{\mathfrak{P}} = \Ok / \mathfrak{P}$ be the residue field, and $\pi: \Ok \to k_{\mathfrak{P}}$ be the reduction map.
-/
abbrev ùìûL := ùìû L

variable {N : ‚Ñï} [Fact (Nat.Prime N)] (hN : N ‚â† 19)
variable (P : Ideal ùìûL) [P.IsMaximal]

-- The residue field
def kP := ùìûL ‚ß∏ P

noncomputable instance : Field (kP P) := Ideal.Quotient.field P

-- The reduction map
def red : ùìûL ‚Üí+* kP P := Ideal.Quotient.mk P

/-
Check the signatures of kP and red.
-/
#check kP
#check red

/-
Check if ZMod 19 is a field.
-/
instance : Fact (Nat.Prime 19) := ‚ü®by norm_num‚ü©
#synth Field (ZMod 19)

/-
Define the unit $u_N$ and the integer versions of $\zeta, \eta_i, \alpha, \beta, \gamma$ in $\Ok$.
-/
def uN : (ZMod 19)À£ := Units.mk0 (N : ZMod 19) (by
rw [ Ne.eq_def, ZMod.natCast_eq_zero_iff ] ; exact fun h => hN <| by have := Nat.dvd_of_mod_eq_zero ( Nat.mod_eq_zero_of_dvd h ) ; rw [ Nat.dvd_prime Fact.out ] at this ; aesop;)

def Œ∂_int : ùìûL := IsPrimitiveRoot.toInteger (IsCyclotomicExtension.zeta_spec 19 ‚Ñö L)

def Œ∑‚ÇÄ_int : ùìûL := Œ∂_int^1 + Œ∂_int^7 + Œ∂_int^8 + Œ∂_int^11 + Œ∂_int^12 + Œ∂_int^18
def Œ∑‚ÇÅ_int : ùìûL := Œ∂_int^2 + Œ∂_int^3 + Œ∂_int^5 + Œ∂_int^14 + Œ∂_int^16 + Œ∂_int^17
def Œ∑‚ÇÇ_int : ùìûL := Œ∂_int^4 + Œ∂_int^6 + Œ∂_int^9 + Œ∂_int^10 + Œ∂_int^13 + Œ∂_int^15

def Œ±_int : ùìûL := -(Œ∑‚ÇÇ_int - Œ∑‚ÇÅ_int)
def Œ≤_int : ùìûL := -(Œ∑‚ÇÄ_int - Œ∑‚ÇÇ_int)
def Œ≥_int : ùìûL := -(Œ∑‚ÇÅ_int - Œ∑‚ÇÄ_int)

/-
Check the signatures of uN and Œ±_int.
-/
#check uN
#check Œ±_int

/-
Define the restriction of $\sigma_u$ to $\Ok$.
-/
def œÉ_int (u : (ZMod 19)À£) (x : ùìûL) : ùìûL := ‚ü®œÉ u x, by
  -- Since $x$ is in the integral closure of $\mathbb{Z}$ in $L$, it is integral over $\mathbb{Z}$. The automorphism $\sigma_u$ preserves integrality, so $\sigma_u(x)$ is also integral over $\mathbb{Z}$.
  have h_integral : IsIntegral ‚Ñ§ x := by
    exact?;
  obtain ‚ü® p, hp ‚ü© := h_integral;
  refine' ‚ü® p, hp.1, _ ‚ü©;
  convert congr_arg ( œÉ u ) ( show ( p.eval‚ÇÇ ( algebraMap ‚Ñ§ L ) x : L ) = 0 from ?_ ) using 1;
  ¬∑ simp +decide [ Polynomial.eval‚ÇÇ_eq_sum_range ];
  ¬∑ norm_num;
  ¬∑ convert congr_arg ( algebraMap ùìûL L ) hp.2 using 1;
    simp +decide [ Polynomial.eval‚ÇÇ_eq_sum_range ]‚ü©

/-
The restriction of $\sigma_u$ to $\Ok$ is compatible with the coercion to $L$.
-/
theorem œÉ_int_coe (u : (ZMod 19)À£) (x : ùìûL) : (œÉ_int u x : L) = œÉ u x := rfl

/-
Define gal_unit as a unit in (ZMod 19).
-/
def gal_unit (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 19) : (ZMod 19)À£ := Units.mk0 (N : ZMod 19) (by
  rw [Ne, ZMod.natCast_zmod_eq_zero_iff_dvd]
  intro h
  have hN_prime : Nat.Prime N := Fact.out
  have : 19 = 1 ‚à® 19 = N := (Nat.dvd_prime hN_prime).mp h
  have : 19 = N := this.resolve_left (by norm_num)
  exact hN this.symm)

/-
Check Algebra Z OL instance.
-/
#synth Algebra ‚Ñ§ ùìûL

/-
œÉ_int preserves addition.
-/
lemma sigma_int_add (u : (ZMod 19)À£) (x y : ùìûL) : œÉ_int u (x + y) = œÉ_int u x + œÉ_int u y := by
  convert congr_arg ( œÉ_int u ) ( show ( x + y : ùìûL ) = ( x : ùìûL ) + ( y : ùìûL ) from rfl ) using 1;
  -- Since œÉ_int u is the restriction of œÉ u, and œÉ u is a ring homomorphism, it preserves addition. Thus, œÉ u (x + y) = œÉ u x + œÉ u y. Therefore, œÉ_int u (x + y) = œÉ u (x + y) = œÉ u x + œÉ u y = œÉ_int u x + œÉ_int u y.
  have h_add : œÉ u (x + y) = œÉ u x + œÉ u y := by
    exact map_add _ _ _;
  exact Subtype.ext h_add.symm

/-
œÉ_int preserves multiplication.
-/
lemma sigma_int_mul (u : (ZMod 19)À£) (x y : ùìûL) : œÉ_int u (x * y) = œÉ_int u x * œÉ_int u y := by
  have h_sigma_int_mul : ‚àÄ (x y : ùìûL), œÉ_int u (x * y) = œÉ_int u x * œÉ_int u y := by
    exact fun x y => by ext; simp +decide [ œÉ_int_coe ] ;
  exact h_sigma_int_mul x y

/-
œÉ_int maps Œ∂_int to Œ∂_int^N.
-/
lemma sigma_zeta : œÉ_int (uN hN) Œ∂_int = Œ∂_int ^ N := by
  -- Since Œ∂_int is the image of Œ∂ in the ring of integers, applying œÉ_int to Œ∂_int should be the same as applying œÉ to Œ∂ and then converting the result back to the ring of integers.
  have h_sigma_int_Œ∂ : œÉ_int (uN hN) Œ∂_int = ‚ü®œÉ (uN hN) Œ∂, by
    refine' ‚ü® Polynomial.X ^ 19 - 1, _, _ ‚ü©;
    ¬∑ erw [ Polynomial.Monic, Polynomial.leadingCoeff_X_pow_sub_C ] ; norm_num;
    ¬∑ simp +decide [ ‚Üê map_pow, ‚Üê map_sub, hŒ∂.pow_eq_one ]‚ü© := by
    exact Subtype.ext rfl
  generalize_proofs at *;
  -- Since œÉ is defined by Œ∂ ‚Ü¶ Œ∂^u, we have œÉ (uN hN) Œ∂ = Œ∂^(uN hN).
  have h_sigma_Œ∂ : œÉ (uN hN) Œ∂ = Œ∂ ^ (uN hN : ZMod 19).val := by
    -- Since œÉ is defined by Œ∂ ‚Ü¶ Œ∂^u, we have œÉ (uN hN) Œ∂ = Œ∂^(uN hN) by definition of œÉ.
    have h_sigma_Œ∂ : ‚àÄ u : (ZMod 19)À£, œÉ u Œ∂ = Œ∂ ^ (u : ZMod 19).val := by
      intros u
      simp [œÉ];
      erw [ PowerBasis.equivOfMinpoly_apply ];
      erw [ PowerBasis.lift_gen ] ; aesop;
    exact h_sigma_Œ∂ _;
  -- Since $uN hN$ is a unit in $(\mathbb{Z}/19\mathbb{Z})^\times$, we have $uN hN \equiv N \pmod{19}$.
  have h_unit : (uN hN : ZMod 19).val = N % 19 := by
    unfold uN; aesop;
  -- Since $N \equiv N \pmod{19}$, we have $\zeta^{N \mod 19} = \zeta^N$.
  have h_exp : Œ∂ ^ (N % 19) = Œ∂ ^ N := by
    rw [ ‚Üê Nat.mod_add_div N 19, pow_add, pow_mul ] ; norm_num [ h_unit ];
    have h_exp : Œ∂ ^ 19 = 1 := by
      exact hŒ∂.pow_eq_one;
    rw [ h_exp, one_pow, mul_one ];
  convert h_sigma_int_Œ∂ using 1;
  ext; simp +decide [ h_sigma_Œ∂, h_unit, h_exp ] ;
  exact?

/-
The ring of integers is generated by Œ∂_int.
-/
lemma adjoin_zeta_eq_top : Algebra.adjoin ‚Ñ§ ({Œ∂_int} : Set ùìûL) = ‚ä§ := by
  -- By definition of cyclotomic fields, the ring of integers of $L$ is $\mathbb{Z}[\zeta_{19}]$.
  have h_cyclotomic : IsCyclotomicExtension {19} ‚Ñ§ ùìûL := by
    exact?;
  have := h_cyclotomic.2;
  ext x;
  simp_all +decide [ Algebra.adjoin_singleton_eq_range_aeval ];
  have := this x;
  refine' Algebra.adjoin_induction _ _ _ _ this;
  ¬∑ intro x hx
    use Polynomial.X ^ (Nat.find (show ‚àÉ k : ‚Ñï, x = Œ∂_int ^ k from by
                                    have h_root : ‚àÄ x : L, x ^ 19 = 1 ‚Üí ‚àÉ k : ‚Ñï, x = Œ∂ ^ k := by
                                      intro x hx
                                      have h_root : x ‚àà Set.range (fun k : ‚Ñï => Œ∂ ^ k) := by
                                        have h_root : x ‚àà Set.range (fun k : ZMod 19 => Œ∂ ^ k.val) := by
                                          have h_poly : x ^ 19 = 1 := hx
                                          have h_poly_factor : ‚àè k ‚àà Finset.range 19, (Polynomial.X - Polynomial.C (Œ∂ ^ k)) = Polynomial.X ^ 19 - 1 := by
                                            refine' Polynomial.eq_of_degree_sub_lt_of_eval_finset_eq _ _ _;
                                            exact Finset.image ( fun k : ‚Ñï => Œ∂ ^ k ) ( Finset.range 19 );
                                            ¬∑ refine' lt_of_lt_of_le ( Polynomial.degree_sub_lt _ _ _ ) _;
                                              ¬∑ norm_num [ Polynomial.degree_prod, Polynomial.degree_X_pow_sub_C ];
                                                erw [ Polynomial.degree_X_pow_sub_C ] <;> norm_num [ Polynomial.degree_sub_eq_left_of_degree_lt ];
                                                erw [ Finset.sum_congr rfl fun _ _ => Polynomial.degree_sub_eq_left_of_degree_lt <| ?_ ] <;> norm_num;
                                                erw [ Polynomial.degree_C ] <;> norm_num;
                                                exact hŒ∂.ne_zero ( by norm_num );
                                              ¬∑ exact Finset.prod_ne_zero_iff.mpr fun i hi => Polynomial.X_sub_C_ne_zero _;
                                              ¬∑ norm_num [ Polynomial.leadingCoeff_prod ];
                                                exact Finset.prod_eq_one fun i hi => by rw [ ‚Üê Polynomial.C_pow, Polynomial.leadingCoeff_X_sub_C ] ;
                                              ¬∑ rw [ Polynomial.degree_prod, Finset.sum_congr rfl fun _ _ => Polynomial.degree_X_sub_C _ ] ; norm_num;
                                                rw [ Finset.card_image_of_injOn ] <;> norm_num;
                                                intro a ha b hb hab; have := hŒ∂.pow_inj ( show a < 19 from ha ) ( show b < 19 from hb ) ; aesop;
                                            ¬∑ simp +decide [ Polynomial.eval_prod ];
                                              intro a ha; rw [ Finset.prod_eq_prod_diff_singleton_mul <| Finset.mem_range.mpr ha ] ; ring;
                                              rw [ pow_mul', show Œ∂ ^ 19 = 1 from by exact hŒ∂.pow_eq_one ] ; norm_num
                                          replace h_poly_factor := congr_arg ( Polynomial.eval x ) h_poly_factor ; simp_all +decide [ Polynomial.eval_prod, Finset.prod_eq_zero_iff, sub_eq_iff_eq_add ];
                                          obtain ‚ü® a, ha, rfl ‚ü© := h_poly_factor; exact ‚ü® ‚ü® a, ha ‚ü©, rfl ‚ü© ;
                                        grind;
                                      exact h_root.imp fun k hk => hk.symm;
                                    obtain ‚ü® k, hk ‚ü© := h_root ( algebraMap ùìûL L x ) ( by simpa [ ‚Üê map_pow ] using congr_arg ( algebraMap ùìûL L ) hx );
                                    use k;
                                    exact?));
    simp +zetaDelta at *;
    exact Nat.find_spec ( _ : ‚àÉ k : ‚Ñï, x = Œ∂_int ^ k ) ‚ñ∏ rfl.symm;
  ¬∑ exact fun r => ‚ü® Polynomial.C r, by simp +decide ‚ü©;
  ¬∑ rintro x y hx hy ‚ü® p, rfl ‚ü© ‚ü® q, rfl ‚ü© ; exact ‚ü® p + q, by simp +decide [ Polynomial.aeval_add ] ‚ü©;
  ¬∑ rintro x y hx hy ‚ü® p, rfl ‚ü© ‚ü® q, rfl ‚ü© ; exact ‚ü® p * q, by simp +decide [ Polynomial.aeval_mul ] ‚ü©

/-
The automorphism œÉ_N reduces to the Frobenius map x ‚Ü¶ x^N modulo P.
-/
theorem artin_property [CharP (kP P) N] (x : ùìûL) : red P (œÉ_int (uN hN) x) = (red P x) ^ N := by
  -- By definition of $œÉ_int$, we know that $œÉ_int (uN hN) x = (œÉ_int (uN hN)) x$.
  have h_sigma_int : ‚àÄ x : ùìûL, (red P) (œÉ_int (uN hN) x) = (red P x) ^ N := by
    have h_gen : ‚àÄ x : ùìûL, x ‚àà Algebra.adjoin ‚Ñ§ ({Œ∂_int} : Set ùìûL) := by
      exact fun x => by rw [ adjoin_zeta_eq_top ] ; exact Algebra.mem_top;
    intro x
    induction' h_gen x using Algebra.adjoin_induction with x hx ih;
    ¬∑ convert congr_arg ( red P ) ( sigma_zeta hN ) using 1;
      ¬∑ grind;
      ¬∑ rw [ show x = Œ∂_int from hx ] ; simp +decide [ red ] ;
    ¬∑ -- Since œÉ_int (uN hN) is an algebra homomorphism, it preserves the algebra map.
      have h_sigma_int_algebra_map : ‚àÄ (ih : ‚Ñ§), œÉ_int (uN hN) (algebraMap ‚Ñ§ ùìûL ih) = algebraMap ‚Ñ§ ùìûL ih := by
        unfold œÉ_int; aesop;
      convert congr_arg ( red P ) ( h_sigma_int_algebra_map ih ) using 1;
      erw [ Ideal.Quotient.eq ];
      -- Since $P$ is a maximal ideal in $\mathcal{O}_L$, we know that $N \in P$.
      have hN_in_P : (algebraMap ‚Ñ§ ùìûL) N ‚àà P := by
        have hN_in_P : (algebraMap ‚Ñ§ (ùìûL ‚ß∏ P)) N = 0 := by
          convert CharP.cast_eq_zero ( kP P ) N using 1;
        erw [ Ideal.Quotient.eq_zero_iff_mem ] at hN_in_P ; aesop;
      have hN_in_P : ‚àÄ (ih : ‚Ñ§), (algebraMap ‚Ñ§ ùìûL) (ih ^ N - ih) ‚àà P := by
        intro ih
        have hN_in_P : (algebraMap ‚Ñ§ ùìûL) (ih ^ N - ih) = (algebraMap ‚Ñ§ ùìûL) N * (algebraMap ‚Ñ§ ùìûL) ((ih ^ N - ih) / N) := by
          rw [ ‚Üê map_mul, Int.mul_ediv_cancel' ];
          haveI := Fact.mk ( Fact.out : Nat.Prime N ) ; simp +decide [ ‚Üê ZMod.intCast_zmod_eq_zero_iff_dvd ] ;
        exact hN_in_P.symm ‚ñ∏ P.mul_mem_right _ ‚Äπ_‚Ä∫;
      convert hN_in_P ih using 1 ; norm_num [ map_sub, map_pow ];
    ¬∑ simp_all +decide [ sigma_int_add ];
      rw [ add_pow_char ];
    ¬∑ rename_i hx hy ihx ihy;
      convert congr_arg‚ÇÇ ( ¬∑ * ¬∑ ) ihx ihy using 1 <;> ring;
      ¬∑ convert congr_arg ( red P ) ( sigma_int_mul ( uN hN ) _ _ ) using 1;
      ¬∑ simp +decide [ ‚Üê mul_pow ];
  exact h_sigma_int x

/-
The integer versions of Œ±, Œ≤, Œ≥ coerce to the field versions.
-/
lemma coe_int_defs : (Œ±_int : L) = Œ± ‚àß (Œ≤_int : L) = Œ≤ ‚àß (Œ≥_int : L) = Œ≥ := by
  bound

/-
The cyclic relations hold for the integer versions Œ±_int, Œ≤_int, Œ≥_int.
-/
lemma cyclic_relations_int : 7 * Œ≤_int = 3 * Œ±_int^2 - 8 * Œ±_int - 38 ‚àß 7 * Œ≥_int = -3 * Œ±_int^2 + Œ±_int + 38 := by
  have h_intRelations : (7 * Œ≤_int : L) = 3 * Œ±_int ^ 2 - 8 * Œ±_int - 38 ‚àß (7 * Œ≥_int : L) = -3 * Œ±_int ^ 2 + Œ±_int + 38 := by
    convert cyclic_relations using 1;
  convert h_intRelations;
  ¬∑ erw [ ‚Üê Subtype.coe_inj ] ; norm_num;
    exact?;
  ¬∑ erw [ ‚Üê Subtype.coe_inj ] ; norm_num;
    exact?

/-
The permutation action on the integer versions of Œ±, Œ≤, Œ≥ matches the global action.
-/
lemma sigma_alpha_eq_beta_or_gamma (u : (ZMod 19)À£) :
  ((u : ZMod 19) ‚àà S1 ‚Üí œÉ_int u Œ±_int = Œ≤_int) ‚àß
  ((u : ZMod 19) ‚àà S2 ‚Üí œÉ_int u Œ±_int = Œ≥_int) := by
    constructor;
    ¬∑ intro hu
      have h_eq : (œÉ_int u Œ±_int : L) = Œ≤_int := by
        rw [ œÉ_int_coe, coe_int_defs.1, coe_int_defs.2.1 ];
        unfold œÉ;
        unfold Œ± Œ≤ Œ∑‚ÇÄ Œ∑‚ÇÅ Œ∑‚ÇÇ;
        fin_cases u <;> simp +decide at hu ‚ä¢ hu ‚ä¢;
        all_goals erw [ PowerBasis.equivOfMinpoly_apply ] ; norm_num;
        all_goals erw [ PowerBasis.lift_gen ];
        all_goals erw [ show Œ∂ = IsCyclotomicExtension.zeta 19 ‚Ñö L from rfl ] ; norm_num [ ZMod.val ] ; ring!;
        all_goals have := IsCyclotomicExtension.zeta_pow 19 ‚Ñö L; simp_all +decide [ pow_succ, mul_assoc ] ;
        grind +ring;
        ¬∑ grind +ring;
        ¬∑ grind +ring;
        ¬∑ grind +ring;
        ¬∑ grind +ring;
        ¬∑ grind +ring;
      exact Subtype.ext h_eq;
    ¬∑ intro hu
      have h_eq : (œÉ_int u Œ±_int : L) = Œ≥_int := by
        simp +decide [ œÉ_int_coe, coe_int_defs ];
        unfold Œ≥;
        unfold Œ± Œ∑‚ÇÄ Œ∑‚ÇÅ Œ∑‚ÇÇ;
        -- By definition of $œÉ$, we know that $œÉ u (Œ∂^k) = Œ∂^{ku}$ for any integer $k$.
        have h_sigma_zeta : ‚àÄ k : ‚Ñï, (œÉ u) (Œ∂ ^ k) = Œ∂ ^ (k * u.val.val % 19) := by
          -- By definition of $œÉ$, we know that $œÉ u (Œ∂) = Œ∂^u$.
          have h_sigma_zeta : (œÉ u) Œ∂ = Œ∂ ^ u.val.val := by
            have h_sigma_zeta : ‚àÄ u : (ZMod 19)À£, œÉ u Œ∂ = Œ∂ ^ (u : ZMod 19).val := by
              unfold œÉ;
              simp +zetaDelta at *;
              intro u; exact (by
              convert ( IsCyclotomicExtension.autEquivPow L ( Polynomial.cyclotomic.irreducible_rat ( n := 19 ) ( by norm_num ) ) ).symm_apply_eq.mpr _;
              rotate_left;
              exact u;
              exact ( IsCyclotomicExtension.autEquivPow L ( Polynomial.cyclotomic.irreducible_rat ( n := 19 ) ( by norm_num ) ) ).symm u;
              ¬∑ exact?;
              ¬∑ erw [ PowerBasis.equivOfMinpoly_gen ];
                simp +decide [ IsPrimitiveRoot.powerBasis ];
                rfl);
            exact h_sigma_zeta u;
          -- Since Œ∂ is a primitive 19th root of unity, we have Œ∂^19 = 1. Therefore, Œ∂^(k*u.val.val) = Œ∂^(k*u.val.val mod 19).
          have h_exp : ‚àÄ k : ‚Ñï, Œ∂ ^ (k * u.val.val) = Œ∂ ^ (k * u.val.val % 19) := by
            have h_exp : Œ∂ ^ 19 = 1 := by
              exact hŒ∂.pow_eq_one;
            exact fun k => by rw [ ‚Üê Nat.mod_add_div ( k * u.val.val ) 19, pow_add, pow_mul ] ; aesop;
          simp_all +decide [ pow_mul' ];
        fin_cases u <;> simp +decide [ * ] at hu ‚ä¢;
        all_goals simp_all +decide [ ZMod.val ];
        all_goals ring;
      exact Subtype.ext h_eq

/-
Explicit formula for the Frobenius action on Œ±.
-/
theorem explicit_frobenius (hN7 : N ‚â† 7) [CharP (kP P) N] :
  ((uN hN : ZMod 19) ‚àà S1 ‚Üí (red P Œ±_int) ^ N = (3 * (red P Œ±_int)^2 - 8 * (red P Œ±_int) - 38) * (7 : kP P)‚Åª¬π) ‚àß
  ((uN hN : ZMod 19) ‚àà S2 ‚Üí (red P Œ±_int) ^ N = (-3 * (red P Œ±_int)^2 + (red P Œ±_int) + 38) * (7 : kP P)‚Åª¬π) := by
    constructor <;> intro h;
    ¬∑ -- By artin_property, (red P Œ±_int)^N = red P (œÉ_int (uN hN) Œ±_int).
      have h1 : (red P Œ±_int) ^ N = red P (œÉ_int (uN hN) Œ±_int) := by
        rw [ ‚Üê artin_property ];
      -- By sigma_alpha_eq_beta_or_gamma, œÉ_int (uN hN) Œ±_int = Œ≤_int.
      have h2 : œÉ_int (uN hN) Œ±_int = Œ≤_int := by
        exact sigma_alpha_eq_beta_or_gamma ( uN hN ) |>.1 h;
      field_simp;
      rw [ h1, h2, eq_div_iff ] <;> norm_num;
      ¬∑ -- By cyclic_relations_int, we have 7 * Œ≤_int = 3 * Œ±_int^2 - 8 * Œ±_int - 38.
        have h3 : 7 * Œ≤_int = 3 * Œ±_int^2 - 8 * Œ±_int - 38 := by
          exact cyclic_relations_int.1;
        convert congr_arg ( red P ) h3 using 1 <;> norm_num ; ring;
        ¬∑ exact?;
        ¬∑ erw [ map_ofNat, map_ofNat, map_ofNat ] ; ring;
      ¬∑ erw [ CharP.cast_eq_zero_iff ( kP P ) N ];
        exact fun h => hN7 <| by have := Nat.le_of_dvd ( by decide ) h; interval_cases N <;> trivial;
    ¬∑ have h_frob_gamma : (red P Œ±_int) ^ N = red P Œ≥_int := by
        have h_frob_gamma : (red P Œ±_int) ^ N = red P (œÉ_int (uN hN) Œ±_int) := by
          rw [ ‚Üê artin_property ];
        convert h_frob_gamma using 1 ; erw [ sigma_alpha_eq_beta_or_gamma _ |>.2 h ] ;
      have h_cyclic_gamma : 7 * red P Œ≥_int = -3 * (red P Œ±_int) ^ 2 + (red P Œ±_int) + 38 := by
        have h_cyclic_gamma : 7 * Œ≥_int = -3 * Œ±_int ^ 2 + Œ±_int + 38 := by
          exact cyclic_relations_int.2;
        convert congr_arg ( red P ) h_cyclic_gamma using 1
      have h_inv_gamma : 7‚Åª¬π * (7 * red P Œ≥_int) = red P Œ≥_int := by
        rw [ ‚Üê mul_assoc, inv_mul_cancel‚ÇÄ, one_mul ];
        intro h; have := CharP.cast_eq_zero_iff ( kP P ) N 7; simp_all +decide ;
        have := Nat.le_of_dvd ( by decide ) this; interval_cases N <;> trivial;
      rw [h_frob_gamma, ‚Üê h_inv_gamma]
      field_simp [h_cyclic_gamma];
      exact congrArg‚ÇÇ _ ( by linear_combination' h_cyclic_gamma ) rfl

def q_val : ‚Ñï := 19
def a_val : ‚Ñï := 7
def s1_val : ZMod 19 := (- (a_val : ZMod 19) - 3) / 6
def s2_val : ZMod 19 := ((a_val : ZMod 19) - 3) / 6
def c_val (N : ‚Ñï) : ZMod 19 := (N : ZMod 19) ^ ((q_val - 1) / 3)

/-
The polynomial f = x^3 - 19x - 19.
-/
def f_poly : Polynomial L := X^3 - 19*X - 19

/-
alpha is a root of f = x^3 - 19x - 19.
-/
theorem alpha_root : (f_poly).eval Œ± = 0 := by
  unfold f_poly;
  unfold Œ±;
  unfold Œ∑‚ÇÇ Œ∑‚ÇÅ;
  -- By definition of $Œ∂$, we know that $Œ∂^19 = 1$ and $Œ∂^k ‚â† 1$ for $1 ‚â§ k < 19$.
  have hŒ∂ : Œ∂ ^ 19 = 1 ‚àß ‚àÄ k : ‚Ñï, 1 ‚â§ k ‚Üí k < 19 ‚Üí Œ∂ ^ k ‚â† 1 := by
    exact ‚ü® hŒ∂.pow_eq_one, fun k hk‚ÇÅ hk‚ÇÇ hk‚ÇÉ => by have := hŒ∂.pow_eq_one_iff_dvd k; interval_cases k <;> simp_all +decide ‚ü©;
  ring_nf at *;
  simp_all +decide [ pow_succ' ];
  grind +ring

/-
alpha + beta + gamma = 0.
-/
theorem sum_zero : Œ± + Œ≤ + Œ≥ = 0 := by
  unfold Œ± Œ≤ Œ≥
  ring

/-
2a beta = 6 alpha^2 - (a+9)alpha - 4q with a=7, q=19.
-/
theorem beta_relation : 2 * 7 * Œ≤ = 6 * Œ±^2 - (7 + 9) * Œ± - 4 * 19 := by
  -- By multiplying both sides of the equation $7 \beta = 3 \alpha^2 - 8 \alpha - 38$ by 2, we get the desired result.
  have h_mul : 2 * 7 * Œ≤ = 2 * (3 * Œ±^2 - 8 * Œ± - 38) := by
    convert congr_arg ( fun x : L => 2 * x ) ( cyclic_relations.left ) using 1 ; ring;
  convert h_mul using 1 ; ring

/-
s1_val is 11 and s2_val is 7 in ZMod 19.
-/
lemma s1_val_eq : s1_val = 11 := by
  native_decide +revert
lemma s2_val_eq : s2_val = 7 := by
  native_decide +revert

/-
N is in S1 iff c_val N = s2_val.
-/
lemma N_in_S1_iff_c_eq_s2 (hN : N ‚â† 19) : (uN hN : ZMod 19) ‚àà S1 ‚Üî c_val N = s2_val := by
  -- By definition of $c_val$, we know that $c_val N = (N : ZMod 19)^6$.
  have hc_val : c_val N = (N : ZMod 19)^6 := by
    exact?;
  simp +decide [ hc_val, s2_val_eq ];
  unfold uN; simp +decide [ S1 ] ;
  grind

/-
N is in S2 iff c_val N = s1_val.
-/
lemma N_in_S2_iff_c_eq_s1 (hN : N ‚â† 19) : (uN hN : ZMod 19) ‚àà S2 ‚Üî c_val N = s1_val := by
  unfold uN S2 c_val s1_val;
  simp +decide [ q_val, a_val ] ; norm_num [ ZMod.natCast_eq_zero_iff ];
  grind

/-
If c = s1, then alpha^N = gamma. If c = s2, then alpha^N = beta.
-/
theorem final_result {N : ‚Ñï} [Fact (Nat.Prime N)] (hN : N ‚â† 19) (P : Ideal ùìûL) [P.IsMaximal] [CharP (kP P) N] (hN7 : N ‚â† 7) :
  (c_val N = s1_val ‚Üí (red P Œ±_int) ^ N = red P Œ≥_int) ‚àß
  (c_val N = s2_val ‚Üí (red P Œ±_int) ^ N = red P Œ≤_int) := by
    constructor <;> intro h;
    ¬∑ have h_sigma_gamma : œÉ_int (uN hN) Œ±_int = Œ≥_int := by
        apply (sigma_alpha_eq_beta_or_gamma (uN hN)).right;
        convert N_in_S2_iff_c_eq_s1 hN |>.2 h using 1;
      rw [ ‚Üê h_sigma_gamma, artin_property ];
    ¬∑ -- By N_in_S1_iff_c_eq_s2, uN hN is in S1.
      have h_S1 : (uN hN : ZMod 19) ‚àà S1 := by
        convert N_in_S1_iff_c_eq_s2 hN |>.2 h using 1;
      rw [ ‚Üê artin_property ];
      rw [ sigma_alpha_eq_beta_or_gamma _ |>.1 h_S1 ];
      assumption

/-
If c = s1, then alpha^N = gamma. If c = s2, then alpha^N = beta.
-/
theorem final_result_proof {N : ‚Ñï} [Fact (Nat.Prime N)] (hN : N ‚â† 19) (P : Ideal ùìûL) [P.IsMaximal] [CharP (kP P) N] (hN7 : N ‚â† 7) :
  (c_val N = s1_val ‚Üí (red P Œ±_int) ^ N = red P Œ≥_int) ‚àß
  (c_val N = s2_val ‚Üí (red P Œ±_int) ^ N = red P Œ≤_int) := by
    convert final_result hN P hN7 using 1

/-
Definitions of constants q=97, a=19, s1, s2, and c for the new problem instance.
-/
def q' : ‚Ñï := 97
def a' : ‚Ñï := 19
def s1' : ZMod 97 := (- (a' : ZMod 97) - 3) * (6 : ZMod 97)‚Åª¬π
def s2' : ZMod 97 := ((a' : ZMod 97) - 3) * (6 : ZMod 97)‚Åª¬π
def c' (N : ‚Ñï) : ZMod 97 := (N : ZMod 97) ^ ((q' - 1) / 3)

/-
Define the cyclotomic field L97 and the primitive root of unity zeta97.
-/
open Polynomial NumberField

def L97 : Type := CyclotomicField 97 ‚Ñö

instance : Field L97 := CyclotomicField.instField 97 ‚Ñö
instance : NumberField L97 := CyclotomicField.instNumberField 97 ‚Ñö
instance : IsCyclotomicExtension {97} ‚Ñö L97 := CyclotomicField.isCyclotomicExtension 97 ‚Ñö

def Œ∂97 : L97 := IsCyclotomicExtension.zeta 97 ‚Ñö L97

instance : Fact (Nat.Prime 97) := ‚ü®by norm_num‚ü©

/-
Define the sets of indices and the Gaussian periods for q=97. Define alpha, beta, gamma.
-/
def S_cubic_res : Finset (ZMod 97) := {x | x ‚â† 0 ‚àß x ^ 32 = 1}
def S_s1 : Finset (ZMod 97) := {x | x ‚â† 0 ‚àß x ^ 32 = s1'}
def S_s2 : Finset (ZMod 97) := {x | x ‚â† 0 ‚àß x ^ 32 = s2'}

def Œ∑‚ÇÄ' : L97 := ‚àë x ‚àà S_cubic_res, Œ∂97 ^ (x.val : ‚Ñï)
def Œ∑‚ÇÅ' : L97 := ‚àë x ‚àà S_s2, Œ∂97 ^ (x.val : ‚Ñï)
def Œ∑‚ÇÇ' : L97 := ‚àë x ‚àà S_s1, Œ∂97 ^ (x.val : ‚Ñï)

def Œ±' : L97 := -(Œ∑‚ÇÇ' - Œ∑‚ÇÅ')
def Œ≤' : L97 := -(Œ∑‚ÇÄ' - Œ∑‚ÇÇ')
def Œ≥' : L97 := -(Œ∑‚ÇÅ' - Œ∑‚ÇÄ')

/-
The sum of alpha, beta, and gamma is zero.
-/
theorem sum_zero' : Œ±' + Œ≤' + Œ≥' = 0 := by
  unfold Œ±' Œ≤' Œ≥' ;
  ring

/-
Definitions of index function, cyclotomic numbers, and period function for q=97.
-/
def ind (x : ZMod 97) : ZMod 3 :=
  if x ‚àà S_cubic_res then 0
  else if x ‚àà S_s1 then 1
  else 2

def cyc_num (i j : ZMod 3) : ‚Ñï :=
  Fintype.card { x : ZMod 97 // x ‚â† 0 ‚àß x ‚â† 1 ‚àß ind x = i ‚àß ind (1 - x) = j }

def period (i : ZMod 3) : L97 :=
  if i = 0 then Œ∑‚ÇÄ'
  else if i = 1 then Œ∑‚ÇÇ'
  else Œ∑‚ÇÅ'

/-
The period function maps 0, 1, 2 to eta0', eta2', eta1' respectively.
-/
lemma period_eq_def : period 0 = Œ∑‚ÇÄ' ‚àß period 1 = Œ∑‚ÇÇ' ‚àß period 2 = Œ∑‚ÇÅ' := by
  aesop

/-
The index function correctly identifies which coset an element belongs to.
-/
lemma ind_spec (x : ZMod 97) (hx : x ‚â† 0) :
  (ind x = 0 ‚Üî x ‚àà S_cubic_res) ‚àß
  (ind x = 1 ‚Üî x ‚àà S_s1) ‚àß
  (ind x = 2 ‚Üî x ‚àà S_s2) := by
    native_decide +revert

/-
Compute the cyclotomic numbers for q=97.
-/
#eval (cyc_num 0 0, cyc_num 0 1, cyc_num 0 2)
#eval (cyc_num 1 0, cyc_num 1 1, cyc_num 1 2)
#eval (cyc_num 2 0, cyc_num 2 1, cyc_num 2 2)

/-
Values of the cyclotomic numbers for q=97.
-/
lemma cyc_num_vals :
  cyc_num 0 0 = 12 ‚àß cyc_num 0 1 = 10 ‚àß cyc_num 0 2 = 9 ‚àß
  cyc_num 1 0 = 10 ‚àß cyc_num 1 1 = 9 ‚àß cyc_num 1 2 = 13 ‚àß
  cyc_num 2 0 = 9 ‚àß cyc_num 2 1 = 13 ‚àß cyc_num 2 2 = 10 := by
  native_decide

/-
Number of solutions to x + y = u with ind x = i and ind y = j.
-/
def N_sol (i j : ZMod 3) (u : ZMod 97) : ‚Ñï :=
  Fintype.card { p : ZMod 97 √ó ZMod 97 // p.1 ‚â† 0 ‚àß p.2 ‚â† 0 ‚àß ind p.1 = i ‚àß ind p.2 = j ‚àß p.1 + p.2 = u }

/-
The index of -1 is 0.
-/
lemma ind_neg_one : ind (-1) = 0 := by
  native_decide

/-
The index function is a homomorphism from the multiplicative group to the additive group Z/3Z.
-/
lemma ind_mul (x y : ZMod 97) (hx : x ‚â† 0) (hy : y ‚â† 0) : ind (x * y) = ind x + ind y := by
  revert x y
  native_decide

/-
The index of the inverse is the negative of the index.
-/
lemma ind_inv (x : ZMod 97) (hx : x ‚â† 0) : ind (x‚Åª¬π) = - ind x := by
  revert x
  native_decide

/-
The number of solutions to x+y=u depends only on the index of u.
-/
lemma N_sol_eq_cyc_num (i j : ZMod 3) (u : ZMod 97) (hu : u ‚â† 0) :
  N_sol i j u = cyc_num (i - ind u) (j - ind u) := by
    refine' Fintype.card_congr _;
    refine' Equiv.ofBijective ( fun x => ‚ü® x.val.1 / u, _, _, _, _ ‚ü© ) ‚ü® _, _ ‚ü©;
    all_goals simp_all +decide [ div_eq_iff, Function.Injective, Function.Surjective ];
    grind;
    ¬∑ grind;
    ¬∑ have := ind_mul ( x.val.1 / u ) u; simp_all +decide [ div_eq_mul_inv ] ;
      grind;
    ¬∑ have h_ind : ind (x.val.2 / u) = ind x.val.2 - ind u := by
        have h_ind : ind (x.val.2 / u) = ind x.val.2 + ind (u‚Åª¬π) := by
          apply ind_mul; exact (by
          exact x.2.2.1); exact (by
          haveI := Fact.mk ( by decide : Nat.Prime 97 ) ; exact inv_ne_zero hu;);
        rw [ h_ind, ind_inv u hu ] ; ring;
      grind;
    ¬∑ aesop;
    ¬∑ native_decide +revert

/-
The cardinalities of the sets S_cubic_res, S_s1, and S_s2 are all 32.
-/
lemma card_S : S_cubic_res.card = 32 ‚àß S_s1.card = 32 ‚àß S_s2.card = 32 := by
  native_decide

/-
Define C_coset to avoid ambiguity and relate it to the period definitions.
-/
def C_coset (i : ZMod 3) : Finset (ZMod 97) := Finset.univ.filter (fun x => x ‚â† 0 ‚àß ind x = i)

lemma C_coset_eq : C_coset 0 = S_cubic_res ‚àß C_coset 1 = S_s1 ‚àß C_coset 2 = S_s2 := by
  native_decide +revert

lemma period_eq_sum_C_coset (i : ZMod 3) : period i = ‚àë x ‚àà C_coset i, Œ∂97 ^ (x.val : ‚Ñï) := by
  rw [ show C_coset i = if i = 0 then S_cubic_res else if i = 1 then S_s1 else S_s2 from ?_ ];
  ¬∑ unfold period; aesop;
  ¬∑ native_decide +revert

/-
Expansion of the product of Gaussian periods in terms of solution counts.
-/
lemma period_mul_eq_sum_N_sol (i j : ZMod 3) :
  period i * period j = (if i = j then 32 else 0) +
  ‚àë u ‚àà Finset.univ.filter (fun x : ZMod 97 => x ‚â† 0), (N_sol i j u : L97) * Œ∂97 ^ (u.val : ‚Ñï) := by
    have h_expand : period i * period j = ‚àë u ‚àà Finset.univ, (if u = 0 then (if i = j then 32 else 0) else (N_sol i j u : L97)) * Œ∂97 ^ u.val := by
      have h_expand : period i * period j = ‚àë x ‚àà C_coset i, ‚àë y ‚àà C_coset j, Œ∂97 ^ (x.val + y.val : ‚Ñï) := by
        rw [ period_eq_sum_C_coset i, period_eq_sum_C_coset j, Finset.sum_mul ];
        simp +decide only [Finset.mul_sum _ _ _, pow_add];
      have h_group : ‚àÄ u : ZMod 97, ‚àë x ‚àà C_coset i, ‚àë y ‚àà C_coset j, (if x + y = u then 1 else 0) * Œ∂97 ^ u.val = (if u = 0 then (if i = j then 32 else 0) else (N_sol i j u : L97)) * Œ∂97 ^ u.val := by
        intro u
        have h_group : ‚àë x ‚àà C_coset i, ‚àë y ‚àà C_coset j, (if x + y = u then 1 else 0) = (if u = 0 then (if i = j then 32 else 0) else (N_sol i j u : ‚Ñï)) := by
          split_ifs <;> simp_all +decide [ N_sol ];
          ¬∑ fin_cases j <;> native_decide;
          ¬∑ intro x hx y hy; contrapose! hy; simp_all +decide [ C_coset ] ;
            intro hy' hy''; have := ind_mul x ( -1 ) ; simp_all +decide [ add_eq_zero_iff_eq_neg ] ;
          ¬∑ rw [ Fintype.card_subtype ];
            rw [ ‚Üê Finset.card_biUnion ];
            ¬∑ refine' Finset.card_bij ( fun x hx => ( u - x, x ) ) _ _ _ <;> simp +decide [ Finset.mem_biUnion, Finset.mem_filter ];
              ¬∑ unfold C_coset at *; aesop;
              ¬∑ unfold C_coset; aesop;
            ¬∑ exact fun x hx y hy hxy => Finset.disjoint_left.mpr fun z hz‚ÇÅ hz‚ÇÇ => hxy <| by aesop;
        convert congr_arg ( ¬∑ * Œ∂97 ^ u.val ) ( show ( ‚àë x ‚àà C_coset i, ‚àë y ‚àà C_coset j, if x + y = u then 1 else 0 : L97 ) = if u = 0 then if i = j then 32 else 0 else N_sol i j u from ?_ ) using 1;
        ¬∑ simp +decide only [Finset.sum_mul _ _ _];
        ¬∑ split_ifs <;> norm_num;
        ¬∑ convert congr_arg ( fun x : ‚Ñï => x : ‚Ñï ‚Üí L97 ) h_group using 1;
          norm_num [ Finset.sum_ite ];
      rw [ ‚Üê Finset.sum_congr rfl fun u hu => h_group u ];
      rw [ h_expand, Finset.sum_comm ];
      rw [ Finset.sum_comm, Finset.sum_congr rfl ];
      rw [ Finset.sum_comm ];
      intro x hx; rw [ Finset.sum_comm ] ; simp +decide [ Finset.sum_ite ] ;
      refine' Finset.sum_congr rfl fun y hy => _;
      have h_exp : Œ∂97 ^ 97 = 1 := by
        exact IsCyclotomicExtension.zeta_pow ( 97 : ‚Ñï ) ‚Ñö L97;
      rw [ ‚Üê Nat.mod_add_div ( x.val + y.val ) 97, pow_add, pow_mul ] ; aesop;
    rw [ h_expand, Finset.sum_eq_add_sum_diff_singleton ( Finset.mem_univ 0 ) ] ; aesop

/-
Multiplication rule for Gaussian periods.
-/
lemma period_mul (i j : ZMod 3) :
  period i * period j = (if i = j then 32 else 0) +
  (cyc_num (i - 0) (j - 0) * period 0 +
   cyc_num (i - 1) (j - 1) * period 1 +
   cyc_num (i - 2) (j - 2) * period 2) := by
     -- Apply Lemma `period_mul_eq_sum_N_sol` to expand the product.
     have h_expand : period i * period j = (if i = j then 32 else 0) +
       ‚àë u ‚àà (Finset.univ.filter (fun x : ZMod 97 => x ‚â† 0)), (cyc_num (i - ind u) (j - ind u) : L97) * Œ∂97 ^ (u.val : ‚Ñï) := by
         rw [ period_mul_eq_sum_N_sol ];
         exact congrArg _ ( Finset.sum_congr rfl fun u hu => by rw [ N_sol_eq_cyc_num i j u ( by simpa using hu ) ] );
     -- Partition the sum over `u != 0` based on `ind u = k` for `k \in {0, 1, 2}`.
     have h_partition : ‚àë u ‚àà (Finset.univ.filter (fun x : ZMod 97 => x ‚â† 0)), (cyc_num (i - ind u) (j - ind u) : L97) * Œ∂97 ^ (u.val : ‚Ñï) =
       ‚àë k ‚àà Finset.univ, (cyc_num (i - k) (j - k) : L97) * ‚àë u ‚àà (Finset.univ.filter (fun x : ZMod 97 => x ‚â† 0 ‚àß ind x = k)), Œ∂97 ^ (u.val : ‚Ñï) := by
         simp +decide only [Finset.sum_filter, Finset.mul_sum _ _ _];
         rw [ Finset.sum_comm, Finset.sum_congr rfl ] ; aesop;
     -- By definition of $C_koset$, we know that $\sum_{u \in C_koset k} \zeta_97^u = \text{period } k$.
     have h_period : ‚àÄ k : ZMod 3, ‚àë u ‚àà (Finset.univ.filter (fun x : ZMod 97 => x ‚â† 0 ‚àß ind x = k)), Œ∂97 ^ (u.val : ‚Ñï) = period k := by
       intro k
       simp [period_eq_sum_C_coset, C_coset];
     simp_all +decide [ Fin.sum_univ_three ];
     erw [ Fin.sum_univ_three ] ; ring!;

/-
alpha' is a root of X^3 - 97X - 97.
-/
theorem alpha_root' : Œ±'^3 - 97*Œ±' - 97 = 0 := by
  unfold Œ±';
  -- By definition of $Œ∑‚ÇÄ'$, $Œ∑‚ÇÅ'$, and $Œ∑‚ÇÇ'$, we know that $Œ∑‚ÇÄ' + Œ∑‚ÇÅ' + Œ∑‚ÇÇ' = -1$.
  have h_sum : Œ∑‚ÇÄ' + Œ∑‚ÇÅ' + Œ∑‚ÇÇ' = -1 := by
    -- The sum of all non-trivial roots of unity in the cyclotomic field is -1.
    have h_sum_roots : ‚àë x ‚àà Finset.univ.filter (fun x : ZMod 97 => x ‚â† 0), Œ∂97 ^ (x.val : ‚Ñï) = -1 := by
      have h_sum : ‚àë x : ZMod 97, (Œ∂97 : L97) ^ (x.val : ‚Ñï) = 0 := by
        have h_geom_sum : ‚àë x ‚àà Finset.range 97, (Œ∂97 : L97) ^ x = 0 := by
          rw [ geom_sum_eq ] <;> norm_num [ IsPrimitiveRoot.ne_one ];
          ¬∑ exact Or.inl ( sub_eq_zero_of_eq <| by exact IsPrimitiveRoot.pow_eq_one <| IsCyclotomicExtension.zeta_spec 97 ‚Ñö L97 );
          ¬∑ have h_order : IsPrimitiveRoot Œ∂97 97 := by
              convert IsCyclotomicExtension.zeta_spec 97 ‚Ñö L97 using 1
              skip
            generalize_proofs at *; exact h_order.ne_one (by norm_num);
        convert h_geom_sum using 1;
      rw [ Finset.sum_eq_add_sum_diff_singleton ( Finset.mem_univ 0 ) ] at h_sum;
      simpa [ Finset.filter_ne' ] using eq_neg_of_add_eq_zero_right h_sum;
    rw [ ‚Üê h_sum_roots, show Œ∑‚ÇÄ' + Œ∑‚ÇÅ' + Œ∑‚ÇÇ' = ‚àë x ‚àà Finset.univ.filter ( fun x : ZMod 97 => x ‚â† 0 ), Œ∂97 ^ x.val from ?_ ];
    rw [ show ( Finset.univ.filter fun x : ZMod 97 => x ‚â† 0 ) = S_cubic_res ‚à™ S_s1 ‚à™ S_s2 from by native_decide, Finset.sum_union, Finset.sum_union ];
    ¬∑ exact?;
    ¬∑ native_decide +revert;
    ¬∑ native_decide +revert;
  have := @period_mul 0 0; ( have := @period_mul 0 1; ( have := @period_mul 0 2; ( have := @period_mul 1 1; ( have := @period_mul 1 2; ( have := @period_mul 2 2; norm_num [ Finset.sum_add_distrib, pow_succ' ] at *; ) ) ) ) );
  simp_all +decide [ period_eq_def ];
  erw [ cyc_num_vals.1, cyc_num_vals.2.1, cyc_num_vals.2.2.1, cyc_num_vals.2.2.2.1, cyc_num_vals.2.2.2.2.1, cyc_num_vals.2.2.2.2.2.1, cyc_num_vals.2.2.2.2.2.2.1, cyc_num_vals.2.2.2.2.2.2.2.1, cyc_num_vals.2.2.2.2.2.2.2.2 ] at * ; norm_num at *;
  grind +ring

/-
Algebraic relation between beta' and alpha'.
-/
theorem beta_relation' : 2 * 19 * Œ≤' = 6 * Œ±'^2 - (19 + 9) * Œ±' - 4 * 97 := by
  unfold Œ≤' Œ±';
  rw [ show Œ∑‚ÇÄ' = period 0 from rfl, show Œ∑‚ÇÅ' = period 2 from rfl, show Œ∑‚ÇÇ' = period 1 from rfl ];
  -- By definition of $period$, we know that $period 0 + period 1 + period 2 = -1$.
  have h_sum : period 0 + period 1 + period 2 = -1 := by
    -- By definition of $period$, we know that $period 0 + period 1 + period 2 = \sum_{x \in \mathbb{Z}/97\mathbb{Z}} \zeta_{97}^x$.
    have h_sum : period 0 + period 1 + period 2 = ‚àë x ‚àà Finset.univ.filter (fun x : ZMod 97 => x ‚â† 0), Œ∂97 ^ (x.val : ‚Ñï) := by
      rw [ period_eq_sum_C_coset, period_eq_sum_C_coset, period_eq_sum_C_coset ];
      rw [ ‚Üê Finset.sum_union, ‚Üê Finset.sum_union ];
      ¬∑ rw [ show C_coset 0 ‚à™ C_coset 1 ‚à™ C_coset 2 = Finset.univ.filter ( fun x : ZMod 97 => x ‚â† 0 ) from ?_ ];
        native_decide +revert;
      ¬∑ native_decide +revert;
      ¬∑ simp +decide [ C_coset, Finset.disjoint_left ];
        grind;
    -- The sum of all powers of $\zeta_{97}$ is zero.
    have h_sum_zero : ‚àë x ‚àà Finset.range 97, Œ∂97 ^ x = 0 := by
      rw [ geom_sum_eq ] <;> norm_num [ hŒ∂ ];
      ¬∑ exact Or.inl ( sub_eq_zero_of_eq <| by exact ( show Œ∂97 ^ 97 = 1 from by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact by rw [ show Œ∂97 = IsCyclotomicExtension.zeta 97 ‚Ñö L97 from rfl ] ; exact? ) ) ) ) ) ) ) ) ) ) ) ) ) );
      ¬∑ have := IsCyclotomicExtension.zeta_spec 97 ‚Ñö L97;
        exact this.ne_one ( by decide );
    rw [ Finset.sum_eq_sum_diff_singleton_add ( Finset.mem_range.mpr ( show 0 < 97 by decide ) ) ] at h_sum_zero;
    convert eq_neg_of_add_eq_zero_left h_sum_zero using 1;
    norm_num;
  -- Substitute the known values of the cyclotomic numbers into the equation.
  have h_cyclotomic : cyc_num 0 0 = 12 ‚àß cyc_num 0 1 = 10 ‚àß cyc_num 0 2 = 9 ‚àß cyc_num 1 0 = 10 ‚àß cyc_num 1 1 = 9 ‚àß cyc_num 1 2 = 13 ‚àß cyc_num 2 0 = 9 ‚àß cyc_num 2 1 = 13 ‚àß cyc_num 2 2 = 10 := by
    exact?;
  rw [ show period 0 = -1 - period 1 - period 2 by linear_combination' h_sum ] ; ring;
  rw [ show period 1 ^ 2 = period 1 * period 1 by ring, show period 2 ^ 2 = period 2 * period 2 by ring ] ; rw [ period_mul 1 1, period_mul 2 2, period_mul 1 2 ] ; simp +decide [ h_cyclotomic ] ; ring;
  rw [ show cyc_num ( -1 ) 0 = 9 by exact h_cyclotomic.2.2.2.2.2.2.1, show cyc_num ( -1 ) ( -1 ) = 10 by exact h_cyclotomic.2.2.2.2.2.2.2.2 ] ; norm_num ; ring;
  rw [ show cyc_num 0 1 = 10 by exact h_cyclotomic.2.1, show cyc_num 1 1 = 9 by exact h_cyclotomic.2.2.2.2.1 ] ; ring ; rw [ show period 0 = -1 - period 1 - period 2 by linear_combination' h_sum ] ; ring

/-
Define the Galois unit and automorphism for q=97.
-/
def gal_unit97 (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 97) : (ZMod 97)À£ := Units.mk0 (N : ZMod 97) (by
  rw [Ne, ZMod.natCast_zmod_eq_zero_iff_dvd]
  intro h
  have hN_prime : Nat.Prime N := Fact.out
  have : 97 = 1 ‚à® 97 = N := (Nat.dvd_prime hN_prime).mp h
  have : 97 = N := this.resolve_left (by norm_num)
  exact hN this.symm)

def sigma97 (u : (ZMod 97)À£) : L97 ‚âÉ‚Çê[‚Ñö] L97 :=
  (IsCyclotomicExtension.autEquivPow L97 (Polynomial.cyclotomic.irreducible_rat (n := 97) (by norm_num))).symm u

/-
The Frobenius automorphism permutes the Gaussian periods by shifting their index by ind(N).
-/
lemma sigma_period (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 97) (i : ZMod 3) :
  sigma97 (gal_unit97 N hN) (period i) = period (i + ind (N : ZMod 97)) := by
    -- By definition of $C_coset$, we know that $C_coset i$ is the set of elements $x$ such that $ind x = i$.
    have hC_coset : ‚àÄ i : ZMod 3, C_coset i = {x : ZMod 97 | x ‚â† 0 ‚àß ind x = i} := by
      unfold C_coset; aesop;
    -- By definition of $sigma97$, we know that it maps $Œ∂97^x$ to $Œ∂97^{Nx}$ for any $x \in \mathbb{Z}/97\mathbb{Z}$.
    have h_sigma_map : ‚àÄ x : ZMod 97, (sigma97 (gal_unit97 N hN)) (Œ∂97 ^ x.val) = Œ∂97 ^ ((N * x).val) := by
      intro x
      have h_sigma_map : (sigma97 (gal_unit97 N hN)) (Œ∂97 ^ x.val) = (sigma97 (gal_unit97 N hN)) (Œ∂97) ^ x.val := by
        exact map_pow _ _ _;
      have h_sigma_map : (sigma97 (gal_unit97 N hN)) Œ∂97 = Œ∂97 ^ (N : ZMod 97).val := by
        unfold sigma97;
        simp +decide [ gal_unit97 ];
        erw [ PowerBasis.equivOfMinpoly_gen ];
        exact?;
      cases N <;> simp_all +decide [ pow_mul ];
      norm_num [ ‚Üê pow_mul, ZMod.val_add, ZMod.val_mul ];
      rw [ ‚Üê Nat.mod_add_div ( ( _ + ZMod.val 1 ) % 97 * x.val ) 97 ] ; norm_num [ pow_add, pow_mul, Nat.mul_mod, Nat.pow_mod ] ;
      have h_zeta_pow : Œ∂97 ^ 97 = 1 := by
        exact IsPrimitiveRoot.pow_eq_one ( IsCyclotomicExtension.zeta_spec 97 ‚Ñö L97 );
      aesop;
    -- By definition of $C_coset$, we know that $C_coset (i + ind N)$ is the set of elements $y$ such that $ind y = i + ind N$.
    have hC_coset_shift : C_coset (i + ind N) = Finset.image (fun x => (N * x : ZMod 97)) (C_coset i) := by
      ext x; simp [hC_coset];
      constructor;
      ¬∑ intro hx
        obtain ‚ü®a, ha‚ü© : ‚àÉ a : ZMod 97, (N * a : ZMod 97) = x := by
          have h_inv : ‚àÉ a : ZMod 97, (N : ZMod 97) * a = 1 := by
            have h_inv : Nat.gcd N 97 = 1 := by
              exact Nat.Coprime.symm ( Nat.Prime.coprime_iff_not_dvd ( by decide ) |>.2 fun h => hN <| by have := Nat.prime_dvd_prime_iff_eq ( by decide : Nat.Prime 97 ) ( Fact.out : Nat.Prime N ) ; tauto );
            have := Nat.exists_mul_emod_eq_one_of_coprime h_inv;
            exact Exists.elim ( this ( by decide ) ) fun m hm => ‚ü® m, by simpa [ ‚Üê ZMod.natCast_eq_zero_iff ] using congr_arg ( fun x : ‚Ñï => x : ‚Ñï ‚Üí ZMod 97 ) hm ‚ü©;
          exact ‚ü® h_inv.choose * x, by linear_combination' h_inv.choose_spec * x ‚ü©;
        use a; simp_all +decide [ Set.ext_iff ] ;
        have h_ind_mul : ind (N * a) = ind N + ind a := by
          have h_ind_mul : ‚àÄ x y : ZMod 97, x ‚â† 0 ‚Üí y ‚â† 0 ‚Üí ind (x * y) = ind x + ind y := by
            exact?;
          apply h_ind_mul; exact (by
          intro h; simp_all +decide [ ZMod.natCast_eq_zero_iff ] ;); exact (by
          grind);
        grind +ring;
      ¬∑ rintro ‚ü® a, ha, rfl ‚ü©;
        have h_ind_mul : ind (N * a) = ind N + ind a := by
          apply ind_mul;
          ¬∑ intro h; have := Fact.out ( p := Nat.Prime N ) ; simp_all +decide [ ZMod.natCast_eq_zero_iff ] ;
            rw [ this.dvd_iff_eq ] at h <;> aesop;
          ¬∑ exact hC_coset i |>.subset ha |>.1;
        simp_all +decide [ add_comm, C_coset ];
        exact?;
    -- By definition of $period$, we know that $period i$ is the sum of $Œ∂97^x$ over $x \in C_coset i$.
    have hperiod_def : ‚àÄ i : ZMod 3, period i = ‚àë x ‚àà C_coset i, Œ∂97 ^ x.val := by
      exact?;
    rw [ hperiod_def, hperiod_def, hC_coset_shift, Finset.sum_image ];
    ¬∑ rw [ map_sum, Finset.sum_congr rfl fun x hx => h_sigma_map x ];
    ¬∑ intro x hx y hy; haveI := Fact.mk ( Fact.out : Nat.Prime N ) ; simp_all +decide [ mul_eq_zero, ZMod.natCast_eq_zero_iff ] ;
      rintro ( rfl | h ) <;> simp_all +decide [ Nat.Prime.dvd_iff_eq Fact.out ]

/-
Integer versions of the periods and roots, and their coercion properties.
-/
def Œ∂97_int : ùìû L97 := IsPrimitiveRoot.toInteger (IsCyclotomicExtension.zeta_spec 97 ‚Ñö L97)

def period_int (i : ZMod 3) : ùìû L97 := ‚àë x ‚àà C_coset i, Œ∂97_int ^ (x.val : ‚Ñï)

def Œ±'_int : ùìû L97 := -(period_int 1 - period_int 2)
def Œ≤'_int : ùìû L97 := -(period_int 0 - period_int 1)
def Œ≥'_int : ùìû L97 := -(period_int 2 - period_int 0)

lemma coe_period_int (i : ZMod 3) : (period_int i : L97) = period i := by
  unfold period_int period;
  unfold Œ∂97_int Œ∑‚ÇÄ' Œ∑‚ÇÅ' Œ∑‚ÇÇ';
  split_ifs <;> simp +decide [ *, Subtype.ext_iff ];
  ¬∑ congr! 1;
    exact C_coset_eq.1;
  ¬∑ congr! 2;
    exact C_coset_eq.2.1;
  ¬∑ congr! 1;
    native_decide +revert

lemma coe_alpha'_int : (Œ±'_int : L97) = Œ±' := by
  unfold Œ±'_int Œ±';
  unfold period_int;
  unfold Œ∑‚ÇÇ' Œ∑‚ÇÅ' C_coset; simp +decide [ Finset.sum_sub_distrib ] ;
  congr! 2;
  ¬∑ native_decide +revert;
  ¬∑ native_decide +revert

lemma coe_beta'_int : (Œ≤'_int : L97) = Œ≤' := by
  unfold Œ≤'_int Œ≤';
  unfold period_int;
  simp +decide [ C_coset_eq, S_s1, S_cubic_res ];
  congr!

lemma coe_gamma'_int : (Œ≥'_int : L97) = Œ≥' := by
  unfold Œ≥'_int Œ≥';
  unfold period_int;
  simp +decide [ C_coset_eq ];
  congr! 2

/-
Relate the index of N to the value of c' N being s1'.
-/
lemma ind_N_eq_1_iff_c_eq_s1 (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 97) :
  ind (N : ZMod 97) = 1 ‚Üî c' N = s1' := by
    unfold ind c' s1';
    unfold S_cubic_res S_s1; simp +decide;
    unfold q' a' s1'; simp +decide ;
    split_ifs <;> simp_all +decide [ ZMod.natCast_eq_zero_iff ];
    ¬∑ native_decide +revert;
    ¬∑ rename_i h‚ÇÅ h‚ÇÇ;
      contrapose! h‚ÇÇ;
      exact ‚ü® fun h => hN <| by have := Nat.prime_dvd_prime_iff_eq ( by decide : Nat.Prime 97 ) ( Fact.out : Nat.Prime N ) ; tauto, h‚ÇÇ ‚ü©

/-
Relate the index of N to the value of c' N being s2'.
-/
lemma ind_N_eq_2_iff_c_eq_s2 (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 97) :
  ind (N : ZMod 97) = 2 ‚Üî c' N = s2' := by
    -- By definition of $c'$ and $ind$, we know that $c' N = s2'$ if and only if $N^{32} = s2'$.
    have h_c'_eq_s2' : c' N = s2' ‚Üî (N : ZMod 97) ^ 32 = s2' := by
      rfl;
    cases eq_or_ne ( N : ZMod 97 ) 0 <;> simp_all +decide [ ind ];
    ¬∑ rw [ ZMod.natCast_eq_zero_iff ] at * ; exact absurd ( Nat.dvd_of_mod_eq_zero ( Nat.mod_eq_zero_of_dvd <| by assumption ) ) ( by rw [ Nat.dvd_prime Fact.out ] ; aesop );
    ¬∑ split_ifs <;> simp_all +decide [ S_cubic_res, S_s1, S_s2 ];
      ¬∑ native_decide +revert;
      ¬∑ native_decide +revert;
      ¬∑ have h_cases : ‚àÄ x : ZMod 97, x ‚â† 0 ‚Üí x ^ 32 = 1 ‚à® x ^ 32 = s1' ‚à® x ^ 32 = s2' := by
          native_decide +revert;
        cases h_cases _ ‚Äπ_‚Ä∫ <;> tauto

/-
Abbreviations for the ring of integers, residue field, and reduction map for q=97.
-/
abbrev ùìûL97 := ùìû L97
def kP97 (P : Ideal ùìûL97) [P.IsMaximal] := ùìûL97 ‚ß∏ P
noncomputable instance (P : Ideal ùìûL97) [P.IsMaximal] : Field (kP97 P) := Ideal.Quotient.field P
def red97 (P : Ideal ùìûL97) [P.IsMaximal] : ùìûL97 ‚Üí+* kP97 P := Ideal.Quotient.mk P

/-
Relate the index of N to the value of c' N being s1'.
-/
lemma ind_N_eq_1_iff_c_eq_s1_new (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 97) :
  ind (N : ZMod 97) = 1 ‚Üî c' N = s1' := by
    convert ind_N_eq_1_iff_c_eq_s1 N hN using 1

/-
Lift the automorphism sigma97 to the ring of integers.
-/
def sigma_int97 (u : (ZMod 97)À£) (x : ùìû L97) : ùìû L97 := ‚ü®sigma97 u x, by
  have h_integral : IsIntegral ‚Ñ§ (x : L97) := x.2
  exact IsIntegral.map (sigma97 u) h_integral‚ü©

/-
The ring of integers is generated by zeta97.
-/
lemma adjoin_zeta_eq_top97 : Algebra.adjoin ‚Ñ§ ({Œ∂97_int} : Set ùìûL97) = ‚ä§ := by
  let hŒ∂ := IsCyclotomicExtension.zeta_spec 97 ‚Ñö L97
  let pb := IsPrimitiveRoot.integralPowerBasis' hŒ∂
  have h_gen : pb.gen = Œ∂97_int := IsPrimitiveRoot.integralPowerBasis'_gen hŒ∂
  rw [‚Üê h_gen]
  exact pb.adjoin_gen_eq_top

/-
The automorphism sigma_N reduces to the Frobenius map modulo P.
-/
theorem artin_property97 {N : ‚Ñï} [Fact (Nat.Prime N)] (hN : N ‚â† 97) (P : Ideal ùìûL97) [P.IsMaximal] [CharP (kP97 P) N] (x : ùìûL97) :
  red97 P (sigma_int97 (gal_unit97 N hN) x) = (red97 P x) ^ N := by
    have h_sigma_int97_zeta : ‚àÄ x : ùìûL97, x ‚àà Algebra.adjoin ‚Ñ§ ({Œ∂97_int} : Set ùìûL97) ‚Üí red97 P (sigma_int97 (gal_unit97 N hN) x) = (red97 P x) ^ N := by
      refine fun x hx => Algebra.adjoin_induction ?_ ?_ ?_ ?_ hx;
      ¬∑ -- Since $\sigma_N(\zeta_{97}) = \zeta_{97}^N$, we have $\sigma_int97(\zeta_{97}) = \zeta_{97}^N$.
        have h_sigma_zeta : sigma_int97 (gal_unit97 N hN) Œ∂97_int = Œ∂97_int ^ N := by
          have h_sigma_zeta : (sigma97 (gal_unit97 N hN) Œ∂97_int : L97) = Œ∂97_int ^ N := by
            have h_sigma_zeta : ‚àÄ (u : (ZMod 97)À£), sigma97 u Œ∂97 = Œ∂97 ^ (u : ZMod 97).val := by
              intro u
              simp [sigma97];
              erw [ PowerBasis.equivOfMinpoly_gen ];
              rfl;
            convert h_sigma_zeta ( gal_unit97 N hN ) using 1;
            simp +decide [ gal_unit97 ];
            rw [ ‚Üê Nat.mod_add_div N 97 ] ; norm_num [ pow_add, pow_mul ] ;
            have h_zeta_97_pow : Œ∂97 ^ 97 = 1 := by
              exact IsPrimitiveRoot.pow_eq_one ( IsCyclotomicExtension.zeta_spec 97 ‚Ñö L97 );
            erw [ show ( Œ∂97_int : L97 ) = Œ∂97 from ?_ ] ; aesop;
            exact?;
          exact?;
        aesop;
      ¬∑ intro r; exact (by
        simp +decide [ red97, sigma_int97 ];
        erw [ Ideal.Quotient.eq ];
        -- Since $P$ is a maximal ideal, it is prime, and thus if $r^N - r$ is in $P$, then either $r$ is in $P$ or $r^{N-1} - 1$ is in $P$.
        have h_prime : ‚àÄ r : ‚Ñ§, (r ^ N - r : ùìûL97) ‚àà P := by
          intro r
          have h_fermat : (r ^ N - r : ‚Ñ§) ‚â° 0 [ZMOD N] := by
            simp +decide [ ‚Üê ZMod.intCast_eq_intCast_iff ];
          obtain ‚ü® k, hk ‚ü© := h_fermat.symm.dvd;
          -- Since $N$ is in $P$, multiplying by $k$ (which is an integer) keeps it in $P$.
          have hN_in_P : (N : ùìûL97) ‚àà P := by
            have hN_in_P : (N : kP97 P) = 0 := by
              exact?;
            exact?;
          convert P.mul_mem_right ( k : ùìûL97 ) hN_in_P using 1 ; norm_cast ; aesop;
        simpa using Submodule.neg_mem _ ( h_prime r ));
      ¬∑ intro x y hx hy hx' hy'; simp +decide [ *, pow_add ] ;
        rw [ show sigma_int97 ( gal_unit97 N hN ) ( x + y ) = sigma_int97 ( gal_unit97 N hN ) x + sigma_int97 ( gal_unit97 N hN ) y from ?_, map_add ];
        ¬∑ rw [ hx', hy', add_pow_char ];
        ¬∑ exact Subtype.ext <| map_add _ _ _;
      ¬∑ simp +contextual [ *, mul_pow ];
        intro x y hx hy hx' hy'; rw [ show sigma_int97 ( gal_unit97 N hN ) ( x * y ) = sigma_int97 ( gal_unit97 N hN ) x * sigma_int97 ( gal_unit97 N hN ) y from ?_ ] ; aesop;
        exact Subtype.ext <| map_mul _ _ _;
    exact h_sigma_int97_zeta x ( by rw [ adjoin_zeta_eq_top97 ] ; exact Algebra.mem_top ) |> fun h => by simpa using h;

/-
If c' N = s1', then sigma_N(alpha') = gamma'.
-/
lemma sigma_alpha_eq_gamma_if_s1 (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 97) (h : c' N = s1') :
  sigma_int97 (gal_unit97 N hN) Œ±'_int = Œ≥'_int := by
    -- We check the equality in the field L97.
    have h_field : sigma97 (gal_unit97 N hN) (Œ±'_int : L97) = (Œ≥'_int : L97) := by
      -- By definition of $c'$, we know that $c' N = s1'$ implies $ind (N : ZMod 97) = 1$.
      have h_ind : ind (N : ZMod 97) = 1 := by
        exact?;
      -- By definition of $sigma97$, we have $sigma97 (gal_unit97 N hN) (Œ±'_int) = sigma97 (gal_unit97 N hN) (period 2 - period 1)$.
      have h_sigma97_def : sigma97 (gal_unit97 N hN) (Œ±'_int : L97) = sigma97 (gal_unit97 N hN) (period 2 - period 1) := by
        rw [ show ( Œ±'_int : L97 ) = period 2 - period 1 from ?_ ];
        convert coe_alpha'_int using 1;
        unfold Œ±';
        exact?;
      -- By definition of $sigma97$, we have $sigma97 (gal_unit97 N hN) (period 2 - period 1) = period (2 + ind (N : ZMod 97)) - period (1 + ind (N : ZMod 97))$.
      have h_sigma97_period : sigma97 (gal_unit97 N hN) (period 2 - period 1) = period (2 + ind (N : ZMod 97)) - period (1 + ind (N : ZMod 97)) := by
        rw [ map_sub, sigma_period, sigma_period ];
      simp_all +decide [ Œ≥'_int ];
      exact congr_arg‚ÇÇ _ ( coe_period_int 0 ‚ñ∏ rfl ) ( coe_period_int 2 ‚ñ∏ rfl );
    convert h_field using 1;
    -- Since the ring of integers is a subalgebra of the field, the elements are equal in the ring if and only if they are equal in the field.
    have h_subalgebra : ‚àÄ (x y : ùìû L97), x = y ‚Üî (x : L97) = (y : L97) := by
      exact?;
    convert h_subalgebra _ _ using 1

/-
If c' N = s2', then sigma_N(alpha') = beta'.
-/
lemma sigma_alpha_eq_beta_if_s2 (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 97) (h : c' N = s2') :
  sigma_int97 (gal_unit97 N hN) Œ±'_int = Œ≤'_int := by
    -- Since $c' N = s2'$, we have $ind N = 2$.
    have h_ind : ind (N : ZMod 97) = 2 := by
      exact?;
    -- Since $\sigma_N(\alpha') = \beta'$ in $L97$, we have $\sigma_N(\alpha'_int) = \beta'_int$ in $\mathcal{O}_{L97}$.
    have h_sigma_alpha_int_eq_beta_int : (sigma97 (gal_unit97 N hN) Œ±' : L97) = Œ≤' := by
      -- Since $c' N = s2'$, we have $ind N = 2$. Therefore, $\sigma_N(\alpha') = \beta'$.
      have h_sigma_beta : (sigma97 (gal_unit97 N hN)) (period 2 - period 1) = period 1 - period 0 := by
        have := sigma_period N hN 2; have := sigma_period N hN 1; aesop;
      generalize_proofs at *; (
      unfold Œ±' Œ≤'; aesop;)
    generalize_proofs at *; (
    convert h_sigma_alpha_int_eq_beta_int using 1
    generalize_proofs at *; (
    constructor <;> intro h <;> simp_all +decide [ ‚Üê coe_alpha'_int, ‚Üê coe_beta'_int, ‚Üê coe_gamma'_int ] ;
    exact Subtype.ext h_sigma_alpha_int_eq_beta_int
    skip))

/-
Final result for q=97: Frobenius action on alpha depends on c' N.
-/
theorem final_result_97 {N : ‚Ñï} [Fact (Nat.Prime N)] (hN : N ‚â† 97) (hN19 : N ‚â† 19) (P : Ideal ùìûL97) [P.IsMaximal] [CharP (kP97 P) N] :
  (c' N = s1' ‚Üí (red97 P Œ±'_int) ^ N = red97 P Œ≥'_int) ‚àß
  (c' N = s2' ‚Üí (red97 P Œ±'_int) ^ N = red97 P Œ≤'_int) := by
  constructor
  ¬∑ intro h
    rw [‚Üê artin_property97 hN P Œ±'_int]
    rw [sigma_alpha_eq_gamma_if_s1 N hN h]
  ¬∑ intro h
    rw [‚Üê artin_property97 hN P Œ±'_int]
    rw [sigma_alpha_eq_beta_if_s2 N hN h]

/-
Definitions of constants q=349, a=37, s1, s2, and c for the new problem instance. Also define the cyclotomic field L349 and the primitive root of unity zeta349.
-/
def q'' : ‚Ñï := 349
def a'' : ‚Ñï := 37
def s1'' : ZMod 349 := (- (a'' : ZMod 349) - 3) * (6 : ZMod 349)‚Åª¬π
def s2'' : ZMod 349 := ((a'' : ZMod 349) - 3) * (6 : ZMod 349)‚Åª¬π
def c'' (N : ‚Ñï) : ZMod 349 := (N : ZMod 349) ^ ((q'' - 1) / 3)

open Polynomial NumberField

def L349 : Type := CyclotomicField 349 ‚Ñö

instance : Field L349 := CyclotomicField.instField 349 ‚Ñö
instance : NumberField L349 := CyclotomicField.instNumberField 349 ‚Ñö
instance : IsCyclotomicExtension {349} ‚Ñö L349 := CyclotomicField.isCyclotomicExtension 349 ‚Ñö

def Œ∂349 : L349 := IsCyclotomicExtension.zeta 349 ‚Ñö L349

instance : Fact (Nat.Prime 349) := ‚ü®by norm_num‚ü©

/-
Define the sets of indices and the Gaussian periods for q=349. Define alpha, beta, gamma. Prove their sum is zero.
-/
def S_cubic_res'' : Finset (ZMod 349) := {x | x ‚â† 0 ‚àß x ^ 116 = 1}
def S_s1'' : Finset (ZMod 349) := {x | x ‚â† 0 ‚àß x ^ 116 = s1''}
def S_s2'' : Finset (ZMod 349) := {x | x ‚â† 0 ‚àß x ^ 116 = s2''}

def Œ∑‚ÇÄ'' : L349 := ‚àë x ‚àà S_cubic_res'', Œ∂349 ^ (x.val : ‚Ñï)
def Œ∑‚ÇÅ'' : L349 := ‚àë x ‚àà S_s2'', Œ∂349 ^ (x.val : ‚Ñï)
def Œ∑‚ÇÇ'' : L349 := ‚àë x ‚àà S_s1'', Œ∂349 ^ (x.val : ‚Ñï)

def Œ±'' : L349 := -(Œ∑‚ÇÇ'' - Œ∑‚ÇÅ'')
def Œ≤'' : L349 := -(Œ∑‚ÇÄ'' - Œ∑‚ÇÇ'')
def Œ≥'' : L349 := -(Œ∑‚ÇÅ'' - Œ∑‚ÇÄ'')

theorem sum_zero'' : Œ±'' + Œ≤'' + Œ≥'' = 0 := by
  -- By definition of Œ±'', Œ≤'', and Œ≥'', we have Œ±'' + Œ≤'' + Œ≥'' = 0 because each period is a sum of roots of unity, and their sum is zero.
  simp [Œ±'', Œ≤'', Œ≥'', Œ∑‚ÇÄ'', Œ∑‚ÇÅ'', Œ∑‚ÇÇ'']

/-
Definitions of index function, cyclotomic numbers, and period function for q=349.
-/
def ind'' (x : ZMod 349) : ZMod 3 :=
  if x ‚àà S_cubic_res'' then 0
  else if x ‚àà S_s1'' then 1
  else 2

def cyc_num'' (i j : ZMod 3) : ‚Ñï :=
  Fintype.card { x : ZMod 349 // x ‚â† 0 ‚àß x ‚â† 1 ‚àß ind'' x = i ‚àß ind'' (1 - x) = j }

def period'' (i : ZMod 3) : L349 :=
  if i = 0 then Œ∑‚ÇÄ''
  else if i = 1 then Œ∑‚ÇÇ''
  else Œ∑‚ÇÅ''

/-
The period function maps 0, 1, 2 to eta0'', eta2'', eta1'' respectively.
-/
lemma period_eq_def'' : period'' 0 = Œ∑‚ÇÄ'' ‚àß period'' 1 = Œ∑‚ÇÇ'' ‚àß period'' 2 = Œ∑‚ÇÅ'' := by
  exact ‚ü® rfl, rfl, rfl ‚ü©

/-
The index function correctly identifies which coset an element belongs to.
-/
lemma ind_spec'' (x : ZMod 349) (hx : x ‚â† 0) :
  (ind'' x = 0 ‚Üî x ‚àà S_cubic_res'') ‚àß
  (ind'' x = 1 ‚Üî x ‚àà S_s1'') ‚àß
  (ind'' x = 2 ‚Üî x ‚àà S_s2'') := by
    native_decide +revert

/-
Evaluate the cyclotomic numbers for q=349.
-/
#eval (cyc_num'' 0 0, cyc_num'' 0 1, cyc_num'' 0 2)
#eval (cyc_num'' 1 0, cyc_num'' 1 1, cyc_num'' 1 2)
#eval (cyc_num'' 2 0, cyc_num'' 2 1, cyc_num'' 2 2)

/-
Define N_sol'' as the number of solutions to x + y = u with ind x = i and ind y = j.
-/
def N_sol'' (i j : ZMod 3) (u : ZMod 349) : ‚Ñï :=
  Fintype.card { p : ZMod 349 √ó ZMod 349 // p.1 ‚â† 0 ‚àß p.2 ‚â† 0 ‚àß ind'' p.1 = i ‚àß ind'' p.2 = j ‚àß p.1 + p.2 = u }

/-
The index of -1 is 0.
-/
lemma ind_neg_one'' : ind'' (-1) = 0 := by
  native_decide +revert

/-
The index function is a homomorphism from the multiplicative group to the additive group Z/3Z.
-/
lemma ind_mul'' (x y : ZMod 349) (hx : x ‚â† 0) (hy : y ‚â† 0) : ind'' (x * y) = ind'' x + ind'' y := by
  native_decide +revert

/-
The index of the inverse is the negative of the index.
-/
lemma ind_inv'' (x : ZMod 349) (hx : x ‚â† 0) : ind'' (x‚Åª¬π) = - ind'' x := by
  native_decide +revert

/-
The cardinalities of the sets S_cubic_res'', S_s1'', and S_s2'' are all 116.
-/
lemma card_S'' : S_cubic_res''.card = 116 ‚àß S_s1''.card = 116 ‚àß S_s2''.card = 116 := by
  native_decide +revert

/-
Define C_coset'' and prove it equals the previously defined sets.
-/
def C_coset'' (i : ZMod 3) : Finset (ZMod 349) := Finset.univ.filter (fun x => x ‚â† 0 ‚àß ind'' x = i)

lemma C_coset_eq'' : C_coset'' 0 = S_cubic_res'' ‚àß C_coset'' 1 = S_s1'' ‚àß C_coset'' 2 = S_s2'' := by
  native_decide +revert

/-
The period function is the sum of zeta powers over the coset.
-/
lemma period_eq_sum_C_coset'' (i : ZMod 3) : period'' i = ‚àë x ‚àà C_coset'' i, Œ∂349 ^ (x.val : ‚Ñï) := by
  fin_cases i <;> simp +decide [ period_eq_def'' ];
  ¬∑ exact C_coset_eq''.left.symm ‚ñ∏ rfl;
  ¬∑ -- By definition of $C_coset''$, we know that $C_coset'' 1 = S_s1''$.
    have h_coset_eq : C_coset'' 1 = S_s1'' := by
      exact C_coset_eq''.2.1;
    exact h_coset_eq.symm ‚ñ∏ rfl;
  ¬∑ exact Eq.symm ( by rw [ show C_coset'' 2 = S_s2'' by exact ( by native_decide ) ] ; rfl )

/-
Expansion of the product of Gaussian periods in terms of solution counts for q=349.
-/
lemma period_mul_eq_sum_N_sol'' (i j : ZMod 3) :
  period'' i * period'' j = (if i = j then 116 else 0) +
  ‚àë u ‚àà Finset.univ.filter (fun x : ZMod 349 => x ‚â† 0), (N_sol'' i j u : L349) * Œ∂349 ^ (u.val : ‚Ñï) := by
    revert i j;
    -- We'll use the fact that $period'' i = \sum_{x \in S_i} \zeta_{349}^x$ to expand the product.
    have h_expand : ‚àÄ i j : ZMod 3, period'' i * period'' j = (if i = j then 116 else 0) + ‚àë x ‚àà C_coset'' i, ‚àë y ‚àà C_coset'' j, if x + y = 0 then 0 else Œ∂349 ^ ((x + y).val : ‚Ñï) := by
      intro i j
      have h_expand : period'' i * period'' j = ‚àë x ‚àà C_coset'' i, ‚àë y ‚àà C_coset'' j, Œ∂349 ^ (x.val : ‚Ñï) * Œ∂349 ^ (y.val : ‚Ñï) := by
        rw [ period_eq_sum_C_coset'' i, period_eq_sum_C_coset'' j, Finset.sum_mul_sum ];
      have h_split : ‚àë x ‚àà C_coset'' i, ‚àë y ‚àà C_coset'' j, Œ∂349 ^ (x.val : ‚Ñï) * Œ∂349 ^ (y.val : ‚Ñï) = ‚àë x ‚àà C_coset'' i, ‚àë y ‚àà C_coset'' j, if x + y = 0 then 1 else Œ∂349 ^ ((x + y).val : ‚Ñï) := by
        refine' Finset.sum_congr rfl fun x hx => Finset.sum_congr rfl fun y hy => _;
        have h_exp : Œ∂349 ^ (x.val + y.val) = Œ∂349 ^ ((x + y).val : ‚Ñï) := by
          have h_exp : Œ∂349 ^ 349 = 1 := by
            exact IsPrimitiveRoot.pow_eq_one ( IsCyclotomicExtension.zeta_spec 349 ‚Ñö L349 );
          rw [ ‚Üê Nat.mod_add_div ( x.val + y.val ) 349, pow_add, pow_mul ] ; aesop;
        split_ifs <;> simp_all +decide [ ‚Üê pow_add ];
      have h_card : ‚àë x ‚àà C_coset'' i, ‚àë y ‚àà C_coset'' j, (if x + y = 0 then 1 else 0) = if i = j then 116 else 0 := by
        fin_cases i <;> fin_cases j <;> native_decide;
      simp_all +decide [ Finset.sum_ite ];
      rw [ Finset.sum_add_distrib, ‚Üê Nat.cast_sum, h_card ];
      split_ifs <;> norm_num;
    intros i j
    have h_double_sum : ‚àë x ‚àà C_coset'' i, ‚àë y ‚àà C_coset'' j, (if x + y = 0 then 0 else Œ∂349 ^ ((x + y).val : ‚Ñï)) = ‚àë u ‚àà Finset.univ.filter (fun x => x ‚â† 0), ‚àë x ‚àà C_coset'' i, ‚àë y ‚àà C_coset'' j, (if x + y = u then Œ∂349 ^ (u.val : ‚Ñï) else 0) := by
      have h_double_sum : ‚àÄ x ‚àà C_coset'' i, ‚àÄ y ‚àà C_coset'' j, (if x + y = 0 then 0 else Œ∂349 ^ ((x + y).val : ‚Ñï)) = ‚àë u ‚àà Finset.univ.filter (fun x => x ‚â† 0), (if x + y = u then Œ∂349 ^ (u.val : ‚Ñï) else 0) := by
        intro x hx y hy; split_ifs <;> simp_all +decide [ Finset.sum_ite ] ;
      rw [ Finset.sum_congr rfl fun x hx => Finset.sum_congr rfl fun y hy => h_double_sum x hx y hy ];
      rw [ Finset.sum_comm, Finset.sum_congr rfl fun _ _ => Finset.sum_comm ];
      rw [ Finset.sum_comm, Finset.sum_congr rfl fun _ _ => Finset.sum_comm ];
    simp_all +decide [ Finset.sum_ite ];
    refine' Finset.sum_congr rfl fun u hu => _;
    rw [ ‚Üê Finset.sum_mul _ _ _ ];
    simp +decide [ N_sol'', Fintype.card_subtype ];
    rw [ show ( Finset.filter ( fun x : ZMod 349 √ó ZMod 349 => ¬¨x.1 = 0 ‚àß ¬¨x.2 = 0 ‚àß ind'' x.1 = i ‚àß ind'' x.2 = j ‚àß x.1 + x.2 = u ) Finset.univ ) = Finset.biUnion ( C_coset'' i ) fun x => Finset.image ( fun y => ( x, y ) ) ( Finset.filter ( fun y => x + y = u ) ( C_coset'' j ) ) from ?_, Finset.card_biUnion ];
    ¬∑ simp +decide [ Finset.card_image_of_injective, Function.Injective ];
    ¬∑ exact fun x hx y hy hxy => Finset.disjoint_left.mpr fun z => by aesop;
    ¬∑ ext ‚ü®x, y‚ü©; simp [C_coset''];
      tauto

/-
The number of solutions to x+y=u depends only on the index of u. Specifically, N_sol(i, j, u) = cyc_num(i - ind(u), j - ind(u)).
-/
lemma N_sol_eq_cyc_num'' (i j : ZMod 3) (u : ZMod 349) (hu : u ‚â† 0) :
  N_sol'' i j u = cyc_num'' (i - ind'' u) (j - ind'' u) := by
    convert Set.ext_iff.mp ?_ ( u, 1 - u ) using 1;
    case convert_1 => exact { p : ZMod 349 √ó ZMod 349 | p.1 ‚â† 0 ‚àß p.2 ‚â† 0 ‚àß p.1 + p.2 = u ‚àß ind'' p.1 = i ‚àß ind'' p.2 = j };
    case convert_2 => exact { p : ZMod 349 √ó ZMod 349 | p.1 ‚â† 0 ‚àß p.2 ‚â† 0 ‚àß p.1 + p.2 = u ‚àß ind'' p.1 = i ‚àß ind'' p.2 = j };
    ¬∑ unfold N_sol'' cyc_num''; simp +decide [ Fintype.card_subtype ] ;
      refine' Finset.card_bij ( fun x hx => x.1 / u ) _ _ _;
      ¬∑ simp +contextual [ hu, sub_eq_iff_eq_add ];
        intro a b ha hb ha' hb' hab; rw [ div_eq_iff_mul_eq ] <;> simp_all +decide [ add_comm, add_left_comm, add_assoc ] ;
        refine' ‚ü® _, _, _ ‚ü© <;> subst_vars <;> simp_all +decide [ div_eq_mul_inv ];
        ¬∑ native_decide +revert;
        ¬∑ native_decide +revert;
      ¬∑ grind;
      ¬∑ intro b hb; use ( b * u, ( 1 - b ) * u ) ; simp_all +decide [ sub_mul, mul_assoc ] ;
        native_decide +revert;
    ¬∑ rfl

/-
Multiplication rule for Gaussian periods for q=349.
-/
lemma period_mul'' (i j : ZMod 3) :
  period'' i * period'' j = (if i = j then 116 else 0) +
  (cyc_num'' (i - 0) (j - 0) * period'' 0 +
   cyc_num'' (i - 1) (j - 1) * period'' 1 +
   cyc_num'' (i - 2) (j - 2) * period'' 2) := by
     -- Apply the lemma N_sol_eq_cyc_num'' to rewrite the sum.
     have h_sum_rewrite : ‚àë u ‚àà Finset.univ.filter (fun x : ZMod 349 => x ‚â† 0), (N_sol'' i j u : L349) * Œ∂349 ^ (u.val : ‚Ñï) = ‚àë k ‚àà Finset.univ, cyc_num'' (i - k) (j - k) * (‚àë u ‚àà C_coset'' k, Œ∂349 ^ (u.val : ‚Ñï)) := by
       have h_sum_rewrite : ‚àë u ‚àà Finset.univ.filter (fun x : ZMod 349 => x ‚â† 0), (N_sol'' i j u : L349) * Œ∂349 ^ (u.val : ‚Ñï) = ‚àë k ‚àà Finset.univ, ‚àë u ‚àà Finset.univ.filter (fun x : ZMod 349 => x ‚â† 0 ‚àß ind'' x = k), (N_sol'' i j u : L349) * Œ∂349 ^ (u.val : ‚Ñï) := by
         rw [ ‚Üê Finset.sum_biUnion ];
         ¬∑ rcongr x ; aesop;
         ¬∑ exact fun x _ y _ hxy => Finset.disjoint_left.mpr fun z => by aesop;
       -- Apply the lemma N_sol_eq_cyc_num'' to each term in the sum.
       have h_inner_sum : ‚àÄ k : ZMod 3, ‚àë u ‚àà Finset.univ.filter (fun x : ZMod 349 => x ‚â† 0 ‚àß ind'' x = k), (N_sol'' i j u : L349) * Œ∂349 ^ (u.val : ‚Ñï) = cyc_num'' (i - k) (j - k) * ‚àë u ‚àà Finset.univ.filter (fun x : ZMod 349 => x ‚â† 0 ‚àß ind'' x = k), Œ∂349 ^ (u.val : ‚Ñï) := by
         intros k
         have h_inner_sum : ‚àÄ u ‚àà Finset.univ.filter (fun x : ZMod 349 => x ‚â† 0 ‚àß ind'' x = k), (N_sol'' i j u : L349) = cyc_num'' (i - k) (j - k) := by
           intros u hu
           have h_ind : ind'' u = k := by
             grind
           rw [N_sol_eq_cyc_num'' i j u (by
           exact Finset.mem_filter.mp hu |>.2.1)];
           rw [ h_ind ];
         rw [ Finset.mul_sum _ _ _, Finset.sum_congr rfl fun u hu => by rw [ h_inner_sum u hu ] ];
       simp_all +decide only [C_coset''];
     convert congr_arg ( fun x : L349 => ( if i = j then 116 else 0 ) + x ) h_sum_rewrite using 1;
     ¬∑ convert period_mul_eq_sum_N_sol'' i j using 1;
     ¬∑ rw [ show ( Finset.univ : Finset ( ZMod 3 ) ) = { 0, 1, 2 } by decide, Finset.sum_insert, Finset.sum_insert ] <;> simp +decide [ Finset.sum_singleton ];
       rw [ ‚Üê add_assoc, ‚Üê period_eq_sum_C_coset'' 0, ‚Üê period_eq_sum_C_coset'' 1, ‚Üê period_eq_sum_C_coset'' 2 ]

/-
Values of the cyclotomic numbers for q=349.
-/
lemma cyc_num_vals'' :
  cyc_num'' 0 0 = 42 ‚àß cyc_num'' 0 1 = 37 ‚àß cyc_num'' 0 2 = 36 ‚àß
  cyc_num'' 1 0 = 37 ‚àß cyc_num'' 1 1 = 36 ‚àß cyc_num'' 1 2 = 43 ‚àß
  cyc_num'' 2 0 = 36 ‚àß cyc_num'' 2 1 = 43 ‚àß cyc_num'' 2 2 = 37 := by
    native_decide +revert

/-
Prove that the sum of the periods is -1.
-/
lemma sum_eta'' : Œ∑‚ÇÄ'' + Œ∑‚ÇÅ'' + Œ∑‚ÇÇ'' = -1 := by
  unfold Œ∑‚ÇÄ'' Œ∑‚ÇÅ'' Œ∑‚ÇÇ'';
  -- The union of S_cubic_res'', S_s2'', and S_s1'' is the set of all non-zero elements in ZMod 349.
  have h_union : S_cubic_res'' ‚à™ S_s2'' ‚à™ S_s1'' = Finset.univ.erase 0 := by
    native_decide +revert;
  rw [ ‚Üê Finset.sum_union, ‚Üê Finset.sum_union ] <;> norm_num [ h_union ];
  ¬∑ have h_sum_zero : ‚àë x ‚àà Finset.range 349, Œ∂349 ^ x = 0 := by
      rw [ geom_sum_eq ] <;> norm_num [ IsPrimitiveRoot.pow_eq_one ];
      ¬∑ exact Or.inl ( sub_eq_zero_of_eq <| IsCyclotomicExtension.zeta_pow 349 ‚Ñö L349 );
      ¬∑ -- By definition of Œ∂349, it is a primitive 349th root of unity, so it cannot be equal to 1.
        have h_primitive : IsPrimitiveRoot Œ∂349 349 := by
          convert IsCyclotomicExtension.zeta_spec 349 ‚Ñö L349;
        exact h_primitive.ne_one ( by decide );
    convert h_sum_zero using 1;
  ¬∑ native_decide +revert;
  ¬∑ native_decide +revert

/-
Calculate alpha squared in terms of the periods.
-/
lemma alpha_sq_eq'' : Œ±''^2 = 232 - 13*Œ∑‚ÇÄ'' + 4*Œ∑‚ÇÇ'' + 7*Œ∑‚ÇÅ'' := by
  -- By definition of Œ±'', we have Œ±'' = -(Œ∑‚ÇÇ'' - Œ∑‚ÇÅ''). Squaring both sides gives Œ±''¬≤ = (Œ∑‚ÇÇ'' - Œ∑‚ÇÅ'')¬≤.
  have h_alpha_sq : Œ±'' ^ 2 = (Œ∑‚ÇÇ'' - Œ∑‚ÇÅ'') ^ 2 := by
    unfold Œ±''; ring;
  -- Expanding the right-hand side: (Œ∑‚ÇÇ'' - Œ∑‚ÇÅ'')¬≤ = Œ∑‚ÇÇ''¬≤ - 2Œ∑‚ÇÇ''Œ∑‚ÇÅ'' + Œ∑‚ÇÅ''¬≤.
  rw [h_alpha_sq]
  have h_expand : (Œ∑‚ÇÇ'' - Œ∑‚ÇÅ'') ^ 2 = Œ∑‚ÇÇ'' ^ 2 - 2 * Œ∑‚ÇÇ'' * Œ∑‚ÇÅ'' + Œ∑‚ÇÅ'' ^ 2 := by
    ring;
  -- Substitute the multiplication rules for Gaussian periods into the expanded form.
  have h_subst : Œ∑‚ÇÇ'' ^ 2 = (if 1 = 1 then 116 else 0) + (cyc_num'' (1 - 0) (1 - 0) * Œ∑‚ÇÄ'' + cyc_num'' (1 - 1) (1 - 1) * Œ∑‚ÇÇ'' + cyc_num'' (1 - 2) (1 - 2) * Œ∑‚ÇÅ'') := by
    convert period_mul'' 1 1 using 1 ; norm_num [ period_eq_def'' ];
    ring;
  have h_subst2 : Œ∑‚ÇÅ'' ^ 2 = (if 2 = 2 then 116 else 0) + (cyc_num'' (2 - 0) (2 - 0) * Œ∑‚ÇÄ'' + cyc_num'' (2 - 1) (2 - 1) * Œ∑‚ÇÇ'' + cyc_num'' (2 - 2) (2 - 2) * Œ∑‚ÇÅ'') := by
    convert period_mul'' 2 2 using 1;
    rw [ sq, ‚Üê period_eq_def'' |>.2.2 ]
  have h_subst3 : Œ∑‚ÇÇ'' * Œ∑‚ÇÅ'' = (if 1 = 2 then 116 else 0) + (cyc_num'' (1 - 0) (2 - 0) * Œ∑‚ÇÄ'' + cyc_num'' (1 - 1) (2 - 1) * Œ∑‚ÇÇ'' + cyc_num'' (1 - 2) (2 - 2) * Œ∑‚ÇÅ'') := by
    convert period_mul'' 1 2 using 1;
  rw [ h_expand, h_subst, h_subst2, show ( 2 : L349 ) * Œ∑‚ÇÇ'' * Œ∑‚ÇÅ'' = 2 * ( Œ∑‚ÇÇ'' * Œ∑‚ÇÅ'' ) by ring, h_subst3 ] ; ring;
  rw [ show cyc_num'' 1 1 = 36 by exact cyc_num_vals''.2.2.2.2.1, show cyc_num'' 1 2 = 43 by exact cyc_num_vals''.2.2.2.2.2.1, show cyc_num'' 2 2 = 37 by exact cyc_num_vals''.2.2.2.2.2.2.2.2, show cyc_num'' 0 0 = 42 by exact cyc_num_vals''.1, show cyc_num'' 0 1 = 37 by exact cyc_num_vals''.2.1, show cyc_num'' ( -1 ) ( -1 ) = 37 by exact cyc_num_vals''.2.2.2.2.2.2.2.2, show cyc_num'' ( -1 ) 0 = 36 by exact cyc_num_vals''.2.2.2.2.2.2.1 ] ; ring;
  grind

/-
Prove the algebraic relation between beta'' and alpha''.
-/
theorem beta_relation'' : 2 * 37 * Œ≤'' = 6 * Œ±''^2 - (37 + 9) * Œ±'' - 4 * 349 := by
  rw [alpha_sq_eq'']
  have h_sum : Œ∑‚ÇÄ'' + Œ∑‚ÇÅ'' + Œ∑‚ÇÇ'' = -1 := sum_eta''
  have h_beta : Œ≤'' = -Œ∑‚ÇÄ'' + Œ∑‚ÇÇ'' := by
    rw [Œ≤'']; ring
  have h_alpha : Œ±'' = -Œ∑‚ÇÇ'' + Œ∑‚ÇÅ'' := by
    rw [Œ±'']; ring
  rw [h_beta, h_alpha]
  linear_combination 4 * h_sum

/-
Define the Galois unit and automorphism for q=349.
-/
def gal_unit349 (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 349) : (ZMod 349)À£ := Units.mk0 (N : ZMod 349) (by
  rw [Ne, ZMod.natCast_zmod_eq_zero_iff_dvd]
  intro h
  have hN_prime : Nat.Prime N := Fact.out
  have : 349 = 1 ‚à® 349 = N := (Nat.dvd_prime hN_prime).mp h
  have : 349 = N := this.resolve_left (by norm_num)
  exact hN this.symm)

def sigma349 (u : (ZMod 349)À£) : L349 ‚âÉ‚Çê[‚Ñö] L349 :=
  (IsCyclotomicExtension.autEquivPow L349 (Polynomial.cyclotomic.irreducible_rat (n := 349) (by norm_num))).symm u

/-
Multiplication table for the Gaussian periods (corrected).
-/
lemma eta_mul_table'' :
  Œ∑‚ÇÄ''^2 = 116 + 42*Œ∑‚ÇÄ'' + 36*Œ∑‚ÇÅ'' + 37*Œ∑‚ÇÇ'' ‚àß
  Œ∑‚ÇÅ''^2 = 116 + 37*Œ∑‚ÇÄ'' + 42*Œ∑‚ÇÅ'' + 36*Œ∑‚ÇÇ'' ‚àß
  Œ∑‚ÇÇ''^2 = 116 + 36*Œ∑‚ÇÄ'' + 37*Œ∑‚ÇÅ'' + 42*Œ∑‚ÇÇ'' ‚àß
  Œ∑‚ÇÄ''*Œ∑‚ÇÅ'' = 36*Œ∑‚ÇÄ'' + 37*Œ∑‚ÇÅ'' + 43*Œ∑‚ÇÇ'' ‚àß
  Œ∑‚ÇÄ''*Œ∑‚ÇÇ'' = 37*Œ∑‚ÇÄ'' + 43*Œ∑‚ÇÅ'' + 36*Œ∑‚ÇÇ'' ‚àß
  Œ∑‚ÇÅ''*Œ∑‚ÇÇ'' = 43*Œ∑‚ÇÄ'' + 36*Œ∑‚ÇÅ'' + 37*Œ∑‚ÇÇ'' := by
    -- Apply the period multiplication rule to each term in the conjunction.
    apply And.intro (by
    -- Substitute the cyclotomic numbers into the multiplication rule.
    have h_subst : period'' 0 * period'' 0 = 116 + 42 * Œ∑‚ÇÄ'' + 36 * Œ∑‚ÇÅ'' + 37 * Œ∑‚ÇÇ'' := by
      convert period_mul'' 0 0 using 1 ; norm_num [ cyc_num_vals'' ];
      rw [ show cyc_num'' ( -1 ) ( -1 ) = 37 by native_decide, show cyc_num'' ( -2 ) ( -2 ) = 36 by native_decide ] ; ring!;
    convert h_subst using 1 ; rw [ sq, period_eq_def'' |>.1 ]) (And.intro (by
    have := period_mul'' 2 2; norm_num at this ‚ä¢; (
    rw [ sq ] ; rw [ show period'' 2 = Œ∑‚ÇÅ'' from by rfl ] at this; rw [ show period'' 0 = Œ∑‚ÇÄ'' from by rfl ] at this; rw [ show period'' 1 = Œ∑‚ÇÇ'' from by rfl ] at this; rw [ show cyc_num'' 2 2 = 37 from by native_decide ] at this; rw [ show cyc_num'' 1 1 = 36 from by native_decide ] at this; rw [ show cyc_num'' 0 0 = 42 from by native_decide ] at this; linear_combination' this;);) (And.intro (by
    have := period_mul'' 1 1; simp_all +decide [ sq ] ;
    convert this using 1 ; norm_num [ cyc_num_vals'' ] ; ring!;
    erw [ show cyc_num'' ( -1 ) ( -1 ) = 37 by native_decide ] ; norm_num) (And.intro (by
    convert period_mul'' 0 2 using 1 ; norm_num [ cyc_num_vals'' ] ; ring!;
    erw [ show cyc_num'' ( -2 ) 0 = 37 by { exact by rw [ show ( -2 : ZMod 3 ) = 1 by decide ] ; exact by rw [ show cyc_num'' 1 0 = 37 by exact by native_decide ] } ] ; erw [ show cyc_num'' ( -1 ) 1 = 43 by { exact by rw [ show ( -1 : ZMod 3 ) = 2 by decide ] ; exact by rw [ show cyc_num'' 2 1 = 43 by exact by native_decide ] } ] ; norm_cast;
    simp +decide [ ZMod ]) (And.intro (by
    convert period_mul'' 0 1 using 1 ; norm_num [ cyc_num_vals'' ];
    rw [ show cyc_num'' ( -1 ) 0 = 36 by native_decide, show cyc_num'' ( -2 ) ( -1 ) = 43 by native_decide ] ; norm_num [ period_eq_def'' ] ; ring) (by
    convert period_mul'' 2 1 using 1 ; ring!;
    erw [ show cyc_num'' 2 1 = 43 by
            native_decide +revert, show cyc_num'' 0 ( -1 ) = 36 by
                                              native_decide +revert, show cyc_num'' 1 0 = 37 by
                                                                                    native_decide +revert ] ; ring!;
    simp +decide)))))

/-
Define the integer version of zeta349.
-/
def Œ∂349_int : ùìû L349 := IsPrimitiveRoot.toInteger (IsCyclotomicExtension.zeta_spec 349 ‚Ñö L349)

/-
Multiplication table for the Gaussian periods (corrected).
-/
lemma eta_mul_table_corrected'' :
  Œ∑‚ÇÄ''^2 = 116 + 42*Œ∑‚ÇÄ'' + 36*Œ∑‚ÇÅ'' + 37*Œ∑‚ÇÇ'' ‚àß
  Œ∑‚ÇÅ''^2 = 116 + 37*Œ∑‚ÇÄ'' + 42*Œ∑‚ÇÅ'' + 36*Œ∑‚ÇÇ'' ‚àß
  Œ∑‚ÇÇ''^2 = 116 + 36*Œ∑‚ÇÄ'' + 37*Œ∑‚ÇÅ'' + 42*Œ∑‚ÇÇ'' ‚àß
  Œ∑‚ÇÄ''*Œ∑‚ÇÅ'' = 36*Œ∑‚ÇÄ'' + 37*Œ∑‚ÇÅ'' + 43*Œ∑‚ÇÇ'' ‚àß
  Œ∑‚ÇÄ''*Œ∑‚ÇÇ'' = 37*Œ∑‚ÇÄ'' + 43*Œ∑‚ÇÅ'' + 36*Œ∑‚ÇÇ'' ‚àß
  Œ∑‚ÇÅ''*Œ∑‚ÇÇ'' = 43*Œ∑‚ÇÄ'' + 36*Œ∑‚ÇÅ'' + 37*Œ∑‚ÇÇ'' := by
    -- Apply the period multiplication rule to each term in the conjunction.
    apply And.intro (by
    -- Substitute the cyclotomic numbers into the multiplication rule.
    have h_subst : period'' 0 * period'' 0 = 116 + 42 * Œ∑‚ÇÄ'' + 36 * Œ∑‚ÇÅ'' + 37 * Œ∑‚ÇÇ'' := by
      convert period_mul'' 0 0 using 1 ; norm_num [ cyc_num_vals'' ];
      rw [ show cyc_num'' ( -1 ) ( -1 ) = 37 by native_decide, show cyc_num'' ( -2 ) ( -2 ) = 36 by native_decide ] ; ring!;
    convert h_subst using 1 ; rw [ sq, period_eq_def'' |>.1 ]) (And.intro (by
    have := period_mul'' 2 2; norm_num at this ‚ä¢; (
    rw [ sq ] ; rw [ show period'' 2 = Œ∑‚ÇÅ'' from by rfl ] at this; rw [ show period'' 0 = Œ∑‚ÇÄ'' from by rfl ] at this; rw [ show period'' 1 = Œ∑‚ÇÇ'' from by rfl ] at this; rw [ show cyc_num'' 2 2 = 37 from by native_decide ] at this; rw [ show cyc_num'' 1 1 = 36 from by native_decide ] at this; rw [ show cyc_num'' 0 0 = 42 from by native_decide ] at this; linear_combination' this;);) (And.intro (by
    have := period_mul'' 1 1; simp_all +decide [ sq ] ;
    convert this using 1 ; norm_num [ cyc_num_vals'' ] ; ring!;
    erw [ show cyc_num'' ( -1 ) ( -1 ) = 37 by native_decide ] ; norm_num) (And.intro (by
    convert period_mul'' 0 2 using 1 ; norm_num [ cyc_num_vals'' ] ; ring!;
    erw [ show cyc_num'' ( -2 ) 0 = 37 by { exact by rw [ show ( -2 : ZMod 3 ) = 1 by decide ] ; exact by rw [ show cyc_num'' 1 0 = 37 by exact by native_decide ] } ] ; erw [ show cyc_num'' ( -1 ) 1 = 43 by { exact by rw [ show ( -1 : ZMod 3 ) = 2 by decide ] ; exact by rw [ show cyc_num'' 2 1 = 43 by exact by native_decide ] } ] ; norm_cast;
    simp +decide [ ZMod ]) (And.intro (by
    convert period_mul'' 0 1 using 1 ; norm_num [ cyc_num_vals'' ];
    rw [ show cyc_num'' ( -1 ) 0 = 36 by native_decide, show cyc_num'' ( -2 ) ( -1 ) = 43 by native_decide ] ; norm_num [ period_eq_def'' ] ; ring) (by
    convert period_mul'' 2 1 using 1 ; ring!;
    erw [ show cyc_num'' 2 1 = 43 by
            native_decide +revert, show cyc_num'' 0 ( -1 ) = 36 by
                                              native_decide +revert, show cyc_num'' 1 0 = 37 by
                                                                                    native_decide +revert ] ; ring!;
    simp +decide)))))

/-
Define the integer versions of the periods and roots for q=349.
-/
def period_int'' (i : ZMod 3) : ùìû L349 := ‚àë x ‚àà C_coset'' i, Œ∂349_int ^ (x.val : ‚Ñï)

def Œ±''_int : ùìû L349 := -(period_int'' 1 - period_int'' 2)
def Œ≤''_int : ùìû L349 := -(period_int'' 0 - period_int'' 1)
def Œ≥''_int : ùìû L349 := -(period_int'' 2 - period_int'' 0)

/-
Prove that the integer period coerces to the field period.
-/
lemma coe_period_int'' (i : ZMod 3) : (period_int'' i : L349) = period'' i := by
  -- The algebra map is a ring homomorphism, so it preserves addition. Therefore, applying the algebra map to each term in the sum and then summing them is the same as summing the terms first and then applying the algebra map.
  have h_sum : ‚àÄ (s : Finset (ZMod 349)), (‚àë x ‚àà s, (Œ∂349_int ^ (x.val : ‚Ñï) : L349)) = (‚àë x ‚àà s, (Œ∂349 ^ (x.val : ‚Ñï) : L349)) := by
    intro s
    congr! 1;
  convert h_sum ( C_coset'' i ) using 1;
  ¬∑ unfold period_int''; aesop;
  ¬∑ exact?

/-
Prove that the integer root alpha'' coerces to the field root alpha''.
-/
lemma coe_alpha''_int : (Œ±''_int : L349) = Œ±'' := by
  -- By definition of coercion, we have that the coercion of the integer period_int'' i is equal to the field period'' i.
  have h_coe_period : ‚àÄ i : ZMod 3, (period_int'' i : L349) = period'' i := by
    exact?;
  unfold Œ±''_int Œ±''; aesop;

/-
Prove that the integer root beta'' coerces to the field root beta''.
-/
lemma coe_beta''_int : (Œ≤''_int : L349) = Œ≤'' := by
  unfold Œ≤''_int;
  convert congr_arg ( fun x : L349 => - ( Œ∑‚ÇÄ'' - x ) ) ( coe_period_int'' 1 ) using 1;
  simp +decide [ coe_period_int'' ];
  exact?

/-
Prove that the integer root gamma'' coerces to the field root gamma''.
-/
lemma coe_gamma''_int : (Œ≥''_int : L349) = Œ≥'' := by
  -- By definition of coercion, we can rewrite the goal using the definitions of Œ≥''_int and Œ≥''.
  simp [Œ≥''_int, Œ≥''];
  convert congr_arg‚ÇÇ ( ¬∑ - ¬∑ ) ( coe_period_int'' 0 ) ( coe_period_int'' 2 ) using 1

/-
Relate the index of N to the value of c'' N being s1''.
-/
lemma ind_N_eq_1_iff_c_eq_s1'' (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 349) :
  ind'' (N : ZMod 349) = 1 ‚Üî c'' N = s1'' := by
    -- By definition of $c''$, we know that $c'' N = (N : ZMod 349) ^ ((349 - 1) / 3)$.
    have hc'' : c'' N = (N : ZMod 349) ^ 116 := by
      rfl;
    convert ind_spec'' ( N : ZMod 349 ) ( show ( N : ZMod 349 ) ‚â† 0 from ?_ ) |> And.right |> And.left using 1
    generalize_proofs at *;
    ¬∑ simp +decide [ S_s1'', hc'' ];
      intro h; intro h'; simp_all +decide [ ZMod.natCast_eq_zero_iff ] ;
      exact absurd h ( by native_decide );
    ¬∑ exact?

/-
Relate the index of N to the value of c'' N being s2''.
-/
lemma ind_N_eq_2_iff_c_eq_s2'' (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 349) :
  ind'' (N : ZMod 349) = 2 ‚Üî c'' N = s2'' := by
    -- By definition of $ind''$, we know that $ind'' (N : ZMod 349) = 2$ if and only if $N \equiv N \pmod{349}$ and $ind'' N = 2$.
    simp [ind''];
    split_ifs <;> simp_all +decide [ S_cubic_res'', S_s1'', S_s2'' ];
    ¬∑ unfold c'' s2''; simp_all +decide [ ZMod.natCast_eq_zero_iff ] ;
      erw [ inv_eq_one_div, mul_one_div, eq_div_iff ] <;> norm_cast ; simp_all +decide [ ZMod.natCast_eq_zero_iff ];
      erw [ show ( q'' - 1 ) / 3 = 116 by rfl ] ; simp_all +decide [ ‚Üê ZMod.natCast_eq_zero_iff ] ;
    ¬∑ simp_all +decide [ c'' ];
      simp_all +decide [ q'' ];
      native_decide +revert;
    ¬∑ by_cases h‚ÇÉ : ( N : ZMod 349 ) = 0 <;> simp_all +decide [ ZMod.natCast_eq_zero_iff ];
      ¬∑ rw [ Nat.dvd_prime Fact.out ] at h‚ÇÉ ; aesop;
      ¬∑ -- Since $N$ is a prime not equal to $349$, $N$ is coprime with $349$, and thus $N^{116} \equiv 1 \pmod{349}$.
        have h_order : (N : ZMod 349) ^ 348 = 1 := by
          have h_order : Nat.gcd N 349 = 1 := by
            exact Nat.Coprime.symm ( Nat.Prime.coprime_iff_not_dvd ( by norm_num ) |>.2 h‚ÇÉ );
          simpa [ ‚Üê ZMod.natCast_eq_natCast_iff ] using Nat.ModEq.pow_totient h_order;
        simp_all +decide [ show ( N : ZMod 349 ) ^ 348 = ( N ^ 116 ) ^ 3 by ring ];
        have h_order : ‚àÄ x : ZMod 349, x ^ 3 = 1 ‚Üí x = 1 ‚à® x = s1'' ‚à® x = s2'' := by
          native_decide;
        cases h_order _ ‚Äπ_‚Ä∫ <;> aesop

/-
Abbreviations for the ring of integers, residue field, and reduction map for q=349.
-/
abbrev ùìûL349 := ùìû L349
def kP349 (P : Ideal ùìûL349) [P.IsMaximal] := ùìûL349 ‚ß∏ P
noncomputable instance (P : Ideal ùìûL349) [P.IsMaximal] : Field (kP349 P) := Ideal.Quotient.field P
def red349 (P : Ideal ùìûL349) [P.IsMaximal] : ùìûL349 ‚Üí+* kP349 P := Ideal.Quotient.mk P

/-
Lift the automorphism sigma349 to the ring of integers.
-/
def sigma_int349 (u : (ZMod 349)À£) (x : ùìû L349) : ùìû L349 := ‚ü®sigma349 u x, by
  have h_integral : IsIntegral ‚Ñ§ (x : L349) := x.2
  exact IsIntegral.map (sigma349 u) h_integral‚ü©

/-
The ring of integers is generated by zeta349.
-/
lemma adjoin_zeta_eq_top349 : Algebra.adjoin ‚Ñ§ ({Œ∂349_int} : Set ùìûL349) = ‚ä§ := by
  have h_adjoin : IsPrimitiveRoot Œ∂349_int 349 := by
    have h_primitive : IsPrimitiveRoot (IsCyclotomicExtension.zeta 349 ‚Ñö L349) 349 := by
      convert IsCyclotomicExtension.zeta_spec 349 ‚Ñö L349;
    convert h_primitive using 1;
    ext; simp +decide [ IsPrimitiveRoot.iff_def ] ;
    constructor <;> rintro ‚ü® h‚ÇÅ, h‚ÇÇ ‚ü© <;> refine' ‚ü® _, _ ‚ü© <;> norm_cast at *;
    ¬∑ exact?;
    ¬∑ intro l hl; specialize h‚ÇÇ l; aesop;
    ¬∑ erw [ ‚Üê Subtype.coe_inj ] ; norm_num [ IsCyclotomicExtension.zeta ];
      exact?;
    ¬∑ intro l hl; specialize h‚ÇÇ l; simp_all +decide [ ‚Üê Subtype.coe_inj ] ;
      convert h‚ÇÇ _;
      convert congr_arg ( algebraMap (ùìû L349) L349 ) hl using 1;
  have h_adjoin : IsCyclotomicExtension {349} ‚Ñ§ (ùìû L349) := by
    convert IsCyclotomicExtension.zeta_spec 349 ‚Ñ§ (ùìû L349) using 1
    generalize_proofs at *; (
    exact iff_of_true ‚Äπ_‚Ä∫ ( by exact? ))
  generalize_proofs at *; (
  convert h_adjoin.adjoin_primitive_root_eq_top _;
  assumption)

/-
The automorphism sigma_N reduces to the Frobenius map modulo P.
-/
theorem artin_property349 {N : ‚Ñï} [Fact (Nat.Prime N)] (hN : N ‚â† 349) (P : Ideal ùìûL349) [P.IsMaximal] [CharP (kP349 P) N] (x : ùìûL349) :
  red349 P (sigma_int349 (gal_unit349 N hN) x) = (red349 P x) ^ N := by
    have h_frobenius : ‚àÄ (x : ùìûL349), (red349 P) (sigma_int349 (gal_unit349 N hN) x) = (red349 P x) ^ N := by
      intro x
      have h_gen : ‚àÄ y : ùìûL349, y ‚àà Algebra.adjoin ‚Ñ§ ({Œ∂349_int} : Set ùìûL349) := by
        exact fun y => by rw [ adjoin_zeta_eq_top349 ] ; exact Algebra.mem_top;
      refine' Algebra.adjoin_induction _ _ _ _ ( h_gen x );
      ¬∑ -- By definition of sigma_int349, we have sigma_int349 (gal_unit349 N hN) Œ∂349_int = Œ∂349_int^N.
        have h_sigma_zeta : sigma_int349 (gal_unit349 N hN) Œ∂349_int = Œ∂349_int ^ N := by
          unfold sigma_int349;
          unfold sigma349 gal_unit349;
          erw [ Subtype.mk_eq_mk ];
          simp +decide [ IsCyclotomicExtension.autEquivPow ];
          erw [ PowerBasis.equivOfMinpoly_gen ];
          simp +decide [ IsPrimitiveRoot.powerBasis ];
          erw [ ‚Üê Nat.mod_add_div N 349 ] ; norm_num [ pow_add, pow_mul ];
          erw [ show ( Œ∂349_int : L349 ) ^ 349 = 1 from ?_ ] ; aesop;
          convert IsPrimitiveRoot.pow_eq_one ( IsCyclotomicExtension.zeta_spec 349 ‚Ñö L349 ) using 1;
        aesop;
      ¬∑ intro r
        simp [sigma_int349];
        have h_frobenius : ‚àÄ (r : ‚Ñ§), (red349 P) (algebraMap ‚Ñ§ (ùìûL349) r) = (r : kP349 P) ^ N := by
          intro r; exact (by
          have h_frobenius : ‚àÄ (r : ‚Ñ§), (red349 P) (algebraMap ‚Ñ§ (ùìûL349) r) = (r : kP349 P) := by
            exact?;
          rw [ h_frobenius, eq_comm ];
          have h_frobenius : ‚àÄ (r : ZMod N), r ^ N = r := by
            exact fun r => by rw [ ZMod.pow_card ] ;
          convert h_frobenius ( r : ZMod N ) using 1;
          norm_cast;
          erw [ ZMod.intCast_eq_intCast_iff ];
          exact?);
        convert h_frobenius r using 1;
      ¬∑ intro x y hx hy hx' hy'; simp_all +decide [ ‚Üê map_mul, ‚Üê map_add ] ;
        convert congr_arg‚ÇÇ ( ¬∑ + ¬∑ ) hx' hy' using 1 <;> ring;
        ¬∑ convert map_add _ _ _ using 1;
          rotate_left 1;
          exact inferInstance;
          ¬∑ infer_instance;
          ¬∑ unfold sigma_int349; aesop;
        ¬∑ rw [ ‚Üê add_pow_char ];
          rw [ map_add ];
      ¬∑ simp +contextual [ *, mul_pow ];
        intro x y hx hy; rw [ ‚Üê hx, ‚Üê hy ] ; simp +decide [ ‚Üê map_mul ] ;
        unfold sigma_int349; aesop;
    exact h_frobenius x

/-
The Frobenius automorphism permutes the Gaussian periods by shifting their index by ind(N).
-/
lemma sigma_period'' (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 349) (i : ZMod 3) :
  sigma349 (gal_unit349 N hN) (period'' i) = period'' (i + ind'' (N : ZMod 349)) := by
    -- By definition of the automorphism, it permutes the Gaussian periods by shifting their index by ind(N).
    have h_aut_perm : ‚àÄ x : ZMod 349, x ‚â† 0 ‚Üí sigma349 (gal_unit349 N hN) (Œ∂349 ^ (x.val : ‚Ñï)) = Œ∂349 ^ ((x * N : ZMod 349).val : ‚Ñï) := by
      intro x hx_ne_zero
      have h_sigma_zeta : sigma349 (gal_unit349 N hN) (Œ∂349) = Œ∂349 ^ (N : ZMod 349).val := by
        have h_sigma_zeta : ‚àÄ u : (ZMod 349)À£, (IsCyclotomicExtension.autEquivPow L349 (Polynomial.cyclotomic.irreducible_rat (n := 349) (by norm_num))).symm u (IsCyclotomicExtension.zeta 349 ‚Ñö L349) = (IsCyclotomicExtension.zeta 349 ‚Ñö L349) ^ (u.val.val : ‚Ñï) := by
          intro u
          simp [IsCyclotomicExtension.autEquivPow];
          rw [ PowerBasis.equivOfMinpoly_apply ];
          convert ( IsPrimitiveRoot.powerBasis ‚Ñö ( show IsPrimitiveRoot ( IsCyclotomicExtension.zeta 349 ‚Ñö L349 ) 349 from ?_ ) ).lift_gen _ _ using 1;
          exact?;
        convert h_sigma_zeta ( gal_unit349 N hN ) using 1;
      convert congr_arg ( ¬∑ ^ x.val ) h_sigma_zeta using 1 <;> norm_num [ pow_mul', mul_comm ];
      rw [ ‚Üê pow_mul, mul_comm, ZMod.val_mul ];
      rw [ ‚Üê Nat.mod_add_div ( N % 349 * x.val ) 349, pow_add, pow_mul ] ; norm_num [ pow_mul, pow_succ ];
      have h_zeta_order : Œ∂349 ^ 349 = 1 := by
        exact IsPrimitiveRoot.pow_eq_one ( IsCyclotomicExtension.zeta_spec 349 ‚Ñö L349 );
      simp_all +decide [ pow_succ, mul_assoc ];
    -- By definition of the automorphism, it permutes the Gaussian periods by shifting their index by ind(N). Hence, we can rewrite the sum.
    have h_sum_perm : ‚àë x ‚àà C_coset'' i, sigma349 (gal_unit349 N hN) (Œ∂349 ^ (x.val : ‚Ñï)) = ‚àë x ‚àà C_coset'' (i + ind'' (N : ZMod 349)), Œ∂349 ^ (x.val : ‚Ñï) := by
      apply Finset.sum_bij (fun x hx => (x * N : ZMod 349));
      ¬∑ intro x hx
        simp [C_coset''] at hx ‚ä¢
        generalize_proofs at *;
        have h_ind_mul : ‚àÄ x y : ZMod 349, x ‚â† 0 ‚Üí y ‚â† 0 ‚Üí ind'' (x * y) = ind'' x + ind'' y := by
          exact?
        generalize_proofs at *; (
        have hN_ne_zero : (N : ZMod 349) ‚â† 0 := by
          exact?
        generalize_proofs at *; (
        exact ‚ü® ‚ü® hx.1, hN_ne_zero ‚ü©, by rw [ h_ind_mul x N hx.1 hN_ne_zero, hx.2 ] ‚ü©));
      ¬∑ intro a‚ÇÅ ha‚ÇÅ a‚ÇÇ ha‚ÇÇ h_eq
        have h_inv : (N : ZMod 349) ‚â† 0 := by
          exact?
        have h_inv_mul : (a‚ÇÅ : ZMod 349) = (a‚ÇÇ : ZMod 349) := by
          haveI := Fact.mk ( by norm_num : Nat.Prime 349 ) ; exact mul_right_cancel‚ÇÄ h_inv h_eq;
        exact h_inv_mul;
      ¬∑ intro b hb
        use b * (N : ZMod 349)‚Åª¬π;
        have h_inv : (N : ZMod 349) ‚â† 0 := by
          exact?;
        have h_ind : ind'' (b * (N : ZMod 349)‚Åª¬π) = ind'' b - ind'' (N : ZMod 349) := by
          have h_ind : ind'' (b * (N : ZMod 349)‚Åª¬π) = ind'' b + ind'' ((N : ZMod 349)‚Åª¬π) := by
            apply ind_mul'';
            ¬∑ exact Finset.mem_filter.mp hb |>.2.1;
            ¬∑ haveI := Fact.mk ( by norm_num : Nat.Prime 349 ) ; exact inv_ne_zero h_inv;
          have h_ind_inv : ind'' ((N : ZMod 349)‚Åª¬π) = -ind'' (N : ZMod 349) := by
            exact?;
          rw [h_ind, h_ind_inv]
          ring;
        unfold C_coset'' at *; aesop;
      ¬∑ exact fun x hx => h_aut_perm x <| Finset.mem_filter.mp hx |>.2.1;
    convert h_sum_perm using 1;
    ¬∑ rw [ period_eq_sum_C_coset'' ];
      rw [ map_sum ];
    ¬∑ exact?

/-
If c'' N = s1'', then sigma_N(alpha'') = gamma''.
-/
lemma sigma_alpha_eq_gamma_if_s1'' (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 349) (h : c'' N = s1'') :
  sigma_int349 (gal_unit349 N hN) Œ±''_int = Œ≥''_int := by
    have h_sigma_period : sigma349 (gal_unit349 N hN) Œ±'' = Œ≥'' := by
      have h_sigma_period : sigma349 (gal_unit349 N hN) (period'' 1) = period'' 2 ‚àß sigma349 (gal_unit349 N hN) (period'' 2) = period'' 0 ‚àß sigma349 (gal_unit349 N hN) (period'' 0) = period'' 1 := by
        have h_sigma_period : sigma349 (gal_unit349 N hN) (period'' 1) = period'' (1 + ind'' (N : ZMod 349)) ‚àß sigma349 (gal_unit349 N hN) (period'' 2) = period'' (2 + ind'' (N : ZMod 349)) ‚àß sigma349 (gal_unit349 N hN) (period'' 0) = period'' (0 + ind'' (N : ZMod 349)) := by
          exact ‚ü® sigma_period'' N hN 1, sigma_period'' N hN 2, sigma_period'' N hN 0 ‚ü©;
        have h_ind : ind'' (N : ZMod 349) = 1 := by
          exact?;
        simp_all +decide [ ZMod ];
      convert congr_arg‚ÇÇ ( fun x y : L349 => - ( x - y ) ) h_sigma_period.1 h_sigma_period.2.1 using 1;
      rw [ show Œ±'' = - ( period'' 1 - period'' 2 ) by rfl ] ; norm_num;
    refine' Subtype.ext _;
    convert h_sigma_period using 1;
    ¬∑ convert congr_arg ( sigma349 ( gal_unit349 N hN ) ) ( coe_alpha''_int ) using 1;
    ¬∑ exact coe_gamma''_int

/-
If c'' N = s2'', then sigma_N(alpha'') = beta''.
-/
lemma sigma_alpha_eq_beta_if_s2'' (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 349) (h : c'' N = s2'') :
  sigma_int349 (gal_unit349 N hN) Œ±''_int = Œ≤''_int := by
    -- By definition of $c''$, we know that $c'' N = s2''$ implies $ind'' (N : ZMod 349) = 2$.
    have h_ind_N_eq_2 : ind'' (N : ZMod 349) = 2 := by
      exact?;
    -- By definition of $sigma_int349$, we know that $sigma_int349 (gal_unit349 N hN) (Œ±''_int) = œÉ_N (Œ±''_int)$.
    have h_sigma_int349_alpha : sigma_int349 (gal_unit349 N hN) Œ±''_int = - (sigma_int349 (gal_unit349 N hN) (period_int'' 1) - sigma_int349 (gal_unit349 N hN) (period_int'' 2)) := by
      unfold sigma_int349 Œ±''_int; norm_num;
      exact?;
    -- By definition of $sigma_int349$, we know that $sigma_int349 (gal_unit349 N hN) (period_int'' i) = period_int'' (i + ind'' (N : ZMod 349))$.
    have h_sigma_int349_period : ‚àÄ i : ZMod 3, sigma_int349 (gal_unit349 N hN) (period_int'' i) = period_int'' (i + ind'' (N : ZMod 349)) := by
      intro i
      have h_sigma_int349_period_i : sigma_int349 (gal_unit349 N hN) (period_int'' i) = sigma349 (gal_unit349 N hN) (period'' i) := by
        exact congr_arg ( fun x : L349 => x ) ( coe_period_int'' i ) ‚ñ∏ rfl;
      have h_sigma_int349_period_i : sigma349 (gal_unit349 N hN) (period'' i) = period'' (i + ind'' (N : ZMod 349)) := by
        exact?;
      have h_sigma_int349_period_i : period'' (i + ind'' (N : ZMod 349)) = (period_int'' (i + ind'' (N : ZMod 349)) : L349) := by
        convert coe_period_int'' ( i + ind'' ( N : ZMod 349 ) ) |> Eq.symm using 1;
      exact Subtype.ext <| by aesop;
    simp_all +decide [ ZMod ];
    unfold Œ≤''_int; ring;

/-
Final result for q=349: Frobenius action on alpha'' depends on c'' N.
-/
theorem final_result_349 {N : ‚Ñï} [Fact (Nat.Prime N)] (hN : N ‚â† 349) (P : Ideal ùìûL349) [P.IsMaximal] [CharP (kP349 P) N] :
  (c'' N = s1'' ‚Üí (red349 P Œ±''_int) ^ N = red349 P Œ≥''_int) ‚àß
  (c'' N = s2'' ‚Üí (red349 P Œ±''_int) ^ N = red349 P Œ≤''_int) := by
    apply And.intro;
    ¬∑ intro h
      have h_sigma : sigma_int349 (gal_unit349 N hN) Œ±''_int = Œ≥''_int := by
        convert sigma_alpha_eq_gamma_if_s1'' N hN h using 1;
      rw [ ‚Üê h_sigma, artin_property349 ];
    ¬∑ -- Apply the artin property349 theorem to get the reduction.
      have h_reduction : red349 P (sigma_int349 (gal_unit349 N hN) Œ±''_int) = (red349 P Œ±''_int) ^ N := by
        convert artin_property349 hN P Œ±''_int using 1;
      intro h; rw [ ‚Üê h_reduction, sigma_alpha_eq_beta_if_s2'' N hN h ] ;

/-
Define the polynomial f'' = X^3 - 349X - 349.
-/
def f_poly'' : Polynomial L349 := X^3 - 349*X - 349

/-
Prove that alpha'' is a root of f''.
-/
theorem alpha_root'' : (f_poly'').eval Œ±'' = 0 := by
  -- By definition of $f_poly''$, we know that $f_poly''.eval Œ±'' = Œ±''^3 - 349 * Œ±'' - 349$.
  simp [f_poly''];
  field_simp;
  rw [ show Œ±'' ^ 2 = 232 - 13 * Œ∑‚ÇÄ'' + 4 * Œ∑‚ÇÇ'' + 7 * Œ∑‚ÇÅ'' from ?_, show Œ∑‚ÇÄ'' = -1 - Œ∑‚ÇÅ'' - Œ∑‚ÇÇ'' from ?_ ] <;> ring;
  ¬∑ rw [ show Œ±'' = - ( Œ∑‚ÇÇ'' - Œ∑‚ÇÅ'' ) by rfl ] ; ring;
    rw [ show Œ∑‚ÇÇ'' ^ 2 = 116 + 36 * Œ∑‚ÇÄ'' + 37 * Œ∑‚ÇÅ'' + 42 * Œ∑‚ÇÇ'' by
          convert eta_mul_table''.2.2.1 using 1, show Œ∑‚ÇÅ'' ^ 2 = 116 + 37 * Œ∑‚ÇÄ'' + 42 * Œ∑‚ÇÅ'' + 36 * Œ∑‚ÇÇ'' by
                                                                            -- Apply the lemma eta_mul_table'' to conclude the proof.
                                                                            apply (eta_mul_table'' |>.2.1), show Œ∑‚ÇÇ'' * Œ∑‚ÇÅ'' = 43 * Œ∑‚ÇÄ'' + 36 * Œ∑‚ÇÅ'' + 37 * Œ∑‚ÇÇ'' by
                                                                                                                                              exact eta_mul_table_corrected''.2.2.2.2.2.symm ‚ñ∏ by ring; ] ; ring;
    -- By definition of Œ∑‚ÇÄ'', Œ∑‚ÇÅ'', and Œ∑‚ÇÇ'', we know that their sum is -1.
    have h_sum : Œ∑‚ÇÄ'' + Œ∑‚ÇÅ'' + Œ∑‚ÇÇ'' = -1 := by
      exact?;
    linear_combination -h_sum;
  ¬∑ exact eq_add_of_sub_eq' ( by linear_combination' sum_eta'' );
  ¬∑ convert alpha_sq_eq'' using 1 ; ring!

/-
Check if f_poly'' is defined.
-/
#check f_poly''

/-
Check if the main declarations are present.
-/
#check f_poly''
#check Œ±''
#check alpha_root''
#check final_result_349

/-
Prove that alpha'' is a root of f''.
-/
theorem alpha_is_root_of_f : (f_poly'').eval Œ±'' = 0 := by
  -- Substitute Œ±'' into the polynomial f_poly'' and simplify using the known relation.
  convert alpha_root'' using 1

/-
Definitions for q=877, a=59, s1, s2, c, and the cyclotomic field L877.
-/
def q''' : ‚Ñï := 877
def a''' : ‚Ñï := 59
def s1''' : ZMod 877 := (- (a''' : ZMod 877) - 3) * (6 : ZMod 877)‚Åª¬π
def s2''' : ZMod 877 := ((a''' : ZMod 877) - 3) * (6 : ZMod 877)‚Åª¬π
def c''' (N : ‚Ñï) : ZMod 877 := (N : ZMod 877) ^ ((q''' - 1) / 3)

open Polynomial NumberField

def L877 : Type := CyclotomicField 877 ‚Ñö

instance : Field L877 := CyclotomicField.instField 877 ‚Ñö
instance : NumberField L877 := CyclotomicField.instNumberField 877 ‚Ñö
instance : IsCyclotomicExtension {877} ‚Ñö L877 := CyclotomicField.isCyclotomicExtension 877 ‚Ñö

def Œ∂877 : L877 := IsCyclotomicExtension.zeta 877 ‚Ñö L877

instance : Fact (Nat.Prime 877) := ‚ü®by norm_num‚ü©

/-
Define the sets of indices and the Gaussian periods for q=877. Define alpha, beta, gamma. Prove their sum is zero.
-/
def S_cubic_res''' : Finset (ZMod 877) := {x | x ‚â† 0 ‚àß x ^ ((877 - 1) / 3) = 1}
def S_s1''' : Finset (ZMod 877) := {x | x ‚â† 0 ‚àß x ^ ((877 - 1) / 3) = s1'''}
def S_s2''' : Finset (ZMod 877) := {x | x ‚â† 0 ‚àß x ^ ((877 - 1) / 3) = s2'''}

def Œ∑‚ÇÄ''' : L877 := ‚àë x ‚àà S_cubic_res''', Œ∂877 ^ (x.val : ‚Ñï)
def Œ∑‚ÇÅ''' : L877 := ‚àë x ‚àà S_s2''', Œ∂877 ^ (x.val : ‚Ñï)
def Œ∑‚ÇÇ''' : L877 := ‚àë x ‚àà S_s1''', Œ∂877 ^ (x.val : ‚Ñï)

def Œ±''' : L877 := -(Œ∑‚ÇÇ''' - Œ∑‚ÇÅ''')
def Œ≤''' : L877 := -(Œ∑‚ÇÄ''' - Œ∑‚ÇÇ''')
def Œ≥''' : L877 := -(Œ∑‚ÇÅ''' - Œ∑‚ÇÄ''')

theorem sum_zero''' : Œ±''' + Œ≤''' + Œ≥''' = 0 := by
  unfold Œ±''' Œ≤''' Œ≥''' ; ring;

/-
Definitions of index function, cyclotomic numbers, and period function for q=877.
-/
def ind''' (x : ZMod 877) : ZMod 3 :=
  if x ‚àà S_cubic_res''' then 0
  else if x ‚àà S_s1''' then 1
  else 2

def cyc_num''' (i j : ZMod 3) : ‚Ñï :=
  Fintype.card { x : ZMod 877 // x ‚â† 0 ‚àß x ‚â† 1 ‚àß ind''' x = i ‚àß ind''' (1 - x) = j }

def period''' (i : ZMod 3) : L877 :=
  if i = 0 then Œ∑‚ÇÄ'''
  else if i = 1 then Œ∑‚ÇÇ'''
  else Œ∑‚ÇÅ'''

/-
The period function maps 0, 1, 2 to eta0''', eta2''', eta1''' respectively.
-/
lemma period_eq_def''' : period''' 0 = Œ∑‚ÇÄ''' ‚àß period''' 1 = Œ∑‚ÇÇ''' ‚àß period''' 2 = Œ∑‚ÇÅ''' := by
  exact ‚ü® rfl, rfl, rfl ‚ü©

/-
The index function correctly identifies which coset an element belongs to.
-/
lemma ind_spec''' (x : ZMod 877) (hx : x ‚â† 0) :
  (ind''' x = 0 ‚Üî x ‚àà S_cubic_res''') ‚àß
  (ind''' x = 1 ‚Üî x ‚àà S_s1''') ‚àß
  (ind''' x = 2 ‚Üî x ‚àà S_s2''') := by
    native_decide +revert

/-
Define N_sol''' as the number of solutions to x + y = u with ind x = i and ind y = j.
-/
def N_sol''' (i j : ZMod 3) (u : ZMod 877) : ‚Ñï :=
  Fintype.card { p : ZMod 877 √ó ZMod 877 // p.1 ‚â† 0 ‚àß p.2 ‚â† 0 ‚àß ind''' p.1 = i ‚àß ind''' p.2 = j ‚àß p.1 + p.2 = u }

/-
The index of -1 is 0.
-/
lemma ind_neg_one''' : ind''' (-1) = 0 := by
  native_decide +revert

/-
Evaluate the cyclotomic numbers for q=877.
-/
#eval (cyc_num''' 0 0, cyc_num''' 0 1, cyc_num''' 0 2)
#eval (cyc_num''' 1 0, cyc_num''' 1 1, cyc_num''' 1 2)
#eval (cyc_num''' 2 0, cyc_num''' 2 1, cyc_num''' 2 2)

/-
Define C_coset''' and prove it equals the previously defined sets.
-/
def C_coset''' (i : ZMod 3) : Finset (ZMod 877) := Finset.univ.filter (fun x => x ‚â† 0 ‚àß ind''' x = i)

lemma C_coset_eq''' : C_coset''' 0 = S_cubic_res''' ‚àß C_coset''' 1 = S_s1''' ‚àß C_coset''' 2 = S_s2''' := by
  native_decide +revert

/-
The period function is the sum of zeta powers over the coset.
-/
lemma period_eq_sum_C_coset''' (i : ZMod 3) : period''' i = ‚àë x ‚àà C_coset''' i, Œ∂877 ^ (x.val : ‚Ñï) := by
  -- By definition of $C_coset'''$, we can rewrite the sum over $C_coset''' i$ as the sum over $S_cubic_res'''$, $S_s1'''$, or $S_s2'''$ depending on the value of $i$.
  have h_coset_eq : ‚àÄ i : ZMod 3, C_coset''' i = if i = 0 then S_cubic_res''' else if i = 1 then S_s1''' else S_s2''' := by
    exact fun i => by fin_cases i <;> [ exact C_coset_eq'''.1; exact C_coset_eq'''.2.1; exact C_coset_eq'''.2.2 ] ;
  -- By definition of $period'''$, we can split into cases based on the value of $i$.
  cases' i with i hi;
  interval_cases i <;> simp +decide [ h_coset_eq ];
  ¬∑ exact?;
  ¬∑ exact?;
  ¬∑ exact?

/-
Prove that s1''' and s2''' are roots of x^2 + x + 1 = 0.
-/
lemma s1_s2_roots''' : s1'''^2 + s1''' + 1 = 0 ‚àß s2'''^2 + s2''' + 1 = 0 := by
  native_decide +revert

/-
The index function is a homomorphism from the multiplicative group to the additive group Z/3Z.
-/
lemma ind_mul''' (x y : ZMod 877) (hx : x ‚â† 0) (hy : y ‚â† 0) : ind''' (x * y) = ind''' x + ind''' y := by
  revert x y;
  native_decide

/-
The index of the inverse is the negative of the index.
-/
lemma ind_inv''' (x : ZMod 877) (hx : x ‚â† 0) : ind''' (x‚Åª¬π) = - ind''' x := by
  native_decide +revert

/-
The cardinalities of the sets S_cubic_res''', S_s1''', and S_s2''' are all 292.
-/
lemma card_S''' : S_cubic_res'''.card = 292 ‚àß S_s1'''.card = 292 ‚àß S_s2'''.card = 292 := by
  native_decide +revert

/-
Values of the cyclotomic numbers for q=877.
-/
lemma cyc_num_vals''' :
  cyc_num''' 0 0 = 90 ‚àß cyc_num''' 0 1 = 100 ‚àß cyc_num''' 0 2 = 101 ‚àß
  cyc_num''' 1 0 = 100 ‚àß cyc_num''' 1 1 = 101 ‚àß cyc_num''' 1 2 = 91 ‚àß
  cyc_num''' 2 0 = 101 ‚àß cyc_num''' 2 1 = 91 ‚àß cyc_num''' 2 2 = 100 := by
    native_decide +revert

/-
Prove that the sum of the periods is -1.
-/
lemma sum_eta''' : Œ∑‚ÇÄ''' + Œ∑‚ÇÅ''' + Œ∑‚ÇÇ''' = -1 := by
  -- By ÔøΩ definitionÔøΩ of $Œ∑ ÔøΩ‚ÇÄÔøΩ'''$, $ ÔøΩŒ∑ÔøΩ‚ÇÅ'''$, and $Œ∑‚ÇÇ'''$, we know that their sum is equal to the sum of $Œ∂877^x$ over all $x \in \mathbb{Z}/877\mathbb{Z}$.
  have h_sum_all : Œ∑‚ÇÄ''' + Œ∑‚ÇÅ''' + Œ∑‚ÇÇ''' = ‚àë x ‚àà Finset.univ.filter (fun x : ZMod 877 => x ‚â† 0), Œ∂877 ^ (x.val : ‚Ñï) := by
    -- By definition of $C_coset'''$, we can rewrite the sum.
    have hC_coset''' : ‚àë x ‚àà Finset.univ.filter (fun x : ZMod 877 => x ‚â† 0), Œ∂877 ^ (x.val : ‚Ñï) = ‚àë x ‚àà S_cubic_res''', Œ∂877 ^ (x.val : ‚Ñï) + ‚àë x ‚àà S_s1''', Œ∂877 ^ (x.val : ‚Ñï) + ‚àë x ‚àà S_s2''', Œ∂877 ^ (x.val : ‚Ñï) := by
      rw [ ‚Üê Finset.sum_union, ‚Üê Finset.sum_union ];
      ¬∑ rw [ show S_cubic_res''' ‚à™ S_s1''' ‚à™ S_s2''' = Finset.univ.filter ( fun x : ZMod 877 => x ‚â† 0 ) from ?_ ];
        native_decide +revert;
      ¬∑ native_decide +revert;
      ¬∑ native_decide +revert;
    rw [ hC_coset''' ];
    exact?;
  -- Since 87 ÔøΩ7ÔøΩ is prime, the sum of all powers ofÔøΩ ÔøΩ8ÔøΩ77 from 0 to 876 is zero by the properties of the roots of unity.
  have h_sum_all : ‚àë i ‚àà Finset.range 877, Œ∂877 ^ i = 0 := by
    rw [ geom_sum_eq ] <;> norm_num;
    ¬∑ exact Or.inl ( sub_eq_zero_of_eq <| by exact ( IsCyclotomicExtension.zeta_pow _ _ _ ) );
    ¬∑ have h_zeta_ne_one : IsPrimitiveRoot Œ∂877 877 := by
        convert IsCyclotomicExtension.zeta_spec 877 ‚Ñö L877;
      exact h_zeta_ne_one.ne_one ( by decide );
  -- The sum of all powers ofŒ∂877 from 0 to 876 is zero, so the sum from 1 to 876 is -1.
  have h_sum_all : ‚àë x ‚àà Finset.univ.filter (fun x : ZMod 877 => x ‚â† 0), Œ∂877 ^ (x.val : ‚Ñï) = ‚àë x ‚àà Finset.range 877, Œ∂877 ^ x - 1 := by
    rw [ Finset.sum_eq_sum_diff_singleton_add ( Finset.mem_range.mpr ( Nat.succ_pos _ ) ) ] ; norm_num [ Finset.filter_ne' ] ; ring;
    rfl;
  aesop

/-
The index of -x is the same as the index of x.
-/
lemma ind_neg''' (x : ZMod 877) (hx : x ‚â† 0) : ind''' (-x) = ind''' x := by
  native_decide +revert

/-
Define the maps between the solution set and the cyclotomic number set.
-/
def sol_map (u : ZMod 877) (p : ZMod 877 √ó ZMod 877) : ZMod 877 := p.1 * u‚Åª¬π
def cyc_map (u : ZMod 877) (x : ZMod 877) : ZMod 877 √ó ZMod 877 := (x * u, (1 - x) * u)

/-
Define the solution set and the cyclotomic set as Finsets.
-/
def SolSet (i j : ZMod 3) (u : ZMod 877) : Finset (ZMod 877 √ó ZMod 877) := Finset.univ.filter (fun p => p.1 ‚â† 0 ‚àß p.2 ‚â† 0 ‚àß ind''' p.1 = i ‚àß ind''' p.2 = j ‚àß p.1 + p.2 = u)

def CycSet (i j : ZMod 3) (u : ZMod 877) : Finset (ZMod 877) := Finset.univ.filter (fun x => x ‚â† 0 ‚àß x ‚â† 1 ‚àß ind''' x = i - ind''' u ‚àß ind''' (1 - x) = j - ind''' u)

/-
Unfolded version of sol_map_mem to avoid linter issues.
-/
lemma sol_map_mem_unfolded (i j : ZMod 3) (u : ZMod 877) (hu : u ‚â† 0) (p : ZMod 877 √ó ZMod 877)
  (hp1 : p.1 ‚â† 0) (hp2 : p.2 ‚â† 0) (hind1 : ind''' p.1 = i) (hind2 : ind''' p.2 = j) (hsum : p.1 + p.2 = u) :
  let x := p.1 * u‚Åª¬π
  x ‚â† 0 ‚àß x ‚â† 1 ‚àß ind''' x = i - ind''' u ‚àß ind''' (1 - x) = j - ind''' u := by
    have h_ind_mul : ‚àÄ x y : ZMod 877, x ‚â† 0 ‚Üí y ‚â† 0 ‚Üí ind''' (x * y) = ind''' x + ind''' y := by
      exact?
    generalize_proofs at *;
    have h_ind_inv : ind''' u‚Åª¬π = -ind''' u := by
      exact?;
    have h_ind_sub : ind''' (1 - p.1 * u‚Åª¬π) = ind''' (p.2 * u‚Åª¬π) := by
      grind
    generalize_proofs at *;
    grind

/-
Helper lemma: sol_map is not zero if p.1 is not zero.
-/
lemma sol_map_ne_zero (u : ZMod 877) (hu : u ‚â† 0) (p : ZMod 877 √ó ZMod 877) (hp1 : p.1 ‚â† 0) :
  sol_map u p ‚â† 0 := by
    exact mul_ne_zero hp1 ( inv_ne_zero hu )

/-
Helper lemma: sol_map is not one if p.2 is not zero and p.1 + p.2 = u.
-/
lemma sol_map_ne_one (u : ZMod 877) (hu : u ‚â† 0) (p : ZMod 877 √ó ZMod 877) (hp2 : p.2 ‚â† 0) (hsum : p.1 + p.2 = u) :
  sol_map u p ‚â† 1 := by
    unfold sol_map;
    intro h; haveI := Fact.mk ( by norm_num : Nat.Prime 877 ) ; simp_all +decide [ ‚Üê eq_sub_iff_add_eq' ] ;
    rw [ mul_inv_eq_iff_eq_mul‚ÇÄ ] at h <;> simp_all +decide [ sub_eq_iff_eq_add ]

/-
Helper lemma: The index of sol_map u p is i - ind''' u.
-/
lemma sol_map_ind_eq (i : ZMod 3) (u : ZMod 877) (hu : u ‚â† 0) (p : ZMod 877 √ó ZMod 877) (hp1 : p.1 ‚â† 0) (hind1 : ind''' p.1 = i) :
  ind''' (sol_map u p) = i - ind''' u := by
    have h_index_mul : ind''' (p.1 * u‚Åª¬π) = ind''' p.1 - ind''' u := by
      have h_index_mul : ‚àÄ x y : ZMod 877, x ‚â† 0 ‚Üí y ‚â† 0 ‚Üí ind''' (x * y) = ind''' x + ind''' y := by
        exact?;
      have h_index_inv : ind''' (u‚Åª¬π) = -ind''' u := by
        native_decide +revert;
      rw [ h_index_mul _ _ hp1 ( inv_ne_zero hu ), h_index_inv, sub_eq_add_neg ];
    aesop

/-
Helper lemma: 1 - sol_map u p = p.2 * u‚Åª¬π.
-/
lemma sol_map_sub_eq (u : ZMod 877) (hu : u ‚â† 0) (p : ZMod 877 √ó ZMod 877) (hsum : p.1 + p.2 = u) :
  1 - sol_map u p = p.2 * u‚Åª¬π := by
    unfold sol_map; ring;
    grind

/-
Helper lemma: The index of 1 - sol_map u p is j - ind''' u.
-/
lemma sol_map_ind_one_sub_eq (j : ZMod 3) (u : ZMod 877) (hu : u ‚â† 0) (p : ZMod 877 √ó ZMod 877) (hp2 : p.2 ‚â† 0) (hind2 : ind''' p.2 = j) (hsum : p.1 + p.2 = u) :
  ind''' (1 - sol_map u p) = j - ind''' u := by
    rw [ sol_map_sub_eq u hu p hsum, ind_mul''' ] <;> simp_all +decide;
    rw [ ind_inv''' u hu ] ; ring

/-
Prove that sol_map is the left inverse of cyc_map.
-/
lemma sol_map_inv (u : ZMod 877) (hu : u ‚â† 0) (x : ZMod 877) : sol_map u (cyc_map u x) = x := by
  unfold sol_map cyc_map; aesop;

/-
Prove that cyc_map is the left inverse of sol_map for elements in the solution set.
-/
lemma cyc_map_inv (u : ZMod 877) (hu : u ‚â† 0) (p : ZMod 877 √ó ZMod 877) (hp : p.1 + p.2 = u) : cyc_map u (sol_map u p) = p := by
  -- By definition of sol_map and cyc_map, we have:
  simp [sol_map, cyc_map];
  rw [ sub_mul, one_mul, mul_assoc, inv_mul_cancel‚ÇÄ hu ] ; aesop

/-
Helper lemma: The first component of cyc_map u x is non-zero if x is non-zero.
-/
lemma cyc_map_ne_zero_left (u : ZMod 877) (hu : u ‚â† 0) (x : ZMod 877) (hx : x ‚â† 0) :
  (cyc_map u x).1 ‚â† 0 := by
    native_decide +revert

/-
Helper lemma: The second component of cyc_map u x is non-zero if x is not 1.
-/
lemma cyc_map_ne_zero_right (u : ZMod 877) (hu : u ‚â† 0) (x : ZMod 877) (hx : x ‚â† 1) :
  (cyc_map u x).2 ‚â† 0 := by
    native_decide +revert

/-
Helper lemma: The sum of the components of cyc_map u x is u.
-/
lemma cyc_map_sum (u : ZMod 877) (x : ZMod 877) :
  (cyc_map u x).1 + (cyc_map u x).2 = u := by
    unfold cyc_map; ring;

/-
Helper lemma: The index of the first component of cyc_map u x is ind''' x + ind''' u.
-/
lemma cyc_map_ind_left_eq (u : ZMod 877) (hu : u ‚â† 0) (x : ZMod 877) (hx : x ‚â† 0) :
  ind''' (cyc_map u x).1 = ind''' x + ind''' u := by
    -- Apply the lemma that states the index of a product is the sum of the indices.
    apply ind_mul''' x u hx hu

/-
Helper lemma: The index of the second component of cyc_map u x is ind''' (1 - x) + ind''' u.
-/
lemma cyc_map_ind_right_eq (u : ZMod 877) (hu : u ‚â† 0) (x : ZMod 877) (hx : x ‚â† 1) :
  ind''' (cyc_map u x).2 = ind''' (1 - x) + ind''' u := by
    by_cases h : 1 - x = 0 <;> simp_all +decide [ ind_mul''' ];
    ¬∑ grind;
    ¬∑ convert ind_mul''' ( 1 - x ) u h hu using 1

/-
sol_map is injective on the set of pairs summing to u.
-/
lemma sol_map_inj_on (u : ZMod 877) (hu : u ‚â† 0) (p1 p2 : ZMod 877 √ó ZMod 877)
  (hsum1 : p1.1 + p1.2 = u) (hsum2 : p2.1 + p2.2 = u) (h : sol_map u p1 = sol_map u p2) :
  p1 = p2 := by
  rw [‚Üê cyc_map_inv u hu p1 hsum1, ‚Üê cyc_map_inv u hu p2 hsum2, h]

/-
Define count_solutions and prove the expansion of the product of periods.
-/
def count_solutions (i j : ZMod 3) (u : ZMod 877) : ‚Ñï :=
  (Finset.univ.filter (fun p : ZMod 877 √ó ZMod 877 => p.1 ‚àà C_coset''' i ‚àß p.2 ‚àà C_coset''' j ‚àß p.1 + p.2 = u)).card

lemma period_mul_expansion (i j : ZMod 3) :
  period''' i * period''' j = ‚àë u : ZMod 877, (count_solutions i j u : L877) * Œ∂877 ^ (u.val : ‚Ñï) := by
    -- By definition of count_solutions, we can rewrite the sum as a double sum over x and y.
    have h_double_sum : ‚àë u, (count_solutions i j u : L877) * Œ∂877 ^ (u.val : ‚Ñï) = ‚àë x ‚àà C_coset''' i, ‚àë y ‚àà C_coset''' j, Œ∂877 ^ (x.val + y.val : ‚Ñï) := by
      -- By definition of count_solutions, we can rewrite the sum as a double sum over x and y, where x is in C_coset''' i and y is in C_coset''' j.
      have h_double_sum : ‚àë u, (count_solutions i j u : L877) * Œ∂877 ^ (u.val : ‚Ñï) = ‚àë x ‚àà C_coset''' i, ‚àë y ‚àà C_coset''' j, Œ∂877 ^ ((x + y).val : ‚Ñï) := by
        have h_count : ‚àÄ u, (count_solutions i j u : L877) = ‚àë x ‚àà C_coset''' i, ‚àë y ‚àà C_coset''' j, if x + y = u then 1 else 0 := by
          unfold count_solutions;
          intro u; rw [ show ( { p : ZMod 877 √ó ZMod 877 | p.1 ‚àà C_coset''' i ‚àß p.2 ‚àà C_coset''' j ‚àß p.1 + p.2 = u } : Finset ( ZMod 877 √ó ZMod 877 ) ) = Finset.filter ( fun p => p.1 + p.2 = u ) ( C_coset''' i √óÀ¢ C_coset''' j ) by ext; aesop ] ; rw [ Finset.card_filter ] ;
          rw [ Finset.sum_product ] ; norm_cast
        simp +decide only [h_count, Finset.sum_mul];
        rw [ Finset.sum_comm, Finset.sum_congr rfl ];
        intro x hx; rw [ Finset.sum_comm ] ; simp +decide [ Finset.sum_ite ] ;
      convert h_double_sum using 3;
      erw [ ZMod.val_add ];
      rw [ pow_eq_pow_mod ];
      exact IsCyclotomicExtension.zeta_pow _ _ _;
    rw [ h_double_sum, period_eq_sum_C_coset''' ];
    rw [ period_eq_sum_C_coset''' ] ; simp +decide [ pow_add, Finset.mul_sum _ _ _, Finset.sum_mul ] ;
    exact Finset.sum_comm.trans ( Finset.sum_congr rfl fun _ _ => Finset.sum_congr rfl fun _ _ => by ring )

/-
Unfolded version of cyc_map_mem to avoid linter issues. Proved using helper lemmas.
-/
lemma cyc_map_mem_unfolded (i j : ZMod 3) (u : ZMod 877) (hu : u ‚â† 0) (x : ZMod 877)
  (hx0 : x ‚â† 0) (hx1 : x ‚â† 1) (hind1 : ind''' x = i - ind''' u) (hind2 : ind''' (1 - x) = j - ind''' u) :
  let p := cyc_map u x
  p.1 ‚â† 0 ‚àß p.2 ‚â† 0 ‚àß ind''' p.1 = i ‚àß ind''' p.2 = j ‚àß p.1 + p.2 = u := by
  intro p
  refine ‚ü®?_, ?_, ?_, ?_, ?_‚ü©
  ¬∑ exact cyc_map_ne_zero_left u hu x hx0
  ¬∑ exact cyc_map_ne_zero_right u hu x hx1
  ¬∑ rw [cyc_map_ind_left_eq u hu x hx0, hind1, sub_add_cancel]
  ¬∑ rw [cyc_map_ind_right_eq u hu x hx1, hind2, sub_add_cancel]
  ¬∑ exact cyc_map_sum u x

/-
Prove that the cardinality of SolSet equals the cardinality of CycSet using the bijection sol_map and unfolded helper lemmas. Explicitly defining the function f to help the elaborator.
-/
lemma card_SolSet_eq_card_CycSet (i j : ZMod 3) (u : ZMod 877) (hu : u ‚â† 0) :
  (SolSet i j u).card = (CycSet i j u).card := by
    rw [ show SolSet i j u = Finset.image ( fun x => cyc_map u x ) ( CycSet i j u ) from ?_, Finset.card_image_of_injective _ fun x y hxy => ?_ ];
    ¬∑ unfold cyc_map at hxy; aesop;
    ¬∑ ext ‚ü®x, y‚ü©; simp [SolSet, CycSet];
      constructor;
      ¬∑ intro h
        use x * u‚Åª¬π;
        have := sol_map_mem_unfolded i j u hu ( x, y ) h.1 h.2.1 h.2.2.1 h.2.2.2.1 h.2.2.2.2; simp_all +decide [ cyc_map ] ;
        grind;
      ¬∑ rintro ‚ü® a, ‚ü® ha‚ÇÅ, ha‚ÇÇ, ha‚ÇÉ, ha‚ÇÑ ‚ü©, rfl, rfl ‚ü© ; exact ‚ü® by
          exact mul_ne_zero ha‚ÇÅ hu, by
          haveI := Fact.mk ( by decide : Nat.Prime 877 ) ; simp_all +decide [ sub_eq_iff_eq_add ] ;
          exact Ne.symm ha‚ÇÇ, by
          have := ind_mul''' a u ha‚ÇÅ hu; aesop;, by
          rw [ ind_mul''' ] <;> simp_all +decide [ sub_eq_iff_eq_add ];
          exact Ne.symm ha‚ÇÇ, by
          ring ‚ü©

/-
The number of solutions to x+y=u depends only on the index of u. Specifically, N_sol(i, j, u) = cyc_num(i - ind(u), j - ind(u)). Proved using card_SolSet_eq_card_CycSet.
-/
lemma N_sol_eq_cyc_num''' (i j : ZMod 3) (u : ZMod 877) (hu : u ‚â† 0) :
  N_sol''' i j u = cyc_num''' (i - ind''' u) (j - ind''' u) := by
    unfold cyc_num''' N_sol''';
    rw [ Fintype.card_subtype, Fintype.card_subtype ];
    convert card_SolSet_eq_card_CycSet i j u hu using 1

/-
Prove that the cardinality of SolSet equals the cardinality of CycSet using the bijection sol_map. Renamed to avoid name collision.
-/
lemma card_SolSet_eq_card_CycSet_proof (i j : ZMod 3) (u : ZMod 877) (hu : u ‚â† 0) :
  (SolSet i j u).card = (CycSet i j u).card := by
    convert card_SolSet_eq_card_CycSet i j u hu using 1

/-
Prove that count_solutions is equal to N_sol'''.
-/
lemma count_solutions_eq_N_sol (i j : ZMod 3) (u : ZMod 877) :
  count_solutions i j u = N_sol''' i j u := by
    unfold count_solutions N_sol''';
    rw [ Fintype.subtype_card ];
    congr with p;
    unfold C_coset''' ; aesop

/-
Prove that zeta raised to the sum of values is equal to zeta raised to the value of the sum.
-/
lemma zeta_pow_add_eq_zeta_pow_add_val (x y : ZMod 877) :
  Œ∂877 ^ (x.val + y.val) = Œ∂877 ^ ((x + y).val : ‚Ñï) := by
    -- By definition of exponentiation in the cyclotomic field, we have Œ∂877 ^ (x.val + y.val) = Œ∂877 ^ ((x + y).val).
    have h_exp_add : ‚àÄ (n m : ‚Ñï), Œ∂877 ^ (n + m) = Œ∂877 ^ ((n + m) % 877) := by
      -- Since Œ∂877 is a root of unity, we have Œ∂877^877 = 1.
      have h_root_of_unity : Œ∂877 ^ 877 = 1 := by
        convert IsPrimitiveRoot.pow_eq_one ( IsCyclotomicExtension.zeta_spec 877 ‚Ñö L877 );
      exact fun n m => by rw [ ‚Üê Nat.mod_add_div ( n + m ) 877, pow_add, pow_mul ] ; aesop;
    convert h_exp_add x.val y.val using 1

/-
Helper lemmas for membership in SolSet and CycSet to avoid unfolding issues.
-/
lemma mem_SolSet (i j : ZMod 3) (u : ZMod 877) (p : ZMod 877 √ó ZMod 877) :
  p ‚àà SolSet i j u ‚Üî p.1 ‚â† 0 ‚àß p.2 ‚â† 0 ‚àß ind''' p.1 = i ‚àß ind''' p.2 = j ‚àß p.1 + p.2 = u := by
  simp [SolSet]

lemma mem_CycSet (i j : ZMod 3) (u : ZMod 877) (x : ZMod 877) :
  x ‚àà CycSet i j u ‚Üî x ‚â† 0 ‚àß x ‚â† 1 ‚àß ind''' x = i - ind''' u ‚àß ind''' (1 - x) = j - ind''' u := by
  simp [CycSet]

/-
Prove that the number of solutions to x+y=0 is 292 if i=j and 0 otherwise.
-/
lemma count_solutions_zero (i j : ZMod 3) :
  count_solutions i j 0 = if i = j then 292 else 0 := by
    -- Let's simplify the expression for the number of solutions when $u = 0$.
    have h_solutions_zero : ‚àÄ i j : ZMod 3, count_solutions i j 0 = (Finset.filter (fun p => p.1 ‚â† 0 ‚àß p.2 ‚â† 0 ‚àß ind''' p.1 = i ‚àß ind''' p.2 = j ‚àß p.1 = -p.2) (Finset.univ : Finset (ZMod 877 √ó ZMod 877))).card := by
      unfold count_solutions;
      simp +contextual [ C_coset''', eq_neg_iff_add_eq_zero ];
      simp +contextual only [and_assoc, and_left_comm];
      exact fun _ _ => trivial;
    have h_index : ‚àÄ x : ZMod 877, x ‚â† 0 ‚Üí ind''' (-x) = ind''' x := by
      native_decide +revert;
    have h_card : ‚àÄ i : ZMod 3, (Finset.filter (fun x : ZMod 877 => x ‚â† 0 ‚àß ind''' x = i) (Finset.univ : Finset (ZMod 877))).card = 292 := by
      native_decide +revert;
    split_ifs <;> simp_all +contextual [ Finset.card_image_of_injective, Function.Injective ];
    ¬∑ rw [ ‚Üê h_card j, show ( Finset.filter ( fun p : ZMod 877 √ó ZMod 877 => ¬¨p.1 = 0 ‚àß ¬¨p.2 = 0 ‚àß ind''' p.1 = j ‚àß ind''' p.2 = j ‚àß p.1 = -p.2 ) Finset.univ ) = Finset.image ( fun x : ZMod 877 => ( x, -x ) ) ( Finset.filter ( fun x : ZMod 877 => ¬¨x = 0 ‚àß ind''' x = j ) Finset.univ ) from ?_ ];
      ¬∑ rw [ Finset.card_image_of_injective _ fun x y hxy => by injection hxy ];
      ¬∑ grind;
    ¬∑ grind

/-
Expansion of the product of Gaussian periods in terms of solution counts for q=877. Proved using `period_mul_expansion` and `count_solutions_zero`.
-/
lemma period_mul_eq_sum_N_sol''' (i j : ZMod 3) :
  period''' i * period''' j = (if i = j then 292 else 0) +
  ‚àë u ‚àà Finset.univ.filter (fun x : ZMod 877 => x ‚â† 0), (N_sol''' i j u : L877) * Œ∂877 ^ (u.val : ‚Ñï) := by
    have h_split : period''' i * period''' j = ‚àë u : ZMod 877, (count_solutions i j u : L877) * Œ∂877 ^ (u.val : ‚Ñï) := by
      convert period_mul_expansion i j using 1;
    rw [ h_split, Finset.sum_eq_add_sum_diff_singleton ( Finset.mem_univ 0 ) ];
    rw [ count_solutions_zero ];
    exact congrArg‚ÇÇ ( ¬∑ + ¬∑ ) ( by erw [ pow_zero ] ; norm_num ) ( Finset.sum_congr rfl fun x hx => by rw [ count_solutions_eq_N_sol ] )

/-
Multiplication rule for Gaussian periods for q=877. Proved using `period_mul_expansion`, `count_solutions_zero`, `count_solutions_eq_N_sol`, `N_sol_eq_cyc_num'''`, and grouping by index.
-/
lemma period_mul''' (i j : ZMod 3) :
  period''' i * period''' j = (if i = j then 292 else 0) +
  (cyc_num''' (i - 0) (j - 0) * period''' 0 +
   cyc_num''' (i - 1) (j - 1) * period''' 1 +
   cyc_num''' (i - 2) (j - 2) * period''' 2) := by
     convert period_mul_eq_sum_N_sol''' i j using 1;
     -- By definition of $N_sol'''$, we know that $N_sol''' i j u = cyc_num''' (i - ind''' u) (j - ind''' u)$ for all $u \neq 0$.
     have h_N_sol_eq_cyc_num : ‚àÄ u : ZMod 877, u ‚â† 0 ‚Üí N_sol''' i j u = cyc_num''' (i - ind''' u) (j - ind''' u) := by
       intro u hu
       apply N_sol_eq_cyc_num''' i j u hu;
     rw [ Finset.sum_congr rfl fun x hx => by rw [ h_N_sol_eq_cyc_num x ( Finset.mem_filter.mp hx |>.2 ) ] ];
     -- By definition of $C_coset'''$, we can split the sum into three parts based on the value of $ind''' x$.
     have h_split_sum : ‚àë x ‚àà Finset.univ.filter (fun x : ZMod 877 => x ‚â† 0), (cyc_num''' (i - ind''' x) (j - ind''' x) : L877) * Œ∂877 ^ (x.val : ‚Ñï) = ‚àë x ‚àà C_coset''' 0, (cyc_num''' (i - 0) (j - 0) : L877) * Œ∂877 ^ (x.val : ‚Ñï) + ‚àë x ‚àà C_coset''' 1, (cyc_num''' (i - 1) (j - 1) : L877) * Œ∂877 ^ (x.val : ‚Ñï) + ‚àë x ‚àà C_coset''' 2, (cyc_num''' (i - 2) (j - 2) : L877) * Œ∂877 ^ (x.val : ‚Ñï) := by
       rw [ show ( Finset.univ.filter fun x : ZMod 877 => x ‚â† 0 ) = C_coset''' 0 ‚à™ C_coset''' 1 ‚à™ C_coset''' 2 from ?_, Finset.sum_union, Finset.sum_union ];
       ¬∑ refine' congrArg‚ÇÇ _ ( congrArg‚ÇÇ _ ( Finset.sum_congr rfl fun x hx => _ ) ( Finset.sum_congr rfl fun x hx => _ ) ) ( Finset.sum_congr rfl fun x hx => _ );
         ¬∑ rw [ show ind''' x = 0 from _ ];
           exact Finset.mem_filter.mp hx |>.2.2;
         ¬∑ rw [ show ind''' x = 1 from by rw [ C_coset''' ] at hx; exact Finset.mem_filter.mp hx |>.2.2 ];
         ¬∑ rw [ show ind''' x = 2 from by { exact Finset.mem_filter.mp hx |>.2.2 } ];
       ¬∑ native_decide +revert;
       ¬∑ native_decide +revert;
       ¬∑ native_decide +revert;
     rw [ h_split_sum, period_eq_sum_C_coset''' 0, period_eq_sum_C_coset''' 1, period_eq_sum_C_coset''' 2 ];
     rw [ Finset.mul_sum _ _ _, Finset.mul_sum _ _ _, Finset.mul_sum _ _ _ ]

/-
Check if period_mul''' is already declared.
-/
#check period_mul'''

/-
Define the integer version of zeta for q=877.
-/
def Œ∂877_int : ùìû L877 := IsPrimitiveRoot.toInteger (IsCyclotomicExtension.zeta_spec 877 ‚Ñö L877)

/-
Define integer versions of periods and roots for q=877 and prove coercion properties.
-/
def period_int''' (i : ZMod 3) : ùìû L877 := ‚àë x ‚àà C_coset''' i, Œ∂877_int ^ (x.val : ‚Ñï)

def Œ±'''_int : ùìû L877 := -(period_int''' 1 - period_int''' 2)
def Œ≤'''_int : ùìû L877 := -(period_int''' 0 - period_int''' 1)
def Œ≥'''_int : ùìû L877 := -(period_int''' 2 - period_int''' 0)

lemma coe_period_int''' (i : ZMod 3) : (period_int''' i : L877) = period''' i := by
  -- By definition of coercion, we can show that the coercion of each term in the sum is equal to the corresponding term in the field.
  have h_coe_term : ‚àÄ x ‚àà C_coset''' i, (Œ∂877_int ^ (x.val : ‚Ñï) : L877) = Œ∂877 ^ (x.val : ‚Ñï) := by
    -- By definition of Œ∂877_int, we know that its coercion to L877 is Œ∂877.
    have h_coe_zeta : (Œ∂877_int : L877) = Œ∂877 := by
      rfl;
    exact fun x hx => by rw [ h_coe_zeta ] ;
  convert Finset.sum_congr rfl h_coe_term using 1;
  ¬∑ convert map_sum _ _ _;
    infer_instance;
  ¬∑ exact?

lemma coe_alpha'''_int : (Œ±'''_int : L877) = Œ±''' := by
  -- By definition of Œ±'''_int, we have Œ±'''_int = -(period_int''' 1 - period_int''' 2).
  simp [Œ±'''_int];
  -- By definition of $period_int'''$, we know that $(algebraMap (ùìû L877) L877) (period_int''' i) = period''' i$.
  have h_period_int''' : ‚àÄ i : ZMod 3, (algebraMap (ùìû L877) L877) (period_int''' i) = period''' i := by
    exact?;
  -- By definition of Œ±''', we have Œ±''' = -(Œ∑‚ÇÇ''' - Œ∑‚ÇÅ''').
  simp [Œ±''', h_period_int'''];
  unfold period''' ; simp +decide [ sub_eq_neg_add ]

lemma coe_beta'''_int : (Œ≤'''_int : L877) = Œ≤''' := by
  unfold Œ≤'''_int Œ≤'''; norm_num;
  -- The period_int is defined as the sum of zeta powers over the coset, and the algebra map preserves this sum.
  have h_period_int_eq_period : ‚àÄ i : ZMod 3, (period_int''' i : L877) = period''' i := by
    exact?;
  exact congr_arg‚ÇÇ _ ( h_period_int_eq_period _ ) ( h_period_int_eq_period _ )

lemma coe_gamma'''_int : (Œ≥'''_int : L877) = Œ≥''' := by
  unfold Œ≥'''_int Œ≥''';
  -- By definition of coercion, we know that the coercion of a finite sum is the sum of the coercions.
  have h_coercion : ‚àÄ (s : Finset (ZMod 877)), (Finset.sum s (fun x => Œ∂877_int ^ (x.val : ‚Ñï)) : L877) = Finset.sum s (fun x => Œ∂877 ^ (x.val : ‚Ñï)) := by
    intro s
    induction' s using Finset.induction with x s ih;
    ¬∑ norm_num;
    ¬∑ rw [ Finset.sum_insert ih, Finset.sum_insert ih ] ; aesop;
  simp +decide [ period_int''', h_coercion ];
  rw [ show C_coset''' 0 = S_cubic_res''' from C_coset_eq'''.left, show C_coset''' 2 = S_s2''' from C_coset_eq'''.right.right ];
  rfl

/-
Define the Galois unit and automorphism for q=877, and lift it to the ring of integers.
-/
def gal_unit877 (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 877) : (ZMod 877)À£ := Units.mk0 (N : ZMod 877) (by
  rw [Ne, ZMod.natCast_zmod_eq_zero_iff_dvd]
  intro h
  have hN_prime : Nat.Prime N := Fact.out
  have : 877 = 1 ‚à® 877 = N := (Nat.dvd_prime hN_prime).mp h
  have : 877 = N := this.resolve_left (by norm_num)
  exact hN this.symm)

def sigma877 (u : (ZMod 877)À£) : L877 ‚âÉ‚Çê[‚Ñö] L877 :=
  (IsCyclotomicExtension.autEquivPow L877 (Polynomial.cyclotomic.irreducible_rat (n := 877) (by norm_num))).symm u

def sigma_int877 (u : (ZMod 877)À£) (x : ùìû L877) : ùìû L877 := ‚ü®sigma877 u x, by
  have h_integral : IsIntegral ‚Ñ§ (x : L877) := x.2
  exact IsIntegral.map (sigma877 u) h_integral‚ü©

/-
Relate the index of N to the value of c''' N being s1'''.
-/
lemma ind_N_eq_1_iff_c_eq_s1''' (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 877) :
  ind''' (N : ZMod 877) = 1 ‚Üî c''' N = s1''' := by
    have h_nz : ( N : ZMod 877 ) ‚â† 0 := by
      exact?;
    rw [ ind_spec''' _ h_nz |>.2.1 ];
    unfold S_s1''' c''';
    aesop

/-
Abbreviations for the ring of integers, residue field, and reduction map for q=877.
-/
abbrev ùìûL877 := ùìû L877
def kP877 (P : Ideal ùìûL877) [P.IsMaximal] := ùìûL877 ‚ß∏ P
noncomputable instance (P : Ideal ùìûL877) [P.IsMaximal] : Field (kP877 P) := Ideal.Quotient.field P
def red877 (P : Ideal ùìûL877) [P.IsMaximal] : ùìûL877 ‚Üí+* kP877 P := Ideal.Quotient.mk P

/-
Prove the summation identity relating N_sol and cyc_num/period.
-/
lemma sum_N_sol_eq_sum_cyc_num_period (i j : ZMod 3) :
  ‚àë u ‚àà Finset.univ.filter (fun x : ZMod 877 => x ‚â† 0), (N_sol''' i j u : L877) * Œ∂877 ^ (u.val : ‚Ñï) =
  (cyc_num''' (i - 0) (j - 0) * period''' 0 +
   cyc_num''' (i - 1) (j - 1) * period''' 1 +
   cyc_num''' (i - 2) (j - 2) * period''' 2) := by
     -- Apply the lemma `period_mul'''` to rewrite the product of periods.
     have h_period_mul : period''' i * period''' j = (if i = j then 292 else 0) + ‚àë u ‚àà Finset.univ.filter (fun x : ZMod 877 => x ‚â† 0), (N_sol''' i j u : L877) * Œ∂877 ^ (u.val : ‚Ñï) := by
       convert period_mul_eq_sum_N_sol''' i j using 1;
     convert congr_arg ( fun x : L877 => x - ( if i = j then 292 else 0 ) ) h_period_mul using 1;
     ¬∑ rw [ h_period_mul, add_sub_cancel_left ];
     ¬∑ convert congr_arg ( fun x : L877 => x - ( if i = j then 292 else 0 ) ) ( period_mul''' i j ) using 1 ; ring;
       ¬∑ rw [ period_mul''' ] ; ring;
       ¬∑ convert congr_arg ( fun x : L877 => x - ( if i = j then 292 else 0 ) ) ( period_mul''' i j ) using 1 ; ring;
         grind

/-
Check if period_mul''' is defined.
-/
#check period_mul'''

/-
Multiplication table for the Gaussian periods. Using `period_mul'''` and `cyc_num_vals'''`. Note: `period''' 1 = Œ∑‚ÇÇ'''` and `period''' 2 = Œ∑‚ÇÅ'''`.
-/
lemma eta_mul_table''' :
  Œ∑‚ÇÄ'''^2 = 292 + 90*Œ∑‚ÇÄ''' + 101*Œ∑‚ÇÅ''' + 100*Œ∑‚ÇÇ''' ‚àß
  Œ∑‚ÇÅ'''^2 = 292 + 100*Œ∑‚ÇÄ''' + 90*Œ∑‚ÇÅ''' + 101*Œ∑‚ÇÇ''' ‚àß
  Œ∑‚ÇÇ'''^2 = 292 + 101*Œ∑‚ÇÄ''' + 100*Œ∑‚ÇÅ''' + 90*Œ∑‚ÇÇ''' ‚àß
  Œ∑‚ÇÄ'''*Œ∑‚ÇÅ''' = 101*Œ∑‚ÇÄ''' + 100*Œ∑‚ÇÅ''' + 91*Œ∑‚ÇÇ''' ‚àß
  Œ∑‚ÇÄ'''*Œ∑‚ÇÇ''' = 100*Œ∑‚ÇÄ''' + 91*Œ∑‚ÇÅ''' + 101*Œ∑‚ÇÇ''' ‚àß
  Œ∑‚ÇÅ'''*Œ∑‚ÇÇ''' = 91*Œ∑‚ÇÄ''' + 101*Œ∑‚ÇÅ''' + 100*Œ∑‚ÇÇ''' := by
    have h_mul_table : ‚àÄ i j : ZMod 3, period''' i * period''' j = (if i = j then 292 else 0) + (cyc_num''' (i - 0) (j - 0) * period''' 0 + cyc_num''' (i - 1) (j - 1) * period''' 1 + cyc_num''' (i - 2) (j - 2) * period''' 2) := by
      exact?;
    rw [ show cyc_num''' = fun i j => if i = 0 ‚àß j = 0 then 90 else if i = 0 ‚àß j = 1 then 100 else if i = 0 ‚àß j = 2 then 101 else if i = 1 ‚àß j = 0 then 100 else if i = 1 ‚àß j = 1 then 101 else if i = 1 ‚àß j = 2 then 91 else if i = 2 ‚àß j = 0 then 101 else if i = 2 ‚àß j = 1 then 91 else 100 from by
          native_decide +revert ; ] at h_mul_table;
    have := h_mul_table 0 0; have := h_mul_table 0 1; have := h_mul_table 0 2; have := h_mul_table 1 0; have := h_mul_table 1 1; have := h_mul_table 1 2; have := h_mul_table 2 0; have := h_mul_table 2 1; have := h_mul_table 2 2; simp +decide [ period_eq_def''' ] at *;
    exact ‚ü® by linear_combination' ‚ÄπŒ∑‚ÇÄ''' * Œ∑‚ÇÄ''' = 292 + ( 90 * Œ∑‚ÇÄ''' + 100 * Œ∑‚ÇÇ''' + 101 * Œ∑‚ÇÅ''') ‚Ä∫, by linear_combination' ‚ÄπŒ∑‚ÇÅ''' * Œ∑‚ÇÅ''' = 292 + ( 100 * Œ∑‚ÇÄ''' + 101 * Œ∑‚ÇÇ''' + 90 * Œ∑‚ÇÅ''') ‚Ä∫, by linear_combination' ‚ÄπŒ∑‚ÇÇ''' * Œ∑‚ÇÇ''' = 292 + ( 101 * Œ∑‚ÇÄ''' + 90 * Œ∑‚ÇÇ''' + 100 * Œ∑‚ÇÅ''') ‚Ä∫, by linear_combination' ‚ÄπŒ∑‚ÇÄ''' * Œ∑‚ÇÅ''' = 101 * Œ∑‚ÇÄ''' + 91 * Œ∑‚ÇÇ''' + 100 * Œ∑‚ÇÅ''' ‚Ä∫, by linear_combination' ‚ÄπŒ∑‚ÇÄ''' * Œ∑‚ÇÇ''' = 100 * Œ∑‚ÇÄ''' + 101 * Œ∑‚ÇÇ''' + 91 * Œ∑‚ÇÅ''' ‚Ä∫, by linear_combination' ‚ÄπŒ∑‚ÇÅ''' * Œ∑‚ÇÇ''' = 91 * Œ∑‚ÇÄ''' + 100 * Œ∑‚ÇÇ''' + 101 * Œ∑‚ÇÅ''' ‚Ä∫ ‚ü©

/-
Prove the formula for eta0 squared.
-/
lemma eta0_sq''' : Œ∑‚ÇÄ'''^2 = 292 + 90*Œ∑‚ÇÄ''' + 101*Œ∑‚ÇÅ''' + 100*Œ∑‚ÇÇ''' := by
  -- Apply the multiplication table lemma to get the result.
  have := eta_mul_table''' ; aesop

/-
Check if eta_mul_table''' is defined.
-/
#check eta_mul_table'''

/-
The cyclic relations hold for the integer versions Œ±'''_int, Œ≤'''_int, Œ≥'''_int. Corrected relation for q=877, a=59. 59 * Œ≤'''_int = -3 * Œ±'''_int^2 - 34 * Œ±'''_int + 1754.
-/
lemma cyclic_relations_int''' : 59 * Œ≤'''_int = -3 * Œ±'''_int^2 - 34 * Œ±'''_int + 1754 ‚àß 59 * Œ≥'''_int = 3 * Œ±'''_int^2 - 25 * Œ±'''_int - 1754 := by
  have h_beta : 59 * Œ≤'''_int = -3 * Œ±'''_int^2 - 34 * Œ±'''_int + 1754 := by
    have h_beta : 59 * Œ≤''' = -3 * Œ±'''^2 - 34 * Œ±''' + 1754 := by
      unfold Œ≤''' Œ±''';
      have h_sub : Œ∑‚ÇÄ''' + Œ∑‚ÇÅ''' + Œ∑‚ÇÇ''' = -1 := by
        exact?
      have h_sub' : Œ∑‚ÇÄ''' * Œ∑‚ÇÅ''' = 101 * Œ∑‚ÇÄ''' + 100 * Œ∑‚ÇÅ''' + 91 * Œ∑‚ÇÇ''' := by
        exact eta_mul_table''' |>.2.2.2.1 |> Eq.trans <| by ring;
      have h_sub'' : Œ∑‚ÇÄ''' * Œ∑‚ÇÇ''' = 100 * Œ∑‚ÇÄ''' + 91 * Œ∑‚ÇÅ''' + 101 * Œ∑‚ÇÇ''' := by
        convert eta_mul_table''' |>.2.2.2.2.1 using 1
      have h_sub''' : Œ∑‚ÇÅ''' * Œ∑‚ÇÇ''' = 91 * Œ∑‚ÇÄ''' + 101 * Œ∑‚ÇÅ''' + 100 * Œ∑‚ÇÇ''' := by
        exact eta_mul_table''' |>.2.2.2.2.2 ‚ñ∏ rfl;
      have h_sub'''' : Œ∑‚ÇÄ'''^2 = 292 + 90 * Œ∑‚ÇÄ''' + 101 * Œ∑‚ÇÅ''' + 100 * Œ∑‚ÇÇ''' := by
        convert eta0_sq''' using 1
      have h_sub''''' : Œ∑‚ÇÅ'''^2 = 292 + 100 * Œ∑‚ÇÄ''' + 90 * Œ∑‚ÇÅ''' + 101 * Œ∑‚ÇÇ''' := by
        grind
      have h_sub'''''' : Œ∑‚ÇÇ'''^2 = 292 + 101 * Œ∑‚ÇÄ''' + 100 * Œ∑‚ÇÅ''' + 90 * Œ∑‚ÇÇ''' := by
        convert eta_mul_table''' |>.2.2.1 using 1
        skip
      skip
      generalize_proofs at *; (
      grind +ring);
    -- Since the coercion from the ring of integers to the field L877 is injective, we can conclude that the integer versions satisfy the same equation.
    have h_inj : Function.Injective (algebraMap (ùìû L877) L877) := by
      exact Subtype.coe_injective;
    exact h_inj <| by simpa [ coe_alpha'''_int, coe_beta'''_int ] using h_beta;
  have h_gamma : 59 * Œ≥'''_int = 3 * Œ±'''_int^2 - 25 * Œ±'''_int - 1754 := by
    have h_eq : Œ±'''_int + Œ≤'''_int + Œ≥'''_int = 0 := by
      -- By definition of Œ±'''_int, Œ≤'''_int, and Œ≥'''_int, we have Œ±'''_int + Œ≤'''_int + Œ≥'''_int = -(Œ∑‚ÇÇ''' - Œ∑‚ÇÅ''') + -(Œ∑‚ÇÄ''' - Œ∑‚ÇÇ''') + -(Œ∑‚ÇÅ''' - Œ∑‚ÇÄ''').
      simp [Œ±'''_int, Œ≤'''_int, Œ≥'''_int]
    grind;
  exact ‚ü® h_beta, h_gamma ‚ü©

/-
The Frobenius automorphism permutes the Gaussian periods by shifting their index by ind(N).
-/
lemma sigma_period''' (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 877) (i : ZMod 3) :
  sigma877 (gal_unit877 N hN) (period''' i) = period''' (i + ind''' (N : ZMod 877)) := by
    -- By definition of $C_coset'''$, we know that $C_coset''' i$ is the image of $C_coset''' (i + \text{ind}(N))$ under the map $x \mapsto xN$.
    have h_coset_image : C_coset''' i = Finset.image (fun x => x * (N : ZMod 877)‚Åª¬π) (C_coset''' (i + ind''' (N : ZMod 877))) := by
      ext x;
      constructor <;> intro hx <;> simp_all +decide [ C_coset''' ];
      ¬∑ use x * (N : ZMod 877);
        by_cases hN : ( N : ZMod 877 ) = 0 <;> simp_all +decide [ ZMod.natCast_eq_zero_iff ];
        ¬∑ rw [ Nat.dvd_prime Fact.out ] at hN ; aesop;
        ¬∑ convert ind_mul''' x N hx.1 ( show ( N : ZMod 877 ) ‚â† 0 from by rw [ Ne.eq_def, ZMod.natCast_eq_zero_iff ] ; aesop ) using 1 ; aesop;
      ¬∑ -- Since $a \neq 0$ and $N \neq 0$, their product $a * (N)^{-1}$ is also non-zero.
        obtain ‚ü®a, ha‚ÇÅ, ha‚ÇÇ‚ü© := hx;
        have hx_ne_zero : x ‚â† 0 := by
          have hx_ne_zero : (N : ZMod 877) ‚â† 0 := by
            rw [ Ne.eq_def, ZMod.natCast_eq_zero_iff ] ; exact fun h => hN <| by have := Nat.prime_dvd_prime_iff_eq ( show Nat.Prime 877 by norm_num ) ( Fact.out : Nat.Prime N ) ; aesop;
          grind;
        have hx_ind : ind''' (a * (N : ZMod 877)‚Åª¬π) = ind''' a - ind''' (N : ZMod 877) := by
          have hx_ind : ind''' (a * (N : ZMod 877)‚Åª¬π) = ind''' a + ind''' ((N : ZMod 877)‚Åª¬π) := by
            apply ind_mul''';
            ¬∑ exact ha‚ÇÅ.1;
            ¬∑ intro h; simp_all +decide [ ZMod.natCast_eq_zero_iff ] ;
          rw [ hx_ind, ind_inv''' ] ; ring;
          grind;
        grind;
    -- Apply the automorphism $\sigma_N$ to each term in the sum defining $\eta_i$.
    have h_sigma_apply : ‚àÄ x ‚àà C_coset''' i, sigma877 (gal_unit877 N hN) (Œ∂877 ^ (x.val : ‚Ñï)) = Œ∂877 ^ ((x * (N : ZMod 877)).val : ‚Ñï) := by
      intro x hx
      have h_sigma_apply_term : sigma877 (gal_unit877 N hN) (Œ∂877 ^ (x.val : ‚Ñï)) = (IsCyclotomicExtension.zeta 877 ‚Ñö L877) ^ (x.val * N : ‚Ñï) := by
        have h_sigma_apply_term : sigma877 (gal_unit877 N hN) (IsCyclotomicExtension.zeta 877 ‚Ñö L877) = (IsCyclotomicExtension.zeta 877 ‚Ñö L877) ^ N := by
          unfold sigma877;
          simp +decide [ gal_unit877 ];
          erw [ PowerBasis.equivOfMinpoly_gen ];
          simp +decide [ IsPrimitiveRoot.powerBasis ];
          rw [ ‚Üê Nat.mod_add_div N 877, pow_add, pow_mul ] ; norm_num [ IsCyclotomicExtension.zeta_spec ];
          have := IsCyclotomicExtension.zeta_pow 877 ‚Ñö L877; aesop;
        simp +decide [ pow_mul', h_sigma_apply_term ];
        exact?;
      -- Since $x$ is an element of $ZMod 877$, multiplying it by $N$ and then taking the value is the same as multiplying the value of $x$ by $N$.
      have h_val_mul : (x * (N : ZMod 877)).val = x.val * N % 877 := by
        simp +decide [ ZMod.val_mul ];
      rw [ h_sigma_apply_term, h_val_mul, ‚Üê Nat.mod_add_div ( x.val * N ) 877 ] ; norm_num [ pow_add, pow_mul ] ;
      have h_zeta_pow : IsCyclotomicExtension.zeta 877 ‚Ñö L877 ^ 877 = 1 := by
        exact IsPrimitiveRoot.pow_eq_one ( IsCyclotomicExtension.zeta_spec 877 ‚Ñö L877 );
      aesop;
    -- By combining the results from h_coset_image and h_sigma_apply, we can conclude the proof.
    have h_final : ‚àë x ‚àà C_coset''' i, sigma877 (gal_unit877 N hN) (Œ∂877 ^ (x.val : ‚Ñï)) = ‚àë x ‚àà C_coset''' (i + ind''' (N : ZMod 877)), Œ∂877 ^ (x.val : ‚Ñï) := by
      rw [ h_coset_image, Finset.sum_image ];
      ¬∑ refine' Finset.sum_congr rfl fun x hx => _;
        by_cases hN : ( N : ZMod 877 ) = 0 <;> simp_all +decide [ mul_assoc ];
        rw [ ZMod.natCast_eq_zero_iff ] at hN ; exact absurd ( Nat.dvd_of_mod_eq_zero ( show N % 877 = 0 from Nat.mod_eq_zero_of_dvd <| by simpa [ ‚Üê Int.natCast_dvd_natCast ] using hN ) ) ( by rw [ Nat.dvd_prime Fact.out ] ; aesop );
      ¬∑ intro x hx y hy; simp_all +decide [ mul_comm ] ;
        rintro ( rfl | h ) <;> simp_all +decide [ ZMod.natCast_eq_zero_iff ];
        exact absurd ( Nat.prime_dvd_prime_iff_eq ( Fact.out : Nat.Prime 877 ) ( Fact.out : Nat.Prime N ) |>.1 h ) ( by aesop );
    convert h_final using 1;
    ¬∑ rw [ period_eq_sum_C_coset''' ];
      rw [ map_sum ];
    ¬∑ convert period_eq_sum_C_coset''' ( i + ind''' ( N : ZMod 877 ) ) using 1

/-
Relate the index of N to the value of c''' N being s2'''.
-/
lemma ind_N_eq_2_iff_c_eq_s2''' (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 877) :
  ind''' (N : ZMod 877) = 2 ‚Üî c''' N = s2''' := by
    have h_def : (ind''' (N : (ZMod 877))) = 2 ‚Üî (N : (ZMod 877)) ^ ((877 - 1) / 3) = s2''' := by
      have h_nonzero : (N : (ZMod 877)) ‚â† 0 := by
        exact?
      rw [ ind_spec''' _ h_nonzero |>.2.2 ];
      unfold S_s2''' ; aesop;
    exact h_def.trans ( by unfold c''' ; rfl )

/-
If c''' N = s1''', then sigma_N(alpha''') = gamma'''.
-/
lemma sigma_alpha_eq_gamma_if_s1''' (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 877) (h : c''' N = s1''') :
  sigma_int877 (gal_unit877 N hN) Œ±'''_int = Œ≥'''_int := by
    -- By definition of $c'''$, we know that $c''' N = s1'''$ implies $ind''' (N : ZMod 877) = 1$.
    have h_ind : ind''' (N : ZMod 877) = 1 := by
      apply (ind_N_eq_1_iff_c_eq_s1''' N hN).mpr h;
    -- By the properties of the shifting automorphism and the definition of Œ±'''_int and Œ≥'''_int, we have:
    have h_shift : sigma877 (gal_unit877 N hN) (Œ±''' : L877) = (Œ≥''' : L877) := by
      unfold Œ±''' Œ≥''';
      have := sigma_period''' N hN 0; have := sigma_period''' N hN 1; have := sigma_period''' N hN 2; simp_all +decide [ sub_eq_iff_eq_add ] ;
      erw [ show period''' 0 = Œ∑‚ÇÄ''' from rfl, show period''' 1 = Œ∑‚ÇÇ''' from rfl, show period''' 2 = Œ∑‚ÇÅ''' from rfl ] at * ; ring_nf at * ; aesop ( simp_config := { decide := true } ) ;
    convert h_shift using 1;
    -- Since the automorphism is linear and the coefficients are integers, the integer version of the automorphism applied to the integer version of the root is the same as the automorphism applied to the field version of the root.
    have h_linear : ‚àÄ (x : ùìû L877), (sigma877 (gal_unit877 N hN) x : L877) = sigma_int877 (gal_unit877 N hN) x := by
      exact?;
    rw [ ‚Üê coe_alpha'''_int, ‚Üê coe_gamma'''_int, h_linear ] ; norm_cast

/-
If c''' N = s2''', then sigma_N(alpha''') = beta'''.
-/
lemma sigma_alpha_eq_beta_if_s2''' (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 877) (h : c''' N = s2''') :
  sigma_int877 (gal_unit877 N hN) Œ±'''_int = Œ≤'''_int := by
    -- From Lemma 3, we know that $\sigma_N(\alpha''' = \beta'''$ if $c''' N = s2'''$.
    have h_sigma_alpha_beta : sigma877 (gal_unit877 N hN) Œ±''' = Œ≤''' := by
      -- Since $c''' N = s2'''$, we have $\text{ind}'''(N) = 2$.
      have h_ind : ind''' (N : ZMod 877) = 2 := by
        exact?;
      unfold Œ±''' Œ≤''';
      have := sigma_period''' N hN 1; have := sigma_period''' N hN 2; simp_all +decide [ sub_eq_iff_eq_add ] ;
      unfold period''' at *; simp_all +decide [ sub_eq_iff_eq_add ] ;
    convert h_sigma_alpha_beta using 1;
    rw [ ‚Üê coe_alpha'''_int, ‚Üê coe_beta'''_int, ‚Üê Subtype.coe_inj ];
    unfold sigma_int877; aesop;

/-
sigma_int877 maps zeta to zeta^N.
-/
lemma sigma_int877_zeta {N : ‚Ñï} [Fact (Nat.Prime N)] (hN : N ‚â† 877) :
  sigma_int877 (gal_unit877 N hN) Œ∂877_int = Œ∂877_int ^ N := by
    unfold sigma_int877;
    unfold sigma877 gal_unit877
    generalize_proofs at *;
    erw [ Subtype.mk_eq_mk ];
    erw [ IsCyclotomicExtension.autEquivPow_symm_apply ];
    erw [ PowerBasis.equivOfMinpoly_gen ];
    simp +decide [ IsPrimitiveRoot.powerBasis ];
    erw [ ‚Üê Nat.mod_add_div N 877 ] ; norm_num [ pow_add, pow_mul ];
    erw [ ( IsCyclotomicExtension.zeta_spec 877 ‚Ñö L877 ).pow_eq_one ] ; aesop

/-
The ring of integers is generated by zeta877.
-/
lemma adjoin_zeta_eq_top877 : Algebra.adjoin ‚Ñ§ ({Œ∂877_int} : Set ùìûL877) = ‚ä§ := by
  rw [ eq_top_iff ];
  have h_adjoin : IsCyclotomicExtension {877} ‚Ñ§ (ùìû L877) := by
    have h_cyclotomic : IsCyclotomicExtension {877} ‚Ñö L877 := by
      exact?
    generalize_proofs at *;
    exact?
  generalize_proofs at *;
  intro x
  generalize_proofs at *;
  have h_gen : ‚àÄ x : ùìû L877, x ‚àà Algebra.adjoin ‚Ñ§ {Œ∂877_int} := by
    intro x
    have h_gen : x ‚àà Algebra.adjoin ‚Ñ§ (Set.range (fun n : ‚Ñï => Œ∂877_int ^ n)) := by
      have h_gen : ‚àÄ x : ùìû L877, x ‚àà Algebra.adjoin ‚Ñ§ (Set.range (fun n : ‚Ñï => Œ∂877_int ^ n)) := by
        intro x
        have h_gen : x ‚àà Algebra.adjoin ‚Ñ§ (Set.range (fun n : ‚Ñï => Œ∂877_int ^ n)) := by
          have h_gen : IsCyclotomicExtension {877} ‚Ñ§ (ùìû L877) := h_adjoin
          have := h_gen.adjoin_primitive_root_eq_top ( show IsPrimitiveRoot Œ∂877_int 877 from ?_ );
          ¬∑ rw [ Algebra.eq_top_iff ] at this;
            exact Algebra.adjoin_mono ( Set.singleton_subset_iff.mpr <| Set.mem_range.mpr ‚ü® 1, by norm_num ‚ü© ) ( this x );
          ¬∑ convert IsCyclotomicExtension.zeta_spec 877 ‚Ñö L877 using 1
            skip
            generalize_proofs at *; (
            ext; simp [Œ∂877_int];
            exact ‚ü® fun h => ‚ü® Subtype.ext_iff.mp h.1, fun l hl => h.2 l <| Subtype.ext hl ‚ü©, fun h => ‚ü® Subtype.ext h.1, fun l hl => h.2 l <| Subtype.ext_iff.mp hl ‚ü© ‚ü©
            skip)
        exact h_gen
      generalize_proofs at *; (
      exact h_gen x)
    refine' Algebra.adjoin_le _ h_gen
    generalize_proofs at *; (
    exact Set.range_subset_iff.mpr fun n => Subalgebra.pow_mem _ ( Algebra.subset_adjoin <| Set.mem_singleton _ ) _)
  generalize_proofs at *; (
  grind)

/-
The automorphism sigma_N reduces to the Frobenius map modulo P for q=877.
-/
theorem artin_property877 {N : ‚Ñï} [Fact (Nat.Prime N)] (hN : N ‚â† 877) (P : Ideal ùìûL877) [P.IsMaximal] [CharP (kP877 P) N] (x : ùìûL877) :
  red877 P (sigma_int877 (gal_unit877 N hN) x) = (red877 P x) ^ N := by
    -- Since $x$ is in the adjoin of $\zeta_{877}$, we can write it as a polynomial in $\zeta_{877}$ with integer coefficients.
    obtain ‚ü®P, hP‚ü© : ‚àÉ P : Polynomial ‚Ñ§, x = Polynomial.aeval (R := ‚Ñ§) Œ∂877_int P := by
      have h_poly : x ‚àà Algebra.adjoin ‚Ñ§ ({Œ∂877_int} : Set ùìûL877) := by
        have h_poly : Algebra.adjoin ‚Ñ§ ({Œ∂877_int} : Set ùìûL877) = ‚ä§ := by
          exact?;
        aesop;
      rw [ Algebra.adjoin_singleton_eq_range_aeval ] at h_poly ; aesop;
    -- Apply the Frobenius map to each term in the polynomial.
    have h_frobenius : ‚àÄ (i : ‚Ñï) (c : ‚Ñ§), (red877 ‚Äπ_‚Ä∫) (sigma_int877 (gal_unit877 N hN) (c ‚Ä¢ Œ∂877_int ^ i)) = (red877 ‚Äπ_‚Ä∫) (c ‚Ä¢ Œ∂877_int ^ i) ^ N := by
      intro i c
      have h_frobenius_term : (red877 ‚Äπ_‚Ä∫) (sigma_int877 (gal_unit877 N hN) (Œ∂877_int ^ i)) = (red877 ‚Äπ_‚Ä∫) (Œ∂877_int ^ i) ^ N := by
        have h_frobenius : (red877 ‚Äπ_‚Ä∫) (sigma_int877 (gal_unit877 N hN) Œ∂877_int) = (red877 ‚Äπ_‚Ä∫) Œ∂877_int ^ N := by
          rw [ sigma_int877_zeta ];
          exact map_pow _ _ _;
        convert congr_arg ( ¬∑ ^ i ) h_frobenius using 1 <;> norm_num [ pow_right_comm ];
        unfold sigma_int877; aesop;
      convert congr_arg ( fun x : kP877 _ => c ‚Ä¢ x ) h_frobenius_term using 1;
      ¬∑ unfold sigma_int877; aesop;
      ¬∑ induction' c using Int.induction_on with c ih c ih <;> simp_all +decide [ pow_succ, mul_assoc, mul_left_comm, mul_add, add_mul, sub_mul, mul_sub ];
        ¬∑ exact Nat.Prime.ne_zero Fact.out;
        ¬∑ rw [ add_pow_char ] ; aesop;
        ¬∑ rw [ ‚Üê ih, sub_eq_add_neg, add_pow_char ] ; ring ; norm_num [ mul_pow, pow_add, pow_mul ];
          by_cases h : Even N <;> simp_all +decide [ Nat.Prime.even_iff Fact.out ] ; ring;
          ¬∑ grind;
          ¬∑ rw [ neg_one_pow_eq_pow_mod_two ] ; norm_num [ Nat.Prime.eq_two_or_odd ( Fact.out : Nat.Prime N ) |> Or.resolve_left <| h ] ; ring;
    -- Apply the Frobenius map to each term in the polynomial P.
    have h_frobenius_poly : ‚àÄ (P : Polynomial ‚Ñ§), (red877 ‚Äπ_‚Ä∫) (sigma_int877 (gal_unit877 N hN) (Polynomial.aeval (R := ‚Ñ§) Œ∂877_int P)) = (red877 ‚Äπ_‚Ä∫) (Polynomial.aeval (R := ‚Ñ§) Œ∂877_int P) ^ N := by
      intro P
      induction' P using Polynomial.induction_on' with P Q hP hQop;
      ¬∑ convert congr_arg‚ÇÇ ( ¬∑ + ¬∑ ) hP hQop using 1;
        ¬∑ unfold sigma_int877; aesop;
        ¬∑ simp +decide [ ‚Üê hP, ‚Üê hQop ];
          rw [ hP, hQop, add_pow_char ];
      ¬∑ simpa [ Algebra.smul_def ] using h_frobenius _ _;
    rw [ hP, h_frobenius_poly ]

/-
The automorphism sigma_N reduces to the Frobenius map modulo P for q=877.
-/
theorem artin_property877_proof {N : ‚Ñï} [Fact (Nat.Prime N)] (hN : N ‚â† 877) (P : Ideal ùìûL877) [P.IsMaximal] [CharP (kP877 P) N] (x : ùìûL877) :
  red877 P (sigma_int877 (gal_unit877 N hN) x) = (red877 P x) ^ N := by
    have h_frobenius : ‚àÄ x : ùìûL877, (red877 P) (sigma_int877 (gal_unit877 N hN) x) = (red877 P x) ^ N := by
      convert artin_property877 hN P using 1;
    exact h_frobenius x

/-
Final result for q=877: Frobenius action on alpha''' depends on c''' N.
-/
theorem final_result_877 {N : ‚Ñï} [Fact (Nat.Prime N)] (hN : N ‚â† 877) (P : Ideal ùìûL877) [P.IsMaximal] [CharP (kP877 P) N] :
  (c''' N = s1''' ‚Üí (red877 P Œ±'''_int) ^ N = red877 P Œ≥'''_int) ‚àß
  (c''' N = s2''' ‚Üí (red877 P Œ±'''_int) ^ N = red877 P Œ≤'''_int) := by
    have h_frobenius : ‚àÄ x : ùìû L877, (red877 P) (sigma_int877 (gal_unit877 N hN) x) = (red877 P x) ^ N := by
      exact?;
    constructor <;> intro h <;> rw [ ‚Üê h_frobenius ];
    ¬∑ rw [ sigma_alpha_eq_gamma_if_s1''' N hN h ];
    ¬∑ rw [ sigma_alpha_eq_beta_if_s2''' N hN h ]