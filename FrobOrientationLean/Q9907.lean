/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: b9de3357-2987-44f4-99cd-467dafec09fb

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Formalization of the Dream Theorem for q = 9907.
Includes definitions of the cyclotomic field K = Q(zeta_9907), the ring of integers Ok,
and the cubic periods alpha, beta, gamma.
Proves the Artin property for the extension K/Q.
Proves the Dream Theorem (final_result_9907) relating the cubic character of N
to the Frobenius action on alpha, under the assumption of the period equation.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 8011b3b0-5b9d-44a9-a431-7da2e7415d10

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We have successfully proved the Dream Theorem for the prime $q = 1567$.
The proof follows the structure of prior proofs for $q = 877, 937, 1063, 1129$.
We defined the field $K = \mathbb{Q}(\zeta_{1567})$, the ring of integers $\mathcal{O}_K$, and the Gaussian periods $\eta_0, \eta_1, \eta_2$.
We defined the period differences $\alpha, \beta, \gamma$ with the appropriate sign convention.
We established the algebraic relations between $\alpha, \beta, \gamma$ using the period equation and computation.
We proved the Artin property for the extension $K/\mathbb{Q}$.
We characterized the cosets $C_1, C_2$ using the cubic character $\chi$.
Finally, we proved `final_result_1567`, which states that for a prime $N \neq 1567$, the Frobenius action on $\alpha$ is determined by the value of the cubic character $\chi(N)$.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: ff94a4ce-df04-43b6-855b-2c35922c8831

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We define the cyclotomic field $K = \mathbb{Q}(\zeta_{1129})$, the ring of integers $\mathcal{O}_K$, and the Gaussian periods $\eta_0, \eta_1, \eta_2$. We define the period differences $\alpha, \beta, \gamma$ with the correct sign convention. We prove the Artin property for $\mathcal{O}_K$ and use it to prove the Dream Theorem for $q = 1129$, which relates the Frobenius action on $\alpha$ to the cubic character $c(N)$. The proof assumes the period equation for $\alpha$ as requested.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 49ab742d-7e60-49a0-9635-aa76ebf271b7

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Proof of the Dream Theorem for q = 1063.

We define the cyclotomic field K = Q(zeta_1063), the ring of integers Ok, and the Gaussian periods.
We identify a generator g = 6 such that the cubic character c(g) = s2 = 719.
We define the roots alpha, beta, gamma using this generator and the standard sign convention.
We prove the Artin property for the extension.
We prove the global permutation of roots under the Galois group.
Finally, we prove the Dream Theorem:
If c(N) = s1, then alpha^N = gamma mod P.
If c(N) = s2, then alpha^N = beta mod P.
This relies on the period equation alpha^3 = 1063*alpha + 1063, which is added as a hypothesis.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f1e85200-2efb-4b56-a019-1c5b75f4b05f

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Proof of the Dream Theorem for q = 937.

We define the cyclotomic field K = Q(zeta_937), its ring of integers Ok, and the Gaussian periods.
We identify a generator g = 7 for which the cubic character values match the s1/s2 definitions.
We prove the Artin property for the extension K/Q.
We prove the main theorem `dream_theorem_937` which states that for a prime N != 937:
- If c(N) = s1, then alpha^N = gamma mod P.
- If c(N) = s2, then alpha^N = beta mod P.
This assumes the period equation `alpha^3 = 937*alpha + 937`.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: b08f138a-15ed-40a2-a0c0-b8f4ce6443e1

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We define the cyclotomic field K for q = 877 and the Gaussian periods. We prove the Dream Theorem for q = 877, which states that the Frobenius automorphism maps the period difference α to β or γ depending on the cubic character of the prime N modulo 877. The proof relies on the Artin property of the Frobenius map and the explicit calculation of the Galois action on the periods.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f1f9f2e4-1b7a-4d8c-ad24-d62d489ea7c9

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: a7add749-96ca-48e2-a89d-fbb216918bc3

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 22a1ac83-9054-4f97-9a50-f0ea72bded01

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: e6ee589a-f550-42ef-89e5-1fd2afd7fa5e

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We defined the constants s1, s2, and the value c(N). We proved lemmas characterizing the cosets C1 and C2 in terms of the 12th power residue symbol (which relates to c(N)). Finally, we proved the main theorem `final_result` which establishes the Frobenius action on alpha (i.e., alpha^N) in terms of beta and gamma, depending on the value of c(N). The proof utilizes the `explicit_frobenius` theorem and the algebraic relations between alpha, beta, and gamma.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 939f55fb-68a7-4ef0-bca3-475f675055ca

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
This module formalizes the proof of the Frobenius Orientation conjecture for q=37.
It defines the cyclotomic field K = Q(zeta_37), the Gaussian periods, and the cubic roots.
It proves the cyclic algebraic relations between these roots and establishes the global Galois action.
It descends to the residue field modulo a prime P lying over N != 37, proving the Artin property.
Finally, it derives the explicit Frobenius action on the reduction of alpha modulo P.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section











/-
Definitions for q=9907, s1, s2, and the cubic character c.
-/
def q9907 : ℕ := 9907

instance fact_prime_9907 : Fact (Nat.Prime 9907) := ⟨by native_decide⟩

def s1_9907 : ZMod 9907 := 6571
def s2_9907 : ZMod 9907 := 3335
def c9907 (N : ℕ) : ZMod 9907 := (N : ZMod 9907)^3302

/-
Find a generator g for ZMod 9907 such that c(g) = s2.
-/
def find_g_9907 : IO Unit := do
  let q := 9907
  let s2 := 3335
  let c (n : Nat) := (n : Nat) ^ 3302 % q
  let order := q - 1
  -- 9906 = 2 * 4953 = 2 * 3 * 1651. 1651 = 13 * 127. So factors are 2, 3, 13, 127.
  let factors := [2, 3, 13, 127]
  
  for g in [2:100] do
    let mut is_prim := true
    for f in factors do
      if (g ^ (order / f)) % q == 1 then
        is_prim := false
        break
    
    if is_prim then
      if c g == s2 then
        IO.println s!"Found good generator: {g}"
        return
  
  IO.println "No generator found in range"

#eval find_g_9907

/-
Definitions of the cyclotomic field K9907, zeta element, cubic residue sets H, C1, C2, and Gaussian periods eta0, eta1, eta2.
-/
abbrev K9907 := CyclotomicField 9907 ℚ

noncomputable def zeta9907 : K9907 := IsCyclotomicExtension.zeta 9907 ℚ K9907

def g9907 : ZMod 9907 := 2

def H9907 : Finset (ZMod 9907) := ((Finset.univ : Finset (ZMod 9907)).filter (fun x => x ≠ 0)).image (fun x => x^3)

def C1_9907 : Finset (ZMod 9907) := H9907.image (fun x => g9907 * x)

def C2_9907 : Finset (ZMod 9907) := H9907.image (fun x => g9907^2 * x)

open scoped BigOperators

noncomputable def eta9907 (S : Finset (ZMod 9907)) : K9907 := ∑ x ∈ S, zeta9907^(x.val)

noncomputable def eta0_9907 := eta9907 H9907
noncomputable def eta1_9907 := eta9907 C1_9907
noncomputable def eta2_9907 := eta9907 C2_9907

/-
Definitions of alpha', beta', gamma' in K.
-/
noncomputable def alpha_prime_9907 := eta0_9907 - eta1_9907
noncomputable def beta_prime_9907 := eta1_9907 - eta2_9907
noncomputable def gamma_prime_9907 := eta2_9907 - eta0_9907

/-
Ring of integers Ok9907 and irreducibility of cyclotomic polynomial.
-/
abbrev Ok9907 := NumberField.RingOfIntegers K9907

theorem h_irr_9907 : Irreducible (Polynomial.cyclotomic 9907 ℚ) := by
  exact Polynomial.cyclotomic.irreducible_rat <| by norm_num;

/-
Automorphism sigma for K9907.
-/
noncomputable def sigma9907 (n : (ZMod 9907)ˣ) : K9907 ≃ₐ[ℚ] K9907 :=
  (IsCyclotomicExtension.autEquivPow K9907 h_irr_9907).symm n

/-
Zeta is integral, and the element in the ring of integers.
-/
theorem zeta_isIntegral_9907 : IsIntegral ℤ zeta9907 := by
  refine' ⟨ Polynomial.X ^ 9907 - 1, _, _ ⟩ <;> norm_num;
  · exact Polynomial.monic_X_pow_sub_C _ ( by norm_num );
  · exact sub_eq_zero_of_eq ( IsCyclotomicExtension.zeta_pow _ _ _ )

def zeta_int9907 : Ok9907 := ⟨zeta9907, zeta_isIntegral_9907⟩

/-
Integer versions of sigma, eta, and the differences alpha', beta', gamma'.
-/
noncomputable def sigma_int9907 (n : (ZMod 9907)ˣ) : Ok9907 ≃ₐ[ℤ] Ok9907 :=
  (NumberField.RingOfIntegers.mapAlgEquiv (sigma9907 n)).restrictScalars ℤ

noncomputable def eta_int9907 (S : Finset (ZMod 9907)) : Ok9907 := ∑ x ∈ S, zeta_int9907^(x.val)

noncomputable def eta0_int9907 := eta_int9907 H9907
noncomputable def eta1_int9907 := eta_int9907 C1_9907
noncomputable def eta2_int9907 := eta_int9907 C2_9907

noncomputable def alpha_prime_int9907 := eta0_int9907 - eta1_int9907
noncomputable def beta_prime_int9907 := eta1_int9907 - eta2_int9907
noncomputable def gamma_prime_int9907 := eta2_int9907 - eta0_int9907

/-
Sign convention and final definitions of alpha, beta, gamma.
-/
open Classical

noncomputable def sign_9907 : ℤ :=
  if alpha_prime_int9907 * beta_prime_int9907 * gamma_prime_int9907 = (9907 : Ok9907) then 1 else -1

noncomputable def alpha_int9907 := (sign_9907 : Ok9907) * alpha_prime_int9907
noncomputable def beta_int9907 := (sign_9907 : Ok9907) * beta_prime_int9907
noncomputable def gamma_int9907 := (sign_9907 : Ok9907) * gamma_prime_int9907

noncomputable def alpha9907_field : K9907 := alpha_int9907
noncomputable def beta9907_field : K9907 := beta_int9907
noncomputable def gamma9907_field : K9907 := gamma_int9907

/-
Dream assumptions and N_mod helper.
-/
def DreamAssumptions_9907 : Prop :=
  alpha_int9907^3 = 9907 * alpha_int9907 + 9907 ∧
  alpha_int9907 * beta_int9907 * gamma_int9907 = 9907 ∧
  199 * beta_int9907 = 3 * alpha_int9907^2 - 104 * alpha_int9907 - 19814 ∧
  199 * gamma_int9907 = -3 * alpha_int9907^2 + 95 * alpha_int9907 + 19814

def N_mod_9907 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 9907) : (ZMod 9907)ˣ :=
  ZMod.unitOfCoprime N (Nat.Coprime.symm ((Nat.coprime_primes (by norm_num) (Fact.out)).mpr hN.symm))

/-
Sigma action on zeta.
-/
lemma sigma_int_zeta_pow_9907 (n : (ZMod 9907)ˣ) :
  sigma_int9907 n zeta_int9907 = zeta_int9907 ^ (n : ZMod 9907).val := by
    have h_sigma_def : ∀ n : (ZMod 9907)ˣ, sigma9907 n zeta9907 = zeta9907^(n.val.val) := by
      intro n
      unfold sigma9907
      simp [mul_comm, mul_assoc, pow_mul];
      erw [ PowerBasis.equivOfMinpoly_apply ];
      erw [ PowerBasis.lift_gen ];
      exact?;
    aesop

/-
Artin property for zeta: sigma_N(zeta) = zeta^N mod P.
-/
theorem artin_property_zeta_9907 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 9907) (P : Ideal Ok9907) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  Ideal.Quotient.mk P (sigma_int9907 (N_mod_9907 N hN) zeta_int9907) = (Ideal.Quotient.mk P zeta_int9907)^N := by
    -- By definition of the Artin map, we have that $\sigma_N(\zeta_{9907}) = \zeta_{9907}^N$ modulo $P$.
    have h_artin : ((Ideal.Quotient.mk P) (zeta_int9907)) ^ N = ((Ideal.Quotient.mk P) (zeta_int9907 ^ (N_mod_9907 N hN).val.val)) := by
      have h_artin : zeta_int9907 ^ (9907 : ℕ) = 1 := by
        have h_order : zeta9907 ^ 9907 = 1 := by
          exact IsCyclotomicExtension.zeta_pow _ _ _;
        exact Subtype.ext h_order;
      have h_artin : (Ideal.Quotient.mk P zeta_int9907) ^ (9907 : ℕ) = 1 := by
        simpa using congr_arg ( Ideal.Quotient.mk P ) h_artin;
      have h_artin : (Ideal.Quotient.mk P zeta_int9907) ^ N = (Ideal.Quotient.mk P zeta_int9907) ^ (N % 9907) := by
        rw [ ← Nat.mod_add_div N 9907, pow_add, pow_mul ] ; aesop;
      convert h_artin using 1;
    rw [ h_artin, sigma_int_zeta_pow_9907 ]

/-
Zeta is a primitive 9907-th root of unity.
-/
theorem zeta_isPrimitiveRoot_9907 : IsPrimitiveRoot zeta9907 9907 := by
  -- By definition of `IsCyclotomicExtension.zeta`, we know that `zeta9907` is a primitive 9907-th root of unity.
  apply IsCyclotomicExtension.zeta_spec

/-
The ring of integers Ok9907 is generated by zeta_int9907 over ℤ.
-/
theorem Ok9907_eq_adjoin : (⊤ : Subalgebra ℤ Ok9907) = Algebra.adjoin ℤ {zeta_int9907} := by
  have h_gen : ∀ x : K9907, IsIntegral ℤ x → x ∈ Algebra.adjoin ℤ {zeta9907} := by
    have := @IsCyclotomicExtension.Rat.isIntegralClosure_adjoin_singleton_of_prime 9907;
    have := @this K9907 ( by infer_instance ) zeta9907 ( by infer_instance ) ( by infer_instance ) ( by infer_instance ) ( zeta_isPrimitiveRoot_9907 );
    cases this ; aesop;
  ext x;
  constructor <;> intro hx <;> specialize h_gen x.1 x.2 <;> simp_all +decide [ Algebra.adjoin_singleton_eq_range_aeval ];
  obtain ⟨ p, hp ⟩ := h_gen;
  refine' ⟨ p, _ ⟩;
  erw [ Polynomial.aeval_eq_sum_range ] at * ; aesop

/-
The ring of integers Ok9907 is generated by zeta_int9907 over ℤ.
-/
theorem Ok9907_eq_adjoin_new : (⊤ : Subalgebra ℤ Ok9907) = Algebra.adjoin ℤ {zeta_int9907} := by
  exact?

/-
The Artin property holds for all elements of the ring of integers.
-/
theorem artin_property_9907 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 9907) (P : Ideal Ok9907) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) (x : Ok9907) :
  Ideal.Quotient.mk P (sigma_int9907 (N_mod_9907 N hN) x) = (Ideal.Quotient.mk P x)^N := by
    have h_int : ∀ x : Ok9907, (Ideal.Quotient.mk P) (sigma_int9907 (N_mod_9907 N hN) x) = (Ideal.Quotient.mk P x)^N := by
      intros x;
      have h_sigma_zeta : (Ideal.Quotient.mk P) ((sigma_int9907 (N_mod_9907 N hN)) zeta_int9907) = (Ideal.Quotient.mk P zeta_int9907)^N := by
        convert artin_property_zeta_9907 N hN P hP using 1;
      have h_sigma_poly : ∀ p : Polynomial ℤ, (Ideal.Quotient.mk P) ((sigma_int9907 (N_mod_9907 N hN)) (p.eval₂ (algebraMap ℤ Ok9907) zeta_int9907)) = (Ideal.Quotient.mk P (p.eval₂ (algebraMap ℤ Ok9907) zeta_int9907))^N := by
        intro p;
        induction' p using Polynomial.induction_on' with p q hp hq;
        · have h_char : ∀ x y : Ok9907 ⧸ P, (x + y) ^ N = x ^ N + y ^ N := by
            intro x y
            have h_char : (N : Ok9907 ⧸ P) = 0 := by
              erw [ Ideal.Quotient.eq_zero_iff_mem ];
              have := hP.1;
              exact Ideal.mem_comap.mp ( this ▸ Ideal.mem_span_singleton_self _ )
            have h_char : ∀ x y : Ok9907 ⧸ P, (x + y) ^ N = x ^ N + y ^ N := by
              intro x y
              have h_char : (x + y) ^ N = ∑ i ∈ Finset.range (N + 1), Nat.choose N i * x ^ i * y ^ (N - i) := by
                simp +decide [ add_pow, mul_assoc, mul_comm, mul_left_comm ]
              rw [ h_char, Finset.sum_range_succ ];
              rw [ Finset.sum_eq_single 0 ] <;> simp_all +decide [ Nat.choose_eq_zero_of_lt ];
              · ring;
              · intro b hb hb'; left; norm_cast;
                exact Or.inl <| by rw [ show ( N.choose b : Ok9907 ⧸ P ) = ( N.choose b : ℤ ) by norm_cast ] ; exact by rw [ show ( N.choose b : ℤ ) = N * ( N.choose b / N ) by rw [ Int.mul_ediv_cancel' <| mod_cast Nat.dvd_of_mod_eq_zero <| by rw [ Nat.mod_eq_zero_of_dvd ] ; exact Nat.Prime.dvd_choose_self ( Fact.out : Nat.Prime N ) ( by aesop ) ( by aesop ) ] ] ; aesop;
              · exact Nat.Prime.ne_zero Fact.out;
            exact h_char x y;
          simp_all +decide [ RingHom.map_add, RingHom.map_pow ];
        · simp_all +decide [ Polynomial.eval₂_monomial ];
          erw [ Ideal.Quotient.eq ];
          have h_char : (↑‹ℤ› : Ok9907) ^ N - ↑‹ℤ› ∈ P := by
            have h_char : (↑‹ℤ› : ℤ) ^ N ≡ ↑‹ℤ› [ZMOD N] := by
              haveI := Fact.mk ( Fact.out : Nat.Prime N ) ; simp +decide [ ← ZMod.intCast_eq_intCast_iff ] ;
            obtain ⟨ k, hk ⟩ := h_char.symm.dvd;
            convert P.mul_mem_right ( k : Ok9907 ) ( hP.1 ▸ Ideal.mem_span_singleton_self ( N : ℤ ) ) using 1 ; norm_cast ; aesop;
          convert P.mul_mem_left ( zeta_int9907 ^ ( N * ‹_› ) ) ( P.neg_mem h_char ) using 1 ; ring;
      have h_sigma_poly : ∀ x : Ok9907, ∃ p : Polynomial ℤ, x = p.eval₂ (algebraMap ℤ Ok9907) zeta_int9907 := by
        intro x
        have h_gen : x ∈ Algebra.adjoin ℤ {zeta_int9907} := by
          have h_gen : (⊤ : Subalgebra ℤ Ok9907) = Algebra.adjoin ℤ {zeta_int9907} := by
            exact?;
          exact h_gen ▸ Algebra.mem_top;
        rw [ Algebra.adjoin_singleton_eq_range_aeval ] at h_gen; aesop;
      obtain ⟨ p, rfl ⟩ := h_sigma_poly x; aesop;
    exact h_int x

/-
Definition of the cubic character chi and its multiplicativity.
-/
def chi9907 (x : ZMod 9907) : ZMod 9907 := x ^ 3302

lemma chi9907_mul (x y : ZMod 9907) : chi9907 (x * y) = chi9907 x * chi9907 y := by
  -- By definition of exponentiation in modular arithmetic, we have $(x * y)^{9907 / 3} \equiv x^{9907 / 3} * y^{9907 / 3} \pmod{9907}$.
  have h_exp : (x * y) ^ 3302 = x ^ 3302 * y ^ 3302 := by
    rw [ mul_pow ];
  unfold chi9907; norm_num [ h_exp ] ;

/-
Check values of chi on the generator.
-/
def check_chi_values_9907 : IO Unit := do
  let q := 9907
  let s1 := 6571
  let s2 := 3335
  let g := 2
  let chi (n : Nat) := (n : Nat) ^ 3302 % q
  let chig := chi g
  IO.println s!"chi(g) = {chig}"
  if chig == s1 then IO.println "chi(g) = s1"
  else if chig == s2 then IO.println "chi(g) = s2"
  else IO.println "chi(g) is neither"

#eval check_chi_values_9907

/-
Action of sigma on eta sums.
-/
lemma sigma_eta_9907 (n : (ZMod 9907)ˣ) (S : Finset (ZMod 9907)) :
  sigma_int9907 n (eta_int9907 S) = eta_int9907 (S.image (fun x => (n : ZMod 9907) * x)) := by
    unfold eta_int9907; simp +zetaDelta at *;
    rw [ Finset.sum_congr rfl ];
    intro x hx
    have h_sigma_zeta : sigma_int9907 n zeta_int9907 = zeta_int9907 ^ (n : ZMod 9907).val := by
      exact?;
    rw [ h_sigma_zeta, ← pow_mul, ZMod.val_mul ];
    have h_exp : zeta_int9907 ^ 9907 = 1 := by
      have h_exp : zeta9907 ^ 9907 = 1 := by
        exact IsPrimitiveRoot.pow_eq_one ( zeta_isPrimitiveRoot_9907 );
      exact Subtype.ext h_exp;
    rw [ ← Nat.mod_add_div ( ( n : ZMod 9907 ).val * x.val ) 9907, pow_add, pow_mul ] ; aesop

/-
Action of H on the sets H, C1, C2. Multiplication by an element of H stabilizes each set.
-/
lemma action_H_9907 (n : ZMod 9907) (hn : n ∈ H9907) :
  H9907.image (fun x => n * x) = H9907 ∧
  C1_9907.image (fun x => n * x) = C1_9907 ∧
  C2_9907.image (fun x => n * x) = C2_9907 := by
    have h_stable : ∀ h ∈ H9907, h ∈ H9907 ∧ h * n ∈ H9907 := by
      intros h hh;
      obtain ⟨ k, hk, rfl ⟩ := Finset.mem_image.mp hh;
      obtain ⟨ m, hm, rfl ⟩ := Finset.mem_image.mp hn;
      exact ⟨ hh, Finset.mem_image.mpr ⟨ k * m, Finset.mem_filter.mpr ⟨ Finset.mem_univ _, by aesop ⟩, by ring ⟩ ⟩;
    have h_stable_C1 : ∀ x ∈ C1_9907, n * x ∈ C1_9907 := by
      simp +contextual [ C1_9907, mul_assoc ];
      exact fun a ha => ⟨ a * n, by simpa only [ mul_comm, mul_left_comm ] using h_stable a ha |>.2, by ring ⟩;
    have h_stable_C2 : ∀ x ∈ C2_9907, n * x ∈ C2_9907 := by
      simp +contextual [ C2_9907, Finset.mem_image ];
      grind;
    refine' ⟨ Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr fun x hx => by simpa only [ mul_comm ] using h_stable x hx |>.2 ) _, Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr fun x hx => h_stable_C1 x hx ) _, Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr fun x hx => h_stable_C2 x hx ) _ ⟩;
    · rw [ Finset.card_image_of_injective _ fun x y hxy => mul_left_cancel₀ ( show n ≠ 0 from by rintro rfl; exact absurd hn ( by native_decide ) ) hxy ];
    · rw [ Finset.card_image_of_injective _ fun x y hxy => mul_left_cancel₀ ( show n ≠ 0 from by rintro rfl; exact absurd hn ( by native_decide ) ) hxy ];
    · rw [ Finset.card_image_of_injective _ fun x y hxy => mul_left_cancel₀ ( show n ≠ 0 from by rintro rfl; exact absurd hn ( by native_decide ) ) hxy ]

/-
Action of C1 on the sets H, C1, C2. Multiplication by an element of C1 permutes them cyclically (H -> C1 -> C2 -> H).
-/
lemma action_C1_9907 (n : ZMod 9907) (hn : n ∈ C1_9907) :
  H9907.image (fun x => n * x) = C1_9907 ∧
  C1_9907.image (fun x => n * x) = C2_9907 ∧
  C2_9907.image (fun x => n * x) = H9907 := by
    have h_mul_H_C1 : ∀ h ∈ H9907, Finset.image (fun x => h * x) H9907 = H9907 ∧ Finset.image (fun x => h * x) C1_9907 = C1_9907 ∧ Finset.image (fun x => h * x) C2_9907 = C2_9907 := by
      intros h hh;
      apply action_H_9907 h hh;
    obtain ⟨h, hh⟩ : ∃ h ∈ H9907, n = g9907 * h := by
      unfold C1_9907 at hn; aesop;
    simp +decide [ *, mul_assoc, Finset.image_image ];
    have h_mul_g_H_C1 : Finset.image (fun x => g9907 * x) H9907 = C1_9907 ∧ Finset.image (fun x => g9907 * x) C1_9907 = C2_9907 ∧ Finset.image (fun x => g9907 * x) C2_9907 = H9907 := by
      native_decide;
    have h_mul_h_g_C1 : Finset.image (fun x => h * x) (Finset.image (fun x => g9907 * x) H9907) = Finset.image (fun x => g9907 * x) H9907 ∧ Finset.image (fun x => h * x) (Finset.image (fun x => g9907 * x) C1_9907) = Finset.image (fun x => g9907 * x) C1_9907 ∧ Finset.image (fun x => h * x) (Finset.image (fun x => g9907 * x) C2_9907) = Finset.image (fun x => g9907 * x) C2_9907 := by
      simp +decide [ *, Finset.ext_iff ];
    simp +decide only [Finset.image_image, mul_assoc] at h_mul_h_g_C1 ⊢;
    simp +decide only [Function.comp_def, mul_left_comm] at h_mul_h_g_C1 ⊢; exact ⟨by simpa only [mul_comm] using h_mul_h_g_C1.left.trans h_mul_g_H_C1.left, by simpa only [mul_comm] using h_mul_h_g_C1.right.left.trans h_mul_g_H_C1.right.left, by simpa only [mul_comm] using h_mul_h_g_C1.right.right.trans h_mul_g_H_C1.right.right⟩;

/-
Action of C2 on the sets H, C1, C2. Multiplication by an element of C2 permutes them cyclically (H -> C2 -> C1 -> H).
-/
lemma action_C2_9907 (n : ZMod 9907) (hn : n ∈ C2_9907) :
  H9907.image (fun x => n * x) = C2_9907 ∧
  C1_9907.image (fun x => n * x) = H9907 ∧
  C2_9907.image (fun x => n * x) = C1_9907 := by
    unfold C2_9907 at hn; ( unfold C1_9907; ( unfold H9907 at *; ( norm_num at *; ) ) );
    rcases hn with ⟨ a, ha, rfl ⟩ ; unfold g9907; ( ( rw [ Finset.image_image ] ; ) );
    rw [ Finset.image_image, Finset.image_image ] ; ( unfold C2_9907; ( unfold g9907; ) );
    unfold H9907; ( rw [ Finset.image_image ] ; );
    refine' ⟨ _, _, _ ⟩ <;> rw [ Finset.ext_iff ] <;> intros <;> simp +contextual [ ha ];
    · constructor <;> rintro ⟨ b, hb, rfl ⟩;
      · exact ⟨ a * b, mul_ne_zero ha hb, by ring ⟩;
      · -- Let $a_1 = b / a$.
        use b / a;
        grind;
    · constructor <;> rintro ⟨ b, hb, rfl ⟩;
      · -- Let's choose $a_1 = 2 * a * b$.
        use 2 * a * b;
        grind +ring;
      · -- Let $a_1 = \frac{b}{2a}$.
        use b * (2 * a)⁻¹;
        haveI := Fact.mk ( by norm_num : Nat.Prime 9907 ) ; simp +decide [ ha, hb, mul_assoc, mul_comm, mul_left_comm, pow_three ] ;
        native_decide +revert;
    · constructor <;> rintro ⟨ b, hb, rfl ⟩;
      · -- Let's choose $a_1 = 2 * a * b$.
        use 2 * a * b;
        grind;
      · -- We need to find $a_1$ such that $2^4 * a^3 * a_1^3 = 2 * b^3$. This simplifies to $a_1^3 = \frac{2 * b^3}{2^4 * a^3} = \frac{b^3}{8 * a^3}$.
        suffices h_exists_a1 : ∃ a_1 : ZMod 9907, a_1^3 = b^3 / (8 * a^3) by
          grind;
        -- Since $8 * a^3$ is a cube, we can write it as $(2 * a)^3$.
        use b / (2 * a);
        rw [ div_pow ] ; ring

/-
The automorphism sigma_n permutes alpha, beta, gamma according to which coset n belongs to.
-/
lemma global_permutation_9907 (n : (ZMod 9907)ˣ) :
  ((n : ZMod 9907) ∈ C1_9907 → sigma_int9907 n alpha_int9907 = beta_int9907) ∧
  ((n : ZMod 9907) ∈ C2_9907 → sigma_int9907 n alpha_int9907 = gamma_int9907) ∧
  ((n : ZMod 9907) ∈ H9907 → sigma_int9907 n alpha_int9907 = alpha_int9907) := by
    refine' ⟨ fun hn => _, fun hn => _, fun hn => _ ⟩;
    · -- By definition of $alpha$, $beta$, and $gamma$, we can write
      have h_sigma_alpha : sigma_int9907 n alpha_prime_int9907 = beta_prime_int9907 := by
        unfold alpha_prime_int9907 beta_prime_int9907;
        have h_sigma_eta : sigma_int9907 n (eta_int9907 H9907) = eta_int9907 (H9907.image (fun x => (n : ZMod 9907) * x)) ∧ sigma_int9907 n (eta_int9907 C1_9907) = eta_int9907 (C1_9907.image (fun x => (n : ZMod 9907) * x)) := by
          exact ⟨ sigma_eta_9907 n H9907, sigma_eta_9907 n C1_9907 ⟩;
        have h_sigma_eta : H9907.image (fun x => (n : ZMod 9907) * x) = C1_9907 ∧ C1_9907.image (fun x => (n : ZMod 9907) * x) = C2_9907 := by
          exact ⟨ action_C1_9907 _ hn |>.1, action_C1_9907 _ hn |>.2.1 ⟩;
        unfold eta0_int9907 eta1_int9907 eta2_int9907 at *; aesop;
      unfold alpha_int9907 beta_int9907; aesop;
    · -- By definition of $C2_9907$, we know that $n \in C2_9907$ implies $\sigma_n(\alpha) = \gamma$.
      have h_sigma_gamma : sigma_int9907 n eta0_int9907 = eta2_int9907 ∧ sigma_int9907 n eta1_int9907 = eta0_int9907 ∧ sigma_int9907 n eta2_int9907 = eta1_int9907 := by
        have h_sigma_eta : sigma_int9907 n eta0_int9907 = eta_int9907 (H9907.image (fun x => (n : ZMod 9907) * x)) ∧ sigma_int9907 n eta1_int9907 = eta_int9907 (C1_9907.image (fun x => (n : ZMod 9907) * x)) ∧ sigma_int9907 n eta2_int9907 = eta_int9907 (C2_9907.image (fun x => (n : ZMod 9907) * x)) := by
          exact ⟨ sigma_eta_9907 n H9907, sigma_eta_9907 n C1_9907, sigma_eta_9907 n C2_9907 ⟩;
        rw [ h_sigma_eta.1, h_sigma_eta.2.1, h_sigma_eta.2.2 ];
        rw [ action_C2_9907 _ hn |>.1, action_C2_9907 _ hn |>.2.1, action_C2_9907 _ hn |>.2.2 ];
        exact ⟨ rfl, rfl, rfl ⟩;
      unfold alpha_int9907 gamma_int9907;
      unfold alpha_prime_int9907 gamma_prime_int9907; simp +decide [ h_sigma_gamma ] ;
    · unfold alpha_int9907;
      unfold alpha_prime_int9907;
      unfold eta0_int9907 eta1_int9907; simp +decide [ sigma_eta_9907, action_H_9907 _ hn ] ;

/-
Check the relation between s1 and s2.
-/
def check_s_relation_9907 : IO Unit := do
  let s1 := 6571
  let s2 := 3335
  let q := 9907
  let s2_sq := s2 * s2 % q
  IO.println s!"s2^2 = {s2_sq}"
  if s2_sq == s1 then IO.println "s2^2 = s1" else IO.println "s2^2 != s1"

#eval check_s_relation_9907

/-
Characterization of C1 using the cubic character chi.
-/
lemma mem_C1_iff_chi_eq_s2_9907 (n : ZMod 9907) (hn : n ≠ 0) : n ∈ C1_9907 ↔ chi9907 n = s2_9907 := by
  revert n; native_decide;

/-
Characterization of C2 using the cubic character chi.
-/
lemma mem_C2_iff_chi_eq_s1_9907 (n : ZMod 9907) (hn : n ≠ 0) : n ∈ C2_9907 ↔ chi9907 n = s1_9907 := by
  native_decide +revert

/-
The Dream Theorem for q=9907.
-/
theorem final_result_9907 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 9907) (hN_odd : N % 2 = 1) (hN_a : Nat.Coprime 199 N)
  (P : Ideal Ok9907) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_assum : DreamAssumptions_9907) :
  let alpha_bar := Ideal.Quotient.mk P alpha_int9907
  let beta_bar := Ideal.Quotient.mk P beta_int9907
  let gamma_bar := Ideal.Quotient.mk P gamma_int9907
  (chi9907 N = s1_9907 → alpha_bar ^ N = gamma_bar) ∧
  (chi9907 N = s2_9907 → alpha_bar ^ N = beta_bar) := by
    convert artin_property_9907 N hN P _ using 1;
    · refine' ⟨ fun h => _, fun h => _ ⟩;
      · exact?;
      · constructor <;> intro hchi <;> have := h_assum.2.1 <;> simp_all +decide [ ← h ];
        · have h_sigma_gamma : (N_mod_9907 N hN : ZMod 9907) ∈ C2_9907 := by
            apply (mem_C2_iff_chi_eq_s1_9907 _ _).mpr hchi;
            rw [ Ne.eq_def, ZMod.natCast_eq_zero_iff ] ; intro h ; have := Nat.dvd_gcd ( by decide : 9907 ∣ 9907 ) h ; simp_all +decide [ Nat.Prime.dvd_iff_eq Fact.out ] ;
          rw [ global_permutation_9907 _ |>.2.1 h_sigma_gamma ];
        · have := global_permutation_9907 ( N_mod_9907 N hN );
          have := mem_C1_iff_chi_eq_s2_9907 ( N_mod_9907 N hN ) ?_ <;> simp_all +decide [ ZMod.unitOfCoprime ];
          unfold N_mod_9907 at *; simp_all +decide [ ZMod.val_natCast ] ;
    · assumption