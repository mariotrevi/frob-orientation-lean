/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: e1b305ca-997f-4b6f-bf98-b23aa48a1687

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
This module proves the Dream Theorem for the prime q = 8017.
It defines the cyclotomic field K = Q(zeta_8017), the ring of integers Ok, and the relevant periods and differences.
It sets up the subgroups H, C1, C2 of (Z/8017Z)* and analyzes their action on the periods.
It proves the Artin property for the extension K/Q and uses it to derive the main result:
for a prime N != 8017, the value of c(N) determines the image of alpha under the Frobenius map.
Specifically, if c(N) = s1, then alpha^N = gamma mod P, and if c(N) = s2, then alpha^N = beta mod P.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 8011b3b0-5b9d-44a9-a431-7da2e7415d10

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We have successfully proved the Dream Theorem for the prime $q = 1567$.
The proof follows the structure of prior proofs for $q = 877, 937, 1063, 1129$.
We defined the field $K = \mathbb{Q}(\zeta_{1567})$, the ring of integers $\mathcal{O}_K$, and the Gaussian periods $\eta_0, \eta_1, \eta_2$.
We defined the period differences $\alpha, \beta, \gamma$ with the appropriate sign convention.
We established the algebraic relations between $\alpha, \beta, \gamma$ using the period equation and computation.
We proved the Artin property for the extension $K/\mathbb{Q}$.
We characterized the cosets $C_1, C_2$ using the cubic character $\chi$.
Finally, we proved `final_result_1567`, which states that for a prime $N \neq 1567$, the Frobenius action on $\alpha$ is determined by the value of the cubic character $\chi(N)$.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: ff94a4ce-df04-43b6-855b-2c35922c8831

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We define the cyclotomic field $K = \mathbb{Q}(\zeta_{1129})$, the ring of integers $\mathcal{O}_K$, and the Gaussian periods $\eta_0, \eta_1, \eta_2$. We define the period differences $\alpha, \beta, \gamma$ with the correct sign convention. We prove the Artin property for $\mathcal{O}_K$ and use it to prove the Dream Theorem for $q = 1129$, which relates the Frobenius action on $\alpha$ to the cubic character $c(N)$. The proof assumes the period equation for $\alpha$ as requested.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 49ab742d-7e60-49a0-9635-aa76ebf271b7

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Proof of the Dream Theorem for q = 1063.

We define the cyclotomic field K = Q(zeta_1063), the ring of integers Ok, and the Gaussian periods.
We identify a generator g = 6 such that the cubic character c(g) = s2 = 719.
We define the roots alpha, beta, gamma using this generator and the standard sign convention.
We prove the Artin property for the extension.
We prove the global permutation of roots under the Galois group.
Finally, we prove the Dream Theorem:
If c(N) = s1, then alpha^N = gamma mod P.
If c(N) = s2, then alpha^N = beta mod P.
This relies on the period equation alpha^3 = 1063*alpha + 1063, which is added as a hypothesis.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f1e85200-2efb-4b56-a019-1c5b75f4b05f

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Proof of the Dream Theorem for q = 937.

We define the cyclotomic field K = Q(zeta_937), its ring of integers Ok, and the Gaussian periods.
We identify a generator g = 7 for which the cubic character values match the s1/s2 definitions.
We prove the Artin property for the extension K/Q.
We prove the main theorem `dream_theorem_937` which states that for a prime N != 937:
- If c(N) = s1, then alpha^N = gamma mod P.
- If c(N) = s2, then alpha^N = beta mod P.
This assumes the period equation `alpha^3 = 937*alpha + 937`.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: b08f138a-15ed-40a2-a0c0-b8f4ce6443e1

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We define the cyclotomic field K for q = 877 and the Gaussian periods. We prove the Dream Theorem for q = 877, which states that the Frobenius automorphism maps the period difference α to β or γ depending on the cubic character of the prime N modulo 877. The proof relies on the Artin property of the Frobenius map and the explicit calculation of the Galois action on the periods.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f1f9f2e4-1b7a-4d8c-ad24-d62d489ea7c9

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: a7add749-96ca-48e2-a89d-fbb216918bc3

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 22a1ac83-9054-4f97-9a50-f0ea72bded01

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: e6ee589a-f550-42ef-89e5-1fd2afd7fa5e

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We defined the constants s1, s2, and the value c(N). We proved lemmas characterizing the cosets C1 and C2 in terms of the 12th power residue symbol (which relates to c(N)). Finally, we proved the main theorem `final_result` which establishes the Frobenius action on alpha (i.e., alpha^N) in terms of beta and gamma, depending on the value of c(N). The proof utilizes the `explicit_frobenius` theorem and the algebraic relations between alpha, beta, and gamma.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 939f55fb-68a7-4ef0-bca3-475f675055ca

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
This module formalizes the proof of the Frobenius Orientation conjecture for q=37.
It defines the cyclotomic field K = Q(zeta_37), the Gaussian periods, and the cubic roots.
It proves the cyclic algebraic relations between these roots and establishes the global Galois action.
It descends to the residue field modulo a prime P lying over N != 37, proving the Artin property.
Finally, it derives the explicit Frobenius action on the reduction of alpha modulo P.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section













/-
Definitions for q = 8017, s1, s2, and c(N).
-/
def q8017 : ℕ := 8017

instance fact_prime_8017 : Fact (Nat.Prime 8017) := ⟨by native_decide⟩

def s1_8017 : ZMod 8017 := 2642
def s2_8017 : ZMod 8017 := 5374
def c8017 (N : ℕ) : ZMod 8017 := (N : ZMod 8017)^2672

/-
Find a generator g for q=8017 such that g^((q-1)/3) = s2.
-/
def find_g_8017 : IO Unit := do
  let q := 8017
  let s2 := 5374
  let order := q - 1
  let power := order / 3
  
  for g in [2:100] do
    let val := (g : Nat) ^ power % q
    if val == s2 then
      IO.println s!"Found generator g = {g}"
      return
  
  IO.println "No generator found in range"

#eval find_g_8017

/-
Definitions for K, zeta, g, H, C1, C2 for q = 8017.
-/
abbrev K8017 := CyclotomicField 8017 ℚ

noncomputable def zeta8017 : K8017 := IsCyclotomicExtension.zeta 8017 ℚ K8017

def g8017 : ZMod 8017 := 2

def H8017 : Finset (ZMod 8017) := ((Finset.univ : Finset (ZMod 8017)).filter (fun x => x ≠ 0)).image (fun x => x^3)

def C1_8017 : Finset (ZMod 8017) := H8017.image (fun x => g8017 * x)

def C2_8017 : Finset (ZMod 8017) := H8017.image (fun x => g8017^2 * x)

/-
Definitions of periods and differences in K for q = 8017.
-/
open scoped BigOperators

noncomputable def eta8017 (S : Finset (ZMod 8017)) : K8017 := ∑ x ∈ S, zeta8017^(x.val)

noncomputable def eta0_8017 := eta8017 H8017
noncomputable def eta1_8017 := eta8017 C1_8017
noncomputable def eta2_8017 := eta8017 C2_8017

noncomputable def alpha_prime_8017 := eta0_8017 - eta1_8017
noncomputable def beta_prime_8017 := eta1_8017 - eta2_8017
noncomputable def gamma_prime_8017 := eta2_8017 - eta0_8017

/-
Ring of integers and automorphisms for q = 8017.
-/
abbrev Ok8017 := NumberField.RingOfIntegers K8017

theorem h_irr_8017 : Irreducible (Polynomial.cyclotomic 8017 ℚ) := by
  exact Polynomial.cyclotomic.irreducible_rat <| by norm_num;

noncomputable def sigma8017 (n : (ZMod 8017)ˣ) : K8017 ≃ₐ[ℚ] K8017 :=
  (IsCyclotomicExtension.autEquivPow K8017 h_irr_8017).symm n

/-
Integral elements, sign convention, and Dream Assumptions for q = 8017.
-/
theorem zeta_isIntegral_8017 : IsIntegral ℤ zeta8017 := by
  -- Since $zeta8017$ is a root of the monic polynomial $x^{8017} - 1$ with integer coefficients, it is integral over $\mathbb{Z}$.
  have hzeta_poly : zeta8017 ^ 8017 = 1 := by
    convert IsPrimitiveRoot.pow_eq_one ( show IsPrimitiveRoot zeta8017 8017 from ?_ ) using 1;
    convert IsCyclotomicExtension.zeta_spec 8017 ℚ K8017 using 1;
  exact ⟨ Polynomial.X ^ 8017 - 1, by exact Polynomial.monic_X_pow_sub_C _ ( by norm_num ), by aesop ⟩

def zeta_int8017 : Ok8017 := ⟨zeta8017, zeta_isIntegral_8017⟩

noncomputable def sigma_int8017 (n : (ZMod 8017)ˣ) : Ok8017 ≃ₐ[ℤ] Ok8017 :=
  (NumberField.RingOfIntegers.mapAlgEquiv (sigma8017 n)).restrictScalars ℤ

noncomputable def eta_int8017 (S : Finset (ZMod 8017)) : Ok8017 := ∑ x ∈ S, zeta_int8017^(x.val)

noncomputable def eta0_int8017 := eta_int8017 H8017
noncomputable def eta1_int8017 := eta_int8017 C1_8017
noncomputable def eta2_int8017 := eta_int8017 C2_8017

noncomputable def alpha_prime_int8017 := eta0_int8017 - eta1_int8017
noncomputable def beta_prime_int8017 := eta1_int8017 - eta2_int8017
noncomputable def gamma_prime_int8017 := eta2_int8017 - eta0_int8017

open Classical

noncomputable def sign_8017 : ℤ :=
  if alpha_prime_int8017 * beta_prime_int8017 * gamma_prime_int8017 = (8017 : Ok8017) then 1 else -1

noncomputable def alpha_int8017 := (sign_8017 : Ok8017) * alpha_prime_int8017
noncomputable def beta_int8017 := (sign_8017 : Ok8017) * beta_prime_int8017
noncomputable def gamma_int8017 := (sign_8017 : Ok8017) * gamma_prime_int8017

def DreamAssumptions_8017 : Prop :=
  alpha_int8017^3 = 8017 * alpha_int8017 + 8017 ∧
  alpha_int8017 * beta_int8017 * gamma_int8017 = 8017 ∧
  179 * beta_int8017 = 3 * alpha_int8017^2 - 94 * alpha_int8017 - 16034 ∧
  179 * gamma_int8017 = -3 * alpha_int8017^2 + 85 * alpha_int8017 + 16034

/-
Definition of N mod 8017 as a unit.
-/
def N_mod_8017 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 8017) : (ZMod 8017)ˣ :=
  ZMod.unitOfCoprime N (Nat.Coprime.symm ((Nat.coprime_primes (by norm_num) (Fact.out)).mpr hN.symm))

/-
Action of sigma on zeta for q = 8017.
-/
lemma sigma_int_zeta_pow_8017 (n : (ZMod 8017)ˣ) :
  sigma_int8017 n zeta_int8017 = zeta_int8017 ^ (n : ZMod 8017).val := by
    unfold sigma_int8017;
    unfold NumberField.RingOfIntegers.mapAlgEquiv sigma8017;
    erw [ Subtype.mk_eq_mk ];
    erw [ IsCyclotomicExtension.autEquivPow_symm_apply ];
    erw [ PowerBasis.equivOfMinpoly_gen ];
    rfl

/-
Artin property for zeta for q = 8017.
-/
theorem artin_property_zeta_8017 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 8017) (P : Ideal Ok8017) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  Ideal.Quotient.mk P (sigma_int8017 (N_mod_8017 N hN) zeta_int8017) = (Ideal.Quotient.mk P zeta_int8017)^N := by
    rw [ sigma_int_zeta_pow_8017 ];
    erw [ ZMod.val_natCast ];
    rw [ ← Nat.mod_add_div N 8017 ] ; norm_num [ pow_add, pow_mul ] ;
    have h_zeta_pow : zeta_int8017 ^ 8017 = 1 := by
      have h_zeta_pow : zeta8017 ^ 8017 = 1 := by
        exact IsCyclotomicExtension.zeta_pow _ _ _;
      exact Subtype.ext h_zeta_pow;
    erw [ show ( Ideal.Quotient.mk P ) zeta_int8017 ^ 8017 = 1 from by simpa using congr_arg ( Ideal.Quotient.mk P ) h_zeta_pow ] ; norm_num

/-
Zeta is a primitive root.
-/
theorem zeta_isPrimitiveRoot_8017 : IsPrimitiveRoot zeta8017 8017 := by
  apply_rules [ IsCyclotomicExtension.zeta_spec ]

theorem Ok8017_eq_adjoin : (⊤ : Subalgebra ℤ Ok8017) = Algebra.adjoin ℤ {zeta_int8017} := by
  -- We'll use that $K_{8017}$ is generated by $zeta_{8017}$ over $\mathbb{Q}$.
  have h_gen : ∀ x : K8017, IsIntegral ℤ x → x ∈ Algebra.adjoin ℤ {zeta8017} := by
    intro x hx;
    have h_int_closed : IsIntegralClosure (Algebra.adjoin ℤ {zeta8017}) ℤ K8017 := by
      have := @IsCyclotomicExtension.Rat.isIntegralClosure_adjoin_singleton_of_prime ( 8017 : ℕ ) K8017;
      exact this ( zeta_isPrimitiveRoot_8017 );
    have := h_int_closed.isIntegral_iff.mp hx; aesop;
  ext x;
  convert h_gen x.1 x.2;
  simp +decide [ Algebra.adjoin_singleton_eq_range_aeval ];
  constructor <;> rintro ⟨ p, hp ⟩;
  · use p;
    convert congr_arg Subtype.val hp using 1;
    simp +decide [ Polynomial.aeval_def, Polynomial.eval₂_eq_sum_range ];
    induction ( Finset.range ( p.natDegree + 1 ) ) using Finset.induction <;> aesop;
  · use p;
    erw [ Polynomial.aeval_eq_sum_range ] at * ; aesop

theorem Ok8017_eq_adjoin_2 : (⊤ : Subalgebra ℤ Ok8017) = Algebra.adjoin ℤ {zeta_int8017} := by
  exact?

/-
Definition of chi and its multiplicativity.
-/
def chi8017 (x : ZMod 8017) : ZMod 8017 := x ^ 2672

lemma chi8017_mul (x y : ZMod 8017) : chi8017 (x * y) = chi8017 x * chi8017 y := by
  by_cases hx : x = 0 <;> by_cases hy : y = 0 <;> simp_all +decide [ chi8017 ];
  ring

/-
Action of sigma on eta for q = 8017.
-/
lemma sigma_eta_8017 (n : (ZMod 8017)ˣ) (S : Finset (ZMod 8017)) :
  sigma_int8017 n (eta_int8017 S) = eta_int8017 (S.image (fun x => (n : ZMod 8017) * x)) := by
    unfold eta_int8017;
    simp +zetaDelta at *;
    refine' Finset.sum_congr rfl fun x hx => _;
    rw [ sigma_int_zeta_pow_8017 ];
    rw [ ← pow_mul, ZMod.val_mul ];
    rw [ ← Nat.mod_add_div ( ( n : ZMod 8017 ).val * x.val ) 8017, pow_add, pow_mul ] ; norm_num;
    have h_zeta_pow : zeta_int8017 ^ 8017 = 1 := by
      have h_zeta_pow : zeta8017 ^ 8017 = 1 := by
        exact IsPrimitiveRoot.pow_eq_one ( zeta_isPrimitiveRoot_8017 );
      exact Subtype.ext h_zeta_pow;
    rw [ h_zeta_pow, one_pow, mul_one ]

/-
Action of H on the cosets for q = 8017.
-/
lemma action_H_8017 (n : ZMod 8017) (hn : n ∈ H8017) :
  H8017.image (fun x => n * x) = H8017 ∧
  C1_8017.image (fun x => n * x) = C1_8017 ∧
  C2_8017.image (fun x => n * x) = C2_8017 := by
    have h_mul : ∀ n ∈ H8017, ∀ x ∈ H8017, n * x ∈ H8017 ∧ ∀ x ∈ C1_8017, n * x ∈ C1_8017 ∧ ∀ x ∈ C2_8017, n * x ∈ C2_8017 := by
      simp_all +contextual [ H8017, C1_8017, C2_8017 ];
      refine fun a ha b hb => ⟨ ?_, fun c hc => ⟨ ?_, fun d hd => ?_ ⟩ ⟩;
      · exact ⟨ a * b, mul_ne_zero ha hb, by ring ⟩;
      · exact ⟨ a * c, mul_ne_zero ha hc, by ring ⟩;
      · exact ⟨ a * d, mul_ne_zero ha hd, by ring ⟩;
    refine' ⟨ _, _, _ ⟩;
    · refine' Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr fun x hx => h_mul n hn x hx |>.1 ) _;
      rw [ Finset.card_image_of_injective _ fun x y hxy => mul_left_cancel₀ ( show n ≠ 0 from by rintro rfl; exact absurd hn ( by native_decide ) ) hxy ];
    · refine' Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr fun x hx => h_mul n hn 1 ( by native_decide ) |>.2 x hx |>.1 ) _;
      rw [ Finset.card_image_of_injective _ fun x y hxy => mul_left_cancel₀ ( show n ≠ 0 from by rintro rfl; exact absurd hn ( by native_decide ) ) hxy ];
    · refine' Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr fun x hx => _ ) _;
      · exact h_mul n hn _ ( show 1 ∈ H8017 from by native_decide ) |>.2 _ ( show g8017 ∈ C1_8017 from by native_decide ) |>.2 _ hx;
      · rw [ Finset.card_image_of_injective _ fun x y hxy => _ ];
        intro x y hxy; haveI := Fact.mk ( show Nat.Prime 8017 by native_decide ) ; exact mul_left_cancel₀ ( show n ≠ 0 from by rintro rfl; exact absurd hn ( by native_decide ) ) hxy;

/-
Action of C1 on the cosets for q = 8017.
-/
lemma action_C1_8017 (n : ZMod 8017) (hn : n ∈ C1_8017) :
  H8017.image (fun x => n * x) = C1_8017 ∧
  C1_8017.image (fun x => n * x) = C2_8017 ∧
  C2_8017.image (fun x => n * x) = H8017 := by
    obtain ⟨ m, hm, rfl ⟩ := Finset.mem_image.mp hn;
    -- Since $m \in H8017$, multiplying by $m$ permutes the elements of $H8017$.
    have h_perm : Finset.image (fun x => m * x) H8017 = H8017 ∧ Finset.image (fun x => m * x) C1_8017 = C1_8017 ∧ Finset.image (fun x => m * x) C2_8017 = C2_8017 := by
      apply action_H_8017 m hm;
    -- Since $g8017 \in C1_8017$, multiplying by $g8017$ permutes the elements of $H8017$, $C1_8017$, and $C2_8017$.
    have h_perm_g : Finset.image (fun x => g8017 * x) H8017 = C1_8017 ∧ Finset.image (fun x => g8017 * x) C1_8017 = C2_8017 ∧ Finset.image (fun x => g8017 * x) C2_8017 = H8017 := by
      native_decide +revert;
    -- By combining the results from h_perm and h_perm_g, we can conclude the proof.
    have h_combined : Finset.image (fun x => g8017 * m * x) H8017 = Finset.image (fun x => g8017 * x) (Finset.image (fun x => m * x) H8017) ∧ Finset.image (fun x => g8017 * m * x) C1_8017 = Finset.image (fun x => g8017 * x) (Finset.image (fun x => m * x) C1_8017) ∧ Finset.image (fun x => g8017 * m * x) C2_8017 = Finset.image (fun x => g8017 * x) (Finset.image (fun x => m * x) C2_8017) := by
      simp +decide [ mul_assoc, Finset.ext_iff ];
    aesop

/-
Action of C2 on the cosets for q = 8017.
-/
lemma action_C2_8017 (n : ZMod 8017) (hn : n ∈ C2_8017) :
  H8017.image (fun x => n * x) = C2_8017 ∧
  C1_8017.image (fun x => n * x) = H8017 ∧
  C2_8017.image (fun x => n * x) = C1_8017 := by
    -- Since $n \in C2_8017$, we have $n = g8017^2 * h$ for some $h \in H8017$.
    obtain ⟨h, hh⟩ : ∃ h ∈ H8017, n = g8017^2 * h := by
      native_decide +revert;
    -- Since $h \in H8017$, multiplying by $h$ preserves the cosets.
    have h_coset_preserve : ∀ S ∈ ({H8017, C1_8017, C2_8017} : Finset (Finset (ZMod 8017))), Finset.image (fun x => h * x) S = S := by
      have := action_H_8017 h hh.1; aesop;
    -- Since $g8017^2$ maps $H8017$ to $C2_8017$, $C1_8017$ to $H8017$, and $C2_8017$ to $C1_8017$, we can conclude the proof.
    have h_g2_map : Finset.image (fun x => g8017^2 * x) H8017 = C2_8017 ∧ Finset.image (fun x => g8017^2 * x) C1_8017 = H8017 ∧ Finset.image (fun x => g8017^2 * x) C2_8017 = C1_8017 := by
      native_decide +revert;
    simp_all +contextual only [mul_assoc, mul_left_comm];
    have h_image : ∀ S ∈ ({H8017, C1_8017, C2_8017} : Finset (Finset (ZMod 8017))), Finset.image (fun x => h * (g8017^2 * x)) S = Finset.image (fun x => h * x) (Finset.image (fun x => g8017^2 * x) S) := by
      simp +contextual [ Finset.ext_iff ];
    aesop

/-
Global permutation of alpha by sigma_n for q = 8017.
-/
lemma global_permutation_8017 (n : (ZMod 8017)ˣ) :
  ((n : ZMod 8017) ∈ C1_8017 → sigma_int8017 n alpha_int8017 = beta_int8017) ∧
  ((n : ZMod 8017) ∈ C2_8017 → sigma_int8017 n alpha_int8017 = gamma_int8017) ∧
  ((n : ZMod 8017) ∈ H8017 → sigma_int8017 n alpha_int8017 = alpha_int8017) := by
    refine' ⟨ _, _, _ ⟩;
    · intro hn
      have h_sigma_alpha : sigma_int8017 n alpha_prime_int8017 = beta_prime_int8017 := by
        unfold alpha_prime_int8017 beta_prime_int8017;
        unfold eta0_int8017 eta1_int8017 eta2_int8017;
        rw [ map_sub ];
        rw [ sigma_eta_8017, sigma_eta_8017 ];
        rw [ action_C1_8017 _ hn |>.1, action_C1_8017 _ hn |>.2.1 ];
      unfold alpha_int8017 beta_int8017; aesop;
    · intro hn
      have h_sigma_eta : sigma_int8017 n eta0_int8017 = eta2_int8017 ∧ sigma_int8017 n eta1_int8017 = eta0_int8017 ∧ sigma_int8017 n eta2_int8017 = eta1_int8017 := by
        have h_sigma_eta : H8017.image (fun x => (n : ZMod 8017) * x) = C2_8017 ∧ C1_8017.image (fun x => (n : ZMod 8017) * x) = H8017 ∧ C2_8017.image (fun x => (n : ZMod 8017) * x) = C1_8017 := by
          exact?;
        have h_sigma_eta : ∀ S : Finset (ZMod 8017), sigma_int8017 n (eta_int8017 S) = eta_int8017 (S.image (fun x => (n : ZMod 8017) * x)) := by
          exact?;
        unfold eta0_int8017 eta1_int8017 eta2_int8017; aesop;
      unfold alpha_int8017 gamma_int8017;
      unfold alpha_prime_int8017 gamma_prime_int8017; simp +decide [ h_sigma_eta ] ;
    · unfold alpha_int8017;
      unfold alpha_prime_int8017;
      unfold eta0_int8017 eta1_int8017; simp +decide [ mul_sub, sub_mul, sigma_eta_8017 ] ;
      intro hn;
      rw [ action_H_8017 _ hn |>.1, action_H_8017 _ hn |>.2.1 ]

/-
Check if s2^2 = s1 mod 8017.
-/
def check_s_relation_8017 : IO Unit := do
  let s1 := 2642
  let s2 := 5374
  let q := 8017
  let s2_sq := s2 * s2 % q
  IO.println s!"s2^2 = {s2_sq}"
  if s2_sq == s1 then IO.println "s2^2 = s1" else IO.println "s2^2 != s1"

#eval check_s_relation_8017

/-
Characterization of C1 for q = 8017.
-/
lemma mem_C1_iff_chi_eq_s2_8017 (n : ZMod 8017) (hn : n ≠ 0) : n ∈ C1_8017 ↔ chi8017 n = s2_8017 := by
  native_decide +revert

/-
Characterization of C2 for q = 8017.
-/
lemma mem_C2_iff_chi_eq_s1_8017 (n : ZMod 8017) (hn : n ≠ 0) : n ∈ C2_8017 ↔ chi8017 n = s1_8017 := by
  native_decide +revert

/-
Characteristic of Ok/P is N.
-/
lemma char_Ok_mod_P_8017 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 8017) (P : Ideal Ok8017) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  CharP (Ok8017 ⧸ P) N := by
    have := hP.1;
    rw [ eq_comm ] at this;
    rw [ Ideal.ext_iff ] at this;
    constructor;
    intro x; specialize this x; simp_all +decide [ Ideal.mem_span_singleton ] ;
    erw [ Ideal.Quotient.eq_zero_iff_mem ] ; norm_cast at *

/-
Frobenius homomorphism defined via composition.
-/
def frobenius_hom_8017 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 8017) (P : Ideal Ok8017) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) : Ok8017 →+* (Ok8017 ⧸ P) :=
  haveI := char_Ok_mod_P_8017 N hN P hP
  (frobenius (Ok8017 ⧸ P) N).comp (Ideal.Quotient.mk P)

/-
Artin property for general elements of Ok8017.
-/
theorem artin_property_8017 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 8017) (P : Ideal Ok8017) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) (x : Ok8017) :
  Ideal.Quotient.mk P (sigma_int8017 (N_mod_8017 N hN) x) = (Ideal.Quotient.mk P x)^N := by
    -- Since Ok8017 is generated by zeta_int8017, it suffices to show that the equality holds for zeta_int8017.
    have h_gen : ∀ x : Ok8017, x ∈ Algebra.adjoin ℤ {zeta_int8017} → (Ideal.Quotient.mk P) ((sigma_int8017 (N_mod_8017 N hN)) x) = (Ideal.Quotient.mk P x) ^ N := by
      intro x hx
      induction' hx using Algebra.adjoin_induction with x hx ih;
      · convert artin_property_zeta_8017 N hN P hP using 1;
        · aesop;
        · aesop;
      · erw [ Ideal.Quotient.eq ];
        have := hP.1;
        replace this := SetLike.ext_iff.mp this ( ih ^ N - ih ) ; simp_all +decide [ ← ZMod.intCast_zmod_eq_zero_iff_dvd, Ideal.mem_span_singleton ] ;
        simpa using P.neg_mem this;
      · rename_i hx hy hx' hy';
        convert congr_arg₂ ( · + · ) hx' hy' using 1 <;> ring;
        · exact congr_arg _ ( map_add _ _ _ );
        · haveI := char_Ok_mod_P_8017 N hN P hP;
          rw [ ← add_pow_char ];
          exact?;
      · simp_all +decide [ mul_pow, map_mul ];
    rw [ ← Ok8017_eq_adjoin_2 ] at * ; aesop

/-
The Dream Theorem for q = 8017.
-/
theorem final_result_8017 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 8017) (hN_odd : N % 2 = 1) (hN_a : Nat.Coprime 179 N)
  (P : Ideal Ok8017) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_assum : DreamAssumptions_8017) :
  let alpha_bar := Ideal.Quotient.mk P alpha_int8017
  let beta_bar := Ideal.Quotient.mk P beta_int8017
  let gamma_bar := Ideal.Quotient.mk P gamma_int8017
  (chi8017 N = s1_8017 → alpha_bar ^ N = gamma_bar) ∧
  (chi8017 N = s2_8017 → alpha_bar ^ N = beta_bar) := by
    apply And.intro
    intro hchi1
    have hcoset : (N_mod_8017 N hN : ZMod 8017) ∈ C2_8017 := by
      exact mem_C2_iff_chi_eq_s1_8017 _ ( by
        have := hP.1; simp_all +decide [ Ideal.span_singleton_prime ] ; ) |>.2 hchi1
    have hsign : alpha_int8017 ^ (3 : ℕ) = 8017 * alpha_int8017 + 8017 := by
      exact h_assum.1
    exact (by
    have hsigma : Ideal.Quotient.mk P (sigma_int8017 (N_mod_8017 N hN) alpha_int8017) = Ideal.Quotient.mk P gamma_int8017 := by
      apply congr_arg (Ideal.Quotient.mk P) (global_permutation_8017 (N_mod_8017 N hN) |>.2.1 hcoset);
    rw [ ← hsigma, artin_property_8017 ];
    exact hP)
    intro hchi2
    have hcoset : (N_mod_8017 N hN : ZMod 8017) ∈ C1_8017 := by
      exact mem_C1_iff_chi_eq_s2_8017 _ ( by intro h; simp_all +decide [ chi8017 ] ) |>.2 hchi2
    have hsign : alpha_int8017 ^ (3 : ℕ) = 8017 * alpha_int8017 + 8017 := by
      exact h_assum.1
    exact (by
    have := artin_property_8017 N hN P hP alpha_int8017;
    rw [ ← this, global_permutation_8017 _ |>.1 hcoset ])