/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 6a06c28c-5c48-4f7d-8c08-9d6c3b1cff13

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Formalization of the Dream Theorem for q = 1987. The theorem is proved by combining the separate cases for c(N) = s1 and c(N) = s2, which are established as lemmas `final_result_1987_part1` and `final_result_1987_part2` assuming the period equation.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: d0b4ee60-8218-4a5b-99d3-856046ac8df9

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: ff94a4ce-df04-43b6-855b-2c35922c8831

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We define the cyclotomic field $K = \mathbb{Q}(\zeta_{1129})$, the ring of integers $\mathcal{O}_K$, and the Gaussian periods $\eta_0, \eta_1, \eta_2$. We define the period differences $\alpha, \beta, \gamma$ with the correct sign convention. We prove the Artin property for $\mathcal{O}_K$ and use it to prove the Dream Theorem for $q = 1129$, which relates the Frobenius action on $\alpha$ to the cubic character $c(N)$. The proof assumes the period equation for $\alpha$ as requested.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 49ab742d-7e60-49a0-9635-aa76ebf271b7

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Proof of the Dream Theorem for q = 1063.

We define the cyclotomic field K = Q(zeta_1063), the ring of integers Ok, and the Gaussian periods.
We identify a generator g = 6 such that the cubic character c(g) = s2 = 719.
We define the roots alpha, beta, gamma using this generator and the standard sign convention.
We prove the Artin property for the extension.
We prove the global permutation of roots under the Galois group.
Finally, we prove the Dream Theorem:
If c(N) = s1, then alpha^N = gamma mod P.
If c(N) = s2, then alpha^N = beta mod P.
This relies on the period equation alpha^3 = 1063*alpha + 1063, which is added as a hypothesis.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f1e85200-2efb-4b56-a019-1c5b75f4b05f

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Proof of the Dream Theorem for q = 937.

We define the cyclotomic field K = Q(zeta_937), its ring of integers Ok, and the Gaussian periods.
We identify a generator g = 7 for which the cubic character values match the s1/s2 definitions.
We prove the Artin property for the extension K/Q.
We prove the main theorem `dream_theorem_937` which states that for a prime N != 937:
- If c(N) = s1, then alpha^N = gamma mod P.
- If c(N) = s2, then alpha^N = beta mod P.
This assumes the period equation `alpha^3 = 937*alpha + 937`.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: b08f138a-15ed-40a2-a0c0-b8f4ce6443e1

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We define the cyclotomic field K for q = 877 and the Gaussian periods. We prove the Dream Theorem for q = 877, which states that the Frobenius automorphism maps the period difference α to β or γ depending on the cubic character of the prime N modulo 877. The proof relies on the Artin property of the Frobenius map and the explicit calculation of the Galois action on the periods.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f1f9f2e4-1b7a-4d8c-ad24-d62d489ea7c9

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: a7add749-96ca-48e2-a89d-fbb216918bc3

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 22a1ac83-9054-4f97-9a50-f0ea72bded01

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: e6ee589a-f550-42ef-89e5-1fd2afd7fa5e

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We defined the constants s1, s2, and the value c(N). We proved lemmas characterizing the cosets C1 and C2 in terms of the 12th power residue symbol (which relates to c(N)). Finally, we proved the main theorem `final_result` which establishes the Frobenius action on alpha (i.e., alpha^N) in terms of beta and gamma, depending on the value of c(N). The proof utilizes the `explicit_frobenius` theorem and the algebraic relations between alpha, beta, and gamma.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 939f55fb-68a7-4ef0-bca3-475f675055ca

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
This module formalizes the proof of the Frobenius Orientation conjecture for q=37.
It defines the cyclotomic field K = Q(zeta_37), the Gaussian periods, and the cubic roots.
It proves the cyclic algebraic relations between these roots and establishes the global Galois action.
It descends to the residue field modulo a prime P lying over N != 37, proving the Artin property.
Finally, it derives the explicit Frobenius action on the reduction of alpha modulo P.
-/

import Mathlib

namespace Q1987


set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section














/-
Define q=1987, s1, s2, c(N), and find a primitive root.
-/
def q1987 : ℕ := 1987

instance fact_prime_1987 : Fact (Nat.Prime 1987) := ⟨by native_decide⟩

def s1_1987 : ZMod 1987 := 647
def s2_1987 : ZMod 1987 := 1339

def c1987 (N : ℕ) : ZMod 1987 := (N : ZMod 1987) ^ 662

def find_g_1987 : IO Unit := do
  let p := 1987
  let order := p - 1
  let factors := [2, 3, 331] -- 1986 = 2 * 3 * 331
  for g in [2:100] do
    let mut is_prim := true
    for f in factors do
      if (g ^ (order / f)) % p == 1 then
        is_prim := false
        break
    if is_prim then
      IO.println s!"Found primitive root: {g}"
      return
  IO.println "No primitive root found in range"

#eval find_g_1987

/-
Define the field K1987, the root of unity zeta1987, and the ring of integers Ok1987.
-/
abbrev K1987 := CyclotomicField 1987 ℚ

noncomputable def zeta1987 : K1987 := IsCyclotomicExtension.zeta 1987 ℚ K1987

abbrev Ok1987 := NumberField.RingOfIntegers K1987

/-
The 1987th cyclotomic polynomial is irreducible over Q.
-/
theorem h_irr_1987 : Irreducible (Polynomial.cyclotomic 1987 ℚ) := by
  exact Polynomial.cyclotomic.irreducible_rat <| by norm_num;

/-
Define the Galois automorphism sigma1987.
-/
noncomputable def sigma1987 (n : (ZMod 1987)ˣ) : K1987 ≃ₐ[ℚ] K1987 :=
  (IsCyclotomicExtension.autEquivPow K1987 h_irr_1987).symm n

/-
zeta1987 is an algebraic integer.
-/
theorem zeta_isIntegral_1987 : IsIntegral ℤ zeta1987 := by
  refine' ⟨ Polynomial.X ^ 1987 - 1, _, _ ⟩;
  · exact Polynomial.monic_X_pow_sub_C _ ( by norm_num );
  · simp +decide [ ← map_pow, zeta1987 ];
    rw [ sub_eq_zero, IsCyclotomicExtension.zeta_pow ]

/-
Define zeta_int1987 and sigma_int1987.
-/
def zeta_int1987 : Ok1987 := ⟨zeta1987, zeta_isIntegral_1987⟩

noncomputable def sigma_int1987 (n : (ZMod 1987)ˣ) : Ok1987 ≃ₐ[ℤ] Ok1987 :=
  (NumberField.RingOfIntegers.mapAlgEquiv (sigma1987 n)).restrictScalars ℤ

/-
Define the generator g=2 and the cosets H, C1, C2 for q=1987.
-/
def g1987 : ZMod 1987 := 2

def H1987 : Finset (ZMod 1987) := ((Finset.univ : Finset (ZMod 1987)).filter (fun x => x ≠ 0)).image (fun x => x^3)

def C1_1987 : Finset (ZMod 1987) := H1987.image (fun x => g1987 * x)

def C2_1987 : Finset (ZMod 1987) := H1987.image (fun x => g1987^2 * x)

/-
Define Gaussian periods and differences for q=1987.
-/
open scoped BigOperators

noncomputable def eta1987 (S : Finset (ZMod 1987)) : K1987 := ∑ x ∈ S, zeta1987^(x.val)

noncomputable def eta0_1987 := eta1987 H1987
noncomputable def eta1_1987 := eta1987 C1_1987
noncomputable def eta2_1987 := eta1987 C2_1987

noncomputable def alpha_prime_1987 := eta0_1987 - eta1_1987
noncomputable def beta_prime_1987 := eta1_1987 - eta2_1987
noncomputable def gamma_prime_1987 := eta2_1987 - eta0_1987

/-
Define integral Gaussian periods and differences for q=1987.
-/
noncomputable def eta_int1987 (S : Finset (ZMod 1987)) : Ok1987 := ∑ x ∈ S, zeta_int1987^(x.val)

noncomputable def eta0_int1987 := eta_int1987 H1987
noncomputable def eta1_int1987 := eta_int1987 C1_1987
noncomputable def eta2_int1987 := eta_int1987 C2_1987

noncomputable def alpha_prime_int1987 := eta0_int1987 - eta1_int1987
noncomputable def beta_prime_int1987 := eta1_int1987 - eta2_int1987
noncomputable def gamma_prime_int1987 := eta2_int1987 - eta0_int1987

/-
Define sign-corrected roots alpha, beta, gamma for q=1987.
-/
noncomputable def sign_1987 : ℤ :=
  if alpha_prime_int1987 * beta_prime_int1987 * gamma_prime_int1987 = (1987 : Ok1987) then 1 else -1

noncomputable def alpha_int1987 := (sign_1987 : Ok1987) * alpha_prime_int1987
noncomputable def beta_int1987 := (sign_1987 : Ok1987) * beta_prime_int1987
noncomputable def gamma_int1987 := (sign_1987 : Ok1987) * gamma_prime_int1987

noncomputable def alpha1987_field : K1987 := alpha_int1987
noncomputable def beta1987_field : K1987 := beta_int1987
noncomputable def gamma1987_field : K1987 := gamma_int1987

/-
Compute coefficients for the algebraic relations of beta and gamma in terms of alpha for q=1987.
-/
def find_coeffs_1987 : IO Unit := do
  let q := 1987
  let a := 89
  -- Find p = k*q + 1
  let mut p := 0
  for k in [2:200] do
    let cand := k * q + 1
    if Nat.Prime cand then
      p := cand
      break
  
  if p == 0 then
    IO.println "No prime found"
    return

  IO.println s!"Using prime p = {p}"

  -- Find element of order q
  let mut g_p := 0
  for g in [2:p] do
    let zeta := (g : Nat) ^ ((p - 1) / q) % p
    if zeta != 1 then
      g_p := g
      break
  
  let zeta := (g_p : Nat) ^ ((p - 1) / q) % p
  IO.println s!"zeta = {zeta}"

  -- Cosets of cubic residues mod q
  -- g_q = 2
  let g_q := 2
  let mut H : List Nat := []
  let mut x := 1
  let g_q_3 := (g_q * g_q * g_q) % q
  for _ in [0:(q-1)/3] do
    H := x :: H
    x := (x * g_q_3) % q
  
  let C1 := H.map (fun h => (h * g_q) % q)
  let C2 := H.map (fun h => (h * g_q * g_q) % q)

  -- Periods mod p
  let sum_zeta (S : List Nat) : Nat :=
    S.foldl (fun acc h => (acc + (zeta ^ h) % p) % p) 0
  
  let eta0 := sum_zeta H
  let eta1 := sum_zeta C1
  let eta2 := sum_zeta C2

  -- Differences
  let alpha_prime := (eta0 + p - eta1) % p
  let beta_prime := (eta1 + p - eta2) % p
  let gamma_prime := (eta2 + p - eta0) % p

  -- Check sign convention
  let prod := (alpha_prime * beta_prime) % p * gamma_prime % p
  let q_mod_p := q % p
  
  let mut alpha := 0
  let mut beta := 0
  let mut gamma := 0

  if prod == q_mod_p then
    alpha := alpha_prime
    beta := beta_prime
    gamma := gamma_prime
    IO.println "Sign convention: positive"
  else
    alpha := (p - alpha_prime) % p
    beta := (p - beta_prime) % p
    gamma := (p - gamma_prime) % p
    IO.println "Sign convention: negative"

  -- Solve 89 * beta = c0 + c1 * alpha + c2 * alpha^2 mod p
  let sub (x y : Nat) := (x + p - y) % p
  let mul (x y : Nat) := (x * y) % p
  let add (x y : Nat) := (x + y) % p
  let pow (x n : Nat) := x ^ n % p
  let inv (x : Nat) := x ^ (p - 2) % p

  let det := mul (sub beta alpha) (mul (sub gamma alpha) (sub gamma beta))
  let det_inv := inv det

  let rhs0 := mul 89 beta
  let rhs1 := mul 89 gamma
  let rhs2 := mul 89 alpha

  -- Solve for c0, c1, c2
  -- c0
  let term0 := mul rhs0 (sub (mul beta (mul gamma gamma)) (mul gamma (mul beta beta)))
  let term1 := mul rhs1 (sub (mul gamma (mul alpha alpha)) (mul alpha (mul gamma gamma)))
  let term2 := mul rhs2 (sub (mul alpha (mul beta beta)) (mul beta (mul alpha alpha)))
  let c0 := mul (add term0 (add term1 term2)) det_inv

  -- c1
  let term0_1 := mul 1 (sub (mul rhs1 (mul gamma gamma)) (mul rhs2 (mul beta beta)))
  let term1_1 := mul 1 (sub (mul rhs2 (mul alpha alpha)) (mul rhs0 (mul gamma gamma)))
  let term2_1 := mul 1 (sub (mul rhs0 (mul beta beta)) (mul rhs1 (mul alpha alpha)))
  let c1 := mul (add term0_1 (add term1_1 term2_1)) det_inv

  -- c2
  let term0_2 := mul 1 (sub (mul beta rhs2) (mul gamma rhs1))
  let term1_2 := mul 1 (sub (mul gamma rhs0) (mul alpha rhs2))
  let term2_2 := mul 1 (sub (mul alpha rhs1) (mul beta rhs0))
  let c2 := mul (add term0_2 (add term1_2 term2_2)) det_inv

  let to_signed (x : Nat) : Int :=
    if x > p / 2 then (x : Int) - p else x

  IO.println s!"Coefficients for beta: c0={to_signed c0}, c1={to_signed c1}, c2={to_signed c2}"
  
  -- Also for gamma
  let rhs0_g := mul 89 gamma
  let rhs1_g := mul 89 alpha
  let rhs2_g := mul 89 beta

  let term0_g := mul rhs0_g (sub (mul beta (mul gamma gamma)) (mul gamma (mul beta beta)))
  let term1_g := mul rhs1_g (sub (mul gamma (mul alpha alpha)) (mul alpha (mul gamma gamma)))
  let term2_g := mul rhs2_g (sub (mul alpha (mul beta beta)) (mul beta (mul alpha alpha)))
  let d0 := mul (add term0_g (add term1_g term2_g)) det_inv

  let term0_1g := mul 1 (sub (mul rhs1_g (mul gamma gamma)) (mul rhs2_g (mul beta beta)))
  let term1_1g := mul 1 (sub (mul rhs2_g (mul alpha alpha)) (mul rhs0_g (mul gamma gamma)))
  let term2_1g := mul 1 (sub (mul rhs0_g (mul beta beta)) (mul rhs1_g (mul alpha alpha)))
  let d1 := mul (add term0_1g (add term1_1g term2_1g)) det_inv

  let term0_2g := mul 1 (sub (mul beta rhs2_g) (mul gamma rhs1_g))
  let term1_2g := mul 1 (sub (mul gamma rhs0_g) (mul alpha rhs2_g))
  let term2_2g := mul 1 (sub (mul alpha rhs1_g) (mul beta rhs0_g))
  let d2 := mul (add term0_2g (add term1_2g term2_2g)) det_inv

  IO.println s!"Coefficients for gamma: d0={to_signed d0}, d1={to_signed d1}, d2={to_signed d2}"

#eval find_coeffs_1987

/-
Check s-values and define DreamAssumptions_1987.
-/
def check_s_values_1987 : IO Unit := do
  let q := 1987
  let g := 2
  let s1 := 647
  let s2 := 1339
  let c (n : Nat) := (n : Nat) ^ 662 % q
  
  let cg := c g
  let cg2 := c (g * g)
  
  IO.println s!"c(g) = {cg}"
  IO.println s!"c(g^2) = {cg2}"
  
  if cg == s1 then IO.println "s1 corresponds to C1 (beta)"
  else if cg == s2 then IO.println "s2 corresponds to C1 (beta)"
  else IO.println "s1/s2 do not match C1"

  if cg2 == s1 then IO.println "s1 corresponds to C2 (gamma)"
  else if cg2 == s2 then IO.println "s2 corresponds to C2 (gamma)"
  else IO.println "s1/s2 do not match C2"

#eval check_s_values_1987

def DreamAssumptions_1987 : Prop :=
  alpha_int1987^3 = 1987 * alpha_int1987 + 1987 ∧
  alpha_int1987 * beta_int1987 * gamma_int1987 = 1987 ∧
  89 * beta_int1987 = -3 * alpha_int1987^2 - 40 * alpha_int1987 + 3974 ∧
  89 * gamma_int1987 = 3 * alpha_int1987^2 - 49 * alpha_int1987 - 3974

/-
Define N as a unit in ZMod 1987.
-/
def N_mod_1987 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 1987) : (ZMod 1987)ˣ :=
  ZMod.unitOfCoprime N (Nat.Coprime.symm ((Nat.coprime_primes (by norm_num) (Fact.out)).mpr hN.symm))

/-
sigma_int maps zeta to zeta^n.
-/
lemma sigma_int_zeta_pow_1987 (n : (ZMod 1987)ˣ) :
  sigma_int1987 n zeta_int1987 = zeta_int1987 ^ (n : ZMod 1987).val := by
    have h_sigma_int_zeta : (sigma1987 n) zeta1987 = zeta1987 ^ (n : ZMod 1987).val := by
      simp [sigma1987];
      rw [ PowerBasis.equivOfMinpoly_apply ];
      erw [ PowerBasis.lift_gen ];
      rfl;
    exact?

/-
Find a generator g such that c(g) = s2.
-/
def find_correct_g_1987 : IO Unit := do
  let q := 1987
  let s2 := 1339
  let c (n : Nat) := (n : Nat) ^ 662 % q
  
  for g in [2:100] do
    -- Check if primitive root
    let mut is_prim := true
    let factors := [2, 3, 331]
    for f in factors do
      if (g ^ (1986 / f)) % q == 1 then
        is_prim := false
        break
    
    if is_prim then
      if c g == s2 then
        IO.println s!"Found good generator: {g}"
        return
  
  IO.println "No generator found"

#eval find_correct_g_1987

/-
Define periods and roots for g=5.
-/
def g5 : ZMod 1987 := 5

def C1_5 : Finset (ZMod 1987) := H1987.image (fun x => g5 * x)
def C2_5 : Finset (ZMod 1987) := H1987.image (fun x => g5^2 * x)

noncomputable def eta1_int_5 := eta_int1987 C1_5
noncomputable def eta2_int_5 := eta_int1987 C2_5

noncomputable def alpha_prime_int_5 := eta0_int1987 - eta1_int_5
noncomputable def beta_prime_int_5 := eta1_int_5 - eta2_int_5
noncomputable def gamma_prime_int_5 := eta2_int_5 - eta0_int1987

noncomputable def sign_5 : ℤ :=
  if alpha_prime_int_5 * beta_prime_int_5 * gamma_prime_int_5 = (1987 : Ok1987) then 1 else -1

noncomputable def alpha_int_5 := (sign_5 : Ok1987) * alpha_prime_int_5
noncomputable def beta_int_5 := (sign_5 : Ok1987) * beta_prime_int_5
noncomputable def gamma_int_5 := (sign_5 : Ok1987) * gamma_prime_int_5

/-
The Artin property holds for zeta: sigma_N(zeta) = zeta^N mod P.
-/
theorem artin_property_zeta_1987 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 1987) (P : Ideal Ok1987) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  Ideal.Quotient.mk P (sigma_int1987 (N_mod_1987 N hN) zeta_int1987) = (Ideal.Quotient.mk P zeta_int1987)^N := by
    have h_artin : ∀ (g : (ZMod 1987)ˣ), (Ideal.Quotient.mk P (sigma_int1987 g zeta_int1987)) = (Ideal.Quotient.mk P zeta_int1987) ^ (g.val.val : ℕ) := by
      intro g
      have h_sigma_g : sigma_int1987 g zeta_int1987 = zeta_int1987 ^ (g.val.val : ℕ) := by
        exact?;
      rw [ h_sigma_g, map_pow ];
    -- Since $N$ is a unit modulo $1987$, we have $(N_mod_1987 N hN).val.val = N \mod 1987$.
    have h_unit : (N_mod_1987 N hN).val.val = N % 1987 := by
      unfold N_mod_1987; norm_num;
    rw [ h_artin, h_unit, ← Nat.mod_add_div N 1987, pow_add, pow_mul ] ; norm_num;
    -- Since $zeta_int1987$ is a root of unity, we have $zeta_int1987^{1987} = 1$.
    have h_root_of_unity : zeta_int1987 ^ 1987 = 1 := by
      have h_zeta_pow : zeta_int1987 ^ 1987 = 1 := by
        have h_zeta_pow : zeta1987 ^ 1987 = 1 := by
          have h_zeta_pow : IsPrimitiveRoot zeta1987 1987 := by
            convert IsCyclotomicExtension.zeta_spec 1987 ℚ K1987 using 1;
          exact h_zeta_pow.pow_eq_one
        exact Subtype.ext h_zeta_pow;
      exact h_zeta_pow;
    erw [ Ideal.Quotient.eq ] at * ; aesop ( simp_config := { singlePass := true } ) ;

/-
zeta_int^n depends only on n mod 1987.
-/
lemma zeta_int_pow_eq_pow_mod_1987 (n : ℕ) : zeta_int1987 ^ n = zeta_int1987 ^ (n % 1987) := by
  -- Since $zeta$ is a primitive 1987th root of unity, we have $zeta^{1987} = 1$.
  have h_root : zeta_int1987 ^ 1987 = 1 := by
    have h_zeta_pow : zeta1987 ^ 1987 = 1 := by
      exact IsCyclotomicExtension.zeta_pow _ _ _;
    exact Subtype.ext h_zeta_pow;
  rw [ ← Nat.mod_add_div n 1987, pow_add, pow_mul ] ; aesop

/-
The Artin property holds for zeta: sigma_N(zeta) = zeta^N mod P.
-/
theorem artin_property_zeta_1987_v2 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 1987) (P : Ideal Ok1987) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  Ideal.Quotient.mk P (sigma_int1987 (N_mod_1987 N hN) zeta_int1987) = (Ideal.Quotient.mk P zeta_int1987)^N := by
    convert artin_property_zeta_1987 N hN P hP using 1

/-
The ring of integers Ok1987 is generated by zeta_int1987.
-/
theorem Ok1987_eq_adjoin : (⊤ : Subalgebra ℤ Ok1987) = Algebra.adjoin ℤ {zeta_int1987} := by
  have h_int_ring : IsCyclotomicExtension {1987} ℤ (NumberField.RingOfIntegers (CyclotomicField 1987 ℚ)) := by
    infer_instance;
  have := h_int_ring;
  have := this.adjoin_primitive_root_eq_top ( show IsPrimitiveRoot ( zeta_int1987 : NumberField.RingOfIntegers ( CyclotomicField 1987 ℚ ) ) 1987 from ?_ ) ; aesop;
  convert IsCyclotomicExtension.zeta_spec 1987 ℚ ( CyclotomicField 1987 ℚ ) using 1;
  ext; simp [zeta_int1987];
  simp +decide [ IsPrimitiveRoot.iff_def ];
  congr! 2;
  · erw [ Subtype.mk_eq_mk ] ; aesop;
  · erw [ Subtype.mk_eq_mk ] ; aesop

/-
The characteristic of Ok1987/P is N.
-/
lemma char_Ok1987_quot_P (N : ℕ) [Fact (Nat.Prime N)] (P : Ideal Ok1987) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  CharP (Ok1987 ⧸ P) N := by
    have := hP.1;
    rw [ eq_comm ] at this;
    rw [ Ideal.ext_iff ] at this;
    constructor;
    intro x; specialize this x; simp_all +decide [ Ideal.mem_span_singleton ] ;
    erw [ Ideal.Quotient.eq_zero_iff_mem ] ; norm_cast at *

/-
The Artin property holds for all elements of Ok1987.
-/
theorem artin_property_1987_v2 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 1987) (P : Ideal Ok1987) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) (x : Ok1987) :
  Ideal.Quotient.mk P (sigma_int1987 (N_mod_1987 N hN) x) = (Ideal.Quotient.mk P x)^N := by
    have h_int : ∀ x : Ok1987, (Ideal.Quotient.mk P (sigma_int1987 (N_mod_1987 N hN) x)) = (Ideal.Quotient.mk P x)^N := by
      have h_gen : ∀ x : Ok1987, x ∈ Algebra.adjoin ℤ {zeta_int1987} := by
        rw [ ← Ok1987_eq_adjoin ] at * ; aesop
      have h_induction : ∀ x : Ok1987, x ∈ Algebra.adjoin ℤ {zeta_int1987} → (Ideal.Quotient.mk P (sigma_int1987 (N_mod_1987 N hN) x)) = (Ideal.Quotient.mk P x)^N := by
        apply Algebra.adjoin_induction;
        · convert artin_property_zeta_1987_v2 N hN P hP using 1;
          simp +decide [ Ideal.Quotient.eq_zero_iff_mem ];
        · intro r;
          erw [ Ideal.Quotient.eq ];
          have := hP.1;
          rw [ Ideal.ext_iff ] at this;
          specialize this ( r ^ N - r ) ; simp_all +decide [ Ideal.mem_span_singleton ];
          rw [ ← neg_sub, Ideal.neg_mem_iff ] ; haveI := Fact.mk ( Fact.out : Nat.Prime N ) ; simp_all +decide [ ← ZMod.intCast_zmod_eq_zero_iff_dvd, sub_eq_iff_eq_add ] ;
        · intro x y hx hy hx' hy';
          have h_char : ∀ (a b : Ok1987 ⧸ P), (a + b) ^ N = a ^ N + b ^ N := by
            intro a b
            have h_char : ∀ (n : ℕ), (a + b) ^ (N ^ n) = a ^ (N ^ n) + b ^ (N ^ n) := by
              intro n
              induction' n with n ih;
              · norm_num;
              · rw [ pow_succ, pow_mul, pow_mul, pow_mul, ih ];
                haveI := char_Ok1987_quot_P N P hP; simp +decide [ add_pow_char ] ;
            simpa using h_char 1;
          convert congr_arg₂ ( · + · ) hx' hy' using 1;
          · exact congr_arg _ ( map_add _ _ _ );
          · convert h_char ( Ideal.Quotient.mk P x ) ( Ideal.Quotient.mk P y ) using 1;
        · simp +contextual [ mul_pow ];
      exact fun x => h_induction x ( h_gen x );
    exact h_int x

/-
Integers are fixed by the Frobenius map modulo P.
-/
lemma frobenius_int_1987 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 1987) (P : Ideal Ok1987) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) (r : ℤ) :
  (Ideal.Quotient.mk P (r : Ok1987))^N = Ideal.Quotient.mk P (r : Ok1987) := by
    convert artin_property_1987_v2 N hN P hP _ using 1;
    convert artin_property_1987_v2 N hN P hP _ using 1;
    convert artin_property_1987_v2 N hN P hP _ using 1;
    convert artin_property_1987_v2 N hN P hP _ using 1;
    convert artin_property_1987_v2 N hN P hP _ using 1;
    any_goals exact ( algebraMap ℤ Ok1987 ) r;
    all_goals rw [ ← artin_property_1987_v2 N hN P hP ];
    · rfl;
    · erw [ AlgEquiv.commutes ];
      rfl

/-
Check availability of frobenius_int_1987 and artin_property_1987_v2.
-/
#check frobenius_int_1987
#check artin_property_1987_v2

/-
Integers are fixed by the Frobenius map modulo P.
-/
lemma frobenius_int_1987_v2 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 1987) (P : Ideal Ok1987) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) (r : ℤ) :
  (Ideal.Quotient.mk P (r : Ok1987))^N = Ideal.Quotient.mk P (r : Ok1987) := by
    -- Apply the hypothesis `h_frobenius_int` to conclude the proof.
    apply frobenius_int_1987 N hN P hP r

/-
Integers are fixed by the Frobenius map modulo P.
-/
lemma frobenius_int_1987_v3 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 1987) (P : Ideal Ok1987) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) (r : ℤ) :
  (Ideal.Quotient.mk P (r : Ok1987))^N = Ideal.Quotient.mk P (r : Ok1987) := by
    convert frobenius_int_1987 N hN P hP r

/-
The Artin property holds for all elements of Ok1987.
-/
theorem artin_property_1987_v3 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 1987) (P : Ideal Ok1987) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) (x : Ok1987) :
  Ideal.Quotient.mk P (sigma_int1987 (N_mod_1987 N hN) x) = (Ideal.Quotient.mk P x)^N := by
    convert artin_property_1987_v2 N hN P hP x using 1

/-
sigma_n(eta_S) = eta_{nS}
-/
lemma sigma_eta_1987 (n : (ZMod 1987)ˣ) (S : Finset (ZMod 1987)) :
  sigma_int1987 n (eta_int1987 S) = eta_int1987 (S.image (fun x => (n : ZMod 1987) * x)) := by
    unfold eta_int1987;
    -- Apply the definition of `sigma_int1987` and the fact that it is a ring homomorphism.
    have h_sigma_hom : ∀ (x : ZMod 1987), sigma_int1987 n (zeta_int1987 ^ x.val) = zeta_int1987 ^ ((n : ZMod 1987) * x).val := by
      intro x
      have h_sigma_hom : sigma_int1987 n (zeta_int1987 ^ x.val) = (sigma_int1987 n zeta_int1987) ^ x.val := by
        exact map_pow _ _ _;
      rw [ h_sigma_hom, sigma_int_zeta_pow_1987 ];
      rw [ ← pow_mul, ZMod.val_mul ];
      exact?;
    rw [ map_sum, Finset.sum_image ];
    · exact Finset.sum_congr rfl fun x hx => h_sigma_hom x;
    · exact fun x hx y hy hxy => mul_left_cancel₀ ( Units.ne_zero n ) hxy

/-
Multiplication by an element of H permutes the cosets trivially.
-/
lemma action_H_1987 (n : ZMod 1987) (hn : n ∈ H1987) :
  H1987.image (fun x => n * x) = H1987 ∧
  C1_1987.image (fun x => n * x) = C1_1987 ∧
  C2_1987.image (fun x => n * x) = C2_1987 := by
    revert hn;
    -- Let's unfold the definition of $H1987$, $C1_1987$, and $C2_1987$.
    simp [H1987, C1_1987, C2_1987];
    revert n;
    intros n x hx hxn
    have h_image : Finset.image (fun x => n * x) (Finset.image (fun x => x^3) (Finset.filter (fun x => x ≠ 0) (Finset.univ : Finset (ZMod 1987)))) = Finset.image (fun x => x^3) (Finset.filter (fun x => x ≠ 0) (Finset.univ : Finset (ZMod 1987))) := by
      ext y;
      simp +decide [ ← hxn, mul_assoc ];
      constructor <;> rintro ⟨ a, ha, rfl ⟩;
      · exact ⟨ x * a, mul_ne_zero hx ha, by ring ⟩;
      · -- Since $x \neq 0$, we can take $a_1 = a / x$.
        use a / x;
        grind;
    have h_image_C1 : Finset.image (fun x => n * x) (Finset.image (fun x => g1987 * x) (Finset.image (fun x => x^3) (Finset.filter (fun x => x ≠ 0) (Finset.univ : Finset (ZMod 1987))))) = Finset.image (fun x => g1987 * x) (Finset.image (fun x => n * x) (Finset.image (fun x => x^3) (Finset.filter (fun x => x ≠ 0) (Finset.univ : Finset (ZMod 1987))))) := by
      ext; simp +decide [ mul_assoc, mul_comm, mul_left_comm ] ;
    have h_image_C2 : Finset.image (fun x => n * x) (Finset.image (fun x => g1987^2 * x) (Finset.image (fun x => x^3) (Finset.filter (fun x => x ≠ 0) (Finset.univ : Finset (ZMod 1987))))) = Finset.image (fun x => g1987^2 * x) (Finset.image (fun x => n * x) (Finset.image (fun x => x^3) (Finset.filter (fun x => x ≠ 0) (Finset.univ : Finset (ZMod 1987))))) := by
      simp +decide only [Finset.image_image];
      exact Finset.image_congr fun x hx => by simp +decide [ mul_assoc, mul_comm, mul_left_comm ] ;
    grind +ring

/-
Multiplication by an element of H permutes the cosets trivially.
-/
lemma action_H_1987_v2 (n : ZMod 1987) (hn : n ∈ H1987) :
  H1987.image (fun x => n * x) = H1987 ∧
  C1_1987.image (fun x => n * x) = C1_1987 ∧
  C2_1987.image (fun x => n * x) = C2_1987 := by
    exact?

/-
Multiplication by an element of C1 permutes the cosets cyclically.
-/
lemma action_C1_1987 (n : ZMod 1987) (hn : n ∈ C1_1987) :
  H1987.image (fun x => n * x) = C1_1987 ∧
  C1_1987.image (fun x => n * x) = C2_1987 ∧
  C2_1987.image (fun x => n * x) = H1987 := by
    -- Since $n \in C1_1987$, there exists $m \in H1987$ such that $n = g1987 * m$.
    obtain ⟨m, hm⟩ : ∃ m ∈ H1987, n = g1987 * m := by
      native_decide +revert;
    have h_mul_H : H1987.image (fun x => m * x) = H1987 ∧ C1_1987.image (fun x => m * x) = C1_1987 ∧ C2_1987.image (fun x => m * x) = C2_1987 := by
      exact action_H_1987 m hm.1;
    have h_mul_g1987 : H1987.image (fun x => g1987 * x) = C1_1987 ∧ C1_1987.image (fun x => g1987 * x) = C2_1987 ∧ C2_1987.image (fun x => g1987 * x) = H1987 := by
      native_decide +revert;
    have h_mul_g1987_m : Finset.image (fun x => g1987 * m * x) H1987 = Finset.image (fun x => g1987 * x) (Finset.image (fun x => m * x) H1987) ∧ Finset.image (fun x => g1987 * m * x) C1_1987 = Finset.image (fun x => g1987 * x) (Finset.image (fun x => m * x) C1_1987) ∧ Finset.image (fun x => g1987 * m * x) C2_1987 = Finset.image (fun x => g1987 * x) (Finset.image (fun x => m * x) C2_1987) := by
      simp +decide only [mul_assoc, Finset.image_image];
      exact ⟨ rfl, rfl, rfl ⟩;
    grind +ring

/-
Multiplication by an element of H permutes the cosets trivially.
-/
lemma action_H_1987_v3 (n : ZMod 1987) (hn : n ∈ H1987) :
  H1987.image (fun x => n * x) = H1987 ∧
  C1_1987.image (fun x => n * x) = C1_1987 ∧
  C2_1987.image (fun x => n * x) = C2_1987 := by
    exact?

/-
Multiplication by an element of H permutes the cosets trivially.
-/
lemma action_H_1987_v4 (n : ZMod 1987) (hn : n ∈ H1987) :
  H1987.image (fun x => n * x) = H1987 ∧
  C1_1987.image (fun x => n * x) = C1_1987 ∧
  C2_1987.image (fun x => n * x) = C2_1987 := by
    exact?

/-
Multiplication by an element of H permutes the cosets trivially.
-/
lemma action_H_1987_v5 (n : ZMod 1987) (hn : n ∈ H1987) :
  H1987.image (fun x => n * x) = H1987 ∧
  C1_1987.image (fun x => n * x) = C1_1987 ∧
  C2_1987.image (fun x => n * x) = C2_1987 := by
    exact?

/-
Multiplication by an element of H permutes the cosets trivially.
-/
lemma action_H_1987_v6 (n : ZMod 1987) (hn : n ∈ H1987) :
  H1987.image (fun x => n * x) = H1987 ∧
  C1_1987.image (fun x => n * x) = C1_1987 ∧
  C2_1987.image (fun x => n * x) = C2_1987 := by
    exact?

/-
Multiplication by an element of H permutes the cosets trivially.
-/
lemma action_H_1987_v7 (n : ZMod 1987) (hn : n ∈ H1987) :
  H1987.image (fun x => n * x) = H1987 ∧
  C1_1987.image (fun x => n * x) = C1_1987 ∧
  C2_1987.image (fun x => n * x) = C2_1987 := by
    -- Apply the lemma that states multiplication by an element of H_permutes the cosets trivially.
    apply action_H_1987_v6 n hn

/-
Multiplication by an element of H permutes the cosets trivially.
-/
lemma action_H_1987_v8 (n : ZMod 1987) (hn : n ∈ H1987) :
  H1987.image (fun x => n * x) = H1987 ∧
  C1_1987.image (fun x => n * x) = C1_1987 ∧
  C2_1987.image (fun x => n * x) = C2_1987 := by
    exact?

/-
Multiplication by an element of C1 permutes the cosets cyclically.
-/
lemma action_C1_1987_v2 (n : ZMod 1987) (hn : n ∈ C1_1987) :
  H1987.image (fun x => n * x) = C1_1987 ∧
  C1_1987.image (fun x => n * x) = C2_1987 ∧
  C2_1987.image (fun x => n * x) = H1987 := by
    exact?

/-
Multiplication by an element of C2 permutes the cosets cyclically.
-/
lemma action_C2_1987_v2 (n : ZMod 1987) (hn : n ∈ C2_1987) :
  H1987.image (fun x => n * x) = C2_1987 ∧
  C1_1987.image (fun x => n * x) = H1987 ∧
  C2_1987.image (fun x => n * x) = C1_1987 := by
    revert hn;
    -- By definition of $C2_1987$, we know that $n \in C2_1987$ implies $n = g * h$ for some $g \in H1987$ and $h \in C2_1987$.
    intro hn
    obtain ⟨g, hg⟩ : ∃ g ∈ H1987, n = g * 2^2 := by
      native_decide +revert;
    -- Since $g \in H1987$, multiplying by $g$ permutes $H1987$, $C1_1987$, and $C2_1987$ trivially.
    have h_perm : Finset.image (fun x => g * x) H1987 = H1987 ∧ Finset.image (fun x => g * x) C1_1987 = C1_1987 ∧ Finset.image (fun x => g * x) C2_1987 = C2_1987 := by
      exact action_H_1987_v8 g hg.1 |> fun h => ⟨ h.1, h.2.1, h.2.2 ⟩;
    have h_perm_2 : Finset.image (fun x => 2^2 * x) H1987 = C2_1987 ∧ Finset.image (fun x => 2^2 * x) C1_1987 = H1987 ∧ Finset.image (fun x => 2^2 * x) C2_1987 = C1_1987 := by
      native_decide +revert;
    have h_perm_combined : Finset.image (fun x => n * x) H1987 = Finset.image (fun x => g * x) (Finset.image (fun x => 2^2 * x) H1987) ∧ Finset.image (fun x => n * x) C1_1987 = Finset.image (fun x => g * x) (Finset.image (fun x => 2^2 * x) C1_1987) ∧ Finset.image (fun x => n * x) C2_1987 = Finset.image (fun x => g * x) (Finset.image (fun x => 2^2 * x) C2_1987) := by
      simp +decide [ hg.2, mul_assoc, Finset.image_image ];
    grind +ring

/-
Multiplication by an element of C1 permutes the cosets cyclically.
-/
lemma action_C1_1987_v3 (n : ZMod 1987) (hn : n ∈ C1_1987) :
  H1987.image (fun x => n * x) = C1_1987 ∧
  C1_1987.image (fun x => n * x) = C2_1987 ∧
  C2_1987.image (fun x => n * x) = H1987 := by
    exact?

/-
Multiplication by an element of C1 permutes the cosets cyclically.
-/
lemma action_C1_1987_v4 (n : ZMod 1987) (hn : n ∈ C1_1987) :
  H1987.image (fun x => n * x) = C1_1987 ∧
  C1_1987.image (fun x => n * x) = C2_1987 ∧
  C2_1987.image (fun x => n * x) = H1987 := by
    convert action_C1_1987_v3 n hn using 1

/-
Multiplication by an element of C2 permutes the cosets cyclically.
-/
lemma action_C2_1987_v3 (n : ZMod 1987) (hn : n ∈ C2_1987) :
  H1987.image (fun x => n * x) = C2_1987 ∧
  C1_1987.image (fun x => n * x) = H1987 ∧
  C2_1987.image (fun x => n * x) = C1_1987 := by
    exact?

/-
Multiplication by an element of C2 permutes the cosets cyclically.
-/
lemma action_C2_1987_v4 (n : ZMod 1987) (hn : n ∈ C2_1987) :
  H1987.image (fun x => n * x) = C2_1987 ∧
  C1_1987.image (fun x => n * x) = H1987 ∧
  C2_1987.image (fun x => n * x) = C1_1987 := by
    exact?

/-
H stabilizes C1_5 and C2_5.
-/
lemma action_H_5 (n : ZMod 1987) (hn : n ∈ H1987) :
  H1987.image (fun x => n * x) = H1987 ∧
  C1_5.image (fun x => n * x) = C1_5 ∧
  C2_5.image (fun x => n * x) = C2_5 := by
    -- Since $n \in H1987$, multiplying any element of $H1987$ by $n$ will still be in $H1987$.
    have hH : H1987.image (fun x => n * x) = H1987 := by
      exact action_H_1987_v8 n hn |>.1;
    refine' ⟨ hH, _, _ ⟩;
    · ext x_5;
      simp +decide only [Finset.mem_image] at hH ⊢;
      constructor;
      · rintro ⟨ a, ha, rfl ⟩;
        rw [ Finset.ext_iff ] at hH;
        obtain ⟨ b, hb, rfl ⟩ := Finset.mem_image.mp ha;
        exact Finset.mem_image.mpr ⟨ _, hH _ |>.1 ( Finset.mem_image.mpr ⟨ _, hb, rfl ⟩ ), by ring ⟩;
      · intro hx_5;
        obtain ⟨ y, hy, rfl ⟩ := Finset.mem_image.mp hx_5;
        obtain ⟨ z, hz, rfl ⟩ := Finset.mem_image.mp ( hH.symm ▸ hy );
        exact ⟨ g5 * z, Finset.mem_image.mpr ⟨ z, hz, rfl ⟩, by ring ⟩;
    · ext x;
      field_simp;
      rw [ Finset.ext_iff ] at hH;
      simp +decide only [Finset.mem_image] at hH ⊢;
      unfold C2_5; simp +decide [ hn, hH ] ;
      constructor <;> rintro ⟨ a, ha, rfl ⟩;
      · exact ⟨ n * a, hH _ |>.1 ⟨ a, ha, rfl ⟩, by ring ⟩;
      · grind

/-
The Galois automorphism sigma_n permutes alpha, beta, gamma according to the coset of n.
-/
theorem global_permutation_1987 (n : (ZMod 1987)ˣ) :
  ((n : ZMod 1987) ∈ C1_1987 → sigma_int1987 n alpha_int1987 = beta_int1987) ∧
  ((n : ZMod 1987) ∈ C2_1987 → sigma_int1987 n alpha_int1987 = gamma_int1987) ∧
  ((n : ZMod 1987) ∈ H1987 → sigma_int1987 n alpha_int1987 = alpha_int1987) := by
    have := @action_H_1987_v8;
    have := @action_C1_1987_v3;
    have := @action_C2_1987_v4;
    have := @sigma_eta_1987;
    unfold alpha_int1987 beta_int1987 gamma_int1987;
    unfold alpha_prime_int1987 beta_prime_int1987 gamma_prime_int1987;
    unfold eta0_int1987 eta1_int1987 eta2_int1987;
    simp +contextual [ *, map_mul, map_sub ]

/-
c1987 is multiplicative.
-/
lemma c1987_mul (x y : ℕ) : c1987 (x * y) = c1987 x * c1987 y := by
  unfold c1987
  push_cast
  rw [mul_pow]

/-
c1987 is 1 on H.
-/
lemma c1987_val_H (x : ZMod 1987) (hx : x ∈ H1987) : c1987 x.val = 1 := by
  native_decide +revert

/-
Check if c(5) = s2.
-/
def check_c5_1987 : IO Unit := do
  let q := 1987
  let s1 := 647
  let s2 := 1339
  let c (n : Nat) := (n : Nat) ^ 662 % q
  let c5 := c 5
  IO.println s!"c(5) = {c5}"
  if c5 == s2 then IO.println "c(5) = s2 (Correct for user theorem)"
  else if c5 == s1 then IO.println "c(5) = s1"
  else IO.println "c(5) is neither"

#eval check_c5_1987

/-
Multiplication by an element of C1_5 permutes the cosets cyclically.
-/
lemma action_C1_5 (n : ZMod 1987) (hn : n ∈ C1_5) :
  H1987.image (fun x => n * x) = C1_5 ∧
  C1_5.image (fun x => n * x) = C2_5 ∧
  C2_5.image (fun x => n * x) = H1987 := by
    -- Let's unfold the definitions of C1_5 and C2_5.
    unfold C1_5 C2_5 at *;
    -- Since $n \in C1_5$, we can write $n = g5 * h$ for some $h \in H1987$.
    obtain ⟨h, hh⟩ : ∃ h ∈ H1987, n = g5 * h := by
      rw [ Finset.mem_image ] at hn; obtain ⟨ h, hh, rfl ⟩ := hn; exact ⟨ h, hh, rfl ⟩ ;
    have h_perm : Finset.image (fun x => g5 * h * x) H1987 = Finset.image (fun x => g5 * x) H1987 ∧ Finset.image (fun x => g5 * h * (g5 * x)) H1987 = Finset.image (fun x => g5^2 * x) H1987 ∧ Finset.image (fun x => g5 * h * (g5^2 * x)) H1987 = H1987 := by
      have h_perm : Finset.image (fun x => h * x) H1987 = H1987 ∧ Finset.image (fun x => h * (g5 * x)) H1987 = Finset.image (fun x => g5 * x) H1987 ∧ Finset.image (fun x => h * (g5^2 * x)) H1987 = Finset.image (fun x => g5^2 * x) H1987 := by
        have h_perm : Finset.image (fun x => h * x) H1987 = H1987 := by
          exact action_H_1987_v8 h hh.1 |>.1;
        have h_perm : Finset.image (fun x => h * (g5 * x)) H1987 = Finset.image (fun x => g5 * x) (Finset.image (fun x => h * x) H1987) ∧ Finset.image (fun x => h * (g5^2 * x)) H1987 = Finset.image (fun x => g5^2 * x) (Finset.image (fun x => h * x) H1987) := by
          simp +decide [ Finset.ext_iff, Set.ext_iff ];
          exact ⟨ fun a => ⟨ fun ⟨ x, hx, hx' ⟩ => ⟨ x, hx, by linear_combination' hx' ⟩, fun ⟨ x, hx, hx' ⟩ => ⟨ x, hx, by linear_combination' hx' ⟩ ⟩, fun a => ⟨ fun ⟨ x, hx, hx' ⟩ => ⟨ x, hx, by linear_combination' hx' ⟩, fun ⟨ x, hx, hx' ⟩ => ⟨ x, hx, by linear_combination' hx' ⟩ ⟩ ⟩;
        grind +ring;
      have h_perm : Finset.image (fun x => g5 * h * x) H1987 = Finset.image (fun x => g5 * x) (Finset.image (fun x => h * x) H1987) ∧ Finset.image (fun x => g5 * h * (g5 * x)) H1987 = Finset.image (fun x => g5 * x) (Finset.image (fun x => h * (g5 * x)) H1987) ∧ Finset.image (fun x => g5 * h * (g5^2 * x)) H1987 = Finset.image (fun x => g5 * x) (Finset.image (fun x => h * (g5^2 * x)) H1987) := by
        simp +decide [ mul_assoc, Finset.ext_iff ];
      simp_all +contextual only [Finset.image_image];
      native_decide +revert;
    simp_all +decide [ Finset.ext_iff ]

/-
Compute coefficients for g=5.
-/
def find_coeffs_1987_g5 : IO Unit := do
  let q := 1987
  let a := 89
  -- Find p = k*q + 1
  let mut p := 0
  for k in [2:200] do
    let cand := k * q + 1
    if Nat.Prime cand then
      p := cand
      break
  
  if p == 0 then
    IO.println "No prime found"
    return

  IO.println s!"Using prime p = {p}"

  -- Find element of order q
  let mut g_p := 0
  for g in [2:p] do
    let zeta := (g : Nat) ^ ((p - 1) / q) % p
    if zeta != 1 then
      g_p := g
      break
  
  let zeta := (g_p : Nat) ^ ((p - 1) / q) % p
  IO.println s!"zeta = {zeta}"

  -- Cosets of cubic residues mod q
  -- g_q = 5
  let g_q := 5
  let mut H : List Nat := []
  let mut x := 1
  let g_q_3 := (g_q * g_q * g_q) % q
  for _ in [0:(q-1)/3] do
    H := x :: H
    x := (x * g_q_3) % q
  
  let C1 := H.map (fun h => (h * g_q) % q)
  let C2 := H.map (fun h => (h * g_q * g_q) % q)

  -- Periods mod p
  let sum_zeta (S : List Nat) : Nat :=
    S.foldl (fun acc h => (acc + (zeta ^ h) % p) % p) 0
  
  let eta0 := sum_zeta H
  let eta1 := sum_zeta C1
  let eta2 := sum_zeta C2

  -- Differences
  let alpha_prime := (eta0 + p - eta1) % p
  let beta_prime := (eta1 + p - eta2) % p
  let gamma_prime := (eta2 + p - eta0) % p

  -- Check sign convention
  let prod := (alpha_prime * beta_prime) % p * gamma_prime % p
  let q_mod_p := q % p
  
  let mut alpha := 0
  let mut beta := 0
  let mut gamma := 0

  if prod == q_mod_p then
    alpha := alpha_prime
    beta := beta_prime
    gamma := gamma_prime
    IO.println "Sign convention: positive"
  else
    alpha := (p - alpha_prime) % p
    beta := (p - beta_prime) % p
    gamma := (p - gamma_prime) % p
    IO.println "Sign convention: negative"

  -- Solve 89 * beta = c0 + c1 * alpha + c2 * alpha^2 mod p
  let sub (x y : Nat) := (x + p - y) % p
  let mul (x y : Nat) := (x * y) % p
  let add (x y : Nat) := (x + y) % p
  let pow (x n : Nat) := x ^ n % p
  let inv (x : Nat) := x ^ (p - 2) % p

  let det := mul (sub beta alpha) (mul (sub gamma alpha) (sub gamma beta))
  let det_inv := inv det

  let rhs0 := mul 89 beta
  let rhs1 := mul 89 gamma
  let rhs2 := mul 89 alpha

  -- Solve for c0, c1, c2
  -- c0
  let term0 := mul rhs0 (sub (mul beta (mul gamma gamma)) (mul gamma (mul beta beta)))
  let term1 := mul rhs1 (sub (mul gamma (mul alpha alpha)) (mul alpha (mul gamma gamma)))
  let term2 := mul rhs2 (sub (mul alpha (mul beta beta)) (mul beta (mul alpha alpha)))
  let c0 := mul (add term0 (add term1 term2)) det_inv

  -- c1
  let term0_1 := mul 1 (sub (mul rhs1 (mul gamma gamma)) (mul rhs2 (mul beta beta)))
  let term1_1 := mul 1 (sub (mul rhs2 (mul alpha alpha)) (mul rhs0 (mul gamma gamma)))
  let term2_1 := mul 1 (sub (mul rhs0 (mul beta beta)) (mul rhs1 (mul alpha alpha)))
  let c1 := mul (add term0_1 (add term1_1 term2_1)) det_inv

  -- c2
  let term0_2 := mul 1 (sub (mul beta rhs2) (mul gamma rhs1))
  let term1_2 := mul 1 (sub (mul gamma rhs0) (mul alpha rhs2))
  let term2_2 := mul 1 (sub (mul alpha rhs1) (mul beta rhs0))
  let c2 := mul (add term0_2 (add term1_2 term2_2)) det_inv

  let to_signed (x : Nat) : Int :=
    if x > p / 2 then (x : Int) - p else x

  IO.println s!"Coefficients for beta: c0={to_signed c0}, c1={to_signed c1}, c2={to_signed c2}"
  
  -- Also for gamma
  let rhs0_g := mul 89 gamma
  let rhs1_g := mul 89 alpha
  let rhs2_g := mul 89 beta

  let term0_g := mul rhs0_g (sub (mul beta (mul gamma gamma)) (mul gamma (mul beta beta)))
  let term1_g := mul rhs1_g (sub (mul gamma (mul alpha alpha)) (mul alpha (mul gamma gamma)))
  let term2_g := mul rhs2_g (sub (mul alpha (mul beta beta)) (mul beta (mul alpha alpha)))
  let d0 := mul (add term0_g (add term1_g term2_g)) det_inv

  let term0_1g := mul 1 (sub (mul rhs1_g (mul gamma gamma)) (mul rhs2_g (mul beta beta)))
  let term1_1g := mul 1 (sub (mul rhs2_g (mul alpha alpha)) (mul rhs0_g (mul gamma gamma)))
  let term2_1g := mul 1 (sub (mul rhs0_g (mul beta beta)) (mul rhs1_g (mul alpha alpha)))
  let d1 := mul (add term0_1g (add term1_1g term2_1g)) det_inv

  let term0_2g := mul 1 (sub (mul beta rhs2_g) (mul gamma rhs1_g))
  let term1_2g := mul 1 (sub (mul gamma rhs0_g) (mul alpha rhs2_g))
  let term2_2g := mul 1 (sub (mul alpha rhs1_g) (mul beta rhs0_g))
  let d2 := mul (add term0_2g (add term1_2g term2_2g)) det_inv

  IO.println s!"Coefficients for gamma: d0={to_signed d0}, d1={to_signed d1}, d2={to_signed d2}"

#eval find_coeffs_1987_g5

/-
Define DreamAssumptions for g=5.
-/
def DreamAssumptions_1987_g5 : Prop :=
  alpha_int_5^3 = 1987 * alpha_int_5 + 1987 ∧
  alpha_int_5 * beta_int_5 * gamma_int_5 = 1987 ∧
  89 * beta_int_5 = 3 * alpha_int_5^2 - 49 * alpha_int_5 - 3974 ∧
  89 * gamma_int_5 = -3 * alpha_int_5^2 - 40 * alpha_int_5 + 3974

/-
If n in C1_5, sigma_n(alpha) = beta.
-/
lemma global_permutation_5_C1 (n : (ZMod 1987)ˣ) (hn : (n : ZMod 1987) ∈ C1_5) :
  sigma_int1987 n alpha_int_5 = beta_int_5 := by
    have h_sigma_beta : sigma_int1987 n (eta0_int1987 - eta1_int_5) = eta1_int_5 - eta2_int_5 := by
      have h_sigma_beta : sigma_int1987 n (eta_int1987 H1987) = eta_int1987 (H1987.image (fun x => (n : ZMod 1987) * x)) ∧ sigma_int1987 n (eta_int1987 C1_5) = eta_int1987 (C1_5.image (fun x => (n : ZMod 1987) * x)) := by
        exact ⟨ sigma_eta_1987 n H1987, sigma_eta_1987 n C1_5 ⟩;
      have h_sigma_beta : H1987.image (fun x => (n : ZMod 1987) * x) = C1_5 ∧ C1_5.image (fun x => (n : ZMod 1987) * x) = C2_5 := by
        have := action_C1_5 ( n : ZMod 1987 ) hn; aesop;
      unfold eta0_int1987 eta1_int_5 eta2_int_5; aesop;
    unfold alpha_int_5 beta_int_5 at *;
    unfold alpha_prime_int_5 beta_prime_int_5 at * ; aesop

/-
If n in C2_5, sigma_n(alpha) = gamma.
-/
lemma global_permutation_5_C2 (n : (ZMod 1987)ˣ) (hn : (n : ZMod 1987) ∈ C2_5) :
  sigma_int1987 n alpha_int_5 = gamma_int_5 := by
    revert n hn;
    intro n hn_C2_5;
    -- By definition of $sigma_int1987$, we know that $sigma_int1987 n (eta0_int1987) = eta2_int_5$.
    have h_sigma_eta0 : sigma_int1987 n eta0_int1987 = eta2_int_5 := by
      have h_sigma_eta0 : sigma_int1987 n eta0_int1987 = eta_int1987 (H1987.image (fun x => (n : ZMod 1987) * x)) := by
        convert sigma_eta_1987 n H1987 using 1;
      rw [ h_sigma_eta0 ];
      unfold C2_5 at hn_C2_5; unfold H1987 at *; unfold eta2_int_5; norm_num at *;
      obtain ⟨ a, ha, hn ⟩ := hn_C2_5; rw [ ← hn ] ;
      unfold C2_5 ;
      unfold H1987; norm_num [ Finset.ext_iff ] ;
      refine' congr_arg _ ( Finset.ext fun x => _ );
      simp +contextual [ Finset.mem_image, Finset.mem_filter ];
      constructor <;> rintro ⟨ b, hb, rfl ⟩;
      · exact ⟨ a * b, mul_ne_zero ha hb, by ring ⟩;
      · -- Since $a \neq 0$ and $b \neq 0$, we can choose $a_1 = b / a$.
        use b / a;
        grind;
    -- By definition of $sigma_int1987$, we know that $sigma_int1987 n (eta1_int_5) = eta0_int1987$.
    have h_sigma_eta1 : sigma_int1987 n eta1_int_5 = eta0_int1987 := by
      unfold C2_5 at hn_C2_5;
      rw [ Finset.mem_image ] at hn_C2_5; obtain ⟨ x, hx, hx' ⟩ := hn_C2_5; simp_all +decide [ mul_assoc, mul_comm, mul_left_comm ] ;
      have h_sigma_eta1 : sigma_int1987 n eta1_int_5 = eta_int1987 (C1_5.image (fun x => (n : ZMod 1987) * x)) := by
        apply sigma_eta_1987;
      rw [ h_sigma_eta1 ];
      rw [ ← hx' ];
      rw [ show Finset.image ( fun x_1 => x * g5 ^ 2 * x_1 ) C1_5 = H1987 from ?_ ];
      · rfl;
      · have h_sigma_eta1 : Finset.image (fun x_1 => x * g5 ^ 2 * x_1) C1_5 = Finset.image (fun x_1 => x * x_1) (Finset.image (fun x_1 => g5 ^ 2 * x_1) C1_5) := by
          simp +decide only [mul_assoc, Finset.image_image];
          rfl;
        rw [ h_sigma_eta1 ];
        rw [ show Finset.image ( fun x_1 => g5 ^ 2 * x_1 ) C1_5 = H1987 from ?_ ];
        · exact action_H_1987_v8 x hx |>.1;
        · native_decide +revert;
    unfold alpha_int_5 gamma_int_5;
    unfold alpha_prime_int_5 gamma_prime_int_5; simp +decide [ *, mul_sub, sub_mul ] ;

/-
If n in H, sigma_n(alpha) = alpha.
-/
lemma global_permutation_5_H (n : (ZMod 1987)ˣ) (hn : (n : ZMod 1987) ∈ H1987) :
  sigma_int1987 n alpha_int_5 = alpha_int_5 := by
    -- By definition of $C1_5$, we know that $n \in H$ implies $\sigma(n)(\eta0) = \eta0$, $\sigma(n)(\eta1) = \eta1$, and $\sigma(n)(\eta2) = \eta2$.
    have h_sigma_C1_5 : (sigma_int1987 n) eta0_int1987 = eta0_int1987 ∧
                        (sigma_int1987 n) eta1_int_5 = eta1_int_5 ∧
                        (sigma_int1987 n) eta2_int_5 = eta2_int_5 := by
                          have h_sigma_C1_5 : ∀ S : Finset (ZMod 1987), (S.image (fun x => (n : ZMod 1987) * x)) = S → (sigma_int1987 n) (eta_int1987 S) = eta_int1987 S := by
                            intros S hS_image
                            have h_sigma_S : sigma_int1987 n (eta_int1987 S) = eta_int1987 (S.image (fun x => (n : ZMod 1987) * x)) := by
                              convert sigma_eta_1987 n S using 1
                              skip
                            generalize_proofs at *; (
                            rw [ h_sigma_S, hS_image ]);
                          exact ⟨ h_sigma_C1_5 _ ( action_H_1987_v8 _ hn |>.1 ), h_sigma_C1_5 _ ( action_H_5 _ hn |>.2.1 ), h_sigma_C1_5 _ ( action_H_5 _ hn |>.2.2 ) ⟩
    generalize_proofs at *; (
    unfold alpha_int_5; simp +decide [ *, sub_eq_add_neg ] ;
    exact Or.inl ( by rw [ show alpha_prime_int_5 = eta0_int1987 - eta1_int_5 from rfl ] ; exact by rw [ map_sub, h_sigma_C1_5.1, h_sigma_C1_5.2.1 ] ) ;)

/-
Check if s2^2 = s1.
-/
def check_s_relation_1987 : IO Unit := do
  let q := 1987
  let s1 := 647
  let s2 := 1339
  let s2_sq := s2 * s2 % q
  IO.println s!"s2^2 = {s2_sq}"
  if s2_sq == s1 then IO.println "s2^2 = s1 (Correct)" else IO.println "s2^2 != s1"

#eval check_s_relation_1987

/-
c(5) = s2.
-/
lemma c1987_val_5 : c1987 5 = s2_1987 := by
  native_decide

/-
s1 * s2 = 1.
-/
lemma s1_mul_s2_1987 : s1_1987 * s2_1987 = 1 := by
  native_decide

/-
Define chi1987 and prove its properties.
-/
def chi1987 (x : ZMod 1987) : ZMod 1987 := x ^ 662

lemma chi1987_mul (x y : ZMod 1987) : chi1987 (x * y) = chi1987 x * chi1987 y := by
  native_decide +revert

lemma chi1987_inv (x : (ZMod 1987)ˣ) : chi1987 (x : ZMod 1987)⁻¹ = (chi1987 x)⁻¹ := by
  native_decide +revert

lemma chi1987_val_H (x : ZMod 1987) (hx : x ∈ H1987) : chi1987 x = 1 := by
  native_decide +revert

lemma chi1987_val_5 : chi1987 5 = s2_1987 := by
  native_decide +revert

/-
x in H iff chi(x) = 1.
-/
lemma mem_H_iff_chi_eq_one_1987 (x : ZMod 1987) (hx : x ≠ 0) : x ∈ H1987 ↔ chi1987 x = 1 := by
  native_decide +revert

/-
Check if mem_H_iff_chi_eq_one_1987 is available.
-/
#check mem_H_iff_chi_eq_one_1987

/-
s2^2 = s1.
-/
lemma s2_sq_eq_s1_1987 : s2_1987 ^ 2 = s1_1987 := by
  native_decide

/-
n in C1_5 iff chi(n) = s2.
-/
lemma mem_C1_iff_chi_eq_s2_1987 (n : ZMod 1987) (hn : n ≠ 0) : n ∈ C1_5 ↔ chi1987 n = s2_1987 := by
  revert n hn; native_decide;

/-
Check if mem_H_iff_chi_eq_one_1987 is available.
-/
#check mem_H_iff_chi_eq_one_1987

/-
x in H iff chi(x) = 1.
-/
lemma mem_H_iff_chi_eq_one_1987_v2 (x : ZMod 1987) (hx : x ≠ 0) : x ∈ H1987 ↔ chi1987 x = 1 := by
  native_decide +revert

/-
Check if mem_C1_iff_chi_eq_s2_1987 is available.
-/
#check mem_C1_iff_chi_eq_s2_1987

/-
n in C2_5 iff chi(n) = s1.
-/
lemma mem_C2_iff_chi_eq_s1_1987 (n : ZMod 1987) (hn : n ≠ 0) : n ∈ C2_5 ↔ chi1987 n = s1_1987 := by
  revert n hn
  native_decide

/-
Part 1 of the Dream Theorem for q=1987.
-/
theorem final_result_1987_part1 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 1987) (hN_odd : N % 2 = 1) (hN_a : Nat.Coprime 89 N)
  (P : Ideal Ok1987) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_period : alpha_int_5^3 = 1987 * alpha_int_5 + 1987) :
  let alpha_bar := Ideal.Quotient.mk P alpha_int_5
  let gamma_bar := Ideal.Quotient.mk P gamma_int_5
  c1987 N = s1_1987 → alpha_bar ^ N = gamma_bar := by
    unfold c1987 at * ; norm_num at *;
    intro hN_s1
    have h_sigma_gamma : sigma_int1987 (N_mod_1987 N hN) alpha_int_5 = gamma_int_5 := by
      apply global_permutation_5_C2;
      apply (mem_C2_iff_chi_eq_s1_1987 _ _).mpr hN_s1;
      intro h; simp_all +decide [ ZMod.natCast_eq_zero_iff ] ;
    rw [ ← h_sigma_gamma, artin_property_1987_v3 ];
    assumption

/-
n in C2_5 iff chi(n) = s1.
-/
lemma mem_C2_iff_chi_eq_s1_1987_v2 (n : ZMod 1987) (hn : n ≠ 0) : n ∈ C2_5 ↔ chi1987 n = s1_1987 := by
  revert n hn
  native_decide

/-
Part 2 of the Dream Theorem for q=1987.
-/
theorem final_result_1987_part2 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 1987) (hN_odd : N % 2 = 1) (hN_a : Nat.Coprime 89 N)
  (P : Ideal Ok1987) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_period : alpha_int_5^3 = 1987 * alpha_int_5 + 1987) :
  let alpha_bar := Ideal.Quotient.mk P alpha_int_5
  let beta_bar := Ideal.Quotient.mk P beta_int_5
  c1987 N = s2_1987 → alpha_bar ^ N = beta_bar := by
    -- By definition of $c1987$, we know that $c1987 N = s2_1987$ implies $N \in C1_5$.
    have hN_C1 : (N : ZMod 1987) ∈ C1_5 ↔ c1987 N = s2_1987 := by
      convert mem_C1_iff_chi_eq_s2_1987 ( N : ZMod 1987 ) _ using 1;
      exact?;
    -- By definition of $c1987$, we know that $c1987 N = s2_1987$ implies $N \in C1_5$. Therefore, we can apply the lemma `global_permutation_5_C1`.
    intros alpha_bar beta_bar h_c1987
    have hN_C1 : (N : ZMod 1987) ∈ C1_5 := by
      exact hN_C1.mpr h_c1987;
    -- By definition of $c1987$, we know that $c1987 N = s2_1987$ implies $N \in C1_5$. Therefore, we can apply the lemma `global_permutation_5_C1` to conclude that $\sigma_N(\alpha) = \beta$.
    have h_sigma_N_alpha_beta : sigma_int1987 (N_mod_1987 N hN) alpha_int_5 = beta_int_5 := by
      convert global_permutation_5_C1 ( N_mod_1987 N hN ) hN_C1 using 1;
    have h_sigma_N_alpha_beta_mod_P : Ideal.Quotient.mk P (sigma_int1987 (N_mod_1987 N hN) alpha_int_5) = (Ideal.Quotient.mk P alpha_int_5) ^ N := by
      convert artin_property_1987_v3 N hN P hP alpha_int_5 using 1;
    aesop

/-
The Dream Theorem for q = 1987.
-/
theorem final_result_1987 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 1987) (hN_odd : N % 2 = 1) (hN_a : Nat.Coprime 89 N)
  (P : Ideal Ok1987) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_period : alpha_int_5^3 = 1987 * alpha_int_5 + 1987) :
  let alpha_bar := Ideal.Quotient.mk P alpha_int_5
  let beta_bar := Ideal.Quotient.mk P beta_int_5
  let gamma_bar := Ideal.Quotient.mk P gamma_int_5
  (c1987 N = s1_1987 → alpha_bar ^ N = gamma_bar) ∧
  (c1987 N = s2_1987 → alpha_bar ^ N = beta_bar) := by
    exact ⟨ fun h => by simpa using final_result_1987_part1 N hN hN_odd hN_a P hP h_period h, fun h => by simpa using final_result_1987_part2 N hN hN_odd hN_a P hP h_period h ⟩
