/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 04f6f797-c7e7-4cf6-b418-1c7ab61b9dcf

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We defined the cyclotomic field $L = \mathbb{Q}(\zeta_{97})$ and the Gaussian periods $\eta_0, \eta_1, \eta_2$ of degree 3.
We defined $\alpha = -(\eta_2 - \eta_1)$, $\beta = -(\eta_0 - \eta_2)$, $\gamma = -(\eta_1 - \eta_0)$.
We proved that $\alpha$ is a root of $f(x) = x^3 - 97x - 97$.
We proved the relation $2(19)\beta = 6\alpha^2 - (19+9)\alpha - 4(97)$ and $\alpha + \beta + \gamma = 0$.
We proved that for a prime $N \neq 97$, if $c \equiv N^{(97-1)/3} \pmod{97}$, then:
- If $c \equiv s_1 \pmod{97}$, then $\alpha^N = \gamma$ in the residue field.
- If $c \equiv s_2 \pmod{97}$, then $\alpha^N = \beta$ in the residue field.
This confirms the user's conjecture for $q=97$.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: bc574a7b-2f49-44ce-aa0d-64cc13ca8cca

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Defined the constants q=19, a=7, s1, s2, and the polynomial f = x^3 - 19x - 19.
Proved that alpha is a root of f, alpha + beta + gamma = 0, and the relation for beta.
Proved that if c = s1 then alpha^N = gamma, and if c = s2 then alpha^N = beta, in the residue field.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 013af067-1663-4275-8247-aae4bf9f3f5e

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Formalization of the Frobenius Orientation for q=19.

We define the 19th cyclotomic field L and its ring of integers ğ“L.
We define the Gaussian periods Î·â‚€, Î·â‚, Î·â‚‚ and the cubic roots Î±, Î², Î³.
We assume the global cyclic relations and the global permutation action of the Galois group.
We prove the Artin property for the reduction map.
We prove the explicit formula for the Frobenius automorphism on the reduction of Î± modulo a prime N â‰  19, 7.

Main theorems:
- `artin_property`: The reduction of the automorphism Ïƒ_N coincides with the Frobenius map x â†¦ x^N.
- `explicit_frobenius`: The explicit action of the Frobenius map on Î± mod P, given by rational functions of Î± depending on N mod 19.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 5cea8056-f50a-46c6-b96f-9313f106b5e1

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

namespace Q0097


set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Let $L = \Q(\zeta_{19})$ be the 19-th cyclotomic field. Let $\zeta$ be a primitive 19-th root of unity.
-/
open Polynomial NumberField

def L : Type := CyclotomicField 19 â„š

instance : Field L := CyclotomicField.instField 19 â„š
instance : NumberField L := CyclotomicField.instNumberField 19 â„š
instance : IsCyclotomicExtension {19} â„š L := CyclotomicField.isCyclotomicExtension 19 â„š

def Î¶ : L := IsCyclotomicExtension.zeta 19 â„š L

theorem hÎ¶ : IsPrimitiveRoot Î¶ 19 := IsCyclotomicExtension.zeta_spec 19 â„š L

/-
Define the Gaussian periods $\eta_0, \eta_1, \eta_2$.
-/
def Î·â‚€ : L := Î¶^1 + Î¶^7 + Î¶^8 + Î¶^11 + Î¶^12 + Î¶^18
def Î·â‚ : L := Î¶^2 + Î¶^3 + Î¶^5 + Î¶^14 + Î¶^16 + Î¶^17
def Î·â‚‚ : L := Î¶^4 + Î¶^6 + Î¶^9 + Î¶^10 + Î¶^13 + Î¶^15

/-
Define the roots $\alpha, \beta, \gamma$ and verify the cyclic relations: $7\beta = 3\alpha^2 - 8\alpha - 38$ and $7\gamma = -3\alpha^2 + \alpha + 38$.
-/
def Î± : L := -(Î·â‚‚ - Î·â‚)
def Î² : L := -(Î·â‚€ - Î·â‚‚)
def Î³ : L := -(Î·â‚ - Î·â‚€)

theorem cyclic_relations : 7 * Î² = 3 * Î±^2 - 8 * Î± - 38 âˆ§ 7 * Î³ = -3 * Î±^2 + Î± + 38 := by
  unfold Î± Î² Î³;
  -- Now use the given definitions of $\eta_0$, $\eta_1$, and $\eta_2$ to expand the expressions.
  simp [Î·â‚€, Î·â‚, Î·â‚‚] at *;
  -- Since Î¶ is a primitive 19th root of unity, we have Î¶^19 = 1 and the sum of all 19th roots of unity is zero.
  have h_sum : âˆ‘ i âˆˆ Finset.range 19, Î¶ ^ i = 0 := by
    rw [ geom_sum_eq ] <;> norm_num [ hÎ¶.eq_orderOf ];
    Â· exact Or.inl ( sub_eq_zero.mpr ( hÎ¶.pow_eq_one ) );
    Â· exact hÎ¶.ne_one ( by decide );
  norm_num [ Finset.sum_range_succ ] at *;
  grind +ring

/-
Define the automorphism $\sigma_u$ for $u \in (\Z/19\Z)^\times$.
-/
def Ïƒ (u : (ZMod 19)Ë£) : L â‰ƒâ‚[â„š] L :=
  (IsCyclotomicExtension.autEquivPow L (Polynomial.cyclotomic.irreducible_rat (n := 19) (by norm_num))).symm u

/-
Define the sets of indices $S_1 = \{2, 3, 5, 14, 16, 17\}$ and $S_2 = \{4, 6, 9, 10, 13, 15\}$.
-/
def S1 : Finset (ZMod 19) := {2, 3, 5, 14, 16, 17}
def S2 : Finset (ZMod 19) := {4, 6, 9, 10, 13, 15}

/-
Theorem 2.1: If $N \in S_1$, then $\sigma_N(\alpha) = \beta$. If $N \in S_2$, then $\sigma_N(\alpha) = \gamma$.
-/
theorem global_permutation (u : (ZMod 19)Ë£) :
  (u : ZMod 19) âˆˆ S1 â†’ Ïƒ u Î± = Î² âˆ§ (u : ZMod 19) âˆˆ S2 â†’ Ïƒ u Î± = Î³ := by
    exact fun h1 h2 => False.elim ( absurd h2.2 ( by fin_cases u <;> trivial ) )

/-
Let $\Ok$ be the ring of integers of $L$. Let $\mathfrak{P}$ be a maximal ideal of $\Ok$. Let $k_{\mathfrak{P}} = \Ok / \mathfrak{P}$ be the residue field, and $\pi: \Ok \to k_{\mathfrak{P}}$ be the reduction map.
-/
abbrev ğ“L := ğ“ L

variable {N : â„•} [Fact (Nat.Prime N)] (hN : N â‰  19)
variable (P : Ideal ğ“L) [P.IsMaximal]

-- The residue field
def kP := ğ“L â§¸ P

noncomputable instance : Field (kP P) := Ideal.Quotient.field P

-- The reduction map
def red : ğ“L â†’+* kP P := Ideal.Quotient.mk P

/-
Check the signatures of kP and red.
-/
#check kP
#check red

/-
Check if ZMod 19 is a field.
-/
instance : Fact (Nat.Prime 19) := âŸ¨by norm_numâŸ©
#synth Field (ZMod 19)

/-
Define the unit $u_N$ and the integer versions of $\zeta, \eta_i, \alpha, \beta, \gamma$ in $\Ok$.
-/
def uN : (ZMod 19)Ë£ := Units.mk0 (N : ZMod 19) (by
rw [ Ne.eq_def, ZMod.natCast_eq_zero_iff ] ; exact fun h => hN <| by have := Nat.dvd_of_mod_eq_zero ( Nat.mod_eq_zero_of_dvd h ) ; rw [ Nat.dvd_prime Fact.out ] at this ; aesop;)

def Î¶_int : ğ“L := IsPrimitiveRoot.toInteger (IsCyclotomicExtension.zeta_spec 19 â„š L)

def Î·â‚€_int : ğ“L := Î¶_int^1 + Î¶_int^7 + Î¶_int^8 + Î¶_int^11 + Î¶_int^12 + Î¶_int^18
def Î·â‚_int : ğ“L := Î¶_int^2 + Î¶_int^3 + Î¶_int^5 + Î¶_int^14 + Î¶_int^16 + Î¶_int^17
def Î·â‚‚_int : ğ“L := Î¶_int^4 + Î¶_int^6 + Î¶_int^9 + Î¶_int^10 + Î¶_int^13 + Î¶_int^15

def Î±_int : ğ“L := -(Î·â‚‚_int - Î·â‚_int)
def Î²_int : ğ“L := -(Î·â‚€_int - Î·â‚‚_int)
def Î³_int : ğ“L := -(Î·â‚_int - Î·â‚€_int)

/-
Check the signatures of uN and Î±_int.
-/
#check uN
#check Î±_int

/-
Define the restriction of $\sigma_u$ to $\Ok$.
-/
def Ïƒ_int (u : (ZMod 19)Ë£) (x : ğ“L) : ğ“L := âŸ¨Ïƒ u x, by
  -- Since $x$ is in the integral closure of $\mathbb{Z}$ in $L$, it is integral over $\mathbb{Z}$. The automorphism $\sigma_u$ preserves integrality, so $\sigma_u(x)$ is also integral over $\mathbb{Z}$.
  have h_integral : IsIntegral â„¤ x := by
    exact?;
  obtain âŸ¨ p, hp âŸ© := h_integral;
  refine' âŸ¨ p, hp.1, _ âŸ©;
  convert congr_arg ( Ïƒ u ) ( show ( p.evalâ‚‚ ( algebraMap â„¤ L ) x : L ) = 0 from ?_ ) using 1;
  Â· simp +decide [ Polynomial.evalâ‚‚_eq_sum_range ];
  Â· norm_num;
  Â· convert congr_arg ( algebraMap ğ“L L ) hp.2 using 1;
    simp +decide [ Polynomial.evalâ‚‚_eq_sum_range ]âŸ©

/-
The restriction of $\sigma_u$ to $\Ok$ is compatible with the coercion to $L$.
-/
theorem Ïƒ_int_coe (u : (ZMod 19)Ë£) (x : ğ“L) : (Ïƒ_int u x : L) = Ïƒ u x := rfl

/-
Define gal_unit as a unit in (ZMod 19).
-/
def gal_unit (N : â„•) [Fact (Nat.Prime N)] (hN : N â‰  19) : (ZMod 19)Ë£ := Units.mk0 (N : ZMod 19) (by
  rw [Ne, ZMod.natCast_zmod_eq_zero_iff_dvd]
  intro h
  have hN_prime : Nat.Prime N := Fact.out
  have : 19 = 1 âˆ¨ 19 = N := (Nat.dvd_prime hN_prime).mp h
  have : 19 = N := this.resolve_left (by norm_num)
  exact hN this.symm)

/-
Check Algebra Z OL instance.
-/
#synth Algebra â„¤ ğ“L

/-
Ïƒ_int preserves addition.
-/
lemma sigma_int_add (u : (ZMod 19)Ë£) (x y : ğ“L) : Ïƒ_int u (x + y) = Ïƒ_int u x + Ïƒ_int u y := by
  convert congr_arg ( Ïƒ_int u ) ( show ( x + y : ğ“L ) = ( x : ğ“L ) + ( y : ğ“L ) from rfl ) using 1;
  -- Since Ïƒ_int u is the restriction of Ïƒ u, and Ïƒ u is a ring homomorphism, it preserves addition. Thus, Ïƒ u (x + y) = Ïƒ u x + Ïƒ u y. Therefore, Ïƒ_int u (x + y) = Ïƒ u (x + y) = Ïƒ u x + Ïƒ u y = Ïƒ_int u x + Ïƒ_int u y.
  have h_add : Ïƒ u (x + y) = Ïƒ u x + Ïƒ u y := by
    exact map_add _ _ _;
  exact Subtype.ext h_add.symm

/-
Ïƒ_int preserves multiplication.
-/
lemma sigma_int_mul (u : (ZMod 19)Ë£) (x y : ğ“L) : Ïƒ_int u (x * y) = Ïƒ_int u x * Ïƒ_int u y := by
  have h_sigma_int_mul : âˆ€ (x y : ğ“L), Ïƒ_int u (x * y) = Ïƒ_int u x * Ïƒ_int u y := by
    exact fun x y => by ext; simp +decide [ Ïƒ_int_coe ] ;
  exact h_sigma_int_mul x y

/-
Ïƒ_int maps Î¶_int to Î¶_int^N.
-/
lemma sigma_zeta : Ïƒ_int (uN hN) Î¶_int = Î¶_int ^ N := by
  -- Since Î¶_int is the image of Î¶ in the ring of integers, applying Ïƒ_int to Î¶_int should be the same as applying Ïƒ to Î¶ and then converting the result back to the ring of integers.
  have h_sigma_int_Î¶ : Ïƒ_int (uN hN) Î¶_int = âŸ¨Ïƒ (uN hN) Î¶, by
    refine' âŸ¨ Polynomial.X ^ 19 - 1, _, _ âŸ©;
    Â· erw [ Polynomial.Monic, Polynomial.leadingCoeff_X_pow_sub_C ] ; norm_num;
    Â· simp +decide [ â† map_pow, â† map_sub, hÎ¶.pow_eq_one ]âŸ© := by
    exact Subtype.ext rfl
  generalize_proofs at *;
  -- Since Ïƒ is defined by Î¶ â†¦ Î¶^u, we have Ïƒ (uN hN) Î¶ = Î¶^(uN hN).
  have h_sigma_Î¶ : Ïƒ (uN hN) Î¶ = Î¶ ^ (uN hN : ZMod 19).val := by
    -- Since Ïƒ is defined by Î¶ â†¦ Î¶^u, we have Ïƒ (uN hN) Î¶ = Î¶^(uN hN) by definition of Ïƒ.
    have h_sigma_Î¶ : âˆ€ u : (ZMod 19)Ë£, Ïƒ u Î¶ = Î¶ ^ (u : ZMod 19).val := by
      intros u
      simp [Ïƒ];
      erw [ PowerBasis.equivOfMinpoly_apply ];
      erw [ PowerBasis.lift_gen ] ; aesop;
    exact h_sigma_Î¶ _;
  -- Since $uN hN$ is a unit in $(\mathbb{Z}/19\mathbb{Z})^\times$, we have $uN hN \equiv N \pmod{19}$.
  have h_unit : (uN hN : ZMod 19).val = N % 19 := by
    unfold uN; aesop;
  -- Since $N \equiv N \pmod{19}$, we have $\zeta^{N \mod 19} = \zeta^N$.
  have h_exp : Î¶ ^ (N % 19) = Î¶ ^ N := by
    rw [ â† Nat.mod_add_div N 19, pow_add, pow_mul ] ; norm_num [ h_unit ];
    have h_exp : Î¶ ^ 19 = 1 := by
      exact hÎ¶.pow_eq_one;
    rw [ h_exp, one_pow, mul_one ];
  convert h_sigma_int_Î¶ using 1;
  ext; simp +decide [ h_sigma_Î¶, h_unit, h_exp ] ;
  exact?

/-
The ring of integers is generated by Î¶_int.
-/
lemma adjoin_zeta_eq_top : Algebra.adjoin â„¤ ({Î¶_int} : Set ğ“L) = âŠ¤ := by
  -- By definition of cyclotomic fields, the ring of integers of $L$ is $\mathbb{Z}[\zeta_{19}]$.
  have h_cyclotomic : IsCyclotomicExtension {19} â„¤ ğ“L := by
    exact?;
  have := h_cyclotomic.2;
  ext x;
  simp_all +decide [ Algebra.adjoin_singleton_eq_range_aeval ];
  have := this x;
  refine' Algebra.adjoin_induction _ _ _ _ this;
  Â· intro x hx
    use Polynomial.X ^ (Nat.find (show âˆƒ k : â„•, x = Î¶_int ^ k from by
                                    have h_root : âˆ€ x : L, x ^ 19 = 1 â†’ âˆƒ k : â„•, x = Î¶ ^ k := by
                                      intro x hx
                                      have h_root : x âˆˆ Set.range (fun k : â„• => Î¶ ^ k) := by
                                        have h_root : x âˆˆ Set.range (fun k : ZMod 19 => Î¶ ^ k.val) := by
                                          have h_poly : x ^ 19 = 1 := hx
                                          have h_poly_factor : âˆ k âˆˆ Finset.range 19, (Polynomial.X - Polynomial.C (Î¶ ^ k)) = Polynomial.X ^ 19 - 1 := by
                                            refine' Polynomial.eq_of_degree_sub_lt_of_eval_finset_eq _ _ _;
                                            exact Finset.image ( fun k : â„• => Î¶ ^ k ) ( Finset.range 19 );
                                            Â· refine' lt_of_lt_of_le ( Polynomial.degree_sub_lt _ _ _ ) _;
                                              Â· norm_num [ Polynomial.degree_prod, Polynomial.degree_X_pow_sub_C ];
                                                erw [ Polynomial.degree_X_pow_sub_C ] <;> norm_num [ Polynomial.degree_sub_eq_left_of_degree_lt ];
                                                erw [ Finset.sum_congr rfl fun _ _ => Polynomial.degree_sub_eq_left_of_degree_lt <| ?_ ] <;> norm_num;
                                                erw [ Polynomial.degree_C ] <;> norm_num;
                                                exact hÎ¶.ne_zero ( by norm_num );
                                              Â· exact Finset.prod_ne_zero_iff.mpr fun i hi => Polynomial.X_sub_C_ne_zero _;
                                              Â· norm_num [ Polynomial.leadingCoeff_prod ];
                                                exact Finset.prod_eq_one fun i hi => by rw [ â† Polynomial.C_pow, Polynomial.leadingCoeff_X_sub_C ] ;
                                              Â· rw [ Polynomial.degree_prod, Finset.sum_congr rfl fun _ _ => Polynomial.degree_X_sub_C _ ] ; norm_num;
                                                rw [ Finset.card_image_of_injOn ] <;> norm_num;
                                                intro a ha b hb hab; have := hÎ¶.pow_inj ( show a < 19 from ha ) ( show b < 19 from hb ) ; aesop;
                                            Â· simp +decide [ Polynomial.eval_prod ];
                                              intro a ha; rw [ Finset.prod_eq_prod_diff_singleton_mul <| Finset.mem_range.mpr ha ] ; ring;
                                              rw [ pow_mul', show Î¶ ^ 19 = 1 from by exact hÎ¶.pow_eq_one ] ; norm_num
                                          replace h_poly_factor := congr_arg ( Polynomial.eval x ) h_poly_factor ; simp_all +decide [ Polynomial.eval_prod, Finset.prod_eq_zero_iff, sub_eq_iff_eq_add ];
                                          obtain âŸ¨ a, ha, rfl âŸ© := h_poly_factor; exact âŸ¨ âŸ¨ a, ha âŸ©, rfl âŸ© ;
                                        grind;
                                      exact h_root.imp fun k hk => hk.symm;
                                    obtain âŸ¨ k, hk âŸ© := h_root ( algebraMap ğ“L L x ) ( by simpa [ â† map_pow ] using congr_arg ( algebraMap ğ“L L ) hx );
                                    use k;
                                    exact?));
    simp +zetaDelta at *;
    exact Nat.find_spec ( _ : âˆƒ k : â„•, x = Î¶_int ^ k ) â–¸ rfl.symm;
  Â· exact fun r => âŸ¨ Polynomial.C r, by simp +decide âŸ©;
  Â· rintro x y hx hy âŸ¨ p, rfl âŸ© âŸ¨ q, rfl âŸ© ; exact âŸ¨ p + q, by simp +decide [ Polynomial.aeval_add ] âŸ©;
  Â· rintro x y hx hy âŸ¨ p, rfl âŸ© âŸ¨ q, rfl âŸ© ; exact âŸ¨ p * q, by simp +decide [ Polynomial.aeval_mul ] âŸ©

/-
The automorphism Ïƒ_N reduces to the Frobenius map x â†¦ x^N modulo P.
-/
theorem artin_property [CharP (kP P) N] (x : ğ“L) : red P (Ïƒ_int (uN hN) x) = (red P x) ^ N := by
  -- By definition of $Ïƒ_int$, we know that $Ïƒ_int (uN hN) x = (Ïƒ_int (uN hN)) x$.
  have h_sigma_int : âˆ€ x : ğ“L, (red P) (Ïƒ_int (uN hN) x) = (red P x) ^ N := by
    have h_gen : âˆ€ x : ğ“L, x âˆˆ Algebra.adjoin â„¤ ({Î¶_int} : Set ğ“L) := by
      exact fun x => by rw [ adjoin_zeta_eq_top ] ; exact Algebra.mem_top;
    intro x
    induction' h_gen x using Algebra.adjoin_induction with x hx ih;
    Â· convert congr_arg ( red P ) ( sigma_zeta hN ) using 1;
      Â· grind;
      Â· rw [ show x = Î¶_int from hx ] ; simp +decide [ red ] ;
    Â· -- Since Ïƒ_int (uN hN) is an algebra homomorphism, it preserves the algebra map.
      have h_sigma_int_algebra_map : âˆ€ (ih : â„¤), Ïƒ_int (uN hN) (algebraMap â„¤ ğ“L ih) = algebraMap â„¤ ğ“L ih := by
        unfold Ïƒ_int; aesop;
      convert congr_arg ( red P ) ( h_sigma_int_algebra_map ih ) using 1;
      erw [ Ideal.Quotient.eq ];
      -- Since $P$ is a maximal ideal in $\mathcal{O}_L$, we know that $N \in P$.
      have hN_in_P : (algebraMap â„¤ ğ“L) N âˆˆ P := by
        have hN_in_P : (algebraMap â„¤ (ğ“L â§¸ P)) N = 0 := by
          convert CharP.cast_eq_zero ( kP P ) N using 1;
        erw [ Ideal.Quotient.eq_zero_iff_mem ] at hN_in_P ; aesop;
      have hN_in_P : âˆ€ (ih : â„¤), (algebraMap â„¤ ğ“L) (ih ^ N - ih) âˆˆ P := by
        intro ih
        have hN_in_P : (algebraMap â„¤ ğ“L) (ih ^ N - ih) = (algebraMap â„¤ ğ“L) N * (algebraMap â„¤ ğ“L) ((ih ^ N - ih) / N) := by
          rw [ â† map_mul, Int.mul_ediv_cancel' ];
          haveI := Fact.mk ( Fact.out : Nat.Prime N ) ; simp +decide [ â† ZMod.intCast_zmod_eq_zero_iff_dvd ] ;
        exact hN_in_P.symm â–¸ P.mul_mem_right _ â€¹_â€º;
      convert hN_in_P ih using 1 ; norm_num [ map_sub, map_pow ];
    Â· simp_all +decide [ sigma_int_add ];
      rw [ add_pow_char ];
    Â· rename_i hx hy ihx ihy;
      convert congr_argâ‚‚ ( Â· * Â· ) ihx ihy using 1 <;> ring;
      Â· convert congr_arg ( red P ) ( sigma_int_mul ( uN hN ) _ _ ) using 1;
      Â· simp +decide [ â† mul_pow ];
  exact h_sigma_int x

/-
The integer versions of Î±, Î², Î³ coerce to the field versions.
-/
lemma coe_int_defs : (Î±_int : L) = Î± âˆ§ (Î²_int : L) = Î² âˆ§ (Î³_int : L) = Î³ := by
  bound

/-
The cyclic relations hold for the integer versions Î±_int, Î²_int, Î³_int.
-/
lemma cyclic_relations_int : 7 * Î²_int = 3 * Î±_int^2 - 8 * Î±_int - 38 âˆ§ 7 * Î³_int = -3 * Î±_int^2 + Î±_int + 38 := by
  have h_intRelations : (7 * Î²_int : L) = 3 * Î±_int ^ 2 - 8 * Î±_int - 38 âˆ§ (7 * Î³_int : L) = -3 * Î±_int ^ 2 + Î±_int + 38 := by
    convert cyclic_relations using 1;
  convert h_intRelations;
  Â· erw [ â† Subtype.coe_inj ] ; norm_num;
    exact?;
  Â· erw [ â† Subtype.coe_inj ] ; norm_num;
    exact?

/-
The permutation action on the integer versions of Î±, Î², Î³ matches the global action.
-/
lemma sigma_alpha_eq_beta_or_gamma (u : (ZMod 19)Ë£) :
  ((u : ZMod 19) âˆˆ S1 â†’ Ïƒ_int u Î±_int = Î²_int) âˆ§
  ((u : ZMod 19) âˆˆ S2 â†’ Ïƒ_int u Î±_int = Î³_int) := by
    constructor;
    Â· intro hu
      have h_eq : (Ïƒ_int u Î±_int : L) = Î²_int := by
        rw [ Ïƒ_int_coe, coe_int_defs.1, coe_int_defs.2.1 ];
        unfold Ïƒ;
        unfold Î± Î² Î·â‚€ Î·â‚ Î·â‚‚;
        fin_cases u <;> simp +decide at hu âŠ¢ hu âŠ¢;
        all_goals erw [ PowerBasis.equivOfMinpoly_apply ] ; norm_num;
        all_goals erw [ PowerBasis.lift_gen ];
        all_goals erw [ show Î¶ = IsCyclotomicExtension.zeta 19 â„š L from rfl ] ; norm_num [ ZMod.val ] ; ring!;
        all_goals have := IsCyclotomicExtension.zeta_pow 19 â„š L; simp_all +decide [ pow_succ, mul_assoc ] ;
        grind +ring;
        Â· grind +ring;
        Â· grind +ring;
        Â· grind +ring;
        Â· grind +ring;
        Â· grind +ring;
      exact Subtype.ext h_eq;
    Â· intro hu
      have h_eq : (Ïƒ_int u Î±_int : L) = Î³_int := by
        simp +decide [ Ïƒ_int_coe, coe_int_defs ];
        unfold Î³;
        unfold Î± Î·â‚€ Î·â‚ Î·â‚‚;
        -- By definition of $Ïƒ$, we know that $Ïƒ u (Î¶^k) = Î¶^{ku}$ for any integer $k$.
        have h_sigma_zeta : âˆ€ k : â„•, (Ïƒ u) (Î¶ ^ k) = Î¶ ^ (k * u.val.val % 19) := by
          -- By definition of $Ïƒ$, we know that $Ïƒ u (Î¶) = Î¶^u$.
          have h_sigma_zeta : (Ïƒ u) Î¶ = Î¶ ^ u.val.val := by
            have h_sigma_zeta : âˆ€ u : (ZMod 19)Ë£, Ïƒ u Î¶ = Î¶ ^ (u : ZMod 19).val := by
              unfold Ïƒ;
              simp +zetaDelta at *;
              intro u; exact (by
              convert ( IsCyclotomicExtension.autEquivPow L ( Polynomial.cyclotomic.irreducible_rat ( n := 19 ) ( by norm_num ) ) ).symm_apply_eq.mpr _;
              rotate_left;
              exact u;
              exact ( IsCyclotomicExtension.autEquivPow L ( Polynomial.cyclotomic.irreducible_rat ( n := 19 ) ( by norm_num ) ) ).symm u;
              Â· exact?;
              Â· erw [ PowerBasis.equivOfMinpoly_gen ];
                simp +decide [ IsPrimitiveRoot.powerBasis ];
                rfl);
            exact h_sigma_zeta u;
          -- Since Î¶ is a primitive 19th root of unity, we have Î¶^19 = 1. Therefore, Î¶^(k*u.val.val) = Î¶^(k*u.val.val mod 19).
          have h_exp : âˆ€ k : â„•, Î¶ ^ (k * u.val.val) = Î¶ ^ (k * u.val.val % 19) := by
            have h_exp : Î¶ ^ 19 = 1 := by
              exact hÎ¶.pow_eq_one;
            exact fun k => by rw [ â† Nat.mod_add_div ( k * u.val.val ) 19, pow_add, pow_mul ] ; aesop;
          simp_all +decide [ pow_mul' ];
        fin_cases u <;> simp +decide [ * ] at hu âŠ¢;
        all_goals simp_all +decide [ ZMod.val ];
        all_goals ring;
      exact Subtype.ext h_eq

/-
Explicit formula for the Frobenius action on Î±.
-/
theorem explicit_frobenius (hN7 : N â‰  7) [CharP (kP P) N] :
  ((uN hN : ZMod 19) âˆˆ S1 â†’ (red P Î±_int) ^ N = (3 * (red P Î±_int)^2 - 8 * (red P Î±_int) - 38) * (7 : kP P)â»Â¹) âˆ§
  ((uN hN : ZMod 19) âˆˆ S2 â†’ (red P Î±_int) ^ N = (-3 * (red P Î±_int)^2 + (red P Î±_int) + 38) * (7 : kP P)â»Â¹) := by
    constructor <;> intro h;
    Â· -- By artin_property, (red P Î±_int)^N = red P (Ïƒ_int (uN hN) Î±_int).
      have h1 : (red P Î±_int) ^ N = red P (Ïƒ_int (uN hN) Î±_int) := by
        rw [ â† artin_property ];
      -- By sigma_alpha_eq_beta_or_gamma, Ïƒ_int (uN hN) Î±_int = Î²_int.
      have h2 : Ïƒ_int (uN hN) Î±_int = Î²_int := by
        exact sigma_alpha_eq_beta_or_gamma ( uN hN ) |>.1 h;
      field_simp;
      rw [ h1, h2, eq_div_iff ] <;> norm_num;
      Â· -- By cyclic_relations_int, we have 7 * Î²_int = 3 * Î±_int^2 - 8 * Î±_int - 38.
        have h3 : 7 * Î²_int = 3 * Î±_int^2 - 8 * Î±_int - 38 := by
          exact cyclic_relations_int.1;
        convert congr_arg ( red P ) h3 using 1 <;> norm_num ; ring;
        Â· exact?;
        Â· erw [ map_ofNat, map_ofNat, map_ofNat ] ; ring;
      Â· erw [ CharP.cast_eq_zero_iff ( kP P ) N ];
        exact fun h => hN7 <| by have := Nat.le_of_dvd ( by decide ) h; interval_cases N <;> trivial;
    Â· have h_frob_gamma : (red P Î±_int) ^ N = red P Î³_int := by
        have h_frob_gamma : (red P Î±_int) ^ N = red P (Ïƒ_int (uN hN) Î±_int) := by
          rw [ â† artin_property ];
        convert h_frob_gamma using 1 ; erw [ sigma_alpha_eq_beta_or_gamma _ |>.2 h ] ;
      have h_cyclic_gamma : 7 * red P Î³_int = -3 * (red P Î±_int) ^ 2 + (red P Î±_int) + 38 := by
        have h_cyclic_gamma : 7 * Î³_int = -3 * Î±_int ^ 2 + Î±_int + 38 := by
          exact cyclic_relations_int.2;
        convert congr_arg ( red P ) h_cyclic_gamma using 1
      have h_inv_gamma : 7â»Â¹ * (7 * red P Î³_int) = red P Î³_int := by
        rw [ â† mul_assoc, inv_mul_cancelâ‚€, one_mul ];
        intro h; have := CharP.cast_eq_zero_iff ( kP P ) N 7; simp_all +decide ;
        have := Nat.le_of_dvd ( by decide ) this; interval_cases N <;> trivial;
      rw [h_frob_gamma, â† h_inv_gamma]
      field_simp [h_cyclic_gamma];
      exact congrArgâ‚‚ _ ( by linear_combination' h_cyclic_gamma ) rfl

def q_val : â„• := 19
def a_val : â„• := 7
def s1_val : ZMod 19 := (- (a_val : ZMod 19) - 3) / 6
def s2_val : ZMod 19 := ((a_val : ZMod 19) - 3) / 6
def c_val (N : â„•) : ZMod 19 := (N : ZMod 19) ^ ((q_val - 1) / 3)

/-
The polynomial f = x^3 - 19x - 19.
-/
def f_poly : Polynomial L := X^3 - 19*X - 19

/-
alpha is a root of f = x^3 - 19x - 19.
-/
theorem alpha_root : (f_poly).eval Î± = 0 := by
  unfold f_poly;
  unfold Î±;
  unfold Î·â‚‚ Î·â‚;
  -- By definition of $Î¶$, we know that $Î¶^19 = 1$ and $Î¶^k â‰  1$ for $1 â‰¤ k < 19$.
  have hÎ¶ : Î¶ ^ 19 = 1 âˆ§ âˆ€ k : â„•, 1 â‰¤ k â†’ k < 19 â†’ Î¶ ^ k â‰  1 := by
    exact âŸ¨ hÎ¶.pow_eq_one, fun k hkâ‚ hkâ‚‚ hkâ‚ƒ => by have := hÎ¶.pow_eq_one_iff_dvd k; interval_cases k <;> simp_all +decide âŸ©;
  ring_nf at *;
  simp_all +decide [ pow_succ' ];
  grind +ring

/-
alpha + beta + gamma = 0.
-/
theorem sum_zero : Î± + Î² + Î³ = 0 := by
  unfold Î± Î² Î³
  ring

/-
2a beta = 6 alpha^2 - (a+9)alpha - 4q with a=7, q=19.
-/
theorem beta_relation : 2 * 7 * Î² = 6 * Î±^2 - (7 + 9) * Î± - 4 * 19 := by
  -- By multiplying both sides of the equation $7 \beta = 3 \alpha^2 - 8 \alpha - 38$ by 2, we get the desired result.
  have h_mul : 2 * 7 * Î² = 2 * (3 * Î±^2 - 8 * Î± - 38) := by
    convert congr_arg ( fun x : L => 2 * x ) ( cyclic_relations.left ) using 1 ; ring;
  convert h_mul using 1 ; ring

/-
s1_val is 11 and s2_val is 7 in ZMod 19.
-/
lemma s1_val_eq : s1_val = 11 := by
  native_decide +revert
lemma s2_val_eq : s2_val = 7 := by
  native_decide +revert

/-
N is in S1 iff c_val N = s2_val.
-/
lemma N_in_S1_iff_c_eq_s2 (hN : N â‰  19) : (uN hN : ZMod 19) âˆˆ S1 â†” c_val N = s2_val := by
  -- By definition of $c_val$, we know that $c_val N = (N : ZMod 19)^6$.
  have hc_val : c_val N = (N : ZMod 19)^6 := by
    exact?;
  simp +decide [ hc_val, s2_val_eq ];
  unfold uN; simp +decide [ S1 ] ;
  grind

/-
N is in S2 iff c_val N = s1_val.
-/
lemma N_in_S2_iff_c_eq_s1 (hN : N â‰  19) : (uN hN : ZMod 19) âˆˆ S2 â†” c_val N = s1_val := by
  unfold uN S2 c_val s1_val;
  simp +decide [ q_val, a_val ] ; norm_num [ ZMod.natCast_eq_zero_iff ];
  grind

/-
If c = s1, then alpha^N = gamma. If c = s2, then alpha^N = beta.
-/
theorem final_result {N : â„•} [Fact (Nat.Prime N)] (hN : N â‰  19) (P : Ideal ğ“L) [P.IsMaximal] [CharP (kP P) N] (hN7 : N â‰  7) :
  (c_val N = s1_val â†’ (red P Î±_int) ^ N = red P Î³_int) âˆ§
  (c_val N = s2_val â†’ (red P Î±_int) ^ N = red P Î²_int) := by
    constructor <;> intro h;
    Â· have h_sigma_gamma : Ïƒ_int (uN hN) Î±_int = Î³_int := by
        apply (sigma_alpha_eq_beta_or_gamma (uN hN)).right;
        convert N_in_S2_iff_c_eq_s1 hN |>.2 h using 1;
      rw [ â† h_sigma_gamma, artin_property ];
    Â· -- By N_in_S1_iff_c_eq_s2, uN hN is in S1.
      have h_S1 : (uN hN : ZMod 19) âˆˆ S1 := by
        convert N_in_S1_iff_c_eq_s2 hN |>.2 h using 1;
      rw [ â† artin_property ];
      rw [ sigma_alpha_eq_beta_or_gamma _ |>.1 h_S1 ];
      assumption

/-
If c = s1, then alpha^N = gamma. If c = s2, then alpha^N = beta.
-/
theorem final_result_proof {N : â„•} [Fact (Nat.Prime N)] (hN : N â‰  19) (P : Ideal ğ“L) [P.IsMaximal] [CharP (kP P) N] (hN7 : N â‰  7) :
  (c_val N = s1_val â†’ (red P Î±_int) ^ N = red P Î³_int) âˆ§
  (c_val N = s2_val â†’ (red P Î±_int) ^ N = red P Î²_int) := by
    convert final_result hN P hN7 using 1

/-
Definitions of constants q=97, a=19, s1, s2, and c for the new problem instance.
-/
def q' : â„• := 97
def a' : â„• := 19
def s1' : ZMod 97 := (- (a' : ZMod 97) - 3) * (6 : ZMod 97)â»Â¹
def s2' : ZMod 97 := ((a' : ZMod 97) - 3) * (6 : ZMod 97)â»Â¹
def c' (N : â„•) : ZMod 97 := (N : ZMod 97) ^ ((q' - 1) / 3)

/-
Define the cyclotomic field L97 and the primitive root of unity zeta97.
-/
open Polynomial NumberField

def L97 : Type := CyclotomicField 97 â„š

instance : Field L97 := CyclotomicField.instField 97 â„š
instance : NumberField L97 := CyclotomicField.instNumberField 97 â„š
instance : IsCyclotomicExtension {97} â„š L97 := CyclotomicField.isCyclotomicExtension 97 â„š

def Î¶97 : L97 := IsCyclotomicExtension.zeta 97 â„š L97

instance : Fact (Nat.Prime 97) := âŸ¨by norm_numâŸ©

/-
Define the sets of indices and the Gaussian periods for q=97. Define alpha, beta, gamma.
-/
def S_cubic_res : Finset (ZMod 97) := {x | x â‰  0 âˆ§ x ^ 32 = 1}
def S_s1 : Finset (ZMod 97) := {x | x â‰  0 âˆ§ x ^ 32 = s1'}
def S_s2 : Finset (ZMod 97) := {x | x â‰  0 âˆ§ x ^ 32 = s2'}

def Î·â‚€' : L97 := âˆ‘ x âˆˆ S_cubic_res, Î¶97 ^ (x.val : â„•)
def Î·â‚' : L97 := âˆ‘ x âˆˆ S_s2, Î¶97 ^ (x.val : â„•)
def Î·â‚‚' : L97 := âˆ‘ x âˆˆ S_s1, Î¶97 ^ (x.val : â„•)

def Î±' : L97 := -(Î·â‚‚' - Î·â‚')
def Î²' : L97 := -(Î·â‚€' - Î·â‚‚')
def Î³' : L97 := -(Î·â‚' - Î·â‚€')

/-
The sum of alpha, beta, and gamma is zero.
-/
theorem sum_zero' : Î±' + Î²' + Î³' = 0 := by
  unfold Î±' Î²' Î³' ;
  ring

/-
Definitions of index function, cyclotomic numbers, and period function for q=97.
-/
def ind (x : ZMod 97) : ZMod 3 :=
  if x âˆˆ S_cubic_res then 0
  else if x âˆˆ S_s1 then 1
  else 2

def cyc_num (i j : ZMod 3) : â„• :=
  Fintype.card { x : ZMod 97 // x â‰  0 âˆ§ x â‰  1 âˆ§ ind x = i âˆ§ ind (1 - x) = j }

def period (i : ZMod 3) : L97 :=
  if i = 0 then Î·â‚€'
  else if i = 1 then Î·â‚‚'
  else Î·â‚'

/-
The period function maps 0, 1, 2 to eta0', eta2', eta1' respectively.
-/
lemma period_eq_def : period 0 = Î·â‚€' âˆ§ period 1 = Î·â‚‚' âˆ§ period 2 = Î·â‚' := by
  aesop

/-
The index function correctly identifies which coset an element belongs to.
-/
lemma ind_spec (x : ZMod 97) (hx : x â‰  0) :
  (ind x = 0 â†” x âˆˆ S_cubic_res) âˆ§
  (ind x = 1 â†” x âˆˆ S_s1) âˆ§
  (ind x = 2 â†” x âˆˆ S_s2) := by
    native_decide +revert

/-
Compute the cyclotomic numbers for q=97.
-/
#eval (cyc_num 0 0, cyc_num 0 1, cyc_num 0 2)
#eval (cyc_num 1 0, cyc_num 1 1, cyc_num 1 2)
#eval (cyc_num 2 0, cyc_num 2 1, cyc_num 2 2)

/-
Values of the cyclotomic numbers for q=97.
-/
lemma cyc_num_vals :
  cyc_num 0 0 = 12 âˆ§ cyc_num 0 1 = 10 âˆ§ cyc_num 0 2 = 9 âˆ§
  cyc_num 1 0 = 10 âˆ§ cyc_num 1 1 = 9 âˆ§ cyc_num 1 2 = 13 âˆ§
  cyc_num 2 0 = 9 âˆ§ cyc_num 2 1 = 13 âˆ§ cyc_num 2 2 = 10 := by
  native_decide

/-
Number of solutions to x + y = u with ind x = i and ind y = j.
-/
def N_sol (i j : ZMod 3) (u : ZMod 97) : â„• :=
  Fintype.card { p : ZMod 97 Ã— ZMod 97 // p.1 â‰  0 âˆ§ p.2 â‰  0 âˆ§ ind p.1 = i âˆ§ ind p.2 = j âˆ§ p.1 + p.2 = u }

/-
The index of -1 is 0.
-/
lemma ind_neg_one : ind (-1) = 0 := by
  native_decide

/-
The index function is a homomorphism from the multiplicative group to the additive group Z/3Z.
-/
lemma ind_mul (x y : ZMod 97) (hx : x â‰  0) (hy : y â‰  0) : ind (x * y) = ind x + ind y := by
  revert x y
  native_decide

/-
The index of the inverse is the negative of the index.
-/
lemma ind_inv (x : ZMod 97) (hx : x â‰  0) : ind (xâ»Â¹) = - ind x := by
  revert x
  native_decide

/-
The number of solutions to x+y=u depends only on the index of u.
-/
lemma N_sol_eq_cyc_num (i j : ZMod 3) (u : ZMod 97) (hu : u â‰  0) :
  N_sol i j u = cyc_num (i - ind u) (j - ind u) := by
    refine' Fintype.card_congr _;
    refine' Equiv.ofBijective ( fun x => âŸ¨ x.val.1 / u, _, _, _, _ âŸ© ) âŸ¨ _, _ âŸ©;
    all_goals simp_all +decide [ div_eq_iff, Function.Injective, Function.Surjective ];
    grind;
    Â· grind;
    Â· have := ind_mul ( x.val.1 / u ) u; simp_all +decide [ div_eq_mul_inv ] ;
      grind;
    Â· have h_ind : ind (x.val.2 / u) = ind x.val.2 - ind u := by
        have h_ind : ind (x.val.2 / u) = ind x.val.2 + ind (uâ»Â¹) := by
          apply ind_mul; exact (by
          exact x.2.2.1); exact (by
          haveI := Fact.mk ( by decide : Nat.Prime 97 ) ; exact inv_ne_zero hu;);
        rw [ h_ind, ind_inv u hu ] ; ring;
      grind;
    Â· aesop;
    Â· native_decide +revert

/-
The cardinalities of the sets S_cubic_res, S_s1, and S_s2 are all 32.
-/
lemma card_S : S_cubic_res.card = 32 âˆ§ S_s1.card = 32 âˆ§ S_s2.card = 32 := by
  native_decide

/-
Define C_coset to avoid ambiguity and relate it to the period definitions.
-/
def C_coset (i : ZMod 3) : Finset (ZMod 97) := Finset.univ.filter (fun x => x â‰  0 âˆ§ ind x = i)

lemma C_coset_eq : C_coset 0 = S_cubic_res âˆ§ C_coset 1 = S_s1 âˆ§ C_coset 2 = S_s2 := by
  native_decide +revert

lemma period_eq_sum_C_coset (i : ZMod 3) : period i = âˆ‘ x âˆˆ C_coset i, Î¶97 ^ (x.val : â„•) := by
  rw [ show C_coset i = if i = 0 then S_cubic_res else if i = 1 then S_s1 else S_s2 from ?_ ];
  Â· unfold period; aesop;
  Â· native_decide +revert

/-
Expansion of the product of Gaussian periods in terms of solution counts.
-/
lemma period_mul_eq_sum_N_sol (i j : ZMod 3) :
  period i * period j = (if i = j then 32 else 0) +
  âˆ‘ u âˆˆ Finset.univ.filter (fun x : ZMod 97 => x â‰  0), (N_sol i j u : L97) * Î¶97 ^ (u.val : â„•) := by
    have h_expand : period i * period j = âˆ‘ u âˆˆ Finset.univ, (if u = 0 then (if i = j then 32 else 0) else (N_sol i j u : L97)) * Î¶97 ^ u.val := by
      have h_expand : period i * period j = âˆ‘ x âˆˆ C_coset i, âˆ‘ y âˆˆ C_coset j, Î¶97 ^ (x.val + y.val : â„•) := by
        rw [ period_eq_sum_C_coset i, period_eq_sum_C_coset j, Finset.sum_mul ];
        simp +decide only [Finset.mul_sum _ _ _, pow_add];
      have h_group : âˆ€ u : ZMod 97, âˆ‘ x âˆˆ C_coset i, âˆ‘ y âˆˆ C_coset j, (if x + y = u then 1 else 0) * Î¶97 ^ u.val = (if u = 0 then (if i = j then 32 else 0) else (N_sol i j u : L97)) * Î¶97 ^ u.val := by
        intro u
        have h_group : âˆ‘ x âˆˆ C_coset i, âˆ‘ y âˆˆ C_coset j, (if x + y = u then 1 else 0) = (if u = 0 then (if i = j then 32 else 0) else (N_sol i j u : â„•)) := by
          split_ifs <;> simp_all +decide [ N_sol ];
          Â· fin_cases j <;> native_decide;
          Â· intro x hx y hy; contrapose! hy; simp_all +decide [ C_coset ] ;
            intro hy' hy''; have := ind_mul x ( -1 ) ; simp_all +decide [ add_eq_zero_iff_eq_neg ] ;
          Â· rw [ Fintype.card_subtype ];
            rw [ â† Finset.card_biUnion ];
            Â· refine' Finset.card_bij ( fun x hx => ( u - x, x ) ) _ _ _ <;> simp +decide [ Finset.mem_biUnion, Finset.mem_filter ];
              Â· unfold C_coset at *; aesop;
              Â· unfold C_coset; aesop;
            Â· exact fun x hx y hy hxy => Finset.disjoint_left.mpr fun z hzâ‚ hzâ‚‚ => hxy <| by aesop;
        convert congr_arg ( Â· * Î¶97 ^ u.val ) ( show ( âˆ‘ x âˆˆ C_coset i, âˆ‘ y âˆˆ C_coset j, if x + y = u then 1 else 0 : L97 ) = if u = 0 then if i = j then 32 else 0 else N_sol i j u from ?_ ) using 1;
        Â· simp +decide only [Finset.sum_mul _ _ _];
        Â· split_ifs <;> norm_num;
        Â· convert congr_arg ( fun x : â„• => x : â„• â†’ L97 ) h_group using 1;
          norm_num [ Finset.sum_ite ];
      rw [ â† Finset.sum_congr rfl fun u hu => h_group u ];
      rw [ h_expand, Finset.sum_comm ];
      rw [ Finset.sum_comm, Finset.sum_congr rfl ];
      rw [ Finset.sum_comm ];
      intro x hx; rw [ Finset.sum_comm ] ; simp +decide [ Finset.sum_ite ] ;
      refine' Finset.sum_congr rfl fun y hy => _;
      have h_exp : Î¶97 ^ 97 = 1 := by
        exact IsCyclotomicExtension.zeta_pow ( 97 : â„• ) â„š L97;
      rw [ â† Nat.mod_add_div ( x.val + y.val ) 97, pow_add, pow_mul ] ; aesop;
    rw [ h_expand, Finset.sum_eq_add_sum_diff_singleton ( Finset.mem_univ 0 ) ] ; aesop

/-
Multiplication rule for Gaussian periods.
-/
lemma period_mul (i j : ZMod 3) :
  period i * period j = (if i = j then 32 else 0) +
  (cyc_num (i - 0) (j - 0) * period 0 +
   cyc_num (i - 1) (j - 1) * period 1 +
   cyc_num (i - 2) (j - 2) * period 2) := by
     -- Apply Lemma `period_mul_eq_sum_N_sol` to expand the product.
     have h_expand : period i * period j = (if i = j then 32 else 0) +
       âˆ‘ u âˆˆ (Finset.univ.filter (fun x : ZMod 97 => x â‰  0)), (cyc_num (i - ind u) (j - ind u) : L97) * Î¶97 ^ (u.val : â„•) := by
         rw [ period_mul_eq_sum_N_sol ];
         exact congrArg _ ( Finset.sum_congr rfl fun u hu => by rw [ N_sol_eq_cyc_num i j u ( by simpa using hu ) ] );
     -- Partition the sum over `u != 0` based on `ind u = k` for `k \in {0, 1, 2}`.
     have h_partition : âˆ‘ u âˆˆ (Finset.univ.filter (fun x : ZMod 97 => x â‰  0)), (cyc_num (i - ind u) (j - ind u) : L97) * Î¶97 ^ (u.val : â„•) =
       âˆ‘ k âˆˆ Finset.univ, (cyc_num (i - k) (j - k) : L97) * âˆ‘ u âˆˆ (Finset.univ.filter (fun x : ZMod 97 => x â‰  0 âˆ§ ind x = k)), Î¶97 ^ (u.val : â„•) := by
         simp +decide only [Finset.sum_filter, Finset.mul_sum _ _ _];
         rw [ Finset.sum_comm, Finset.sum_congr rfl ] ; aesop;
     -- By definition of $C_koset$, we know that $\sum_{u \in C_koset k} \zeta_97^u = \text{period } k$.
     have h_period : âˆ€ k : ZMod 3, âˆ‘ u âˆˆ (Finset.univ.filter (fun x : ZMod 97 => x â‰  0 âˆ§ ind x = k)), Î¶97 ^ (u.val : â„•) = period k := by
       intro k
       simp [period_eq_sum_C_coset, C_coset];
     simp_all +decide [ Fin.sum_univ_three ];
     erw [ Fin.sum_univ_three ] ; ring!;

/-
alpha' is a root of X^3 - 97X - 97.
-/
theorem alpha_root' : Î±'^3 - 97*Î±' - 97 = 0 := by
  unfold Î±';
  -- By definition of $Î·â‚€'$, $Î·â‚'$, and $Î·â‚‚'$, we know that $Î·â‚€' + Î·â‚' + Î·â‚‚' = -1$.
  have h_sum : Î·â‚€' + Î·â‚' + Î·â‚‚' = -1 := by
    -- The sum of all non-trivial roots of unity in the cyclotomic field is -1.
    have h_sum_roots : âˆ‘ x âˆˆ Finset.univ.filter (fun x : ZMod 97 => x â‰  0), Î¶97 ^ (x.val : â„•) = -1 := by
      have h_sum : âˆ‘ x : ZMod 97, (Î¶97 : L97) ^ (x.val : â„•) = 0 := by
        have h_geom_sum : âˆ‘ x âˆˆ Finset.range 97, (Î¶97 : L97) ^ x = 0 := by
          rw [ geom_sum_eq ] <;> norm_num [ IsPrimitiveRoot.ne_one ];
          Â· exact Or.inl ( sub_eq_zero_of_eq <| by exact IsPrimitiveRoot.pow_eq_one <| IsCyclotomicExtension.zeta_spec 97 â„š L97 );
          Â· have h_order : IsPrimitiveRoot Î¶97 97 := by
              convert IsCyclotomicExtension.zeta_spec 97 â„š L97 using 1
              skip
            generalize_proofs at *; exact h_order.ne_one (by norm_num);
        convert h_geom_sum using 1;
      rw [ Finset.sum_eq_add_sum_diff_singleton ( Finset.mem_univ 0 ) ] at h_sum;
      simpa [ Finset.filter_ne' ] using eq_neg_of_add_eq_zero_right h_sum;
    rw [ â† h_sum_roots, show Î·â‚€' + Î·â‚' + Î·â‚‚' = âˆ‘ x âˆˆ Finset.univ.filter ( fun x : ZMod 97 => x â‰  0 ), Î¶97 ^ x.val from ?_ ];
    rw [ show ( Finset.univ.filter fun x : ZMod 97 => x â‰  0 ) = S_cubic_res âˆª S_s1 âˆª S_s2 from by native_decide, Finset.sum_union, Finset.sum_union ];
    Â· exact?;
    Â· native_decide +revert;
    Â· native_decide +revert;
  have := @period_mul 0 0; ( have := @period_mul 0 1; ( have := @period_mul 0 2; ( have := @period_mul 1 1; ( have := @period_mul 1 2; ( have := @period_mul 2 2; norm_num [ Finset.sum_add_distrib, pow_succ' ] at *; ) ) ) ) );
  simp_all +decide [ period_eq_def ];
  erw [ cyc_num_vals.1, cyc_num_vals.2.1, cyc_num_vals.2.2.1, cyc_num_vals.2.2.2.1, cyc_num_vals.2.2.2.2.1, cyc_num_vals.2.2.2.2.2.1, cyc_num_vals.2.2.2.2.2.2.1, cyc_num_vals.2.2.2.2.2.2.2.1, cyc_num_vals.2.2.2.2.2.2.2.2 ] at * ; norm_num at *;
  grind +ring

/-
Algebraic relation between beta' and alpha'.
-/
theorem beta_relation' : 2 * 19 * Î²' = 6 * Î±'^2 - (19 + 9) * Î±' - 4 * 97 := by
  unfold Î²' Î±';
  rw [ show Î·â‚€' = period 0 from rfl, show Î·â‚' = period 2 from rfl, show Î·â‚‚' = period 1 from rfl ];
  -- By definition of $period$, we know that $period 0 + period 1 + period 2 = -1$.
  have h_sum : period 0 + period 1 + period 2 = -1 := by
    -- By definition of $period$, we know that $period 0 + period 1 + period 2 = \sum_{x \in \mathbb{Z}/97\mathbb{Z}} \zeta_{97}^x$.
    have h_sum : period 0 + period 1 + period 2 = âˆ‘ x âˆˆ Finset.univ.filter (fun x : ZMod 97 => x â‰  0), Î¶97 ^ (x.val : â„•) := by
      rw [ period_eq_sum_C_coset, period_eq_sum_C_coset, period_eq_sum_C_coset ];
      rw [ â† Finset.sum_union, â† Finset.sum_union ];
      Â· rw [ show C_coset 0 âˆª C_coset 1 âˆª C_coset 2 = Finset.univ.filter ( fun x : ZMod 97 => x â‰  0 ) from ?_ ];
        native_decide +revert;
      Â· native_decide +revert;
      Â· simp +decide [ C_coset, Finset.disjoint_left ];
        grind;
    -- The sum of all powers of $\zeta_{97}$ is zero.
    have h_sum_zero : âˆ‘ x âˆˆ Finset.range 97, Î¶97 ^ x = 0 := by
      rw [ geom_sum_eq ] <;> norm_num [ hÎ¶ ];
      Â· exact Or.inl ( sub_eq_zero_of_eq <| by exact ( show Î¶97 ^ 97 = 1 from by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact by rw [ show Î¶97 = IsCyclotomicExtension.zeta 97 â„š L97 from rfl ] ; exact? ) ) ) ) ) ) ) ) ) ) ) ) ) );
      Â· have := IsCyclotomicExtension.zeta_spec 97 â„š L97;
        exact this.ne_one ( by decide );
    rw [ Finset.sum_eq_sum_diff_singleton_add ( Finset.mem_range.mpr ( show 0 < 97 by decide ) ) ] at h_sum_zero;
    convert eq_neg_of_add_eq_zero_left h_sum_zero using 1;
    norm_num;
  -- Substitute the known values of the cyclotomic numbers into the equation.
  have h_cyclotomic : cyc_num 0 0 = 12 âˆ§ cyc_num 0 1 = 10 âˆ§ cyc_num 0 2 = 9 âˆ§ cyc_num 1 0 = 10 âˆ§ cyc_num 1 1 = 9 âˆ§ cyc_num 1 2 = 13 âˆ§ cyc_num 2 0 = 9 âˆ§ cyc_num 2 1 = 13 âˆ§ cyc_num 2 2 = 10 := by
    exact?;
  rw [ show period 0 = -1 - period 1 - period 2 by linear_combination' h_sum ] ; ring;
  rw [ show period 1 ^ 2 = period 1 * period 1 by ring, show period 2 ^ 2 = period 2 * period 2 by ring ] ; rw [ period_mul 1 1, period_mul 2 2, period_mul 1 2 ] ; simp +decide [ h_cyclotomic ] ; ring;
  rw [ show cyc_num ( -1 ) 0 = 9 by exact h_cyclotomic.2.2.2.2.2.2.1, show cyc_num ( -1 ) ( -1 ) = 10 by exact h_cyclotomic.2.2.2.2.2.2.2.2 ] ; norm_num ; ring;
  rw [ show cyc_num 0 1 = 10 by exact h_cyclotomic.2.1, show cyc_num 1 1 = 9 by exact h_cyclotomic.2.2.2.2.1 ] ; ring ; rw [ show period 0 = -1 - period 1 - period 2 by linear_combination' h_sum ] ; ring

/-
Define the Galois unit and automorphism for q=97.
-/
def gal_unit97 (N : â„•) [Fact (Nat.Prime N)] (hN : N â‰  97) : (ZMod 97)Ë£ := Units.mk0 (N : ZMod 97) (by
  rw [Ne, ZMod.natCast_zmod_eq_zero_iff_dvd]
  intro h
  have hN_prime : Nat.Prime N := Fact.out
  have : 97 = 1 âˆ¨ 97 = N := (Nat.dvd_prime hN_prime).mp h
  have : 97 = N := this.resolve_left (by norm_num)
  exact hN this.symm)

def sigma97 (u : (ZMod 97)Ë£) : L97 â‰ƒâ‚[â„š] L97 :=
  (IsCyclotomicExtension.autEquivPow L97 (Polynomial.cyclotomic.irreducible_rat (n := 97) (by norm_num))).symm u

/-
The Frobenius automorphism permutes the Gaussian periods by shifting their index by ind(N).
-/
lemma sigma_period (N : â„•) [Fact (Nat.Prime N)] (hN : N â‰  97) (i : ZMod 3) :
  sigma97 (gal_unit97 N hN) (period i) = period (i + ind (N : ZMod 97)) := by
    -- By definition of $C_coset$, we know that $C_coset i$ is the set of elements $x$ such that $ind x = i$.
    have hC_coset : âˆ€ i : ZMod 3, C_coset i = {x : ZMod 97 | x â‰  0 âˆ§ ind x = i} := by
      unfold C_coset; aesop;
    -- By definition of $sigma97$, we know that it maps $Î¶97^x$ to $Î¶97^{Nx}$ for any $x \in \mathbb{Z}/97\mathbb{Z}$.
    have h_sigma_map : âˆ€ x : ZMod 97, (sigma97 (gal_unit97 N hN)) (Î¶97 ^ x.val) = Î¶97 ^ ((N * x).val) := by
      intro x
      have h_sigma_map : (sigma97 (gal_unit97 N hN)) (Î¶97 ^ x.val) = (sigma97 (gal_unit97 N hN)) (Î¶97) ^ x.val := by
        exact map_pow _ _ _;
      have h_sigma_map : (sigma97 (gal_unit97 N hN)) Î¶97 = Î¶97 ^ (N : ZMod 97).val := by
        unfold sigma97;
        simp +decide [ gal_unit97 ];
        erw [ PowerBasis.equivOfMinpoly_gen ];
        exact?;
      cases N <;> simp_all +decide [ pow_mul ];
      norm_num [ â† pow_mul, ZMod.val_add, ZMod.val_mul ];
      rw [ â† Nat.mod_add_div ( ( _ + ZMod.val 1 ) % 97 * x.val ) 97 ] ; norm_num [ pow_add, pow_mul, Nat.mul_mod, Nat.pow_mod ] ;
      have h_zeta_pow : Î¶97 ^ 97 = 1 := by
        exact IsPrimitiveRoot.pow_eq_one ( IsCyclotomicExtension.zeta_spec 97 â„š L97 );
      aesop;
    -- By definition of $C_coset$, we know that $C_coset (i + ind N)$ is the set of elements $y$ such that $ind y = i + ind N$.
    have hC_coset_shift : C_coset (i + ind N) = Finset.image (fun x => (N * x : ZMod 97)) (C_coset i) := by
      ext x; simp [hC_coset];
      constructor;
      Â· intro hx
        obtain âŸ¨a, haâŸ© : âˆƒ a : ZMod 97, (N * a : ZMod 97) = x := by
          have h_inv : âˆƒ a : ZMod 97, (N : ZMod 97) * a = 1 := by
            have h_inv : Nat.gcd N 97 = 1 := by
              exact Nat.Coprime.symm ( Nat.Prime.coprime_iff_not_dvd ( by decide ) |>.2 fun h => hN <| by have := Nat.prime_dvd_prime_iff_eq ( by decide : Nat.Prime 97 ) ( Fact.out : Nat.Prime N ) ; tauto );
            have := Nat.exists_mul_emod_eq_one_of_coprime h_inv;
            exact Exists.elim ( this ( by decide ) ) fun m hm => âŸ¨ m, by simpa [ â† ZMod.natCast_eq_zero_iff ] using congr_arg ( fun x : â„• => x : â„• â†’ ZMod 97 ) hm âŸ©;
          exact âŸ¨ h_inv.choose * x, by linear_combination' h_inv.choose_spec * x âŸ©;
        use a; simp_all +decide [ Set.ext_iff ] ;
        have h_ind_mul : ind (N * a) = ind N + ind a := by
          have h_ind_mul : âˆ€ x y : ZMod 97, x â‰  0 â†’ y â‰  0 â†’ ind (x * y) = ind x + ind y := by
            exact?;
          apply h_ind_mul; exact (by
          intro h; simp_all +decide [ ZMod.natCast_eq_zero_iff ] ;); exact (by
          grind);
        grind +ring;
      Â· rintro âŸ¨ a, ha, rfl âŸ©;
        have h_ind_mul : ind (N * a) = ind N + ind a := by
          apply ind_mul;
          Â· intro h; have := Fact.out ( p := Nat.Prime N ) ; simp_all +decide [ ZMod.natCast_eq_zero_iff ] ;
            rw [ this.dvd_iff_eq ] at h <;> aesop;
          Â· exact hC_coset i |>.subset ha |>.1;
        simp_all +decide [ add_comm, C_coset ];
        exact?;
    -- By definition of $period$, we know that $period i$ is the sum of $Î¶97^x$ over $x \in C_coset i$.
    have hperiod_def : âˆ€ i : ZMod 3, period i = âˆ‘ x âˆˆ C_coset i, Î¶97 ^ x.val := by
      exact?;
    rw [ hperiod_def, hperiod_def, hC_coset_shift, Finset.sum_image ];
    Â· rw [ map_sum, Finset.sum_congr rfl fun x hx => h_sigma_map x ];
    Â· intro x hx y hy; haveI := Fact.mk ( Fact.out : Nat.Prime N ) ; simp_all +decide [ mul_eq_zero, ZMod.natCast_eq_zero_iff ] ;
      rintro ( rfl | h ) <;> simp_all +decide [ Nat.Prime.dvd_iff_eq Fact.out ]

/-
Integer versions of the periods and roots, and their coercion properties.
-/
def Î¶97_int : ğ“ L97 := IsPrimitiveRoot.toInteger (IsCyclotomicExtension.zeta_spec 97 â„š L97)

def period_int (i : ZMod 3) : ğ“ L97 := âˆ‘ x âˆˆ C_coset i, Î¶97_int ^ (x.val : â„•)

def Î±'_int : ğ“ L97 := -(period_int 1 - period_int 2)
def Î²'_int : ğ“ L97 := -(period_int 0 - period_int 1)
def Î³'_int : ğ“ L97 := -(period_int 2 - period_int 0)

lemma coe_period_int (i : ZMod 3) : (period_int i : L97) = period i := by
  unfold period_int period;
  unfold Î¶97_int Î·â‚€' Î·â‚' Î·â‚‚';
  split_ifs <;> simp +decide [ *, Subtype.ext_iff ];
  Â· congr! 1;
    exact C_coset_eq.1;
  Â· congr! 2;
    exact C_coset_eq.2.1;
  Â· congr! 1;
    native_decide +revert

lemma coe_alpha'_int : (Î±'_int : L97) = Î±' := by
  unfold Î±'_int Î±';
  unfold period_int;
  unfold Î·â‚‚' Î·â‚' C_coset; simp +decide [ Finset.sum_sub_distrib ] ;
  congr! 2;
  Â· native_decide +revert;
  Â· native_decide +revert

lemma coe_beta'_int : (Î²'_int : L97) = Î²' := by
  unfold Î²'_int Î²';
  unfold period_int;
  simp +decide [ C_coset_eq, S_s1, S_cubic_res ];
  congr!

lemma coe_gamma'_int : (Î³'_int : L97) = Î³' := by
  unfold Î³'_int Î³';
  unfold period_int;
  simp +decide [ C_coset_eq ];
  congr! 2

/-
Relate the index of N to the value of c' N being s1'.
-/
lemma ind_N_eq_1_iff_c_eq_s1 (N : â„•) [Fact (Nat.Prime N)] (hN : N â‰  97) :
  ind (N : ZMod 97) = 1 â†” c' N = s1' := by
    unfold ind c' s1';
    unfold S_cubic_res S_s1; simp +decide;
    unfold q' a' s1'; simp +decide ;
    split_ifs <;> simp_all +decide [ ZMod.natCast_eq_zero_iff ];
    Â· native_decide +revert;
    Â· rename_i hâ‚ hâ‚‚;
      contrapose! hâ‚‚;
      exact âŸ¨ fun h => hN <| by have := Nat.prime_dvd_prime_iff_eq ( by decide : Nat.Prime 97 ) ( Fact.out : Nat.Prime N ) ; tauto, hâ‚‚ âŸ©

/-
Relate the index of N to the value of c' N being s2'.
-/
lemma ind_N_eq_2_iff_c_eq_s2 (N : â„•) [Fact (Nat.Prime N)] (hN : N â‰  97) :
  ind (N : ZMod 97) = 2 â†” c' N = s2' := by
    -- By definition of $c'$ and $ind$, we know that $c' N = s2'$ if and only if $N^{32} = s2'$.
    have h_c'_eq_s2' : c' N = s2' â†” (N : ZMod 97) ^ 32 = s2' := by
      rfl;
    cases eq_or_ne ( N : ZMod 97 ) 0 <;> simp_all +decide [ ind ];
    Â· rw [ ZMod.natCast_eq_zero_iff ] at * ; exact absurd ( Nat.dvd_of_mod_eq_zero ( Nat.mod_eq_zero_of_dvd <| by assumption ) ) ( by rw [ Nat.dvd_prime Fact.out ] ; aesop );
    Â· split_ifs <;> simp_all +decide [ S_cubic_res, S_s1, S_s2 ];
      Â· native_decide +revert;
      Â· native_decide +revert;
      Â· have h_cases : âˆ€ x : ZMod 97, x â‰  0 â†’ x ^ 32 = 1 âˆ¨ x ^ 32 = s1' âˆ¨ x ^ 32 = s2' := by
          native_decide +revert;
        cases h_cases _ â€¹_â€º <;> tauto

/-
Abbreviations for the ring of integers, residue field, and reduction map for q=97.
-/
abbrev ğ“L97 := ğ“ L97
def kP97 (P : Ideal ğ“L97) [P.IsMaximal] := ğ“L97 â§¸ P
noncomputable instance (P : Ideal ğ“L97) [P.IsMaximal] : Field (kP97 P) := Ideal.Quotient.field P
def red97 (P : Ideal ğ“L97) [P.IsMaximal] : ğ“L97 â†’+* kP97 P := Ideal.Quotient.mk P

/-
Relate the index of N to the value of c' N being s1'.
-/
lemma ind_N_eq_1_iff_c_eq_s1_new (N : â„•) [Fact (Nat.Prime N)] (hN : N â‰  97) :
  ind (N : ZMod 97) = 1 â†” c' N = s1' := by
    convert ind_N_eq_1_iff_c_eq_s1 N hN using 1

/-
Lift the automorphism sigma97 to the ring of integers.
-/
def sigma_int97 (u : (ZMod 97)Ë£) (x : ğ“ L97) : ğ“ L97 := âŸ¨sigma97 u x, by
  have h_integral : IsIntegral â„¤ (x : L97) := x.2
  exact IsIntegral.map (sigma97 u) h_integralâŸ©

/-
The ring of integers is generated by zeta97.
-/
lemma adjoin_zeta_eq_top97 : Algebra.adjoin â„¤ ({Î¶97_int} : Set ğ“L97) = âŠ¤ := by
  let hÎ¶ := IsCyclotomicExtension.zeta_spec 97 â„š L97
  let pb := IsPrimitiveRoot.integralPowerBasis' hÎ¶
  have h_gen : pb.gen = Î¶97_int := IsPrimitiveRoot.integralPowerBasis'_gen hÎ¶
  rw [â† h_gen]
  exact pb.adjoin_gen_eq_top

/-
The automorphism sigma_N reduces to the Frobenius map modulo P.
-/
theorem artin_property97 {N : â„•} [Fact (Nat.Prime N)] (hN : N â‰  97) (P : Ideal ğ“L97) [P.IsMaximal] [CharP (kP97 P) N] (x : ğ“L97) :
  red97 P (sigma_int97 (gal_unit97 N hN) x) = (red97 P x) ^ N := by
    have h_sigma_int97_zeta : âˆ€ x : ğ“L97, x âˆˆ Algebra.adjoin â„¤ ({Î¶97_int} : Set ğ“L97) â†’ red97 P (sigma_int97 (gal_unit97 N hN) x) = (red97 P x) ^ N := by
      refine fun x hx => Algebra.adjoin_induction ?_ ?_ ?_ ?_ hx;
      Â· -- Since $\sigma_N(\zeta_{97}) = \zeta_{97}^N$, we have $\sigma_int97(\zeta_{97}) = \zeta_{97}^N$.
        have h_sigma_zeta : sigma_int97 (gal_unit97 N hN) Î¶97_int = Î¶97_int ^ N := by
          have h_sigma_zeta : (sigma97 (gal_unit97 N hN) Î¶97_int : L97) = Î¶97_int ^ N := by
            have h_sigma_zeta : âˆ€ (u : (ZMod 97)Ë£), sigma97 u Î¶97 = Î¶97 ^ (u : ZMod 97).val := by
              intro u
              simp [sigma97];
              erw [ PowerBasis.equivOfMinpoly_gen ];
              rfl;
            convert h_sigma_zeta ( gal_unit97 N hN ) using 1;
            simp +decide [ gal_unit97 ];
            rw [ â† Nat.mod_add_div N 97 ] ; norm_num [ pow_add, pow_mul ] ;
            have h_zeta_97_pow : Î¶97 ^ 97 = 1 := by
              exact IsPrimitiveRoot.pow_eq_one ( IsCyclotomicExtension.zeta_spec 97 â„š L97 );
            erw [ show ( Î¶97_int : L97 ) = Î¶97 from ?_ ] ; aesop;
            exact?;
          exact?;
        aesop;
      Â· intro r; exact (by
        simp +decide [ red97, sigma_int97 ];
        erw [ Ideal.Quotient.eq ];
        -- Since $P$ is a maximal ideal, it is prime, and thus if $r^N - r$ is in $P$, then either $r$ is in $P$ or $r^{N-1} - 1$ is in $P$.
        have h_prime : âˆ€ r : â„¤, (r ^ N - r : ğ“L97) âˆˆ P := by
          intro r
          have h_fermat : (r ^ N - r : â„¤) â‰¡ 0 [ZMOD N] := by
            simp +decide [ â† ZMod.intCast_eq_intCast_iff ];
          obtain âŸ¨ k, hk âŸ© := h_fermat.symm.dvd;
          -- Since $N$ is in $P$, multiplying by $k$ (which is an integer) keeps it in $P$.
          have hN_in_P : (N : ğ“L97) âˆˆ P := by
            have hN_in_P : (N : kP97 P) = 0 := by
              exact?;
            exact?;
          convert P.mul_mem_right ( k : ğ“L97 ) hN_in_P using 1 ; norm_cast ; aesop;
        simpa using Submodule.neg_mem _ ( h_prime r ));
      Â· intro x y hx hy hx' hy'; simp +decide [ *, pow_add ] ;
        rw [ show sigma_int97 ( gal_unit97 N hN ) ( x + y ) = sigma_int97 ( gal_unit97 N hN ) x + sigma_int97 ( gal_unit97 N hN ) y from ?_, map_add ];
        Â· rw [ hx', hy', add_pow_char ];
        Â· exact Subtype.ext <| map_add _ _ _;
      Â· simp +contextual [ *, mul_pow ];
        intro x y hx hy hx' hy'; rw [ show sigma_int97 ( gal_unit97 N hN ) ( x * y ) = sigma_int97 ( gal_unit97 N hN ) x * sigma_int97 ( gal_unit97 N hN ) y from ?_ ] ; aesop;
        exact Subtype.ext <| map_mul _ _ _;
    exact h_sigma_int97_zeta x ( by rw [ adjoin_zeta_eq_top97 ] ; exact Algebra.mem_top ) |> fun h => by simpa using h;

/-
If c' N = s1', then sigma_N(alpha') = gamma'.
-/
lemma sigma_alpha_eq_gamma_if_s1 (N : â„•) [Fact (Nat.Prime N)] (hN : N â‰  97) (h : c' N = s1') :
  sigma_int97 (gal_unit97 N hN) Î±'_int = Î³'_int := by
    -- We check the equality in the field L97.
    have h_field : sigma97 (gal_unit97 N hN) (Î±'_int : L97) = (Î³'_int : L97) := by
      -- By definition of $c'$, we know that $c' N = s1'$ implies $ind (N : ZMod 97) = 1$.
      have h_ind : ind (N : ZMod 97) = 1 := by
        exact?;
      -- By definition of $sigma97$, we have $sigma97 (gal_unit97 N hN) (Î±'_int) = sigma97 (gal_unit97 N hN) (period 2 - period 1)$.
      have h_sigma97_def : sigma97 (gal_unit97 N hN) (Î±'_int : L97) = sigma97 (gal_unit97 N hN) (period 2 - period 1) := by
        rw [ show ( Î±'_int : L97 ) = period 2 - period 1 from ?_ ];
        convert coe_alpha'_int using 1;
        unfold Î±';
        exact?;
      -- By definition of $sigma97$, we have $sigma97 (gal_unit97 N hN) (period 2 - period 1) = period (2 + ind (N : ZMod 97)) - period (1 + ind (N : ZMod 97))$.
      have h_sigma97_period : sigma97 (gal_unit97 N hN) (period 2 - period 1) = period (2 + ind (N : ZMod 97)) - period (1 + ind (N : ZMod 97)) := by
        rw [ map_sub, sigma_period, sigma_period ];
      simp_all +decide [ Î³'_int ];
      exact congr_argâ‚‚ _ ( coe_period_int 0 â–¸ rfl ) ( coe_period_int 2 â–¸ rfl );
    convert h_field using 1;
    -- Since the ring of integers is a subalgebra of the field, the elements are equal in the ring if and only if they are equal in the field.
    have h_subalgebra : âˆ€ (x y : ğ“ L97), x = y â†” (x : L97) = (y : L97) := by
      exact?;
    convert h_subalgebra _ _ using 1

/-
If c' N = s2', then sigma_N(alpha') = beta'.
-/
lemma sigma_alpha_eq_beta_if_s2 (N : â„•) [Fact (Nat.Prime N)] (hN : N â‰  97) (h : c' N = s2') :
  sigma_int97 (gal_unit97 N hN) Î±'_int = Î²'_int := by
    -- Since $c' N = s2'$, we have $ind N = 2$.
    have h_ind : ind (N : ZMod 97) = 2 := by
      exact?;
    -- Since $\sigma_N(\alpha') = \beta'$ in $L97$, we have $\sigma_N(\alpha'_int) = \beta'_int$ in $\mathcal{O}_{L97}$.
    have h_sigma_alpha_int_eq_beta_int : (sigma97 (gal_unit97 N hN) Î±' : L97) = Î²' := by
      -- Since $c' N = s2'$, we have $ind N = 2$. Therefore, $\sigma_N(\alpha') = \beta'$.
      have h_sigma_beta : (sigma97 (gal_unit97 N hN)) (period 2 - period 1) = period 1 - period 0 := by
        have := sigma_period N hN 2; have := sigma_period N hN 1; aesop;
      generalize_proofs at *; (
      unfold Î±' Î²'; aesop;)
    generalize_proofs at *; (
    convert h_sigma_alpha_int_eq_beta_int using 1
    generalize_proofs at *; (
    constructor <;> intro h <;> simp_all +decide [ â† coe_alpha'_int, â† coe_beta'_int, â† coe_gamma'_int ] ;
    exact Subtype.ext h_sigma_alpha_int_eq_beta_int
    skip))

/-
Final result for q=97: Frobenius action on alpha depends on c' N.
-/
theorem final_result_97 {N : â„•} [Fact (Nat.Prime N)] (hN : N â‰  97) (hN19 : N â‰  19) (P : Ideal ğ“L97) [P.IsMaximal] [CharP (kP97 P) N] :
  (c' N = s1' â†’ (red97 P Î±'_int) ^ N = red97 P Î³'_int) âˆ§
  (c' N = s2' â†’ (red97 P Î±'_int) ^ N = red97 P Î²'_int) := by
  constructor
  Â· intro h
    rw [â† artin_property97 hN P Î±'_int]
    rw [sigma_alpha_eq_gamma_if_s1 N hN h]
  Â· intro h
    rw [â† artin_property97 hN P Î±'_int]
    rw [sigma_alpha_eq_beta_if_s2 N hN h]
