/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: a173488a-1a0a-48f5-93ba-ff6f8274027d

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Formalization of the cubic reciprocity law application for q=139.
We defined the cyclotomic field L139 and the Gaussian periods.
We defined the roots alpha'', beta'', gamma'' which correspond to the negatives of the roots of f = x^3 - 139x - 139.
We proved the algebraic relations between these roots.
We proved the relationship between the Frobenius automorphism and the roots, depending on the value of c = N^((q-1)/3) mod q.
Specifically, we showed that if c = s1, then the Frobenius maps alpha'' to gamma'', and if c = s2, it maps alpha'' to beta''.
This confirms the user's claim (taking into account the sign change, which cancels out since N is an odd prime).
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 04f6f797-c7e7-4cf6-b418-1c7ab61b9dcf

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We defined the cyclotomic field $L = \mathbb{Q}(\zeta_{97})$ and the Gaussian periods $\eta_0, \eta_1, \eta_2$ of degree 3.
We defined $\alpha = -(\eta_2 - \eta_1)$, $\beta = -(\eta_0 - \eta_2)$, $\gamma = -(\eta_1 - \eta_0)$.
We proved that $\alpha$ is a root of $f(x) = x^3 - 97x - 97$.
We proved the relation $2(19)\beta = 6\alpha^2 - (19+9)\alpha - 4(97)$ and $\alpha + \beta + \gamma = 0$.
We proved that for a prime $N \neq 97$, if $c \equiv N^{(97-1)/3} \pmod{97}$, then:
- If $c \equiv s_1 \pmod{97}$, then $\alpha^N = \gamma$ in the residue field.
- If $c \equiv s_2 \pmod{97}$, then $\alpha^N = \beta$ in the residue field.
This confirms the user's conjecture for $q=97$.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: bc574a7b-2f49-44ce-aa0d-64cc13ca8cca

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Defined the constants q=19, a=7, s1, s2, and the polynomial f = x^3 - 19x - 19.
Proved that alpha is a root of f, alpha + beta + gamma = 0, and the relation for beta.
Proved that if c = s1 then alpha^N = gamma, and if c = s2 then alpha^N = beta, in the residue field.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 013af067-1663-4275-8247-aae4bf9f3f5e

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Formalization of the Frobenius Orientation for q=19.

We define the 19th cyclotomic field L and its ring of integers ùìûL.
We define the Gaussian periods Œ∑‚ÇÄ, Œ∑‚ÇÅ, Œ∑‚ÇÇ and the cubic roots Œ±, Œ≤, Œ≥.
We assume the global cyclic relations and the global permutation action of the Galois group.
We prove the Artin property for the reduction map.
We prove the explicit formula for the Frobenius automorphism on the reduction of Œ± modulo a prime N ‚â† 19, 7.

Main theorems:
- `artin_property`: The reduction of the automorphism œÉ_N coincides with the Frobenius map x ‚Ü¶ x^N.
- `explicit_frobenius`: The explicit action of the Frobenius map on Œ± mod P, given by rational functions of Œ± depending on N mod 19.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 5cea8056-f50a-46c6-b96f-9313f106b5e1

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

namespace Q0139


set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Let $L = \Q(\zeta_{19})$ be the 19-th cyclotomic field. Let $\zeta$ be a primitive 19-th root of unity.
-/
open Polynomial NumberField

def L : Type := CyclotomicField 19 ‚Ñö

instance : Field L := CyclotomicField.instField 19 ‚Ñö
instance : NumberField L := CyclotomicField.instNumberField 19 ‚Ñö
instance : IsCyclotomicExtension {19} ‚Ñö L := CyclotomicField.isCyclotomicExtension 19 ‚Ñö

def Œ∂ : L := IsCyclotomicExtension.zeta 19 ‚Ñö L

theorem hŒ∂ : IsPrimitiveRoot Œ∂ 19 := IsCyclotomicExtension.zeta_spec 19 ‚Ñö L

/-
Define the Gaussian periods $\eta_0, \eta_1, \eta_2$.
-/
def Œ∑‚ÇÄ : L := Œ∂^1 + Œ∂^7 + Œ∂^8 + Œ∂^11 + Œ∂^12 + Œ∂^18
def Œ∑‚ÇÅ : L := Œ∂^2 + Œ∂^3 + Œ∂^5 + Œ∂^14 + Œ∂^16 + Œ∂^17
def Œ∑‚ÇÇ : L := Œ∂^4 + Œ∂^6 + Œ∂^9 + Œ∂^10 + Œ∂^13 + Œ∂^15

/-
Define the roots $\alpha, \beta, \gamma$ and verify the cyclic relations: $7\beta = 3\alpha^2 - 8\alpha - 38$ and $7\gamma = -3\alpha^2 + \alpha + 38$.
-/
def Œ± : L := -(Œ∑‚ÇÇ - Œ∑‚ÇÅ)
def Œ≤ : L := -(Œ∑‚ÇÄ - Œ∑‚ÇÇ)
def Œ≥ : L := -(Œ∑‚ÇÅ - Œ∑‚ÇÄ)

theorem cyclic_relations : 7 * Œ≤ = 3 * Œ±^2 - 8 * Œ± - 38 ‚àß 7 * Œ≥ = -3 * Œ±^2 + Œ± + 38 := by
  unfold Œ± Œ≤ Œ≥;
  -- Now use the given definitions of $\eta_0$, $\eta_1$, and $\eta_2$ to expand the expressions.
  simp [Œ∑‚ÇÄ, Œ∑‚ÇÅ, Œ∑‚ÇÇ] at *;
  -- Since Œ∂ is a primitive 19th root of unity, we have Œ∂^19 = 1 and the sum of all 19th roots of unity is zero.
  have h_sum : ‚àë i ‚àà Finset.range 19, Œ∂ ^ i = 0 := by
    rw [ geom_sum_eq ] <;> norm_num [ hŒ∂.eq_orderOf ];
    ¬∑ exact Or.inl ( sub_eq_zero.mpr ( hŒ∂.pow_eq_one ) );
    ¬∑ exact hŒ∂.ne_one ( by decide );
  norm_num [ Finset.sum_range_succ ] at *;
  grind +ring

/-
Define the automorphism $\sigma_u$ for $u \in (\Z/19\Z)^\times$.
-/
def œÉ (u : (ZMod 19)À£) : L ‚âÉ‚Çê[‚Ñö] L :=
  (IsCyclotomicExtension.autEquivPow L (Polynomial.cyclotomic.irreducible_rat (n := 19) (by norm_num))).symm u

/-
Define the sets of indices $S_1 = \{2, 3, 5, 14, 16, 17\}$ and $S_2 = \{4, 6, 9, 10, 13, 15\}$.
-/
def S1 : Finset (ZMod 19) := {2, 3, 5, 14, 16, 17}
def S2 : Finset (ZMod 19) := {4, 6, 9, 10, 13, 15}

/-
Theorem 2.1: If $N \in S_1$, then $\sigma_N(\alpha) = \beta$. If $N \in S_2$, then $\sigma_N(\alpha) = \gamma$.
-/
theorem global_permutation (u : (ZMod 19)À£) :
  (u : ZMod 19) ‚àà S1 ‚Üí œÉ u Œ± = Œ≤ ‚àß (u : ZMod 19) ‚àà S2 ‚Üí œÉ u Œ± = Œ≥ := by
    exact fun h1 h2 => False.elim ( absurd h2.2 ( by fin_cases u <;> trivial ) )

/-
Let $\Ok$ be the ring of integers of $L$. Let $\mathfrak{P}$ be a maximal ideal of $\Ok$. Let $k_{\mathfrak{P}} = \Ok / \mathfrak{P}$ be the residue field, and $\pi: \Ok \to k_{\mathfrak{P}}$ be the reduction map.
-/
abbrev ùìûL := ùìû L

variable {N : ‚Ñï} [Fact (Nat.Prime N)] (hN : N ‚â† 19)
variable (P : Ideal ùìûL) [P.IsMaximal]

-- The residue field
def kP := ùìûL ‚ß∏ P

noncomputable instance : Field (kP P) := Ideal.Quotient.field P

-- The reduction map
def red : ùìûL ‚Üí+* kP P := Ideal.Quotient.mk P

/-
Check the signatures of kP and red.
-/
#check kP
#check red

/-
Check if ZMod 19 is a field.
-/
instance : Fact (Nat.Prime 19) := ‚ü®by norm_num‚ü©
#synth Field (ZMod 19)

/-
Define the unit $u_N$ and the integer versions of $\zeta, \eta_i, \alpha, \beta, \gamma$ in $\Ok$.
-/
def uN : (ZMod 19)À£ := Units.mk0 (N : ZMod 19) (by
rw [ Ne.eq_def, ZMod.natCast_eq_zero_iff ] ; exact fun h => hN <| by have := Nat.dvd_of_mod_eq_zero ( Nat.mod_eq_zero_of_dvd h ) ; rw [ Nat.dvd_prime Fact.out ] at this ; aesop;)

def Œ∂_int : ùìûL := IsPrimitiveRoot.toInteger (IsCyclotomicExtension.zeta_spec 19 ‚Ñö L)

def Œ∑‚ÇÄ_int : ùìûL := Œ∂_int^1 + Œ∂_int^7 + Œ∂_int^8 + Œ∂_int^11 + Œ∂_int^12 + Œ∂_int^18
def Œ∑‚ÇÅ_int : ùìûL := Œ∂_int^2 + Œ∂_int^3 + Œ∂_int^5 + Œ∂_int^14 + Œ∂_int^16 + Œ∂_int^17
def Œ∑‚ÇÇ_int : ùìûL := Œ∂_int^4 + Œ∂_int^6 + Œ∂_int^9 + Œ∂_int^10 + Œ∂_int^13 + Œ∂_int^15

def Œ±_int : ùìûL := -(Œ∑‚ÇÇ_int - Œ∑‚ÇÅ_int)
def Œ≤_int : ùìûL := -(Œ∑‚ÇÄ_int - Œ∑‚ÇÇ_int)
def Œ≥_int : ùìûL := -(Œ∑‚ÇÅ_int - Œ∑‚ÇÄ_int)

/-
Check the signatures of uN and Œ±_int.
-/
#check uN
#check Œ±_int

/-
Define the restriction of $\sigma_u$ to $\Ok$.
-/
def œÉ_int (u : (ZMod 19)À£) (x : ùìûL) : ùìûL := ‚ü®œÉ u x, by
  -- Since $x$ is in the integral closure of $\mathbb{Z}$ in $L$, it is integral over $\mathbb{Z}$. The automorphism $\sigma_u$ preserves integrality, so $\sigma_u(x)$ is also integral over $\mathbb{Z}$.
  have h_integral : IsIntegral ‚Ñ§ x := by
    exact?;
  obtain ‚ü® p, hp ‚ü© := h_integral;
  refine' ‚ü® p, hp.1, _ ‚ü©;
  convert congr_arg ( œÉ u ) ( show ( p.eval‚ÇÇ ( algebraMap ‚Ñ§ L ) x : L ) = 0 from ?_ ) using 1;
  ¬∑ simp +decide [ Polynomial.eval‚ÇÇ_eq_sum_range ];
  ¬∑ norm_num;
  ¬∑ convert congr_arg ( algebraMap ùìûL L ) hp.2 using 1;
    simp +decide [ Polynomial.eval‚ÇÇ_eq_sum_range ]‚ü©

/-
The restriction of $\sigma_u$ to $\Ok$ is compatible with the coercion to $L$.
-/
theorem œÉ_int_coe (u : (ZMod 19)À£) (x : ùìûL) : (œÉ_int u x : L) = œÉ u x := rfl

/-
Define gal_unit as a unit in (ZMod 19).
-/
def gal_unit (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 19) : (ZMod 19)À£ := Units.mk0 (N : ZMod 19) (by
  rw [Ne, ZMod.natCast_zmod_eq_zero_iff_dvd]
  intro h
  have hN_prime : Nat.Prime N := Fact.out
  have : 19 = 1 ‚à® 19 = N := (Nat.dvd_prime hN_prime).mp h
  have : 19 = N := this.resolve_left (by norm_num)
  exact hN this.symm)

/-
Check Algebra Z OL instance.
-/
#synth Algebra ‚Ñ§ ùìûL

/-
œÉ_int preserves addition.
-/
lemma sigma_int_add (u : (ZMod 19)À£) (x y : ùìûL) : œÉ_int u (x + y) = œÉ_int u x + œÉ_int u y := by
  convert congr_arg ( œÉ_int u ) ( show ( x + y : ùìûL ) = ( x : ùìûL ) + ( y : ùìûL ) from rfl ) using 1;
  -- Since œÉ_int u is the restriction of œÉ u, and œÉ u is a ring homomorphism, it preserves addition. Thus, œÉ u (x + y) = œÉ u x + œÉ u y. Therefore, œÉ_int u (x + y) = œÉ u (x + y) = œÉ u x + œÉ u y = œÉ_int u x + œÉ_int u y.
  have h_add : œÉ u (x + y) = œÉ u x + œÉ u y := by
    exact map_add _ _ _;
  exact Subtype.ext h_add.symm

/-
œÉ_int preserves multiplication.
-/
lemma sigma_int_mul (u : (ZMod 19)À£) (x y : ùìûL) : œÉ_int u (x * y) = œÉ_int u x * œÉ_int u y := by
  have h_sigma_int_mul : ‚àÄ (x y : ùìûL), œÉ_int u (x * y) = œÉ_int u x * œÉ_int u y := by
    exact fun x y => by ext; simp +decide [ œÉ_int_coe ] ;
  exact h_sigma_int_mul x y

/-
œÉ_int maps Œ∂_int to Œ∂_int^N.
-/
lemma sigma_zeta : œÉ_int (uN hN) Œ∂_int = Œ∂_int ^ N := by
  -- Since Œ∂_int is the image of Œ∂ in the ring of integers, applying œÉ_int to Œ∂_int should be the same as applying œÉ to Œ∂ and then converting the result back to the ring of integers.
  have h_sigma_int_Œ∂ : œÉ_int (uN hN) Œ∂_int = ‚ü®œÉ (uN hN) Œ∂, by
    refine' ‚ü® Polynomial.X ^ 19 - 1, _, _ ‚ü©;
    ¬∑ erw [ Polynomial.Monic, Polynomial.leadingCoeff_X_pow_sub_C ] ; norm_num;
    ¬∑ simp +decide [ ‚Üê map_pow, ‚Üê map_sub, hŒ∂.pow_eq_one ]‚ü© := by
    exact Subtype.ext rfl
  generalize_proofs at *;
  -- Since œÉ is defined by Œ∂ ‚Ü¶ Œ∂^u, we have œÉ (uN hN) Œ∂ = Œ∂^(uN hN).
  have h_sigma_Œ∂ : œÉ (uN hN) Œ∂ = Œ∂ ^ (uN hN : ZMod 19).val := by
    -- Since œÉ is defined by Œ∂ ‚Ü¶ Œ∂^u, we have œÉ (uN hN) Œ∂ = Œ∂^(uN hN) by definition of œÉ.
    have h_sigma_Œ∂ : ‚àÄ u : (ZMod 19)À£, œÉ u Œ∂ = Œ∂ ^ (u : ZMod 19).val := by
      intros u
      simp [œÉ];
      erw [ PowerBasis.equivOfMinpoly_apply ];
      erw [ PowerBasis.lift_gen ] ; aesop;
    exact h_sigma_Œ∂ _;
  -- Since $uN hN$ is a unit in $(\mathbb{Z}/19\mathbb{Z})^\times$, we have $uN hN \equiv N \pmod{19}$.
  have h_unit : (uN hN : ZMod 19).val = N % 19 := by
    unfold uN; aesop;
  -- Since $N \equiv N \pmod{19}$, we have $\zeta^{N \mod 19} = \zeta^N$.
  have h_exp : Œ∂ ^ (N % 19) = Œ∂ ^ N := by
    rw [ ‚Üê Nat.mod_add_div N 19, pow_add, pow_mul ] ; norm_num [ h_unit ];
    have h_exp : Œ∂ ^ 19 = 1 := by
      exact hŒ∂.pow_eq_one;
    rw [ h_exp, one_pow, mul_one ];
  convert h_sigma_int_Œ∂ using 1;
  ext; simp +decide [ h_sigma_Œ∂, h_unit, h_exp ] ;
  exact?

/-
The ring of integers is generated by Œ∂_int.
-/
lemma adjoin_zeta_eq_top : Algebra.adjoin ‚Ñ§ ({Œ∂_int} : Set ùìûL) = ‚ä§ := by
  -- By definition of cyclotomic fields, the ring of integers of $L$ is $\mathbb{Z}[\zeta_{19}]$.
  have h_cyclotomic : IsCyclotomicExtension {19} ‚Ñ§ ùìûL := by
    exact?;
  have := h_cyclotomic.2;
  ext x;
  simp_all +decide [ Algebra.adjoin_singleton_eq_range_aeval ];
  have := this x;
  refine' Algebra.adjoin_induction _ _ _ _ this;
  ¬∑ intro x hx
    use Polynomial.X ^ (Nat.find (show ‚àÉ k : ‚Ñï, x = Œ∂_int ^ k from by
                                    have h_root : ‚àÄ x : L, x ^ 19 = 1 ‚Üí ‚àÉ k : ‚Ñï, x = Œ∂ ^ k := by
                                      intro x hx
                                      have h_root : x ‚àà Set.range (fun k : ‚Ñï => Œ∂ ^ k) := by
                                        have h_root : x ‚àà Set.range (fun k : ZMod 19 => Œ∂ ^ k.val) := by
                                          have h_poly : x ^ 19 = 1 := hx
                                          have h_poly_factor : ‚àè k ‚àà Finset.range 19, (Polynomial.X - Polynomial.C (Œ∂ ^ k)) = Polynomial.X ^ 19 - 1 := by
                                            refine' Polynomial.eq_of_degree_sub_lt_of_eval_finset_eq _ _ _;
                                            exact Finset.image ( fun k : ‚Ñï => Œ∂ ^ k ) ( Finset.range 19 );
                                            ¬∑ refine' lt_of_lt_of_le ( Polynomial.degree_sub_lt _ _ _ ) _;
                                              ¬∑ norm_num [ Polynomial.degree_prod, Polynomial.degree_X_pow_sub_C ];
                                                erw [ Polynomial.degree_X_pow_sub_C ] <;> norm_num [ Polynomial.degree_sub_eq_left_of_degree_lt ];
                                                erw [ Finset.sum_congr rfl fun _ _ => Polynomial.degree_sub_eq_left_of_degree_lt <| ?_ ] <;> norm_num;
                                                erw [ Polynomial.degree_C ] <;> norm_num;
                                                exact hŒ∂.ne_zero ( by norm_num );
                                              ¬∑ exact Finset.prod_ne_zero_iff.mpr fun i hi => Polynomial.X_sub_C_ne_zero _;
                                              ¬∑ norm_num [ Polynomial.leadingCoeff_prod ];
                                                exact Finset.prod_eq_one fun i hi => by rw [ ‚Üê Polynomial.C_pow, Polynomial.leadingCoeff_X_sub_C ] ;
                                              ¬∑ rw [ Polynomial.degree_prod, Finset.sum_congr rfl fun _ _ => Polynomial.degree_X_sub_C _ ] ; norm_num;
                                                rw [ Finset.card_image_of_injOn ] <;> norm_num;
                                                intro a ha b hb hab; have := hŒ∂.pow_inj ( show a < 19 from ha ) ( show b < 19 from hb ) ; aesop;
                                            ¬∑ simp +decide [ Polynomial.eval_prod ];
                                              intro a ha; rw [ Finset.prod_eq_prod_diff_singleton_mul <| Finset.mem_range.mpr ha ] ; ring;
                                              rw [ pow_mul', show Œ∂ ^ 19 = 1 from by exact hŒ∂.pow_eq_one ] ; norm_num
                                          replace h_poly_factor := congr_arg ( Polynomial.eval x ) h_poly_factor ; simp_all +decide [ Polynomial.eval_prod, Finset.prod_eq_zero_iff, sub_eq_iff_eq_add ];
                                          obtain ‚ü® a, ha, rfl ‚ü© := h_poly_factor; exact ‚ü® ‚ü® a, ha ‚ü©, rfl ‚ü© ;
                                        grind;
                                      exact h_root.imp fun k hk => hk.symm;
                                    obtain ‚ü® k, hk ‚ü© := h_root ( algebraMap ùìûL L x ) ( by simpa [ ‚Üê map_pow ] using congr_arg ( algebraMap ùìûL L ) hx );
                                    use k;
                                    exact?));
    simp +zetaDelta at *;
    exact Nat.find_spec ( _ : ‚àÉ k : ‚Ñï, x = Œ∂_int ^ k ) ‚ñ∏ rfl.symm;
  ¬∑ exact fun r => ‚ü® Polynomial.C r, by simp +decide ‚ü©;
  ¬∑ rintro x y hx hy ‚ü® p, rfl ‚ü© ‚ü® q, rfl ‚ü© ; exact ‚ü® p + q, by simp +decide [ Polynomial.aeval_add ] ‚ü©;
  ¬∑ rintro x y hx hy ‚ü® p, rfl ‚ü© ‚ü® q, rfl ‚ü© ; exact ‚ü® p * q, by simp +decide [ Polynomial.aeval_mul ] ‚ü©

/-
The automorphism œÉ_N reduces to the Frobenius map x ‚Ü¶ x^N modulo P.
-/
theorem artin_property [CharP (kP P) N] (x : ùìûL) : red P (œÉ_int (uN hN) x) = (red P x) ^ N := by
  -- By definition of $œÉ_int$, we know that $œÉ_int (uN hN) x = (œÉ_int (uN hN)) x$.
  have h_sigma_int : ‚àÄ x : ùìûL, (red P) (œÉ_int (uN hN) x) = (red P x) ^ N := by
    have h_gen : ‚àÄ x : ùìûL, x ‚àà Algebra.adjoin ‚Ñ§ ({Œ∂_int} : Set ùìûL) := by
      exact fun x => by rw [ adjoin_zeta_eq_top ] ; exact Algebra.mem_top;
    intro x
    induction' h_gen x using Algebra.adjoin_induction with x hx ih;
    ¬∑ convert congr_arg ( red P ) ( sigma_zeta hN ) using 1;
      ¬∑ grind;
      ¬∑ rw [ show x = Œ∂_int from hx ] ; simp +decide [ red ] ;
    ¬∑ -- Since œÉ_int (uN hN) is an algebra homomorphism, it preserves the algebra map.
      have h_sigma_int_algebra_map : ‚àÄ (ih : ‚Ñ§), œÉ_int (uN hN) (algebraMap ‚Ñ§ ùìûL ih) = algebraMap ‚Ñ§ ùìûL ih := by
        unfold œÉ_int; aesop;
      convert congr_arg ( red P ) ( h_sigma_int_algebra_map ih ) using 1;
      erw [ Ideal.Quotient.eq ];
      -- Since $P$ is a maximal ideal in $\mathcal{O}_L$, we know that $N \in P$.
      have hN_in_P : (algebraMap ‚Ñ§ ùìûL) N ‚àà P := by
        have hN_in_P : (algebraMap ‚Ñ§ (ùìûL ‚ß∏ P)) N = 0 := by
          convert CharP.cast_eq_zero ( kP P ) N using 1;
        erw [ Ideal.Quotient.eq_zero_iff_mem ] at hN_in_P ; aesop;
      have hN_in_P : ‚àÄ (ih : ‚Ñ§), (algebraMap ‚Ñ§ ùìûL) (ih ^ N - ih) ‚àà P := by
        intro ih
        have hN_in_P : (algebraMap ‚Ñ§ ùìûL) (ih ^ N - ih) = (algebraMap ‚Ñ§ ùìûL) N * (algebraMap ‚Ñ§ ùìûL) ((ih ^ N - ih) / N) := by
          rw [ ‚Üê map_mul, Int.mul_ediv_cancel' ];
          haveI := Fact.mk ( Fact.out : Nat.Prime N ) ; simp +decide [ ‚Üê ZMod.intCast_zmod_eq_zero_iff_dvd ] ;
        exact hN_in_P.symm ‚ñ∏ P.mul_mem_right _ ‚Äπ_‚Ä∫;
      convert hN_in_P ih using 1 ; norm_num [ map_sub, map_pow ];
    ¬∑ simp_all +decide [ sigma_int_add ];
      rw [ add_pow_char ];
    ¬∑ rename_i hx hy ihx ihy;
      convert congr_arg‚ÇÇ ( ¬∑ * ¬∑ ) ihx ihy using 1 <;> ring;
      ¬∑ convert congr_arg ( red P ) ( sigma_int_mul ( uN hN ) _ _ ) using 1;
      ¬∑ simp +decide [ ‚Üê mul_pow ];
  exact h_sigma_int x

/-
The integer versions of Œ±, Œ≤, Œ≥ coerce to the field versions.
-/
lemma coe_int_defs : (Œ±_int : L) = Œ± ‚àß (Œ≤_int : L) = Œ≤ ‚àß (Œ≥_int : L) = Œ≥ := by
  bound

/-
The cyclic relations hold for the integer versions Œ±_int, Œ≤_int, Œ≥_int.
-/
lemma cyclic_relations_int : 7 * Œ≤_int = 3 * Œ±_int^2 - 8 * Œ±_int - 38 ‚àß 7 * Œ≥_int = -3 * Œ±_int^2 + Œ±_int + 38 := by
  have h_intRelations : (7 * Œ≤_int : L) = 3 * Œ±_int ^ 2 - 8 * Œ±_int - 38 ‚àß (7 * Œ≥_int : L) = -3 * Œ±_int ^ 2 + Œ±_int + 38 := by
    convert cyclic_relations using 1;
  convert h_intRelations;
  ¬∑ erw [ ‚Üê Subtype.coe_inj ] ; norm_num;
    exact?;
  ¬∑ erw [ ‚Üê Subtype.coe_inj ] ; norm_num;
    exact?

/-
The permutation action on the integer versions of Œ±, Œ≤, Œ≥ matches the global action.
-/
lemma sigma_alpha_eq_beta_or_gamma (u : (ZMod 19)À£) :
  ((u : ZMod 19) ‚àà S1 ‚Üí œÉ_int u Œ±_int = Œ≤_int) ‚àß
  ((u : ZMod 19) ‚àà S2 ‚Üí œÉ_int u Œ±_int = Œ≥_int) := by
    constructor;
    ¬∑ intro hu
      have h_eq : (œÉ_int u Œ±_int : L) = Œ≤_int := by
        rw [ œÉ_int_coe, coe_int_defs.1, coe_int_defs.2.1 ];
        unfold œÉ;
        unfold Œ± Œ≤ Œ∑‚ÇÄ Œ∑‚ÇÅ Œ∑‚ÇÇ;
        fin_cases u <;> simp +decide at hu ‚ä¢ hu ‚ä¢;
        all_goals erw [ PowerBasis.equivOfMinpoly_apply ] ; norm_num;
        all_goals erw [ PowerBasis.lift_gen ];
        all_goals erw [ show Œ∂ = IsCyclotomicExtension.zeta 19 ‚Ñö L from rfl ] ; norm_num [ ZMod.val ] ; ring!;
        all_goals have := IsCyclotomicExtension.zeta_pow 19 ‚Ñö L; simp_all +decide [ pow_succ, mul_assoc ] ;
        grind +ring;
        ¬∑ grind +ring;
        ¬∑ grind +ring;
        ¬∑ grind +ring;
        ¬∑ grind +ring;
        ¬∑ grind +ring;
      exact Subtype.ext h_eq;
    ¬∑ intro hu
      have h_eq : (œÉ_int u Œ±_int : L) = Œ≥_int := by
        simp +decide [ œÉ_int_coe, coe_int_defs ];
        unfold Œ≥;
        unfold Œ± Œ∑‚ÇÄ Œ∑‚ÇÅ Œ∑‚ÇÇ;
        -- By definition of $œÉ$, we know that $œÉ u (Œ∂^k) = Œ∂^{ku}$ for any integer $k$.
        have h_sigma_zeta : ‚àÄ k : ‚Ñï, (œÉ u) (Œ∂ ^ k) = Œ∂ ^ (k * u.val.val % 19) := by
          -- By definition of $œÉ$, we know that $œÉ u (Œ∂) = Œ∂^u$.
          have h_sigma_zeta : (œÉ u) Œ∂ = Œ∂ ^ u.val.val := by
            have h_sigma_zeta : ‚àÄ u : (ZMod 19)À£, œÉ u Œ∂ = Œ∂ ^ (u : ZMod 19).val := by
              unfold œÉ;
              simp +zetaDelta at *;
              intro u; exact (by
              convert ( IsCyclotomicExtension.autEquivPow L ( Polynomial.cyclotomic.irreducible_rat ( n := 19 ) ( by norm_num ) ) ).symm_apply_eq.mpr _;
              rotate_left;
              exact u;
              exact ( IsCyclotomicExtension.autEquivPow L ( Polynomial.cyclotomic.irreducible_rat ( n := 19 ) ( by norm_num ) ) ).symm u;
              ¬∑ exact?;
              ¬∑ erw [ PowerBasis.equivOfMinpoly_gen ];
                simp +decide [ IsPrimitiveRoot.powerBasis ];
                rfl);
            exact h_sigma_zeta u;
          -- Since Œ∂ is a primitive 19th root of unity, we have Œ∂^19 = 1. Therefore, Œ∂^(k*u.val.val) = Œ∂^(k*u.val.val mod 19).
          have h_exp : ‚àÄ k : ‚Ñï, Œ∂ ^ (k * u.val.val) = Œ∂ ^ (k * u.val.val % 19) := by
            have h_exp : Œ∂ ^ 19 = 1 := by
              exact hŒ∂.pow_eq_one;
            exact fun k => by rw [ ‚Üê Nat.mod_add_div ( k * u.val.val ) 19, pow_add, pow_mul ] ; aesop;
          simp_all +decide [ pow_mul' ];
        fin_cases u <;> simp +decide [ * ] at hu ‚ä¢;
        all_goals simp_all +decide [ ZMod.val ];
        all_goals ring;
      exact Subtype.ext h_eq

/-
Explicit formula for the Frobenius action on Œ±.
-/
theorem explicit_frobenius (hN7 : N ‚â† 7) [CharP (kP P) N] :
  ((uN hN : ZMod 19) ‚àà S1 ‚Üí (red P Œ±_int) ^ N = (3 * (red P Œ±_int)^2 - 8 * (red P Œ±_int) - 38) * (7 : kP P)‚Åª¬π) ‚àß
  ((uN hN : ZMod 19) ‚àà S2 ‚Üí (red P Œ±_int) ^ N = (-3 * (red P Œ±_int)^2 + (red P Œ±_int) + 38) * (7 : kP P)‚Åª¬π) := by
    constructor <;> intro h;
    ¬∑ -- By artin_property, (red P Œ±_int)^N = red P (œÉ_int (uN hN) Œ±_int).
      have h1 : (red P Œ±_int) ^ N = red P (œÉ_int (uN hN) Œ±_int) := by
        rw [ ‚Üê artin_property ];
      -- By sigma_alpha_eq_beta_or_gamma, œÉ_int (uN hN) Œ±_int = Œ≤_int.
      have h2 : œÉ_int (uN hN) Œ±_int = Œ≤_int := by
        exact sigma_alpha_eq_beta_or_gamma ( uN hN ) |>.1 h;
      field_simp;
      rw [ h1, h2, eq_div_iff ] <;> norm_num;
      ¬∑ -- By cyclic_relations_int, we have 7 * Œ≤_int = 3 * Œ±_int^2 - 8 * Œ±_int - 38.
        have h3 : 7 * Œ≤_int = 3 * Œ±_int^2 - 8 * Œ±_int - 38 := by
          exact cyclic_relations_int.1;
        convert congr_arg ( red P ) h3 using 1 <;> norm_num ; ring;
        ¬∑ exact?;
        ¬∑ erw [ map_ofNat, map_ofNat, map_ofNat ] ; ring;
      ¬∑ erw [ CharP.cast_eq_zero_iff ( kP P ) N ];
        exact fun h => hN7 <| by have := Nat.le_of_dvd ( by decide ) h; interval_cases N <;> trivial;
    ¬∑ have h_frob_gamma : (red P Œ±_int) ^ N = red P Œ≥_int := by
        have h_frob_gamma : (red P Œ±_int) ^ N = red P (œÉ_int (uN hN) Œ±_int) := by
          rw [ ‚Üê artin_property ];
        convert h_frob_gamma using 1 ; erw [ sigma_alpha_eq_beta_or_gamma _ |>.2 h ] ;
      have h_cyclic_gamma : 7 * red P Œ≥_int = -3 * (red P Œ±_int) ^ 2 + (red P Œ±_int) + 38 := by
        have h_cyclic_gamma : 7 * Œ≥_int = -3 * Œ±_int ^ 2 + Œ±_int + 38 := by
          exact cyclic_relations_int.2;
        convert congr_arg ( red P ) h_cyclic_gamma using 1
      have h_inv_gamma : 7‚Åª¬π * (7 * red P Œ≥_int) = red P Œ≥_int := by
        rw [ ‚Üê mul_assoc, inv_mul_cancel‚ÇÄ, one_mul ];
        intro h; have := CharP.cast_eq_zero_iff ( kP P ) N 7; simp_all +decide ;
        have := Nat.le_of_dvd ( by decide ) this; interval_cases N <;> trivial;
      rw [h_frob_gamma, ‚Üê h_inv_gamma]
      field_simp [h_cyclic_gamma];
      exact congrArg‚ÇÇ _ ( by linear_combination' h_cyclic_gamma ) rfl

def q_val : ‚Ñï := 19
def a_val : ‚Ñï := 7
def s1_val : ZMod 19 := (- (a_val : ZMod 19) - 3) / 6
def s2_val : ZMod 19 := ((a_val : ZMod 19) - 3) / 6
def c_val (N : ‚Ñï) : ZMod 19 := (N : ZMod 19) ^ ((q_val - 1) / 3)

/-
The polynomial f = x^3 - 19x - 19.
-/
def f_poly : Polynomial L := X^3 - 19*X - 19

/-
alpha is a root of f = x^3 - 19x - 19.
-/
theorem alpha_root : (f_poly).eval Œ± = 0 := by
  unfold f_poly;
  unfold Œ±;
  unfold Œ∑‚ÇÇ Œ∑‚ÇÅ;
  -- By definition of $Œ∂$, we know that $Œ∂^19 = 1$ and $Œ∂^k ‚â† 1$ for $1 ‚â§ k < 19$.
  have hŒ∂ : Œ∂ ^ 19 = 1 ‚àß ‚àÄ k : ‚Ñï, 1 ‚â§ k ‚Üí k < 19 ‚Üí Œ∂ ^ k ‚â† 1 := by
    exact ‚ü® hŒ∂.pow_eq_one, fun k hk‚ÇÅ hk‚ÇÇ hk‚ÇÉ => by have := hŒ∂.pow_eq_one_iff_dvd k; interval_cases k <;> simp_all +decide ‚ü©;
  ring_nf at *;
  simp_all +decide [ pow_succ' ];
  grind +ring

/-
alpha + beta + gamma = 0.
-/
theorem sum_zero : Œ± + Œ≤ + Œ≥ = 0 := by
  unfold Œ± Œ≤ Œ≥
  ring

/-
2a beta = 6 alpha^2 - (a+9)alpha - 4q with a=7, q=19.
-/
theorem beta_relation : 2 * 7 * Œ≤ = 6 * Œ±^2 - (7 + 9) * Œ± - 4 * 19 := by
  -- By multiplying both sides of the equation $7 \beta = 3 \alpha^2 - 8 \alpha - 38$ by 2, we get the desired result.
  have h_mul : 2 * 7 * Œ≤ = 2 * (3 * Œ±^2 - 8 * Œ± - 38) := by
    convert congr_arg ( fun x : L => 2 * x ) ( cyclic_relations.left ) using 1 ; ring;
  convert h_mul using 1 ; ring

/-
s1_val is 11 and s2_val is 7 in ZMod 19.
-/
lemma s1_val_eq : s1_val = 11 := by
  native_decide +revert
lemma s2_val_eq : s2_val = 7 := by
  native_decide +revert

/-
N is in S1 iff c_val N = s2_val.
-/
lemma N_in_S1_iff_c_eq_s2 (hN : N ‚â† 19) : (uN hN : ZMod 19) ‚àà S1 ‚Üî c_val N = s2_val := by
  -- By definition of $c_val$, we know that $c_val N = (N : ZMod 19)^6$.
  have hc_val : c_val N = (N : ZMod 19)^6 := by
    exact?;
  simp +decide [ hc_val, s2_val_eq ];
  unfold uN; simp +decide [ S1 ] ;
  grind

/-
N is in S2 iff c_val N = s1_val.
-/
lemma N_in_S2_iff_c_eq_s1 (hN : N ‚â† 19) : (uN hN : ZMod 19) ‚àà S2 ‚Üî c_val N = s1_val := by
  unfold uN S2 c_val s1_val;
  simp +decide [ q_val, a_val ] ; norm_num [ ZMod.natCast_eq_zero_iff ];
  grind

/-
If c = s1, then alpha^N = gamma. If c = s2, then alpha^N = beta.
-/
theorem final_result {N : ‚Ñï} [Fact (Nat.Prime N)] (hN : N ‚â† 19) (P : Ideal ùìûL) [P.IsMaximal] [CharP (kP P) N] (hN7 : N ‚â† 7) :
  (c_val N = s1_val ‚Üí (red P Œ±_int) ^ N = red P Œ≥_int) ‚àß
  (c_val N = s2_val ‚Üí (red P Œ±_int) ^ N = red P Œ≤_int) := by
    constructor <;> intro h;
    ¬∑ have h_sigma_gamma : œÉ_int (uN hN) Œ±_int = Œ≥_int := by
        apply (sigma_alpha_eq_beta_or_gamma (uN hN)).right;
        convert N_in_S2_iff_c_eq_s1 hN |>.2 h using 1;
      rw [ ‚Üê h_sigma_gamma, artin_property ];
    ¬∑ -- By N_in_S1_iff_c_eq_s2, uN hN is in S1.
      have h_S1 : (uN hN : ZMod 19) ‚àà S1 := by
        convert N_in_S1_iff_c_eq_s2 hN |>.2 h using 1;
      rw [ ‚Üê artin_property ];
      rw [ sigma_alpha_eq_beta_or_gamma _ |>.1 h_S1 ];
      assumption

/-
If c = s1, then alpha^N = gamma. If c = s2, then alpha^N = beta.
-/
theorem final_result_proof {N : ‚Ñï} [Fact (Nat.Prime N)] (hN : N ‚â† 19) (P : Ideal ùìûL) [P.IsMaximal] [CharP (kP P) N] (hN7 : N ‚â† 7) :
  (c_val N = s1_val ‚Üí (red P Œ±_int) ^ N = red P Œ≥_int) ‚àß
  (c_val N = s2_val ‚Üí (red P Œ±_int) ^ N = red P Œ≤_int) := by
    convert final_result hN P hN7 using 1

/-
Definitions of constants q=97, a=19, s1, s2, and c for the new problem instance.
-/
def q' : ‚Ñï := 97
def a' : ‚Ñï := 19
def s1' : ZMod 97 := (- (a' : ZMod 97) - 3) * (6 : ZMod 97)‚Åª¬π
def s2' : ZMod 97 := ((a' : ZMod 97) - 3) * (6 : ZMod 97)‚Åª¬π
def c' (N : ‚Ñï) : ZMod 97 := (N : ZMod 97) ^ ((q' - 1) / 3)

/-
Define the cyclotomic field L97 and the primitive root of unity zeta97.
-/
open Polynomial NumberField

def L97 : Type := CyclotomicField 97 ‚Ñö

instance : Field L97 := CyclotomicField.instField 97 ‚Ñö
instance : NumberField L97 := CyclotomicField.instNumberField 97 ‚Ñö
instance : IsCyclotomicExtension {97} ‚Ñö L97 := CyclotomicField.isCyclotomicExtension 97 ‚Ñö

def Œ∂97 : L97 := IsCyclotomicExtension.zeta 97 ‚Ñö L97

instance : Fact (Nat.Prime 97) := ‚ü®by norm_num‚ü©

/-
Define the sets of indices and the Gaussian periods for q=97. Define alpha, beta, gamma.
-/
def S_cubic_res : Finset (ZMod 97) := {x | x ‚â† 0 ‚àß x ^ 32 = 1}
def S_s1 : Finset (ZMod 97) := {x | x ‚â† 0 ‚àß x ^ 32 = s1'}
def S_s2 : Finset (ZMod 97) := {x | x ‚â† 0 ‚àß x ^ 32 = s2'}

def Œ∑‚ÇÄ' : L97 := ‚àë x ‚àà S_cubic_res, Œ∂97 ^ (x.val : ‚Ñï)
def Œ∑‚ÇÅ' : L97 := ‚àë x ‚àà S_s2, Œ∂97 ^ (x.val : ‚Ñï)
def Œ∑‚ÇÇ' : L97 := ‚àë x ‚àà S_s1, Œ∂97 ^ (x.val : ‚Ñï)

def Œ±' : L97 := -(Œ∑‚ÇÇ' - Œ∑‚ÇÅ')
def Œ≤' : L97 := -(Œ∑‚ÇÄ' - Œ∑‚ÇÇ')
def Œ≥' : L97 := -(Œ∑‚ÇÅ' - Œ∑‚ÇÄ')

/-
The sum of alpha, beta, and gamma is zero.
-/
theorem sum_zero' : Œ±' + Œ≤' + Œ≥' = 0 := by
  unfold Œ±' Œ≤' Œ≥' ;
  ring

/-
Definitions of index function, cyclotomic numbers, and period function for q=97.
-/
def ind (x : ZMod 97) : ZMod 3 :=
  if x ‚àà S_cubic_res then 0
  else if x ‚àà S_s1 then 1
  else 2

def cyc_num (i j : ZMod 3) : ‚Ñï :=
  Fintype.card { x : ZMod 97 // x ‚â† 0 ‚àß x ‚â† 1 ‚àß ind x = i ‚àß ind (1 - x) = j }

def period (i : ZMod 3) : L97 :=
  if i = 0 then Œ∑‚ÇÄ'
  else if i = 1 then Œ∑‚ÇÇ'
  else Œ∑‚ÇÅ'

/-
The period function maps 0, 1, 2 to eta0', eta2', eta1' respectively.
-/
lemma period_eq_def : period 0 = Œ∑‚ÇÄ' ‚àß period 1 = Œ∑‚ÇÇ' ‚àß period 2 = Œ∑‚ÇÅ' := by
  aesop

/-
The index function correctly identifies which coset an element belongs to.
-/
lemma ind_spec (x : ZMod 97) (hx : x ‚â† 0) :
  (ind x = 0 ‚Üî x ‚àà S_cubic_res) ‚àß
  (ind x = 1 ‚Üî x ‚àà S_s1) ‚àß
  (ind x = 2 ‚Üî x ‚àà S_s2) := by
    native_decide +revert

/-
Compute the cyclotomic numbers for q=97.
-/
#eval (cyc_num 0 0, cyc_num 0 1, cyc_num 0 2)
#eval (cyc_num 1 0, cyc_num 1 1, cyc_num 1 2)
#eval (cyc_num 2 0, cyc_num 2 1, cyc_num 2 2)

/-
Values of the cyclotomic numbers for q=97.
-/
lemma cyc_num_vals :
  cyc_num 0 0 = 12 ‚àß cyc_num 0 1 = 10 ‚àß cyc_num 0 2 = 9 ‚àß
  cyc_num 1 0 = 10 ‚àß cyc_num 1 1 = 9 ‚àß cyc_num 1 2 = 13 ‚àß
  cyc_num 2 0 = 9 ‚àß cyc_num 2 1 = 13 ‚àß cyc_num 2 2 = 10 := by
  native_decide

/-
Number of solutions to x + y = u with ind x = i and ind y = j.
-/
def N_sol (i j : ZMod 3) (u : ZMod 97) : ‚Ñï :=
  Fintype.card { p : ZMod 97 √ó ZMod 97 // p.1 ‚â† 0 ‚àß p.2 ‚â† 0 ‚àß ind p.1 = i ‚àß ind p.2 = j ‚àß p.1 + p.2 = u }

/-
The index of -1 is 0.
-/
lemma ind_neg_one : ind (-1) = 0 := by
  native_decide

/-
The index function is a homomorphism from the multiplicative group to the additive group Z/3Z.
-/
lemma ind_mul (x y : ZMod 97) (hx : x ‚â† 0) (hy : y ‚â† 0) : ind (x * y) = ind x + ind y := by
  revert x y
  native_decide

/-
The index of the inverse is the negative of the index.
-/
lemma ind_inv (x : ZMod 97) (hx : x ‚â† 0) : ind (x‚Åª¬π) = - ind x := by
  revert x
  native_decide

/-
The number of solutions to x+y=u depends only on the index of u.
-/
lemma N_sol_eq_cyc_num (i j : ZMod 3) (u : ZMod 97) (hu : u ‚â† 0) :
  N_sol i j u = cyc_num (i - ind u) (j - ind u) := by
    refine' Fintype.card_congr _;
    refine' Equiv.ofBijective ( fun x => ‚ü® x.val.1 / u, _, _, _, _ ‚ü© ) ‚ü® _, _ ‚ü©;
    all_goals simp_all +decide [ div_eq_iff, Function.Injective, Function.Surjective ];
    grind;
    ¬∑ grind;
    ¬∑ have := ind_mul ( x.val.1 / u ) u; simp_all +decide [ div_eq_mul_inv ] ;
      grind;
    ¬∑ have h_ind : ind (x.val.2 / u) = ind x.val.2 - ind u := by
        have h_ind : ind (x.val.2 / u) = ind x.val.2 + ind (u‚Åª¬π) := by
          apply ind_mul; exact (by
          exact x.2.2.1); exact (by
          haveI := Fact.mk ( by decide : Nat.Prime 97 ) ; exact inv_ne_zero hu;);
        rw [ h_ind, ind_inv u hu ] ; ring;
      grind;
    ¬∑ aesop;
    ¬∑ native_decide +revert

/-
The cardinalities of the sets S_cubic_res, S_s1, and S_s2 are all 32.
-/
lemma card_S : S_cubic_res.card = 32 ‚àß S_s1.card = 32 ‚àß S_s2.card = 32 := by
  native_decide

/-
Define C_coset to avoid ambiguity and relate it to the period definitions.
-/
def C_coset (i : ZMod 3) : Finset (ZMod 97) := Finset.univ.filter (fun x => x ‚â† 0 ‚àß ind x = i)

lemma C_coset_eq : C_coset 0 = S_cubic_res ‚àß C_coset 1 = S_s1 ‚àß C_coset 2 = S_s2 := by
  native_decide +revert

lemma period_eq_sum_C_coset (i : ZMod 3) : period i = ‚àë x ‚àà C_coset i, Œ∂97 ^ (x.val : ‚Ñï) := by
  rw [ show C_coset i = if i = 0 then S_cubic_res else if i = 1 then S_s1 else S_s2 from ?_ ];
  ¬∑ unfold period; aesop;
  ¬∑ native_decide +revert

/-
Expansion of the product of Gaussian periods in terms of solution counts.
-/
lemma period_mul_eq_sum_N_sol (i j : ZMod 3) :
  period i * period j = (if i = j then 32 else 0) +
  ‚àë u ‚àà Finset.univ.filter (fun x : ZMod 97 => x ‚â† 0), (N_sol i j u : L97) * Œ∂97 ^ (u.val : ‚Ñï) := by
    have h_expand : period i * period j = ‚àë u ‚àà Finset.univ, (if u = 0 then (if i = j then 32 else 0) else (N_sol i j u : L97)) * Œ∂97 ^ u.val := by
      have h_expand : period i * period j = ‚àë x ‚àà C_coset i, ‚àë y ‚àà C_coset j, Œ∂97 ^ (x.val + y.val : ‚Ñï) := by
        rw [ period_eq_sum_C_coset i, period_eq_sum_C_coset j, Finset.sum_mul ];
        simp +decide only [Finset.mul_sum _ _ _, pow_add];
      have h_group : ‚àÄ u : ZMod 97, ‚àë x ‚àà C_coset i, ‚àë y ‚àà C_coset j, (if x + y = u then 1 else 0) * Œ∂97 ^ u.val = (if u = 0 then (if i = j then 32 else 0) else (N_sol i j u : L97)) * Œ∂97 ^ u.val := by
        intro u
        have h_group : ‚àë x ‚àà C_coset i, ‚àë y ‚àà C_coset j, (if x + y = u then 1 else 0) = (if u = 0 then (if i = j then 32 else 0) else (N_sol i j u : ‚Ñï)) := by
          split_ifs <;> simp_all +decide [ N_sol ];
          ¬∑ fin_cases j <;> native_decide;
          ¬∑ intro x hx y hy; contrapose! hy; simp_all +decide [ C_coset ] ;
            intro hy' hy''; have := ind_mul x ( -1 ) ; simp_all +decide [ add_eq_zero_iff_eq_neg ] ;
          ¬∑ rw [ Fintype.card_subtype ];
            rw [ ‚Üê Finset.card_biUnion ];
            ¬∑ refine' Finset.card_bij ( fun x hx => ( u - x, x ) ) _ _ _ <;> simp +decide [ Finset.mem_biUnion, Finset.mem_filter ];
              ¬∑ unfold C_coset at *; aesop;
              ¬∑ unfold C_coset; aesop;
            ¬∑ exact fun x hx y hy hxy => Finset.disjoint_left.mpr fun z hz‚ÇÅ hz‚ÇÇ => hxy <| by aesop;
        convert congr_arg ( ¬∑ * Œ∂97 ^ u.val ) ( show ( ‚àë x ‚àà C_coset i, ‚àë y ‚àà C_coset j, if x + y = u then 1 else 0 : L97 ) = if u = 0 then if i = j then 32 else 0 else N_sol i j u from ?_ ) using 1;
        ¬∑ simp +decide only [Finset.sum_mul _ _ _];
        ¬∑ split_ifs <;> norm_num;
        ¬∑ convert congr_arg ( fun x : ‚Ñï => x : ‚Ñï ‚Üí L97 ) h_group using 1;
          norm_num [ Finset.sum_ite ];
      rw [ ‚Üê Finset.sum_congr rfl fun u hu => h_group u ];
      rw [ h_expand, Finset.sum_comm ];
      rw [ Finset.sum_comm, Finset.sum_congr rfl ];
      rw [ Finset.sum_comm ];
      intro x hx; rw [ Finset.sum_comm ] ; simp +decide [ Finset.sum_ite ] ;
      refine' Finset.sum_congr rfl fun y hy => _;
      have h_exp : Œ∂97 ^ 97 = 1 := by
        exact IsCyclotomicExtension.zeta_pow ( 97 : ‚Ñï ) ‚Ñö L97;
      rw [ ‚Üê Nat.mod_add_div ( x.val + y.val ) 97, pow_add, pow_mul ] ; aesop;
    rw [ h_expand, Finset.sum_eq_add_sum_diff_singleton ( Finset.mem_univ 0 ) ] ; aesop

/-
Multiplication rule for Gaussian periods.
-/
lemma period_mul (i j : ZMod 3) :
  period i * period j = (if i = j then 32 else 0) +
  (cyc_num (i - 0) (j - 0) * period 0 +
   cyc_num (i - 1) (j - 1) * period 1 +
   cyc_num (i - 2) (j - 2) * period 2) := by
     -- Apply Lemma `period_mul_eq_sum_N_sol` to expand the product.
     have h_expand : period i * period j = (if i = j then 32 else 0) +
       ‚àë u ‚àà (Finset.univ.filter (fun x : ZMod 97 => x ‚â† 0)), (cyc_num (i - ind u) (j - ind u) : L97) * Œ∂97 ^ (u.val : ‚Ñï) := by
         rw [ period_mul_eq_sum_N_sol ];
         exact congrArg _ ( Finset.sum_congr rfl fun u hu => by rw [ N_sol_eq_cyc_num i j u ( by simpa using hu ) ] );
     -- Partition the sum over `u != 0` based on `ind u = k` for `k \in {0, 1, 2}`.
     have h_partition : ‚àë u ‚àà (Finset.univ.filter (fun x : ZMod 97 => x ‚â† 0)), (cyc_num (i - ind u) (j - ind u) : L97) * Œ∂97 ^ (u.val : ‚Ñï) =
       ‚àë k ‚àà Finset.univ, (cyc_num (i - k) (j - k) : L97) * ‚àë u ‚àà (Finset.univ.filter (fun x : ZMod 97 => x ‚â† 0 ‚àß ind x = k)), Œ∂97 ^ (u.val : ‚Ñï) := by
         simp +decide only [Finset.sum_filter, Finset.mul_sum _ _ _];
         rw [ Finset.sum_comm, Finset.sum_congr rfl ] ; aesop;
     -- By definition of $C_koset$, we know that $\sum_{u \in C_koset k} \zeta_97^u = \text{period } k$.
     have h_period : ‚àÄ k : ZMod 3, ‚àë u ‚àà (Finset.univ.filter (fun x : ZMod 97 => x ‚â† 0 ‚àß ind x = k)), Œ∂97 ^ (u.val : ‚Ñï) = period k := by
       intro k
       simp [period_eq_sum_C_coset, C_coset];
     simp_all +decide [ Fin.sum_univ_three ];
     erw [ Fin.sum_univ_three ] ; ring!;

/-
alpha' is a root of X^3 - 97X - 97.
-/
theorem alpha_root' : Œ±'^3 - 97*Œ±' - 97 = 0 := by
  unfold Œ±';
  -- By definition of $Œ∑‚ÇÄ'$, $Œ∑‚ÇÅ'$, and $Œ∑‚ÇÇ'$, we know that $Œ∑‚ÇÄ' + Œ∑‚ÇÅ' + Œ∑‚ÇÇ' = -1$.
  have h_sum : Œ∑‚ÇÄ' + Œ∑‚ÇÅ' + Œ∑‚ÇÇ' = -1 := by
    -- The sum of all non-trivial roots of unity in the cyclotomic field is -1.
    have h_sum_roots : ‚àë x ‚àà Finset.univ.filter (fun x : ZMod 97 => x ‚â† 0), Œ∂97 ^ (x.val : ‚Ñï) = -1 := by
      have h_sum : ‚àë x : ZMod 97, (Œ∂97 : L97) ^ (x.val : ‚Ñï) = 0 := by
        have h_geom_sum : ‚àë x ‚àà Finset.range 97, (Œ∂97 : L97) ^ x = 0 := by
          rw [ geom_sum_eq ] <;> norm_num [ IsPrimitiveRoot.ne_one ];
          ¬∑ exact Or.inl ( sub_eq_zero_of_eq <| by exact IsPrimitiveRoot.pow_eq_one <| IsCyclotomicExtension.zeta_spec 97 ‚Ñö L97 );
          ¬∑ have h_order : IsPrimitiveRoot Œ∂97 97 := by
              convert IsCyclotomicExtension.zeta_spec 97 ‚Ñö L97 using 1
              skip
            generalize_proofs at *; exact h_order.ne_one (by norm_num);
        convert h_geom_sum using 1;
      rw [ Finset.sum_eq_add_sum_diff_singleton ( Finset.mem_univ 0 ) ] at h_sum;
      simpa [ Finset.filter_ne' ] using eq_neg_of_add_eq_zero_right h_sum;
    rw [ ‚Üê h_sum_roots, show Œ∑‚ÇÄ' + Œ∑‚ÇÅ' + Œ∑‚ÇÇ' = ‚àë x ‚àà Finset.univ.filter ( fun x : ZMod 97 => x ‚â† 0 ), Œ∂97 ^ x.val from ?_ ];
    rw [ show ( Finset.univ.filter fun x : ZMod 97 => x ‚â† 0 ) = S_cubic_res ‚à™ S_s1 ‚à™ S_s2 from by native_decide, Finset.sum_union, Finset.sum_union ];
    ¬∑ exact?;
    ¬∑ native_decide +revert;
    ¬∑ native_decide +revert;
  have := @period_mul 0 0; ( have := @period_mul 0 1; ( have := @period_mul 0 2; ( have := @period_mul 1 1; ( have := @period_mul 1 2; ( have := @period_mul 2 2; norm_num [ Finset.sum_add_distrib, pow_succ' ] at *; ) ) ) ) );
  simp_all +decide [ period_eq_def ];
  erw [ cyc_num_vals.1, cyc_num_vals.2.1, cyc_num_vals.2.2.1, cyc_num_vals.2.2.2.1, cyc_num_vals.2.2.2.2.1, cyc_num_vals.2.2.2.2.2.1, cyc_num_vals.2.2.2.2.2.2.1, cyc_num_vals.2.2.2.2.2.2.2.1, cyc_num_vals.2.2.2.2.2.2.2.2 ] at * ; norm_num at *;
  grind +ring

/-
Algebraic relation between beta' and alpha'.
-/
theorem beta_relation' : 2 * 19 * Œ≤' = 6 * Œ±'^2 - (19 + 9) * Œ±' - 4 * 97 := by
  unfold Œ≤' Œ±';
  rw [ show Œ∑‚ÇÄ' = period 0 from rfl, show Œ∑‚ÇÅ' = period 2 from rfl, show Œ∑‚ÇÇ' = period 1 from rfl ];
  -- By definition of $period$, we know that $period 0 + period 1 + period 2 = -1$.
  have h_sum : period 0 + period 1 + period 2 = -1 := by
    -- By definition of $period$, we know that $period 0 + period 1 + period 2 = \sum_{x \in \mathbb{Z}/97\mathbb{Z}} \zeta_{97}^x$.
    have h_sum : period 0 + period 1 + period 2 = ‚àë x ‚àà Finset.univ.filter (fun x : ZMod 97 => x ‚â† 0), Œ∂97 ^ (x.val : ‚Ñï) := by
      rw [ period_eq_sum_C_coset, period_eq_sum_C_coset, period_eq_sum_C_coset ];
      rw [ ‚Üê Finset.sum_union, ‚Üê Finset.sum_union ];
      ¬∑ rw [ show C_coset 0 ‚à™ C_coset 1 ‚à™ C_coset 2 = Finset.univ.filter ( fun x : ZMod 97 => x ‚â† 0 ) from ?_ ];
        native_decide +revert;
      ¬∑ native_decide +revert;
      ¬∑ simp +decide [ C_coset, Finset.disjoint_left ];
        grind;
    -- The sum of all powers of $\zeta_{97}$ is zero.
    have h_sum_zero : ‚àë x ‚àà Finset.range 97, Œ∂97 ^ x = 0 := by
      rw [ geom_sum_eq ] <;> norm_num [ hŒ∂ ];
      ¬∑ exact Or.inl ( sub_eq_zero_of_eq <| by exact ( show Œ∂97 ^ 97 = 1 from by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact by rw [ show Œ∂97 = IsCyclotomicExtension.zeta 97 ‚Ñö L97 from rfl ] ; exact? ) ) ) ) ) ) ) ) ) ) ) ) ) );
      ¬∑ have := IsCyclotomicExtension.zeta_spec 97 ‚Ñö L97;
        exact this.ne_one ( by decide );
    rw [ Finset.sum_eq_sum_diff_singleton_add ( Finset.mem_range.mpr ( show 0 < 97 by decide ) ) ] at h_sum_zero;
    convert eq_neg_of_add_eq_zero_left h_sum_zero using 1;
    norm_num;
  -- Substitute the known values of the cyclotomic numbers into the equation.
  have h_cyclotomic : cyc_num 0 0 = 12 ‚àß cyc_num 0 1 = 10 ‚àß cyc_num 0 2 = 9 ‚àß cyc_num 1 0 = 10 ‚àß cyc_num 1 1 = 9 ‚àß cyc_num 1 2 = 13 ‚àß cyc_num 2 0 = 9 ‚àß cyc_num 2 1 = 13 ‚àß cyc_num 2 2 = 10 := by
    exact?;
  rw [ show period 0 = -1 - period 1 - period 2 by linear_combination' h_sum ] ; ring;
  rw [ show period 1 ^ 2 = period 1 * period 1 by ring, show period 2 ^ 2 = period 2 * period 2 by ring ] ; rw [ period_mul 1 1, period_mul 2 2, period_mul 1 2 ] ; simp +decide [ h_cyclotomic ] ; ring;
  rw [ show cyc_num ( -1 ) 0 = 9 by exact h_cyclotomic.2.2.2.2.2.2.1, show cyc_num ( -1 ) ( -1 ) = 10 by exact h_cyclotomic.2.2.2.2.2.2.2.2 ] ; norm_num ; ring;
  rw [ show cyc_num 0 1 = 10 by exact h_cyclotomic.2.1, show cyc_num 1 1 = 9 by exact h_cyclotomic.2.2.2.2.1 ] ; ring ; rw [ show period 0 = -1 - period 1 - period 2 by linear_combination' h_sum ] ; ring

/-
Define the Galois unit and automorphism for q=97.
-/
def gal_unit97 (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 97) : (ZMod 97)À£ := Units.mk0 (N : ZMod 97) (by
  rw [Ne, ZMod.natCast_zmod_eq_zero_iff_dvd]
  intro h
  have hN_prime : Nat.Prime N := Fact.out
  have : 97 = 1 ‚à® 97 = N := (Nat.dvd_prime hN_prime).mp h
  have : 97 = N := this.resolve_left (by norm_num)
  exact hN this.symm)

def sigma97 (u : (ZMod 97)À£) : L97 ‚âÉ‚Çê[‚Ñö] L97 :=
  (IsCyclotomicExtension.autEquivPow L97 (Polynomial.cyclotomic.irreducible_rat (n := 97) (by norm_num))).symm u

/-
The Frobenius automorphism permutes the Gaussian periods by shifting their index by ind(N).
-/
lemma sigma_period (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 97) (i : ZMod 3) :
  sigma97 (gal_unit97 N hN) (period i) = period (i + ind (N : ZMod 97)) := by
    -- By definition of $C_coset$, we know that $C_coset i$ is the set of elements $x$ such that $ind x = i$.
    have hC_coset : ‚àÄ i : ZMod 3, C_coset i = {x : ZMod 97 | x ‚â† 0 ‚àß ind x = i} := by
      unfold C_coset; aesop;
    -- By definition of $sigma97$, we know that it maps $Œ∂97^x$ to $Œ∂97^{Nx}$ for any $x \in \mathbb{Z}/97\mathbb{Z}$.
    have h_sigma_map : ‚àÄ x : ZMod 97, (sigma97 (gal_unit97 N hN)) (Œ∂97 ^ x.val) = Œ∂97 ^ ((N * x).val) := by
      intro x
      have h_sigma_map : (sigma97 (gal_unit97 N hN)) (Œ∂97 ^ x.val) = (sigma97 (gal_unit97 N hN)) (Œ∂97) ^ x.val := by
        exact map_pow _ _ _;
      have h_sigma_map : (sigma97 (gal_unit97 N hN)) Œ∂97 = Œ∂97 ^ (N : ZMod 97).val := by
        unfold sigma97;
        simp +decide [ gal_unit97 ];
        erw [ PowerBasis.equivOfMinpoly_gen ];
        exact?;
      cases N <;> simp_all +decide [ pow_mul ];
      norm_num [ ‚Üê pow_mul, ZMod.val_add, ZMod.val_mul ];
      rw [ ‚Üê Nat.mod_add_div ( ( _ + ZMod.val 1 ) % 97 * x.val ) 97 ] ; norm_num [ pow_add, pow_mul, Nat.mul_mod, Nat.pow_mod ] ;
      have h_zeta_pow : Œ∂97 ^ 97 = 1 := by
        exact IsPrimitiveRoot.pow_eq_one ( IsCyclotomicExtension.zeta_spec 97 ‚Ñö L97 );
      aesop;
    -- By definition of $C_coset$, we know that $C_coset (i + ind N)$ is the set of elements $y$ such that $ind y = i + ind N$.
    have hC_coset_shift : C_coset (i + ind N) = Finset.image (fun x => (N * x : ZMod 97)) (C_coset i) := by
      ext x; simp [hC_coset];
      constructor;
      ¬∑ intro hx
        obtain ‚ü®a, ha‚ü© : ‚àÉ a : ZMod 97, (N * a : ZMod 97) = x := by
          have h_inv : ‚àÉ a : ZMod 97, (N : ZMod 97) * a = 1 := by
            have h_inv : Nat.gcd N 97 = 1 := by
              exact Nat.Coprime.symm ( Nat.Prime.coprime_iff_not_dvd ( by decide ) |>.2 fun h => hN <| by have := Nat.prime_dvd_prime_iff_eq ( by decide : Nat.Prime 97 ) ( Fact.out : Nat.Prime N ) ; tauto );
            have := Nat.exists_mul_emod_eq_one_of_coprime h_inv;
            exact Exists.elim ( this ( by decide ) ) fun m hm => ‚ü® m, by simpa [ ‚Üê ZMod.natCast_eq_zero_iff ] using congr_arg ( fun x : ‚Ñï => x : ‚Ñï ‚Üí ZMod 97 ) hm ‚ü©;
          exact ‚ü® h_inv.choose * x, by linear_combination' h_inv.choose_spec * x ‚ü©;
        use a; simp_all +decide [ Set.ext_iff ] ;
        have h_ind_mul : ind (N * a) = ind N + ind a := by
          have h_ind_mul : ‚àÄ x y : ZMod 97, x ‚â† 0 ‚Üí y ‚â† 0 ‚Üí ind (x * y) = ind x + ind y := by
            exact?;
          apply h_ind_mul; exact (by
          intro h; simp_all +decide [ ZMod.natCast_eq_zero_iff ] ;); exact (by
          grind);
        grind +ring;
      ¬∑ rintro ‚ü® a, ha, rfl ‚ü©;
        have h_ind_mul : ind (N * a) = ind N + ind a := by
          apply ind_mul;
          ¬∑ intro h; have := Fact.out ( p := Nat.Prime N ) ; simp_all +decide [ ZMod.natCast_eq_zero_iff ] ;
            rw [ this.dvd_iff_eq ] at h <;> aesop;
          ¬∑ exact hC_coset i |>.subset ha |>.1;
        simp_all +decide [ add_comm, C_coset ];
        exact?;
    -- By definition of $period$, we know that $period i$ is the sum of $Œ∂97^x$ over $x \in C_coset i$.
    have hperiod_def : ‚àÄ i : ZMod 3, period i = ‚àë x ‚àà C_coset i, Œ∂97 ^ x.val := by
      exact?;
    rw [ hperiod_def, hperiod_def, hC_coset_shift, Finset.sum_image ];
    ¬∑ rw [ map_sum, Finset.sum_congr rfl fun x hx => h_sigma_map x ];
    ¬∑ intro x hx y hy; haveI := Fact.mk ( Fact.out : Nat.Prime N ) ; simp_all +decide [ mul_eq_zero, ZMod.natCast_eq_zero_iff ] ;
      rintro ( rfl | h ) <;> simp_all +decide [ Nat.Prime.dvd_iff_eq Fact.out ]

/-
Integer versions of the periods and roots, and their coercion properties.
-/
def Œ∂97_int : ùìû L97 := IsPrimitiveRoot.toInteger (IsCyclotomicExtension.zeta_spec 97 ‚Ñö L97)

def period_int (i : ZMod 3) : ùìû L97 := ‚àë x ‚àà C_coset i, Œ∂97_int ^ (x.val : ‚Ñï)

def Œ±'_int : ùìû L97 := -(period_int 1 - period_int 2)
def Œ≤'_int : ùìû L97 := -(period_int 0 - period_int 1)
def Œ≥'_int : ùìû L97 := -(period_int 2 - period_int 0)

lemma coe_period_int (i : ZMod 3) : (period_int i : L97) = period i := by
  unfold period_int period;
  unfold Œ∂97_int Œ∑‚ÇÄ' Œ∑‚ÇÅ' Œ∑‚ÇÇ';
  split_ifs <;> simp +decide [ *, Subtype.ext_iff ];
  ¬∑ congr! 1;
    exact C_coset_eq.1;
  ¬∑ congr! 2;
    exact C_coset_eq.2.1;
  ¬∑ congr! 1;
    native_decide +revert

lemma coe_alpha'_int : (Œ±'_int : L97) = Œ±' := by
  unfold Œ±'_int Œ±';
  unfold period_int;
  unfold Œ∑‚ÇÇ' Œ∑‚ÇÅ' C_coset; simp +decide [ Finset.sum_sub_distrib ] ;
  congr! 2;
  ¬∑ native_decide +revert;
  ¬∑ native_decide +revert

lemma coe_beta'_int : (Œ≤'_int : L97) = Œ≤' := by
  unfold Œ≤'_int Œ≤';
  unfold period_int;
  simp +decide [ C_coset_eq, S_s1, S_cubic_res ];
  congr!

lemma coe_gamma'_int : (Œ≥'_int : L97) = Œ≥' := by
  unfold Œ≥'_int Œ≥';
  unfold period_int;
  simp +decide [ C_coset_eq ];
  congr! 2

/-
Relate the index of N to the value of c' N being s1'.
-/
lemma ind_N_eq_1_iff_c_eq_s1 (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 97) :
  ind (N : ZMod 97) = 1 ‚Üî c' N = s1' := by
    unfold ind c' s1';
    unfold S_cubic_res S_s1; simp +decide;
    unfold q' a' s1'; simp +decide ;
    split_ifs <;> simp_all +decide [ ZMod.natCast_eq_zero_iff ];
    ¬∑ native_decide +revert;
    ¬∑ rename_i h‚ÇÅ h‚ÇÇ;
      contrapose! h‚ÇÇ;
      exact ‚ü® fun h => hN <| by have := Nat.prime_dvd_prime_iff_eq ( by decide : Nat.Prime 97 ) ( Fact.out : Nat.Prime N ) ; tauto, h‚ÇÇ ‚ü©

/-
Relate the index of N to the value of c' N being s2'.
-/
lemma ind_N_eq_2_iff_c_eq_s2 (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 97) :
  ind (N : ZMod 97) = 2 ‚Üî c' N = s2' := by
    -- By definition of $c'$ and $ind$, we know that $c' N = s2'$ if and only if $N^{32} = s2'$.
    have h_c'_eq_s2' : c' N = s2' ‚Üî (N : ZMod 97) ^ 32 = s2' := by
      rfl;
    cases eq_or_ne ( N : ZMod 97 ) 0 <;> simp_all +decide [ ind ];
    ¬∑ rw [ ZMod.natCast_eq_zero_iff ] at * ; exact absurd ( Nat.dvd_of_mod_eq_zero ( Nat.mod_eq_zero_of_dvd <| by assumption ) ) ( by rw [ Nat.dvd_prime Fact.out ] ; aesop );
    ¬∑ split_ifs <;> simp_all +decide [ S_cubic_res, S_s1, S_s2 ];
      ¬∑ native_decide +revert;
      ¬∑ native_decide +revert;
      ¬∑ have h_cases : ‚àÄ x : ZMod 97, x ‚â† 0 ‚Üí x ^ 32 = 1 ‚à® x ^ 32 = s1' ‚à® x ^ 32 = s2' := by
          native_decide +revert;
        cases h_cases _ ‚Äπ_‚Ä∫ <;> tauto

/-
Abbreviations for the ring of integers, residue field, and reduction map for q=97.
-/
abbrev ùìûL97 := ùìû L97
def kP97 (P : Ideal ùìûL97) [P.IsMaximal] := ùìûL97 ‚ß∏ P
noncomputable instance (P : Ideal ùìûL97) [P.IsMaximal] : Field (kP97 P) := Ideal.Quotient.field P
def red97 (P : Ideal ùìûL97) [P.IsMaximal] : ùìûL97 ‚Üí+* kP97 P := Ideal.Quotient.mk P

/-
Relate the index of N to the value of c' N being s1'.
-/
lemma ind_N_eq_1_iff_c_eq_s1_new (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 97) :
  ind (N : ZMod 97) = 1 ‚Üî c' N = s1' := by
    convert ind_N_eq_1_iff_c_eq_s1 N hN using 1

/-
Lift the automorphism sigma97 to the ring of integers.
-/
def sigma_int97 (u : (ZMod 97)À£) (x : ùìû L97) : ùìû L97 := ‚ü®sigma97 u x, by
  have h_integral : IsIntegral ‚Ñ§ (x : L97) := x.2
  exact IsIntegral.map (sigma97 u) h_integral‚ü©

/-
The ring of integers is generated by zeta97.
-/
lemma adjoin_zeta_eq_top97 : Algebra.adjoin ‚Ñ§ ({Œ∂97_int} : Set ùìûL97) = ‚ä§ := by
  let hŒ∂ := IsCyclotomicExtension.zeta_spec 97 ‚Ñö L97
  let pb := IsPrimitiveRoot.integralPowerBasis' hŒ∂
  have h_gen : pb.gen = Œ∂97_int := IsPrimitiveRoot.integralPowerBasis'_gen hŒ∂
  rw [‚Üê h_gen]
  exact pb.adjoin_gen_eq_top

/-
The automorphism sigma_N reduces to the Frobenius map modulo P.
-/
theorem artin_property97 {N : ‚Ñï} [Fact (Nat.Prime N)] (hN : N ‚â† 97) (P : Ideal ùìûL97) [P.IsMaximal] [CharP (kP97 P) N] (x : ùìûL97) :
  red97 P (sigma_int97 (gal_unit97 N hN) x) = (red97 P x) ^ N := by
    have h_sigma_int97_zeta : ‚àÄ x : ùìûL97, x ‚àà Algebra.adjoin ‚Ñ§ ({Œ∂97_int} : Set ùìûL97) ‚Üí red97 P (sigma_int97 (gal_unit97 N hN) x) = (red97 P x) ^ N := by
      refine fun x hx => Algebra.adjoin_induction ?_ ?_ ?_ ?_ hx;
      ¬∑ -- Since $\sigma_N(\zeta_{97}) = \zeta_{97}^N$, we have $\sigma_int97(\zeta_{97}) = \zeta_{97}^N$.
        have h_sigma_zeta : sigma_int97 (gal_unit97 N hN) Œ∂97_int = Œ∂97_int ^ N := by
          have h_sigma_zeta : (sigma97 (gal_unit97 N hN) Œ∂97_int : L97) = Œ∂97_int ^ N := by
            have h_sigma_zeta : ‚àÄ (u : (ZMod 97)À£), sigma97 u Œ∂97 = Œ∂97 ^ (u : ZMod 97).val := by
              intro u
              simp [sigma97];
              erw [ PowerBasis.equivOfMinpoly_gen ];
              rfl;
            convert h_sigma_zeta ( gal_unit97 N hN ) using 1;
            simp +decide [ gal_unit97 ];
            rw [ ‚Üê Nat.mod_add_div N 97 ] ; norm_num [ pow_add, pow_mul ] ;
            have h_zeta_97_pow : Œ∂97 ^ 97 = 1 := by
              exact IsPrimitiveRoot.pow_eq_one ( IsCyclotomicExtension.zeta_spec 97 ‚Ñö L97 );
            erw [ show ( Œ∂97_int : L97 ) = Œ∂97 from ?_ ] ; aesop;
            exact?;
          exact?;
        aesop;
      ¬∑ intro r; exact (by
        simp +decide [ red97, sigma_int97 ];
        erw [ Ideal.Quotient.eq ];
        -- Since $P$ is a maximal ideal, it is prime, and thus if $r^N - r$ is in $P$, then either $r$ is in $P$ or $r^{N-1} - 1$ is in $P$.
        have h_prime : ‚àÄ r : ‚Ñ§, (r ^ N - r : ùìûL97) ‚àà P := by
          intro r
          have h_fermat : (r ^ N - r : ‚Ñ§) ‚â° 0 [ZMOD N] := by
            simp +decide [ ‚Üê ZMod.intCast_eq_intCast_iff ];
          obtain ‚ü® k, hk ‚ü© := h_fermat.symm.dvd;
          -- Since $N$ is in $P$, multiplying by $k$ (which is an integer) keeps it in $P$.
          have hN_in_P : (N : ùìûL97) ‚àà P := by
            have hN_in_P : (N : kP97 P) = 0 := by
              exact?;
            exact?;
          convert P.mul_mem_right ( k : ùìûL97 ) hN_in_P using 1 ; norm_cast ; aesop;
        simpa using Submodule.neg_mem _ ( h_prime r ));
      ¬∑ intro x y hx hy hx' hy'; simp +decide [ *, pow_add ] ;
        rw [ show sigma_int97 ( gal_unit97 N hN ) ( x + y ) = sigma_int97 ( gal_unit97 N hN ) x + sigma_int97 ( gal_unit97 N hN ) y from ?_, map_add ];
        ¬∑ rw [ hx', hy', add_pow_char ];
        ¬∑ exact Subtype.ext <| map_add _ _ _;
      ¬∑ simp +contextual [ *, mul_pow ];
        intro x y hx hy hx' hy'; rw [ show sigma_int97 ( gal_unit97 N hN ) ( x * y ) = sigma_int97 ( gal_unit97 N hN ) x * sigma_int97 ( gal_unit97 N hN ) y from ?_ ] ; aesop;
        exact Subtype.ext <| map_mul _ _ _;
    exact h_sigma_int97_zeta x ( by rw [ adjoin_zeta_eq_top97 ] ; exact Algebra.mem_top ) |> fun h => by simpa using h;

/-
If c' N = s1', then sigma_N(alpha') = gamma'.
-/
lemma sigma_alpha_eq_gamma_if_s1 (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 97) (h : c' N = s1') :
  sigma_int97 (gal_unit97 N hN) Œ±'_int = Œ≥'_int := by
    -- We check the equality in the field L97.
    have h_field : sigma97 (gal_unit97 N hN) (Œ±'_int : L97) = (Œ≥'_int : L97) := by
      -- By definition of $c'$, we know that $c' N = s1'$ implies $ind (N : ZMod 97) = 1$.
      have h_ind : ind (N : ZMod 97) = 1 := by
        exact?;
      -- By definition of $sigma97$, we have $sigma97 (gal_unit97 N hN) (Œ±'_int) = sigma97 (gal_unit97 N hN) (period 2 - period 1)$.
      have h_sigma97_def : sigma97 (gal_unit97 N hN) (Œ±'_int : L97) = sigma97 (gal_unit97 N hN) (period 2 - period 1) := by
        rw [ show ( Œ±'_int : L97 ) = period 2 - period 1 from ?_ ];
        convert coe_alpha'_int using 1;
        unfold Œ±';
        exact?;
      -- By definition of $sigma97$, we have $sigma97 (gal_unit97 N hN) (period 2 - period 1) = period (2 + ind (N : ZMod 97)) - period (1 + ind (N : ZMod 97))$.
      have h_sigma97_period : sigma97 (gal_unit97 N hN) (period 2 - period 1) = period (2 + ind (N : ZMod 97)) - period (1 + ind (N : ZMod 97)) := by
        rw [ map_sub, sigma_period, sigma_period ];
      simp_all +decide [ Œ≥'_int ];
      exact congr_arg‚ÇÇ _ ( coe_period_int 0 ‚ñ∏ rfl ) ( coe_period_int 2 ‚ñ∏ rfl );
    convert h_field using 1;
    -- Since the ring of integers is a subalgebra of the field, the elements are equal in the ring if and only if they are equal in the field.
    have h_subalgebra : ‚àÄ (x y : ùìû L97), x = y ‚Üî (x : L97) = (y : L97) := by
      exact?;
    convert h_subalgebra _ _ using 1

/-
If c' N = s2', then sigma_N(alpha') = beta'.
-/
lemma sigma_alpha_eq_beta_if_s2 (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 97) (h : c' N = s2') :
  sigma_int97 (gal_unit97 N hN) Œ±'_int = Œ≤'_int := by
    -- Since $c' N = s2'$, we have $ind N = 2$.
    have h_ind : ind (N : ZMod 97) = 2 := by
      exact?;
    -- Since $\sigma_N(\alpha') = \beta'$ in $L97$, we have $\sigma_N(\alpha'_int) = \beta'_int$ in $\mathcal{O}_{L97}$.
    have h_sigma_alpha_int_eq_beta_int : (sigma97 (gal_unit97 N hN) Œ±' : L97) = Œ≤' := by
      -- Since $c' N = s2'$, we have $ind N = 2$. Therefore, $\sigma_N(\alpha') = \beta'$.
      have h_sigma_beta : (sigma97 (gal_unit97 N hN)) (period 2 - period 1) = period 1 - period 0 := by
        have := sigma_period N hN 2; have := sigma_period N hN 1; aesop;
      generalize_proofs at *; (
      unfold Œ±' Œ≤'; aesop;)
    generalize_proofs at *; (
    convert h_sigma_alpha_int_eq_beta_int using 1
    generalize_proofs at *; (
    constructor <;> intro h <;> simp_all +decide [ ‚Üê coe_alpha'_int, ‚Üê coe_beta'_int, ‚Üê coe_gamma'_int ] ;
    exact Subtype.ext h_sigma_alpha_int_eq_beta_int
    skip))

/-
Final result for q=97: Frobenius action on alpha depends on c' N.
-/
theorem final_result_97 {N : ‚Ñï} [Fact (Nat.Prime N)] (hN : N ‚â† 97) (hN19 : N ‚â† 19) (P : Ideal ùìûL97) [P.IsMaximal] [CharP (kP97 P) N] :
  (c' N = s1' ‚Üí (red97 P Œ±'_int) ^ N = red97 P Œ≥'_int) ‚àß
  (c' N = s2' ‚Üí (red97 P Œ±'_int) ^ N = red97 P Œ≤'_int) := by
  constructor
  ¬∑ intro h
    rw [‚Üê artin_property97 hN P Œ±'_int]
    rw [sigma_alpha_eq_gamma_if_s1 N hN h]
  ¬∑ intro h
    rw [‚Üê artin_property97 hN P Œ±'_int]
    rw [sigma_alpha_eq_beta_if_s2 N hN h]

/-
Definitions of constants q=139, a=23, s1, s2, and c for the new problem instance, and the cyclotomic field L139.
-/
def q'' : ‚Ñï := 139
def a'' : ‚Ñï := 23
def s1'' : ZMod 139 := (- (a'' : ZMod 139) - 3) * (6 : ZMod 139)‚Åª¬π
def s2'' : ZMod 139 := ((a'' : ZMod 139) - 3) * (6 : ZMod 139)‚Åª¬π
def c'' (N : ‚Ñï) : ZMod 139 := (N : ZMod 139) ^ ((q'' - 1) / 3)

open Polynomial NumberField

def L139 : Type := CyclotomicField 139 ‚Ñö

instance : Field L139 := CyclotomicField.instField 139 ‚Ñö
instance : NumberField L139 := CyclotomicField.instNumberField 139 ‚Ñö
instance : IsCyclotomicExtension {139} ‚Ñö L139 := CyclotomicField.isCyclotomicExtension 139 ‚Ñö

def Œ∂139 : L139 := IsCyclotomicExtension.zeta 139 ‚Ñö L139

instance : Fact (Nat.Prime 139) := ‚ü®by norm_num‚ü©

/-
Definitions of sets, Gaussian periods, roots, and index functions for q=139.
-/
def S_cubic_res'' : Finset (ZMod 139) := Finset.univ.filter (fun x => x ‚â† 0 ‚àß x ^ 46 = 1)
def S_s1'' : Finset (ZMod 139) := Finset.univ.filter (fun x => x ‚â† 0 ‚àß x ^ 46 = s1'')
def S_s2'' : Finset (ZMod 139) := Finset.univ.filter (fun x => x ‚â† 0 ‚àß x ^ 46 = s2'')

def Œ∑‚ÇÄ'' : L139 := ‚àë x ‚àà S_cubic_res'', Œ∂139 ^ (x.val : ‚Ñï)
def Œ∑‚ÇÅ'' : L139 := ‚àë x ‚àà S_s2'', Œ∂139 ^ (x.val : ‚Ñï)
def Œ∑‚ÇÇ'' : L139 := ‚àë x ‚àà S_s1'', Œ∂139 ^ (x.val : ‚Ñï)

def Œ±'' : L139 := -(Œ∑‚ÇÇ'' - Œ∑‚ÇÅ'')
def Œ≤'' : L139 := -(Œ∑‚ÇÄ'' - Œ∑‚ÇÇ'')
def Œ≥'' : L139 := -(Œ∑‚ÇÅ'' - Œ∑‚ÇÄ'')

theorem sum_zero'' : Œ±'' + Œ≤'' + Œ≥'' = 0 := by
  unfold Œ±'' Œ≤'' Œ≥'';
  ring

def ind'' (x : ZMod 139) : ZMod 3 :=
  if x ‚àà S_cubic_res'' then 0
  else if x ‚àà S_s1'' then 1
  else 2

def cyc_num'' (i j : ZMod 3) : ‚Ñï :=
  Fintype.card { x : ZMod 139 // x ‚â† 0 ‚àß x ‚â† 1 ‚àß ind'' x = i ‚àß ind'' (1 - x) = j }

def period'' (i : ZMod 3) : L139 :=
  if i = 0 then Œ∑‚ÇÄ''
  else if i = 1 then Œ∑‚ÇÇ''
  else Œ∑‚ÇÅ''

/-
The period function maps 0, 1, 2 to eta0'', eta2'', eta1'' respectively.
-/
lemma period_eq_def'' : period'' 0 = Œ∑‚ÇÄ'' ‚àß period'' 1 = Œ∑‚ÇÇ'' ‚àß period'' 2 = Œ∑‚ÇÅ'' := by
  exact ‚ü® rfl, rfl, rfl ‚ü©

/-
The index function correctly identifies which coset an element belongs to.
-/
lemma ind_spec'' (x : ZMod 139) (hx : x ‚â† 0) :
  (ind'' x = 0 ‚Üî x ‚àà S_cubic_res'') ‚àß
  (ind'' x = 1 ‚Üî x ‚àà S_s1'') ‚àß
  (ind'' x = 2 ‚Üî x ‚àà S_s2'') := by
    native_decide +revert

/-
Compute the cyclotomic numbers for q=139.
-/
#eval (cyc_num'' 0 0, cyc_num'' 0 1, cyc_num'' 0 2)
#eval (cyc_num'' 1 0, cyc_num'' 1 1, cyc_num'' 1 2)
#eval (cyc_num'' 2 0, cyc_num'' 2 1, cyc_num'' 2 2)

/-
Values of the cyclotomic numbers for q=139.
-/
lemma cyc_num_vals'' :
  cyc_num'' 0 0 = 12 ‚àß cyc_num'' 0 1 = 16 ‚àß cyc_num'' 0 2 = 17 ‚àß
  cyc_num'' 1 0 = 16 ‚àß cyc_num'' 1 1 = 17 ‚àß cyc_num'' 1 2 = 13 ‚àß
  cyc_num'' 2 0 = 17 ‚àß cyc_num'' 2 1 = 13 ‚àß cyc_num'' 2 2 = 16 := by
    native_decide +revert

/-
Number of solutions to x + y = u with ind x = i and ind y = j.
-/
def N_sol'' (i j : ZMod 3) (u : ZMod 139) : ‚Ñï :=
  Fintype.card { p : ZMod 139 √ó ZMod 139 // p.1 ‚â† 0 ‚àß p.2 ‚â† 0 ‚àß ind'' p.1 = i ‚àß ind'' p.2 = j ‚àß p.1 + p.2 = u }

/-
Define C_coset'' as the set of non-zero elements with a given index.
-/
def C_coset'' (i : ZMod 3) : Finset (ZMod 139) := Finset.univ.filter (fun x => x ‚â† 0 ‚àß ind'' x = i)

/-
The C_coset sets match the S sets defined earlier.
-/
lemma C_coset_eq'' : C_coset'' 0 = S_cubic_res'' ‚àß C_coset'' 1 = S_s1'' ‚àß C_coset'' 2 = S_s2'' := by
  native_decide +revert

/-
The period function is the sum of zeta powers over the corresponding coset.
-/
lemma period_eq_sum_C_coset'' (i : ZMod 3) : period'' i = ‚àë x ‚àà C_coset'' i, Œ∂139 ^ (x.val : ‚Ñï) := by
  fin_cases i <;> simp +decide [ C_coset_eq'' ];
  ¬∑ unfold period''; aesop;
  ¬∑ rfl;
  ¬∑ exact?

/-
Multiplication rule for Gaussian periods for q=139.
-/
lemma period_mul'' (i j : ZMod 3) :
  period'' i * period'' j = (if i = j then 46 else 0) +
  (cyc_num'' (i - 0) (j - 0) * period'' 0 +
   cyc_num'' (i - 1) (j - 1) * period'' 1 +
   cyc_num'' (i - 2) (j - 2) * period'' 2) := by
     have h_mult_rule : ‚àÄ i j : ZMod 3, period'' i * period'' j = (if i = j then 46 else 0) + ‚àë u ‚àà Finset.univ.filter (fun x : ZMod 139 => x ‚â† 0), (N_sol'' i j u : L139) * Œ∂139 ^ (u.val : ‚Ñï) := by
       intros i j
       have h_mult_rule : period'' i * period'' j = ‚àë x ‚àà C_coset'' i, ‚àë y ‚àà C_coset'' j, Œ∂139 ^ ((x.val + y.val) : ‚Ñï) := by
         rw [ period_eq_sum_C_coset'' i, period_eq_sum_C_coset'' j ];
         simp +decide only [Finset.sum_mul, pow_add];
         simp +decide only [Finset.mul_sum _ _ _];
       have h_mult_rule : ‚àë x ‚àà C_coset'' i, ‚àë y ‚àà C_coset'' j, Œ∂139 ^ ((x.val + y.val) : ‚Ñï) = ‚àë u ‚àà Finset.univ.filter (fun x : ZMod 139 => x ‚â† 0), ‚àë x ‚àà C_coset'' i, ‚àë y ‚àà C_coset'' j, (if x + y = u then Œ∂139 ^ (u.val : ‚Ñï) else 0) + ‚àë x ‚àà C_coset'' i, ‚àë y ‚àà C_coset'' j, (if x + y = 0 then Œ∂139 ^ (0 : ‚Ñï) else 0) := by
         have h_mult_rule : ‚àÄ x ‚àà C_coset'' i, ‚àÄ y ‚àà C_coset'' j, Œ∂139 ^ ((x.val + y.val) : ‚Ñï) = ‚àë u ‚àà Finset.univ.filter (fun x : ZMod 139 => x ‚â† 0), (if x + y = u then Œ∂139 ^ (u.val : ‚Ñï) else 0) + (if x + y = 0 then Œ∂139 ^ (0 : ‚Ñï) else 0) := by
           intro x hx y hy; by_cases h : x + y = 0 <;> simp +decide [ h ] ;
           ¬∑ have h_exp : x.val + y.val ‚â° 0 [MOD 139] := by
               simp +decide [ ‚Üê ZMod.natCast_eq_natCast_iff, h ];
             rw [ ‚Üê Nat.mod_add_div ( x.val + y.val ) 139, h_exp ] ; norm_num [ pow_add, pow_mul, IsPrimitiveRoot.pow_eq_one ] ;
             have h_exp : Œ∂139 ^ 139 = 1 := by
               exact IsPrimitiveRoot.pow_eq_one ( IsCyclotomicExtension.zeta_spec 139 ‚Ñö L139 );
             rw [ h_exp, one_pow ];
           ¬∑ have h_exp : Œ∂139 ^ (x.val + y.val) = Œ∂139 ^ ((x + y).val : ‚Ñï) := by
               have h_order : Œ∂139 ^ 139 = 1 := by
                 exact IsPrimitiveRoot.pow_eq_one ( IsCyclotomicExtension.zeta_spec 139 ‚Ñö L139 )
               rw [ ‚Üê Nat.mod_add_div ( x.val + y.val ) 139, pow_add, pow_mul ] ; aesop;
             exact h_exp;
         rw [ Finset.sum_congr rfl fun x hx => Finset.sum_congr rfl fun y hy => h_mult_rule x hx y hy ];
         simp +decide only [Finset.sum_add_distrib, Finset.sum_sigma'];
         refine' congrArg‚ÇÇ ( ¬∑ + ¬∑ ) _ rfl;
         apply Finset.sum_bij (fun x _ => ‚ü®x.snd.snd, x.fst, x.snd.fst‚ü©);
         ¬∑ simp +contextual [ C_coset'' ];
         ¬∑ grind;
         ¬∑ simp +zetaDelta at *;
           exact fun b hb‚ÇÅ hb‚ÇÇ hb‚ÇÉ => ‚ü® b.2.1, b.2.2, b.1, ‚ü® hb‚ÇÇ, hb‚ÇÉ, hb‚ÇÅ ‚ü©, rfl ‚ü©;
         ¬∑ simp +decide [ add_comm ];
       have h_mult_rule : ‚àë x ‚àà C_coset'' i, ‚àë y ‚àà C_coset'' j, (if x + y = 0 then Œ∂139 ^ (0 : ‚Ñï) else 0) = if i = j then 46 else 0 := by
         have h_mult_rule : ‚àÄ x ‚àà C_coset'' i, ‚àë y ‚àà C_coset'' j, (if x + y = 0 then 1 else 0) = if i = j then 1 else 0 := by
           intro x hx
           have h_inv : -x ‚àà C_coset'' i := by
             have h_inv : ind'' (-x) = ind'' x := by
               have h_inv : ‚àÄ x : ZMod 139, x ‚â† 0 ‚Üí ind'' (-x) = ind'' x := by
                 native_decide +revert;
               exact h_inv x ( by rintro rfl; exact absurd hx ( by simp +decide [ C_coset'' ] ) );
             unfold C_coset'' at *; aesop;
           have h_inv : ‚àÄ y ‚àà C_coset'' j, x + y = 0 ‚Üî y = -x := by
             exact fun y hy => ‚ü® fun h => by linear_combination' h, fun h => by linear_combination' h ‚ü©;
           by_cases hij : i = j <;> simp_all +decide [ Finset.sum_ite ];
           intro hy; have := Finset.mem_filter.mp hx; have := Finset.mem_filter.mp hy; simp_all +decide [ C_coset'' ] ;
         have h_card : C_coset'' i = Finset.univ.filter (fun x : ZMod 139 => x ‚â† 0 ‚àß ind'' x = i) := by
           exact?
         have h_card_val : Finset.card (Finset.univ.filter (fun x : ZMod 139 => x ‚â† 0 ‚àß ind'' x = i)) = 46 := by
           fin_cases i <;> native_decide
         simp_all +decide [ Finset.sum_ite ];
         rw [ Finset.sum_congr rfl fun x hx => by rw [ h_mult_rule x ( Finset.mem_filter.mp hx |>.2.1 ) ( Finset.mem_filter.mp hx |>.2.2 ) ] ] ; aesop;
       have h_mult_rule : ‚àÄ u ‚àà Finset.univ.filter (fun x : ZMod 139 => x ‚â† 0), ‚àë x ‚àà C_coset'' i, ‚àë y ‚àà C_coset'' j, (if x + y = u then Œ∂139 ^ (u.val : ‚Ñï) else 0) = (N_sol'' i j u : L139) * Œ∂139 ^ (u.val : ‚Ñï) := by
         intros u hu
         have h_mult_rule : ‚àë x ‚àà C_coset'' i, ‚àë y ‚àà C_coset'' j, (if x + y = u then Œ∂139 ^ (u.val : ‚Ñï) else 0) = ‚àë p ‚àà Finset.filter (fun p : ZMod 139 √ó ZMod 139 => p.1 ‚â† 0 ‚àß p.2 ‚â† 0 ‚àß ind'' p.1 = i ‚àß ind'' p.2 = j ‚àß p.1 + p.2 = u) (Finset.univ : Finset (ZMod 139 √ó ZMod 139)), Œ∂139 ^ (u.val : ‚Ñï) := by
           rw [ ‚Üê Finset.sum_product' ];
           rw [ ‚Üê Finset.sum_filter ];
           refine' Finset.sum_bij ( fun p hp => p ) _ _ _ _ <;> simp +contextual [ C_coset'' ];
         simp_all +decide [ N_sol'' ];
         exact Or.inl ( by rw [ Fintype.subtype_card ] );
       rw [ ‚Äπperiod'' i * period'' j = _‚Ä∫, ‚Äπ‚àë x ‚àà C_coset'' i, ‚àë y ‚àà C_coset'' j, Œ∂139 ^ ( x.val + y.val ) = _‚Ä∫, Finset.sum_congr rfl h_mult_rule, add_comm ] ; aesop;
     -- By definition of $N_sol''$, we know that $N_sol'' i j u = cyc_num'' (i - ind'' u) (j - ind'' u)$ for all $u \in \mathbb{F}_{139}^\times$.
     have h_N_sol_eq_cyc_num : ‚àÄ i j : ZMod 3, ‚àÄ u : ZMod 139, u ‚â† 0 ‚Üí N_sol'' i j u = cyc_num'' (i - ind'' u) (j - ind'' u) := by
       intros i j u hu_nonzero
       simp [N_sol'', cyc_num''];
       rw [ Fintype.card_subtype, Fintype.card_subtype ];
       refine' Finset.card_bij ( fun x hx => x.1 / u ) _ _ _;
       ¬∑ field_simp;
         intro x hx; have := hx; simp_all +decide [ div_eq_iff, sub_eq_iff_eq_add ] ;
         have h_div : ind'' (x.1 / u) = ind'' x.1 - ind'' u := by
           have h_ind_div : ‚àÄ x y : ZMod 139, x ‚â† 0 ‚Üí y ‚â† 0 ‚Üí ind'' (x * y) = ind'' x + ind'' y := by
             native_decide +revert;
           have h_ind_div : ind'' (x.1 / u * u) = ind'' (x.1 / u) + ind'' u := by
             grind;
           rw [ div_mul_cancel‚ÇÄ _ hu_nonzero ] at h_ind_div ; exact eq_sub_of_add_eq h_ind_div.symm
         have h_div' : ind'' (1 - x.1 / u) = ind'' x.2 - ind'' u := by
           have h_div' : ind'' (1 - x.1 / u) = ind'' (x.2 / u) := by
             grind;
           have h_div' : ind'' (x.2 / u) = ind'' x.2 - ind'' u := by
             have h_div' : ‚àÄ x y : ZMod 139, x ‚â† 0 ‚Üí y ‚â† 0 ‚Üí ind'' (x / y) = ind'' x - ind'' y := by
               native_decide +revert
             exact h_div' _ _ this.2.1 hu_nonzero;
           grind +ring;
         grind +ring;
       ¬∑ simp +contextual [ div_eq_iff, hu_nonzero ];
         aesop;
       ¬∑ intro b hb
         use (b * u, (1 - b) * u);
         have h_ind_mul : ‚àÄ x y : ZMod 139, x ‚â† 0 ‚Üí y ‚â† 0 ‚Üí ind'' (x * y) = ind'' x + ind'' y := by
           native_decide +revert;
         grind;
     -- By partitioning the sum over u into parts where ind'' u is 0, 1, or 2, we can rewrite the sum as a sum over k of cyc_num'' (i - k) (j - k) multiplied by the sum over u in C_k of Œ∂139^u.
     have h_partition : ‚àë u ‚àà Finset.univ.filter (fun x : ZMod 139 => x ‚â† 0), (cyc_num'' (i - ind'' u) (j - ind'' u) : L139) * Œ∂139 ^ (u.val : ‚Ñï) = ‚àë k : ZMod 3, ‚àë u ‚àà C_coset'' k, (cyc_num'' (i - k) (j - k) : L139) * Œ∂139 ^ (u.val : ‚Ñï) := by
       simp +decide only [C_coset''];
       simp +decide only [Finset.sum_filter, ‚Üê Finset.sum_product'];
       rw [ ‚Üê Finset.sum_filter ];
       rw [ ‚Üê Finset.sum_filter ];
       refine' Finset.sum_bij ( fun x hx => ( ind'' x, x ) ) _ _ _ _ <;> simp +contextual;
     rw [ h_mult_rule, Finset.sum_congr rfl fun u hu => by rw [ h_N_sol_eq_cyc_num i j u ( Finset.mem_filter.mp hu |>.2 ) ] ];
     rw [ h_partition, Finset.sum_eq_multiset_sum ] ; norm_cast;
     erw [ Multiset.sum_coe ] ; simp +decide [ Finset.sum_add_distrib, mul_assoc, Finset.mul_sum _ _ _, Finset.sum_mul ] ; ring;
     simp +decide [ List.map, List.sum, period_eq_sum_C_coset'' ] ; ring!;
     simp +decide [ List.finRange, Finset.mul_sum _ _ _, mul_assoc, mul_left_comm, Finset.sum_mul ] ; ring!

/-
The sum of the Gaussian periods is -1.
-/
lemma eta_sum_neg_one'' : Œ∑‚ÇÄ'' + Œ∑‚ÇÅ'' + Œ∑‚ÇÇ'' = -1 := by
  have h_sum : ‚àë x ‚àà Finset.univ.filter (fun x : ZMod 139 => x ‚â† 0), Œ∂139 ^ (x.val : ‚Ñï) = -1 := by
    have h_sum : ‚àë x ‚àà Finset.range 139, Œ∂139 ^ x = 0 := by
      -- Since Œ∂139 is a primitive 139th root of unity, we have Œ∂139^139 = 1 and Œ∂139 ‚â† 1.
      have h_primitive : Œ∂139 ^ 139 = 1 ‚àß Œ∂139 ‚â† 1 := by
        have h_primitive : IsPrimitiveRoot Œ∂139 139 := by
          convert IsCyclotomicExtension.zeta_spec 139 ‚Ñö L139 using 1;
        exact ‚ü® h_primitive.pow_eq_one, h_primitive.ne_one <| by decide ‚ü©;
      rw [ geom_sum_eq ] <;> aesop;
    rw [ show ( Finset.filter ( fun x : ZMod 139 => ¬¨x = 0 ) Finset.univ : Finset ( ZMod 139 ) ) = Finset.image ( fun x : ‚Ñï => x : ‚Ñï ‚Üí ZMod 139 ) ( Finset.Ico 1 139 ) from by native_decide, Finset.sum_image ] <;> norm_num [ h_sum ];
    ¬∑ rw [ Finset.sum_congr rfl fun x hx => by rw [ Nat.mod_eq_of_lt ( by linarith [ Finset.mem_Ico.mp hx ] ) ] ] ; rw [ Finset.sum_Ico_eq_sub _ ] <;> norm_num [ h_sum ] ;
    ¬∑ exact fun x hx y hy hxy => Nat.mod_eq_of_lt ( show x < 139 by linarith [ hx.2 ] ) ‚ñ∏ Nat.mod_eq_of_lt ( show y < 139 by linarith [ hy.2 ] ) ‚ñ∏ by simpa [ ZMod.natCast_eq_natCast_iff ] using hxy;
  rw [ ‚Üê h_sum, show Œ∑‚ÇÄ'' = ‚àë x ‚àà S_cubic_res'', Œ∂139 ^ ( x.val : ‚Ñï ) from rfl, show Œ∑‚ÇÅ'' = ‚àë x ‚àà S_s2'', Œ∂139 ^ ( x.val : ‚Ñï ) from rfl, show Œ∑‚ÇÇ'' = ‚àë x ‚àà S_s1'', Œ∂139 ^ ( x.val : ‚Ñï ) from rfl ];
  rw [ ‚Üê Finset.sum_union, ‚Üê Finset.sum_union ] <;> norm_num [ Finset.disjoint_left ];
  ¬∑ rw [ show S_cubic_res'' ‚à™ ( S_s2'' ‚à™ S_s1'' ) = Finset.univ.filter ( fun x : ZMod 139 => ¬¨x = 0 ) from by native_decide ];
  ¬∑ native_decide +revert;
  ¬∑ native_decide +revert

/-
Corrected formulas for products of Gaussian periods.
-/
lemma eta1_sq_corrected : Œ∑‚ÇÅ''^2 = 46 + 16 * Œ∑‚ÇÄ'' + 12 * Œ∑‚ÇÅ'' + 17 * Œ∑‚ÇÇ'' := by
  rw [ sq ];
  -- Apply the multiplication rule for Gaussian periods with i = 2 and j = 2.
  have h_mul : period'' 2 * period'' 2 = (if 2 = 2 then 46 else 0) + (cyc_num'' (2 - 0) (2 - 0) * period'' 0 + cyc_num'' (2 - 1) (2 - 1) * period'' 1 + cyc_num'' (2 - 2) (2 - 2) * period'' 2) := by
    convert period_mul'' 2 2 using 1;
  convert h_mul using 1 ; norm_num [ cyc_num_vals'' ] ; ring!
lemma eta2_sq_corrected : Œ∑‚ÇÇ''^2 = 46 + 17 * Œ∑‚ÇÄ'' + 16 * Œ∑‚ÇÅ'' + 12 * Œ∑‚ÇÇ'' := by
  convert period_mul'' 1 1 using 1 ; ring!;
  -- By definition of cyc_num'', we know that cyc_num'' 1 1 = 17, cyc_num'' 0 0 = 12, and cyc_num'' 2 2 = 16.
  have h_cyc_num : cyc_num'' 1 1 = 17 ‚àß cyc_num'' 0 0 = 12 ‚àß cyc_num'' 2 2 = 16 := by
    exact ‚ü® by native_decide, by native_decide, by native_decide ‚ü©;
  erw [ h_cyc_num.1, h_cyc_num.2.1, h_cyc_num.2.2 ] ; ring!;
  norm_num [ add_comm, add_left_comm, add_assoc ]
lemma eta1_mul_eta2_corrected : Œ∑‚ÇÅ'' * Œ∑‚ÇÇ'' = 13 * Œ∑‚ÇÄ'' + 17 * Œ∑‚ÇÅ'' + 16 * Œ∑‚ÇÇ'' := by
  unfold Œ∑‚ÇÅ'' Œ∑‚ÇÇ'' Œ∑‚ÇÄ'';
  have := @period_mul'' 1 2; simp_all +decide [ Finset.sum_add_distrib, mul_add, add_mul, mul_assoc, mul_comm, mul_left_comm ] ;
  convert this using 1 ; norm_num [ period_eq_def'' ];
  rw [ show cyc_num'' 1 2 = 13 by native_decide, show cyc_num'' 0 1 = 16 by native_decide, show cyc_num'' ( -1 ) 0 = 17 by native_decide ] ; ring!
lemma eta0_sq_corrected : Œ∑‚ÇÄ''^2 = 46 + 12 * Œ∑‚ÇÄ'' + 17 * Œ∑‚ÇÅ'' + 16 * Œ∑‚ÇÇ'' := by
  have := @period_mul'' 0 0; norm_num [ cyc_num_vals'' ] at this;
  convert this using 1 ; ring!;
  erw [ show cyc_num'' ( -1 ) ( -1 ) = 16 by native_decide, show cyc_num'' ( -2 ) ( -2 ) = 17 by native_decide ] ; ring!;

/-
Corrected algebraic relations for alpha, beta, gamma.
-/
theorem alpha_root_corrected : Œ±''^3 - 139*Œ±'' + 139 = 0 := by
  unfold Œ±'';
  -- Substitute the known values from the hypotheses into the equation.
  have h_sub : Œ∑‚ÇÅ''^2 = 46 + 16 * Œ∑‚ÇÄ'' + 12 * Œ∑‚ÇÅ'' + 17 * Œ∑‚ÇÇ'' ‚àß Œ∑‚ÇÇ''^2 = 46 + 17 * Œ∑‚ÇÄ'' + 16 * Œ∑‚ÇÅ'' + 12 * Œ∑‚ÇÇ'' ‚àß Œ∑‚ÇÅ'' * Œ∑‚ÇÇ'' = 13 * Œ∑‚ÇÄ'' + 17 * Œ∑‚ÇÅ'' + 16 * Œ∑‚ÇÇ'' ‚àß Œ∑‚ÇÄ'' + Œ∑‚ÇÅ'' + Œ∑‚ÇÇ'' = -1 := by
    exact ‚ü® by simpa using eta1_sq_corrected, by simpa using eta2_sq_corrected, by simpa using eta1_mul_eta2_corrected, by simpa using eta_sum_neg_one'' ‚ü©;
  grind +ring
theorem beta_relation_corrected : 2 * 23 * Œ≤'' = -6 * Œ±''^2 - 32 * Œ±'' + 4 * 139 := by
  repeat' rw [ show Œ≤'' = - ( Œ∑‚ÇÄ'' - Œ∑‚ÇÇ'' ) by rfl ] ; repeat' rw [ show Œ±'' = - ( Œ∑‚ÇÇ'' - Œ∑‚ÇÅ'' ) by rfl ] ; ring;
  rw [ show Œ∑‚ÇÅ'' ^ 2 = 46 + 16 * Œ∑‚ÇÄ'' + 12 * Œ∑‚ÇÅ'' + 17 * Œ∑‚ÇÇ'' by exact? ] ; rw [ show Œ∑‚ÇÇ'' ^ 2 = 46 + 17 * Œ∑‚ÇÄ'' + 16 * Œ∑‚ÇÅ'' + 12 * Œ∑‚ÇÇ'' by exact? ] ; ring;
  rw [ show Œ∑‚ÇÄ'' = -1 - Œ∑‚ÇÅ'' - Œ∑‚ÇÇ'' by linear_combination' eta_sum_neg_one'' ] ; ring;
  rw [ eta1_mul_eta2_corrected ] ; ring;
  rw [ show Œ∑‚ÇÄ'' = -1 - Œ∑‚ÇÅ'' - Œ∑‚ÇÇ'' by linear_combination' eta_sum_neg_one'' ] ; ring
theorem gamma_relation_corrected : 2 * 23 * Œ≥'' = 6 * Œ±''^2 - 14 * Œ±'' - 4 * 139 := by
  unfold Œ≥'' Œ±''; ring;
  rw [ eta1_sq_corrected, eta2_sq_corrected, eta1_mul_eta2_corrected ] ; ring;
  rw [ show Œ∑‚ÇÇ'' = -1 - Œ∑‚ÇÄ'' - Œ∑‚ÇÅ'' by linear_combination' eta_sum_neg_one'' ] ; ring;

/-
Define the Galois unit and automorphism for q=139.
-/
def gal_unit139 (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 139) : (ZMod 139)À£ := Units.mk0 (N : ZMod 139) (by
  rw [Ne, ZMod.natCast_zmod_eq_zero_iff_dvd]
  intro h
  have hN_prime : Nat.Prime N := Fact.out
  have : 139 = 1 ‚à® 139 = N := (Nat.dvd_prime hN_prime).mp h
  have : 139 = N := this.resolve_left (by norm_num)
  exact hN this.symm)

def sigma139 (u : (ZMod 139)À£) : L139 ‚âÉ‚Çê[‚Ñö] L139 :=
  (IsCyclotomicExtension.autEquivPow L139 (Polynomial.cyclotomic.irreducible_rat (n := 139) (by norm_num))).symm u

/-
Integer versions of the periods and roots for q=139.
-/
def Œ∂139_int : ùìû L139 := IsPrimitiveRoot.toInteger (IsCyclotomicExtension.zeta_spec 139 ‚Ñö L139)

def period_int139 (i : ZMod 3) : ùìû L139 := ‚àë x ‚àà C_coset'' i, Œ∂139_int ^ (x.val : ‚Ñï)

def Œ±''_int : ùìû L139 := -(period_int139 1 - period_int139 2)
def Œ≤''_int : ùìû L139 := -(period_int139 0 - period_int139 1)
def Œ≥''_int : ùìû L139 := -(period_int139 2 - period_int139 0)

/-
Coercion property for the integer version of periods.
-/
lemma coe_period_int139 (i : ZMod 3) : (period_int139 i : L139) = period'' i := by
  -- By definition of coercion, we can show that the sum of the integer versions of Œ∂139^x is equal to the sum of Œ∂139^x.
  have h_coercion : ‚àÄ x : ZMod 139, (Œ∂139_int ^ (x.val : ‚Ñï) : L139) = Œ∂139 ^ (x.val : ‚Ñï) := by
    exact?;
  simp [period_int139, period'', h_coercion];
  convert period_eq_sum_C_coset'' i using 1;
  ¬∑ exact?;
  ¬∑ convert period_eq_sum_C_coset'' i using 1

/-
Coercion property for the integer version of alpha.
-/
lemma coe_alpha''_int : (Œ±''_int : L139) = Œ±'' := by
  -- By definition of Œ±''_int, we have Œ±''_int = -(period_int139 1 - period_int139 2).
  simp [Œ±''_int, coe_period_int139];
  unfold period'' Œ±'';
  grind

/-
Coercion property for the integer version of beta.
-/
lemma coe_beta''_int : (Œ≤''_int : L139) = Œ≤'' := by
  convert congr_arg ( fun x : L139 => - ( Œ∑‚ÇÄ'' - x ) ) ( coe_period_int139 1 ) using 1;
  -- By definition of Œ≤''_int, we have Œ≤''_int = -(period_int139 0 - period_int139 1).
  simp [Œ≤''_int];
  convert coe_period_int139 0 using 1

/-
Coercion property for the integer version of gamma.
-/
lemma coe_gamma''_int : (Œ≥''_int : L139) = Œ≥'' := by
  convert congr_arg Neg.neg ( congrArg‚ÇÇ ( ¬∑ - ¬∑ ) ( coe_period_int139 2 ) ( coe_period_int139 0 ) ) using 1

/-
Relate the index of N to the value of c'' N being s1''.
-/
lemma ind_N_eq_1_iff_c_eq_s1'' (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 139) :
  ind'' (N : ZMod 139) = 1 ‚Üî c'' N = s1'' := by
    -- By definition of $ind''$, we know that $ind'' N = 1$ if and only if $N \in S_s1''$.
    have h_ind''_def : ind'' (N : ZMod 139) = 1 ‚Üî (N : ZMod 139) ‚àà S_s1'' := by
      by_cases hN_zero : ( N : ZMod 139 ) = 0 <;> simp_all +decide [ S_s1'', ind'' ];
      split_ifs <;> simp_all +decide [ S_cubic_res'' ];
      native_decide +revert;
    convert h_ind''_def using 1;
    -- By definition of $S_s1''$, we know that $N \in S_s1''$ if and only if $N^{46} = s1''$.
    simp [S_s1''];
    constructor <;> intro h <;> simp_all +decide [ ZMod.natCast_eq_zero_iff ];
    ¬∑ exact ‚ü® fun h' => hN <| by have := Nat.prime_dvd_prime_iff_eq ( by decide : Nat.Prime 139 ) ( Fact.out : Nat.Prime N ) ; aesop, by simpa [ c'' ] using h ‚ü©;
    ¬∑ convert h.2 using 1

/-
Relate the index of N to the value of c'' N being s2''.
-/
lemma ind_N_eq_2_iff_c_eq_s2'' (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 139) :
  ind'' (N : ZMod 139) = 2 ‚Üî c'' N = s2'' := by
    have h_ind : ‚àÄ x : ZMod 139, x ‚â† 0 ‚Üí (ind'' x = 2 ‚Üî x ^ 46 = s2'') := by
      native_decide +revert;
    by_cases h : ( N : ZMod 139 ) = 0 <;> simp_all +decide [ ZMod.natCast_eq_zero_iff ];
    ¬∑ rw [ Nat.dvd_prime Fact.out ] at h ; aesop;
    ¬∑ unfold c''; norm_num [ ‚Üê ZMod.natCast_eq_zero_iff ] at *; aesop;

/-
Abbreviations for the ring of integers, residue field, and reduction map for q=139.
-/
abbrev ùìûL139 := ùìû L139
def kP139 (P : Ideal ùìûL139) [P.IsMaximal] := ùìûL139 ‚ß∏ P
noncomputable instance (P : Ideal ùìûL139) [P.IsMaximal] : Field (kP139 P) := Ideal.Quotient.field P
def red139 (P : Ideal ùìûL139) [P.IsMaximal] : ùìûL139 ‚Üí+* kP139 P := Ideal.Quotient.mk P

/-
Lift the automorphism sigma139 to the ring of integers.
-/
def sigma_int139 (u : (ZMod 139)À£) (x : ùìû L139) : ùìû L139 := ‚ü®sigma139 u x, by
  have h_integral : IsIntegral ‚Ñ§ (x : L139) := x.2
  exact IsIntegral.map (sigma139 u) h_integral‚ü©

/-
The ring of integers is generated by zeta139.
-/
lemma adjoin_zeta_eq_top139 : Algebra.adjoin ‚Ñ§ ({Œ∂139_int} : Set ùìûL139) = ‚ä§ := by
  have h_gen_zeta : IsPrimitiveRoot Œ∂139_int 139 := by
    convert IsPrimitiveRoot.toInteger_isPrimitiveRoot _;
    ¬∑ infer_instance;
    ¬∑ decide +kernel
  generalize_proofs at *;
  have h_gen_zeta : IsCyclotomicExtension {139} ‚Ñ§ (ùìû L139) := by
    exact?
  generalize_proofs at *; (
  convert h_gen_zeta.adjoin_primitive_root_eq_top _ using 1
  generalize_proofs at *; (
  assumption))

/-
sigma_int139 maps zeta139_int to zeta139_int^N.
-/
lemma sigma_zeta139 {N : ‚Ñï} [Fact (Nat.Prime N)] (hN : N ‚â† 139) :
  sigma_int139 (gal_unit139 N hN) Œ∂139_int = Œ∂139_int ^ N := by
    convert congr_arg ( algebraMap ùìûL139 L139 ) ?_ using 1;
    field_simp;
    rotate_left;
    exact?;
    ¬∑ rfl;
    ¬∑ -- By definition of the automorphism, we have that œÉ_int139 (gal_unit139 N hN) Œ∂139_int = Œ∂139_int ^ N.
      simp [sigma_int139, gal_unit139];
      unfold sigma139;
      erw [ Subtype.mk_eq_mk ];
      simp +decide [ IsCyclotomicExtension.autEquivPow ];
      erw [ PowerBasis.equivOfMinpoly_gen ];
      simp +decide [ IsPrimitiveRoot.powerBasis ];
      erw [ ‚Üê Nat.mod_add_div N 139 ] ; norm_num [ pow_add, pow_mul ];
      erw [ show ( Œ∂139_int : L139 ) ^ 139 = 1 from ?_ ] ; aesop;
      convert IsPrimitiveRoot.pow_eq_one ( IsCyclotomicExtension.zeta_spec 139 ‚Ñö L139 ) using 1

/-
The automorphism sigma_N reduces to the Frobenius map modulo P.
-/
theorem artin_property139 {N : ‚Ñï} [Fact (Nat.Prime N)] (hN : N ‚â† 139) (P : Ideal ùìûL139) [P.IsMaximal] [CharP (kP139 P) N] (x : ùìûL139) :
  red139 P (sigma_int139 (gal_unit139 N hN) x) = (red139 P x) ^ N := by
    have h_phi_psi : ‚àÄ x : ùìûL139, (red139 P) (sigma_int139 (gal_unit139 N hN) x) = (red139 P x) ^ N := by
      have h_adjoin : ‚àÄ x : ùìûL139, x ‚àà Algebra.adjoin ‚Ñ§ ({Œ∂139_int} : Set ùìûL139) ‚Üí (red139 P) (sigma_int139 (gal_unit139 N hN) x) = (red139 P x) ^ N := by
        intro x hx
        induction' hx using Algebra.adjoin_induction with x hx ihx;
        ¬∑ have := sigma_zeta139 hN; aesop;
        ¬∑ erw [ show sigma_int139 ( gal_unit139 N hN ) ‚Üëihx = ‚Üëihx from ?_ ];
          ¬∑ -- Since the residue field has characteristic N, we have that for any integer k, k^N ‚â° k (mod N).
            have h_char : ‚àÄ k : ‚Ñ§, (k : kP139 P) ^ N = k := by
              intro k; induction k <;> simp_all +decide [ pow_succ, pow_mul ] ;
              ¬∑ exact Nat.Prime.ne_zero Fact.out;
              ¬∑ rw [ add_pow_char ] ; aesop;
              ¬∑ rw [ sub_pow_char ] ; aesop;
            convert h_char ihx |> Eq.symm using 1;
          ¬∑ unfold sigma_int139
            simp [sigma139];
            rfl;
        ¬∑ rename_i hx hy ihx ihy;
          convert congr_arg‚ÇÇ ( ¬∑ + ¬∑ ) ihx ihy using 1;
          ¬∑ unfold sigma_int139; aesop;
          ¬∑ simp +decide [ ‚Üê add_pow_char ];
        ¬∑ rename_i x y hx hy ihx ihy;
          have h_sigma_mul : sigma_int139 (gal_unit139 N hN) (x * y) = sigma_int139 (gal_unit139 N hN) x * sigma_int139 (gal_unit139 N hN) y := by
            exact Subtype.ext <| map_mul _ _ _;
          simp_all +decide [ ‚Üê mul_pow ];
      exact fun x => h_adjoin x <| adjoin_zeta_eq_top139 ‚ñ∏ Algebra.mem_top;
    exact h_phi_psi x

/-
The automorphism sigma_N reduces to the Frobenius map modulo P.
-/
theorem artin_property139' {N : ‚Ñï} [Fact (Nat.Prime N)] (hN : N ‚â† 139) (P : Ideal ùìûL139) [P.IsMaximal] [CharP (kP139 P) N] (x : ùìûL139) :
  red139 P (sigma_int139 (gal_unit139 N hN) x) = (red139 P x) ^ N := by
    have h_phi_psi : ‚àÄ x : ùìûL139, (red139 P) (sigma_int139 (gal_unit139 N hN) x) = (red139 P x) ^ N := by
      have h_adjoin : ‚àÄ x : ùìûL139, x ‚àà Algebra.adjoin ‚Ñ§ ({Œ∂139_int} : Set ùìûL139) ‚Üí (red139 P) (sigma_int139 (gal_unit139 N hN) x) = (red139 P x) ^ N := by
        intro x hx
        induction' hx using Algebra.adjoin_induction with x hx ihx;
        ¬∑ have := sigma_zeta139 hN; aesop;
        ¬∑ erw [ show sigma_int139 ( gal_unit139 N hN ) ‚Üëihx = ‚Üëihx from ?_ ];
          ¬∑ -- Since the residue field has characteristic N, we have that for any integer k, k^N ‚â° k (mod N).
            have h_char : ‚àÄ k : ‚Ñ§, (k : kP139 P) ^ N = k := by
              intro k; induction k <;> simp_all +decide [ pow_succ, pow_mul ] ;
              ¬∑ exact Nat.Prime.ne_zero Fact.out;
              ¬∑ rw [ add_pow_char ] ; aesop;
              ¬∑ rw [ sub_pow_char ] ; aesop;
            convert h_char ihx |> Eq.symm using 1;
          ¬∑ unfold sigma_int139
            simp [sigma139];
            rfl;
        ¬∑ rename_i hx hy ihx ihy;
          convert congr_arg‚ÇÇ ( ¬∑ + ¬∑ ) ihx ihy using 1;
          ¬∑ unfold sigma_int139; aesop;
          ¬∑ simp +decide [ ‚Üê add_pow_char ];
        ¬∑ rename_i x y hx hy ihx ihy;
          have h_sigma_mul : sigma_int139 (gal_unit139 N hN) (x * y) = sigma_int139 (gal_unit139 N hN) x * sigma_int139 (gal_unit139 N hN) y := by
            exact Subtype.ext <| map_mul _ _ _;
          simp_all +decide [ ‚Üê mul_pow ];
      exact fun x => h_adjoin x <| adjoin_zeta_eq_top139 ‚ñ∏ Algebra.mem_top;
    exact h_phi_psi x

/-
The index function is a homomorphism.
-/
lemma ind_mul'' (x y : ZMod 139) (hx : x ‚â† 0) (hy : y ‚â† 0) : ind'' (x * y) = ind'' x + ind'' y := by
  native_decide +revert

/-
The index of -1 is 0.
-/
lemma ind_neg_one'' : ind'' (-1) = 0 := by
  native_decide +revert

/-
The index of the inverse is the negative of the index.
-/
lemma ind_inv'' (x : ZMod 139) (hx : x ‚â† 0) : ind'' (x‚Åª¬π) = - ind'' x := by
  native_decide +revert

/-
If c'' N = s1'', then sigma_N(alpha'') = gamma''.
-/
lemma sigma_alpha_eq_gamma_if_s1'' (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 139) (h : c'' N = s1'') :
  sigma_int139 (gal_unit139 N hN) Œ±''_int = Œ≥''_int := by
    -- Apply the lemma that connects the index of N to the value of c'' N.
    have h_ind : ind'' (N : ZMod 139) = 1 := by
      exact?;
    -- Apply the permutation action on the integer versions of the Gaussian periods.
    have h_perm : sigma139 (gal_unit139 N hN) (period'' 0) = period'' 1 ‚àß sigma139 (gal_unit139 N hN) (period'' 1) = period'' 2 ‚àß sigma139 (gal_unit139 N hN) (period'' 2) = period'' 0 := by
      have h_perm : ‚àÄ i : ZMod 3, sigma139 (gal_unit139 N hN) (period'' i) = period'' (i + ind'' (N : ZMod 139)) := by
        intro i
        have h_sigma_period : ‚àÄ x ‚àà C_coset'' i, sigma139 (gal_unit139 N hN) (Œ∂139 ^ (x.val : ‚Ñï)) = Œ∂139 ^ ((x * N : ZMod 139).val : ‚Ñï) := by
          have h_sigma_period : sigma139 (gal_unit139 N hN) Œ∂139 = Œ∂139 ^ N := by
            convert sigma_zeta139 hN using 1;
            constructor <;> intro h <;> simp_all +decide [ sigma_int139 ];
            ¬∑ exact Subtype.ext <| by simpa [ ‚Üê map_pow ] using h;
            ¬∑ convert congr_arg Subtype.val h using 1;
          simp_all +decide [ pow_mul', mul_comm ];
          intro x hx; rw [ ‚Üê pow_mul, mul_comm ] ;
          erw [ ‚Üê Nat.mod_add_div ( x.val * N ) 139, pow_add, pow_mul ];
          have h_zeta_139_pow : Œ∂139 ^ 139 = 1 := by
            exact IsCyclotomicExtension.zeta_pow ( 139 : ‚Ñï ) ‚Ñö L139;
          simp_all +decide [ ZMod.val_mul ];
        have h_sigma_period_sum : ‚àë x ‚àà C_coset'' i, (sigma139 (gal_unit139 N hN)) (Œ∂139 ^ (x.val : ‚Ñï)) = ‚àë x ‚àà C_coset'' (i + ind'' (N : ZMod 139)), Œ∂139 ^ (x.val : ‚Ñï) := by
          apply Finset.sum_bij (fun x hx => (x * N : ZMod 139));
          ¬∑ intro x hx
            have h_ind : ind'' (x * N : ZMod 139) = ind'' x + ind'' (N : ZMod 139) := by
              apply ind_mul'';
              ¬∑ exact Finset.mem_filter.mp hx |>.2.1;
              ¬∑ rw [ Ne.eq_def, ZMod.natCast_eq_zero_iff ] ; exact fun h => hN <| by have := Nat.dvd_of_mod_eq_zero ( Nat.mod_eq_zero_of_dvd h ) ; rw [ Nat.dvd_prime Fact.out ] at this ; aesop;
            generalize_proofs at *;
            simp_all +decide [ C_coset'' ];
            exact?;
          ¬∑ intro a‚ÇÅ ha‚ÇÅ a‚ÇÇ ha‚ÇÇ h_eq
            have h_inv : (N : ZMod 139) ‚â† 0 := by
              exact?
            have h_inv_mul : (a‚ÇÅ : ZMod 139) = (a‚ÇÇ : ZMod 139) := by
              haveI := Fact.mk ( by decide : Nat.Prime 139 ) ; exact mul_right_cancel‚ÇÄ h_inv h_eq;
            exact h_inv_mul;
          ¬∑ intro b hb
            use b * (N : ZMod 139)‚Åª¬π;
            have h_inv : (N : ZMod 139) ‚â† 0 := by
              intro h; simp_all +decide [ C_coset'' ] ;
              exact absurd h_ind ( by native_decide );
            have h_inv : ind'' (b * (N : ZMod 139)‚Åª¬π) = ind'' b - ind'' (N : ZMod 139) := by
              have h_inv : ind'' (b * (N : ZMod 139)‚Åª¬π) = ind'' b + ind'' ((N : ZMod 139)‚Åª¬π) := by
                apply ind_mul'';
                ¬∑ exact Finset.mem_filter.mp hb |>.2.1;
                ¬∑ aesop;
              have h_inv : ind'' ((N : ZMod 139)‚Åª¬π) = -ind'' (N : ZMod 139) := by
                exact?;
              rw [ ‚Äπind'' ( b * ( N : ZMod 139 ) ‚Åª¬π ) = ind'' b + ind'' ( N : ZMod 139 ) ‚Åª¬π‚Ä∫, h_inv, sub_eq_add_neg ];
            unfold C_coset'' at *; aesop;
          ¬∑ assumption;
        convert h_sigma_period_sum using 1;
        ¬∑ rw [ period_eq_sum_C_coset'' ];
          rw [ map_sum ];
        ¬∑ exact?;
      grind;
    convert congr_arg ( fun x : L139 => - ( x - period'' 2 ) ) ( h_perm.2.2 ) using 1;
    constructor <;> intro h <;> simp_all +decide [ ‚Üê coe_period_int139 ];
    unfold sigma_int139 Œ±''_int Œ≥''_int; aesop;

/-
If c'' N = s2'', then sigma_N(alpha'') = beta''.
-/
lemma sigma_alpha_eq_beta_if_s2'' (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 139) (h : c'' N = s2'') :
  sigma_int139 (gal_unit139 N hN) Œ±''_int = Œ≤''_int := by
    -- Since these two expressions are equal, we can equate them and solve for `sigma_int139`.
    have h_eq : sigma_int139 (gal_unit139 N hN) (-(period_int139 1 - period_int139 2)) = -(period_int139 0 - period_int139 1) := by
      have h_period_shift : sigma139 (gal_unit139 N hN) (period'' 1) = period'' 0 ‚àß sigma139 (gal_unit139 N hN) (period'' 2) = period'' 1 := by
        have h_sigma_period : ‚àÄ i : ZMod 3, sigma139 (gal_unit139 N hN) (period'' i) = period'' (i + ind'' (N : ZMod 139)) := by
          have h_sigma_period : ‚àÄ i : ZMod 3, sigma139 (gal_unit139 N hN) (period'' i) = ‚àë x ‚àà C_coset'' i, Œ∂139 ^ ((N * x).val : ‚Ñï) := by
            intro i
            have h_sigma_period : sigma139 (gal_unit139 N hN) (period'' i) = ‚àë x ‚àà C_coset'' i, sigma139 (gal_unit139 N hN) (Œ∂139 ^ (x.val : ‚Ñï)) := by
              rw [ period_eq_sum_C_coset'' ];
              exact map_sum _ _ _
            generalize_proofs at *; (
            have h_sigma_zeta : ‚àÄ x : ZMod 139, sigma139 (gal_unit139 N hN) (Œ∂139 ^ (x.val : ‚Ñï)) = Œ∂139 ^ ((N * x).val : ‚Ñï) := by
              intro x
              have h_sigma_zeta : sigma139 (gal_unit139 N hN) Œ∂139 = Œ∂139 ^ N := by
                convert sigma_zeta139 hN using 1
                generalize_proofs at *; (
                erw [ Subtype.mk_eq_mk ] ; aesop;)
              generalize_proofs at *; (
              simp +decide [ h_sigma_zeta, pow_mul ];
              rw [ ‚Üê pow_mul, ZMod.val_mul ];
              have h_order : Œ∂139 ^ 139 = 1 := by
                exact IsCyclotomicExtension.zeta_pow _ _ _
              generalize_proofs at *; (
              rw [ ‚Üê Nat.mod_add_div ( N * x.val ) 139, pow_add, pow_mul ] ; aesop))
            generalize_proofs at *; (
            exact h_sigma_period.trans ( Finset.sum_congr rfl fun x hx => h_sigma_zeta x )));
          -- By definition of $C_coset''$, we know that $N * x$ is in $C_coset'' (i + ind'' N)$ for $x$ in $C_coset'' i$.
          have h_coset_shift : ‚àÄ i : ZMod 3, ‚àÄ x ‚àà C_coset'' i, (N * x : ZMod 139) ‚àà C_coset'' (i + ind'' (N : ZMod 139)) := by
            intros i x hx
            have h_ind : ind'' (N * x) = ind'' N + ind'' x := by
              apply ind_mul'';
              ¬∑ intro h; have := Fact.out ( p := Nat.Prime N ) ; simp_all +decide [ ZMod.natCast_eq_zero_iff ] ;
                rw [ this.dvd_iff_eq ] at h <;> aesop_cat;
              ¬∑ exact Finset.mem_filter.mp hx |>.2.1;
            simp_all +decide [ add_comm, C_coset'' ];
            intro h; have := Fact.out ( p := Nat.Prime N ) ; simp_all +decide [ ZMod.natCast_eq_zero_iff ] ;
            rw [ this.dvd_iff_eq ] at h <;> aesop_cat;
          intro i
          rw [h_sigma_period i];
          have h_coset_shift : Finset.image (fun x : ZMod 139 => (N * x : ZMod 139)) (C_coset'' i) = C_coset'' (i + ind'' (N : ZMod 139)) := by
            refine' Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr fun x hx => h_coset_shift i x hx ) _;
            rw [ Finset.card_image_of_injective _ fun x y hxy => _ ];
            ¬∑ have h_coset_card : ‚àÄ i : ZMod 3, (C_coset'' i).card = 46 := by
                native_decide +revert;
              rw [ h_coset_card, h_coset_card ];
            ¬∑ intro x y hxy; haveI := Fact.mk ( show Nat.Prime 139 by norm_num ) ; exact mul_left_cancel‚ÇÄ ( show ( N : ZMod 139 ) ‚â† 0 from by erw [ Ne.eq_def, ZMod.natCast_eq_zero_iff ] ; exact fun h => hN <| by have := Nat.dvd_of_mod_eq_zero ( Nat.mod_eq_zero_of_dvd h ) ; rw [ Nat.dvd_prime Fact.out ] at this ; aesop ) hxy;
          have h_coset_shift : ‚àë x ‚àà C_coset'' i, Œ∂139 ^ ((N * x).val : ‚Ñï) = ‚àë x ‚àà Finset.image (fun x : ZMod 139 => (N * x : ZMod 139)) (C_coset'' i), Œ∂139 ^ (x.val : ‚Ñï) := by
            rw [ Finset.sum_image ];
            intros x hx y hy hxy;
            have h_inv : (N : ZMod 139) ‚â† 0 := by
              intro h; simp_all +decide [ ZMod.natCast_eq_zero_iff ] ;
              exact hN ( by rw [ Nat.dvd_prime Fact.out ] at h; aesop );
            grind;
          rw [h_coset_shift, ‚ÄπFinset.image (fun x : ZMod 139 => ‚ÜëN * x) (C_coset'' i) = C_coset'' (i + ind'' ‚ÜëN)‚Ä∫];
          exact?;
        have h_ind : ind'' (N : ZMod 139) = 2 := by
          apply (ind_N_eq_2_iff_c_eq_s2'' N hN).mpr h;
        grind;
      erw [ Subtype.mk_eq_mk ];
      convert congr_arg ( fun x : L139 => - ( x - period'' 1 ) ) h_period_shift.1 using 1 ; norm_num [ coe_period_int139 ];
      ¬∑ exact h_period_shift.2;
      ¬∑ erw [ Subtype.coe_mk ] ; norm_num [ coe_period_int139 ];
        exact congr_arg‚ÇÇ _ ( coe_period_int139 1 ) ( coe_period_int139 0 );
    convert h_eq using 1

/-
Final result for q=139: Frobenius action on alpha depends on c'' N.
-/
theorem final_result_139 {N : ‚Ñï} [Fact (Nat.Prime N)] (hN : N ‚â† 139) (P : Ideal ùìûL139) [P.IsMaximal] [CharP (kP139 P) N] :
  (c'' N = s1'' ‚Üí (red139 P Œ±''_int) ^ N = red139 P Œ≥''_int) ‚àß
  (c'' N = s2'' ‚Üí (red139 P Œ±''_int) ^ N = red139 P Œ≤''_int) := by
    apply And.intro;
    ¬∑ intro hc
      have h_sigma : sigma_int139 (gal_unit139 N hN) Œ±''_int = Œ≥''_int := by
        exact?
      have h_red : (red139 P Œ±''_int) ^ N = red139 P (sigma_int139 (gal_unit139 N hN) Œ±''_int) := by
        convert artin_property139' hN P Œ±''_int |> Eq.symm using 1
      rw [h_red, h_sigma];
    ¬∑ intro h;
      rw [ ‚Üê artin_property139' ];
      convert congr_arg _ ( sigma_alpha_eq_beta_if_s2'' N hN h ) using 1
