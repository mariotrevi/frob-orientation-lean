/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 49ab742d-7e60-49a0-9635-aa76ebf271b7

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Proof of the Dream Theorem for q = 1063.

We define the cyclotomic field K = Q(zeta_1063), the ring of integers Ok, and the Gaussian periods.
We identify a generator g = 6 such that the cubic character c(g) = s2 = 719.
We define the roots alpha, beta, gamma using this generator and the standard sign convention.
We prove the Artin property for the extension.
We prove the global permutation of roots under the Galois group.
Finally, we prove the Dream Theorem:
If c(N) = s1, then alpha^N = gamma mod P.
If c(N) = s2, then alpha^N = beta mod P.
This relies on the period equation alpha^3 = 1063*alpha + 1063, which is added as a hypothesis.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f1e85200-2efb-4b56-a019-1c5b75f4b05f

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Proof of the Dream Theorem for q = 937.

We define the cyclotomic field K = Q(zeta_937), its ring of integers Ok, and the Gaussian periods.
We identify a generator g = 7 for which the cubic character values match the s1/s2 definitions.
We prove the Artin property for the extension K/Q.
We prove the main theorem `dream_theorem_937` which states that for a prime N != 937:
- If c(N) = s1, then alpha^N = gamma mod P.
- If c(N) = s2, then alpha^N = beta mod P.
This assumes the period equation `alpha^3 = 937*alpha + 937`.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: b08f138a-15ed-40a2-a0c0-b8f4ce6443e1

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We define the cyclotomic field K for q = 877 and the Gaussian periods. We prove the Dream Theorem for q = 877, which states that the Frobenius automorphism maps the period difference α to β or γ depending on the cubic character of the prime N modulo 877. The proof relies on the Artin property of the Frobenius map and the explicit calculation of the Galois action on the periods.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f1f9f2e4-1b7a-4d8c-ad24-d62d489ea7c9

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: a7add749-96ca-48e2-a89d-fbb216918bc3

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 22a1ac83-9054-4f97-9a50-f0ea72bded01

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: e6ee589a-f550-42ef-89e5-1fd2afd7fa5e

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We defined the constants s1, s2, and the value c(N). We proved lemmas characterizing the cosets C1 and C2 in terms of the 12th power residue symbol (which relates to c(N)). Finally, we proved the main theorem `final_result` which establishes the Frobenius action on alpha (i.e., alpha^N) in terms of beta and gamma, depending on the value of c(N). The proof utilizes the `explicit_frobenius` theorem and the algebraic relations between alpha, beta, and gamma.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 939f55fb-68a7-4ef0-bca3-475f675055ca

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
This module formalizes the proof of the Frobenius Orientation conjecture for q=37.
It defines the cyclotomic field K = Q(zeta_37), the Gaussian periods, and the cubic roots.
It proves the cyclic algebraic relations between these roots and establishes the global Galois action.
It descends to the residue field modulo a prime P lying over N != 37, proving the Artin property.
Finally, it derives the explicit Frobenius action on the reduction of alpha modulo P.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section






















/-
Definitions for q=1063: Field K, zeta, generator g=3 (checked), cosets H, C1, C2, periods eta0, eta1, eta2, differences alpha', beta', gamma', and constants s1, s2, c(N).
-/
abbrev K1063 := CyclotomicField 1063 ℚ

noncomputable def zeta1063 : K1063 := IsCyclotomicExtension.zeta 1063 ℚ K1063

def check_prim_1063 (n : ℕ) : Bool :=
  let p := 1063
  let order := p - 1
  let factors := [2, 3, 59]
  factors.all fun f => (n ^ (order / f)) % p != 1

#eval check_prim_1063 2
#eval check_prim_1063 3
#eval check_prim_1063 5

def g1063 : ZMod 1063 := 3

def H1063 : Finset (ZMod 1063) := ((Finset.univ : Finset (ZMod 1063)).filter (fun x => x ≠ 0)).image (fun x => x^3)

def C1_1063 : Finset (ZMod 1063) := H1063.image (fun x => g1063 * x)

def C2_1063 : Finset (ZMod 1063) := H1063.image (fun x => g1063^2 * x)

noncomputable def eta1063 (S : Finset (ZMod 1063)) : K1063 := ∑ x ∈ S, zeta1063^(x.val)

noncomputable def eta0_1063 := eta1063 H1063
noncomputable def eta1_1063 := eta1063 C1_1063
noncomputable def eta2_1063 := eta1063 C2_1063

noncomputable def alpha_prime_1063 := eta0_1063 - eta1_1063
noncomputable def beta_prime_1063 := eta1_1063 - eta2_1063
noncomputable def gamma_prime_1063 := eta2_1063 - eta0_1063

def s1_1063 : ZMod 1063 := 343
def s2_1063 : ZMod 1063 := 719
def c1063 (N : ℕ) : ZMod 1063 := (N : ZMod 1063)^354

/-
Define Ok1063 and state irreducibility of cyclotomic polynomial.
-/
abbrev Ok1063 := NumberField.RingOfIntegers K1063

theorem h_irr_1063 : Irreducible (Polynomial.cyclotomic 1063 ℚ) := by
  exact Polynomial.cyclotomic.irreducible_rat ( by norm_num )

/-
Define the Galois automorphism sigma1063.
-/
noncomputable def sigma1063 (n : (ZMod 1063)ˣ) : K1063 ≃ₐ[ℚ] K1063 :=
  (IsCyclotomicExtension.autEquivPow K1063 h_irr_1063).symm n

/-
Prove that zeta1063 is an algebraic integer.
-/
theorem zeta_isIntegral_1063 : IsIntegral ℤ zeta1063 := by
  refine' ⟨ Polynomial.X ^ 1063 - 1, _, _ ⟩;
  · erw [ Polynomial.Monic, Polynomial.leadingCoeff_X_pow_sub_C ] ; norm_num;
  · simp +decide [ zeta1063 ];
    rw [ sub_eq_zero, IsCyclotomicExtension.zeta_pow ]

/-
Define integral zeta, sigma, periods, and period differences.
-/
def zeta_int1063 : Ok1063 := ⟨zeta1063, zeta_isIntegral_1063⟩

noncomputable def sigma_int1063 (n : (ZMod 1063)ˣ) : Ok1063 ≃ₐ[ℤ] Ok1063 :=
  (NumberField.RingOfIntegers.mapAlgEquiv (sigma1063 n)).restrictScalars ℤ

noncomputable def eta_int1063 (S : Finset (ZMod 1063)) : Ok1063 := ∑ x ∈ S, zeta_int1063^(x.val)

noncomputable def eta0_int1063 := eta_int1063 H1063
noncomputable def eta1_int1063 := eta_int1063 C1_1063
noncomputable def eta2_int1063 := eta_int1063 C2_1063

noncomputable def alpha_prime_int1063 := eta0_int1063 - eta1_int1063
noncomputable def beta_prime_int1063 := eta1_int1063 - eta2_int1063
noncomputable def gamma_prime_int1063 := eta2_int1063 - eta0_int1063

/-
Define sign-corrected roots alpha, beta, gamma for q=1063.
-/
noncomputable def sign_1063 : ℤ :=
  if alpha_prime_int1063 * beta_prime_int1063 * gamma_prime_int1063 = (1063 : Ok1063) then 1 else -1

noncomputable def alpha_int1063 := (sign_1063 : Ok1063) * alpha_prime_int1063
noncomputable def beta_int1063 := (sign_1063 : Ok1063) * beta_prime_int1063
noncomputable def gamma_int1063 := (sign_1063 : Ok1063) * gamma_prime_int1063

noncomputable def alpha1063_field : K1063 := alpha_int1063
noncomputable def beta1063_field : K1063 := beta_int1063
noncomputable def gamma1063_field : K1063 := gamma_int1063

/-
Compute the coefficients for the algebraic relations of beta and gamma in terms of alpha for q=1063.
-/
def find_coeffs_1063 : IO Unit := do
  let q := 1063
  let a := 65
  -- Find p = k*q + 1
  let mut p := 0
  for k in [2:200] do
    let cand := k * q + 1
    if Nat.Prime cand then
      p := cand
      break
  
  if p == 0 then
    IO.println "No prime found"
    return

  IO.println s!"Using prime p = {p}"

  -- Find element of order q
  let mut g_p := 0
  for g in [2:p] do
    let zeta := (g : Nat) ^ ((p - 1) / q) % p
    if zeta != 1 then
      g_p := g
      break
  
  let zeta := (g_p : Nat) ^ ((p - 1) / q) % p
  IO.println s!"zeta = {zeta}"

  -- Cosets of cubic residues mod q
  -- g_q = 3
  let g_q := 3
  let mut H : List Nat := []
  let mut x := 1
  let g_q_3 := (g_q * g_q * g_q) % q
  for _ in [0:(q-1)/3] do
    H := x :: H
    x := (x * g_q_3) % q
  
  let C1 := H.map (fun h => (h * g_q) % q)
  let C2 := H.map (fun h => (h * g_q * g_q) % q)

  -- Periods mod p
  let sum_zeta (S : List Nat) : Nat :=
    S.foldl (fun acc h => (acc + (zeta ^ h) % p) % p) 0
  
  let eta0 := sum_zeta H
  let eta1 := sum_zeta C1
  let eta2 := sum_zeta C2

  -- Differences
  let alpha_prime := (eta0 + p - eta1) % p
  let beta_prime := (eta1 + p - eta2) % p
  let gamma_prime := (eta2 + p - eta0) % p

  -- Check sign convention
  let prod := (alpha_prime * beta_prime) % p * gamma_prime % p
  let q_mod_p := q % p
  
  let mut alpha := 0
  let mut beta := 0
  let mut gamma := 0

  if prod == q_mod_p then
    alpha := alpha_prime
    beta := beta_prime
    gamma := gamma_prime
    IO.println "Sign convention: positive"
  else
    alpha := (p - alpha_prime) % p
    beta := (p - beta_prime) % p
    gamma := (p - gamma_prime) % p
    IO.println "Sign convention: negative"

  -- Solve 65 * beta = c0 + c1 * alpha + c2 * alpha^2 mod p
  let sub (x y : Nat) := (x + p - y) % p
  let mul (x y : Nat) := (x * y) % p
  let add (x y : Nat) := (x + y) % p
  let pow (x n : Nat) := x ^ n % p
  let inv (x : Nat) := x ^ (p - 2) % p

  let det := mul (sub beta alpha) (mul (sub gamma alpha) (sub gamma beta))
  let det_inv := inv det

  let rhs0 := mul 65 beta
  let rhs1 := mul 65 gamma
  let rhs2 := mul 65 alpha

  -- Solve for c0, c1, c2
  -- c0
  let term0 := mul rhs0 (sub (mul beta (mul gamma gamma)) (mul gamma (mul beta beta)))
  let term1 := mul rhs1 (sub (mul gamma (mul alpha alpha)) (mul alpha (mul gamma gamma)))
  let term2 := mul rhs2 (sub (mul alpha (mul beta beta)) (mul beta (mul alpha alpha)))
  let c0 := mul (add term0 (add term1 term2)) det_inv

  -- c1
  let term0_1 := mul 1 (sub (mul rhs1 (mul gamma gamma)) (mul rhs2 (mul beta beta)))
  let term1_1 := mul 1 (sub (mul rhs2 (mul alpha alpha)) (mul rhs0 (mul gamma gamma)))
  let term2_1 := mul 1 (sub (mul rhs0 (mul beta beta)) (mul rhs1 (mul alpha alpha)))
  let c1 := mul (add term0_1 (add term1_1 term2_1)) det_inv

  -- c2
  let term0_2 := mul 1 (sub (mul beta rhs2) (mul gamma rhs1))
  let term1_2 := mul 1 (sub (mul gamma rhs0) (mul alpha rhs2))
  let term2_2 := mul 1 (sub (mul alpha rhs1) (mul beta rhs0))
  let c2 := mul (add term0_2 (add term1_2 term2_2)) det_inv

  let to_signed (x : Nat) : Int :=
    if x > p / 2 then (x : Int) - p else x

  IO.println s!"Coefficients for beta: c0={to_signed c0}, c1={to_signed c1}, c2={to_signed c2}"
  
  -- Also for gamma
  let rhs0_g := mul 65 gamma
  let rhs1_g := mul 65 alpha
  let rhs2_g := mul 65 beta

  let term0_g := mul rhs0_g (sub (mul beta (mul gamma gamma)) (mul gamma (mul beta beta)))
  let term1_g := mul rhs1_g (sub (mul gamma (mul alpha alpha)) (mul alpha (mul gamma gamma)))
  let term2_g := mul rhs2_g (sub (mul alpha (mul beta beta)) (mul beta (mul alpha alpha)))
  let d0 := mul (add term0_g (add term1_g term2_g)) det_inv

  let term0_1g := mul 1 (sub (mul rhs1_g (mul gamma gamma)) (mul rhs2_g (mul beta beta)))
  let term1_1g := mul 1 (sub (mul rhs2_g (mul alpha alpha)) (mul rhs0_g (mul gamma gamma)))
  let term2_1g := mul 1 (sub (mul rhs0_g (mul beta beta)) (mul rhs1_g (mul alpha alpha)))
  let d1 := mul (add term0_1g (add term1_1g term2_1g)) det_inv

  let term0_2g := mul 1 (sub (mul beta rhs2_g) (mul gamma rhs1_g))
  let term1_2g := mul 1 (sub (mul gamma rhs0_g) (mul alpha rhs2_g))
  let term2_2g := mul 1 (sub (mul alpha rhs1_g) (mul beta rhs0_g))
  let d2 := mul (add term0_2g (add term1_2g term2_2g)) det_inv

  IO.println s!"Coefficients for gamma: d0={to_signed d0}, d1={to_signed d1}, d2={to_signed d2}"

#eval find_coeffs_1063

/-
Define the assumptions for the Dream Theorem for q=1063: period equation, product of roots, and algebraic relations.
-/
def DreamAssumptions_1063 : Prop :=
  alpha_int1063^3 = 1063 * alpha_int1063 + 1063 ∧
  alpha_int1063 * beta_int1063 * gamma_int1063 = 1063 ∧
  65 * beta_int1063 = 2126 - 28 * alpha_int1063 - 3 * alpha_int1063^2 ∧
  65 * gamma_int1063 = -2126 - 37 * alpha_int1063 + 3 * alpha_int1063^2

/-
Define N as a unit mod 1063 and prove sigma maps zeta to zeta^n.
-/
def N_mod_1063 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 1063) : (ZMod 1063)ˣ :=
  ZMod.unitOfCoprime N (Nat.Coprime.symm ((Nat.coprime_primes (by norm_num) (Fact.out)).mpr hN.symm))

lemma sigma_int_zeta_pow_1063 (n : (ZMod 1063)ˣ) :
  sigma_int1063 n zeta_int1063 = zeta_int1063 ^ (n : ZMod 1063).val := by
    have h_sigma_zeta : ∀ (n : (ZMod 1063)ˣ), (sigma1063 n) zeta1063 = zeta1063 ^ (n : ZMod 1063).val := by
      intro n
      unfold sigma1063
      simp [mul_comm, mul_assoc, pow_succ'];
      erw [ PowerBasis.equivOfMinpoly_gen ];
      exact?;
    unfold sigma_int1063; aesop;

/-
Prove the Artin property for zeta: sigma_N(zeta) = zeta^N mod P.
-/
theorem artin_property_zeta_1063 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 1063) (P : Ideal Ok1063) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  Ideal.Quotient.mk P (sigma_int1063 (N_mod_1063 N hN) zeta_int1063) = (Ideal.Quotient.mk P zeta_int1063)^N := by
    have h_char : (Ideal.Quotient.mk P) zeta_int1063 ^ 1063 = 1 := by
      have h_zeta_pow : zeta_int1063 ^ 1063 = 1 := by
        have h_zeta_pow : (zeta1063 : K1063) ^ 1063 = 1 := by
          exact IsPrimitiveRoot.pow_eq_one ( show IsPrimitiveRoot zeta1063 1063 from by exact ( IsCyclotomicExtension.zeta_spec 1063 ℚ K1063 ) );
        exact Subtype.ext h_zeta_pow
      convert congr_arg ( Ideal.Quotient.mk P ) h_zeta_pow using 1;
    have h_sigma_pow : ∀ (n : (ZMod 1063)ˣ), (Ideal.Quotient.mk P) (sigma_int1063 n zeta_int1063) = (Ideal.Quotient.mk P) (zeta_int1063 ^ (n : ZMod 1063).val) := by
      exact fun n => congr_arg _ ( sigma_int_zeta_pow_1063 n );
    convert h_sigma_pow ( N_mod_1063 N hN ) using 1;
    have h_exp : (Ideal.Quotient.mk P) zeta_int1063 ^ N = (Ideal.Quotient.mk P) zeta_int1063 ^ (N % 1063) := by
      rw [ ← Nat.mod_add_div N 1063, pow_add, pow_mul ] ; aesop;
    convert h_exp using 1

/-
Prove that the ring of integers Ok1063 is generated by zeta_int1063.
-/
theorem Ok1063_eq_adjoin : (⊤ : Subalgebra ℤ Ok1063) = Algebra.adjoin ℤ {zeta_int1063} := by
  have h_gen : IsIntegralClosure (Algebra.adjoin ℤ {zeta1063}) ℤ K1063 := by
    have h_integral_closure : IsIntegralClosure (Algebra.adjoin ℤ {zeta1063}) ℤ K1063 := by
      have h_cyclotomic : IsCyclotomicExtension {1063} ℚ K1063 := by
        exact?
      have h_irreducible : Irreducible (Polynomial.cyclotomic 1063 ℚ) := by
        exact Polynomial.cyclotomic.irreducible_rat <| by norm_num;
      apply_rules [ IsCyclotomicExtension.Rat.isIntegralClosure_adjoin_singleton_of_prime ];
      · convert IsCyclotomicExtension.zeta_spec 1063 ℚ K1063 using 1;
      · exact ⟨ by norm_num ⟩;
    exact h_integral_closure;
  have h_gen : IsIntegralClosure (Algebra.adjoin ℤ {zeta_int1063}) ℤ K1063 := by
    refine' ⟨ _, _, _ ⟩;
    · exact?;
    · intro hx
      obtain ⟨y, hy⟩ := h_gen.isIntegral_iff.mp hx;
      -- Since $y$ is in the adjoin of $\mathbb{Z}$ and $\zeta_{1063}$, we can write it as a polynomial in $\zeta_{1063}$ with integer coefficients.
      obtain ⟨p, hp⟩ : ∃ p : Polynomial ℤ, y = Polynomial.aeval (R := ℤ) zeta1063 p := by
        have h_poly : ∀ y ∈ Algebra.adjoin ℤ {zeta1063}, ∃ p : Polynomial ℤ, y = Polynomial.aeval (R := ℤ) zeta1063 p := by
          intro y hy;
          rw [ Algebra.adjoin_singleton_eq_range_aeval ] at hy; aesop;
        exact h_poly _ y.2;
      use ⟨Polynomial.aeval (R := ℤ) zeta_int1063 p, by
        exact?⟩
      generalize_proofs at *;
      convert hp using 1;
      · convert hp.symm using 1;
        simp +decide [ Polynomial.aeval_def, Polynomial.eval₂_eq_sum_range ];
        congr! 2;
      · exact hy ▸ hp ▸ rfl;
    · rintro ⟨ y, rfl ⟩;
      obtain ⟨ p, hp ⟩ := y;
      rw [ Algebra.adjoin_singleton_eq_range_aeval ] at hp;
      obtain ⟨ q, rfl ⟩ := hp;
      simp +decide [ Polynomial.aeval_def ];
      rw [ Polynomial.eval₂_eq_sum_range ];
      refine' IsIntegral.sum _ fun i hi => _;
      refine' IsIntegral.mul _ _;
      · exact isIntegral_algebraMap;
      · exact IsIntegral.pow ( by exact? ) _;
  have h_gen : ∀ x : Ok1063, x.val ∈ Algebra.adjoin ℤ {zeta1063} := by
    intro x
    have h_int : IsIntegral ℤ x.val := by
      exact x.2;
    rename_i h;
    have := h.isIntegral_iff.mp h_int;
    exact this.elim fun y hy => hy ▸ Subtype.mem y;
  ext x;
  constructor <;> intro hx <;> simp_all +decide [ Algebra.adjoin_singleton_eq_range_aeval ];
  obtain ⟨ p, hp ⟩ := h_gen x;
  use p;
  erw [ Polynomial.aeval_def, Polynomial.eval₂_eq_sum_range ] at * ; aesop

/-
Prove that the subalgebra generated by zeta1063 is equal to the ring of integers.
-/
lemma adjoin_zeta_eq_ringOfIntegers : Algebra.adjoin ℤ {zeta1063} = NumberField.RingOfIntegers K1063 := by
  -- Since $K$ is a cyclotomic field, its ring of integers is given by $O_K = \mathbb{Z}[\zeta]$.
  have h_cyclotomic : IsCyclotomicExtension {1063} ℚ K1063 := by
    infer_instance;
  apply_rules [ IsCyclotomicExtension.Rat.isIntegralClosure_adjoin_singleton_of_prime ];
  ext x;
  constructor <;> intro hx;
  · refine' Algebra.adjoin_induction _ _ _ _ hx;
    · exact fun x hx => by rw [ Set.mem_singleton_iff.mp hx ] ; exact zeta_isIntegral_1063;
    · exact fun r => ⟨ Polynomial.X - Polynomial.C r, Polynomial.monic_X_sub_C r, by simp +decide ⟩;
    · exact fun x y hx hy hx' hy' => hx'.add hy';
    · exact fun x y hx hy hx' hy' => hx'.mul hy';
  · have h_integral_closure : IsIntegralClosure (Algebra.adjoin ℤ {zeta1063}) ℤ K1063 := by
      apply_rules [ IsCyclotomicExtension.Rat.isIntegralClosure_adjoin_singleton_of_prime ];
      · convert h_cyclotomic.zeta_spec using 1;
      · exact ⟨ by norm_num ⟩;
    have := h_integral_closure.isIntegral_iff.mp hx;
    aesop

/-
Prove that Ok1063 is generated by zeta_int1063 (renamed to avoid conflict).
-/
theorem Ok1063_eq_adjoin_2 : (⊤ : Subalgebra ℤ Ok1063) = Algebra.adjoin ℤ {zeta_int1063} := by
  exact?

/-
Prove that the characteristic of Ok1063/P is N.
-/
lemma char_Ok1063_quot_P (N : ℕ) [Fact (Nat.Prime N)] (P : Ideal Ok1063) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  CharP (Ok1063 ⧸ P) N := by
    -- Since P lies over the ideal spanned by N in ℤ, N is in P.
    have hN_in_P : (N : Ok1063) ∈ P := by
      have := hP.1;
      exact Ideal.mem_comap.mp ( this ▸ Ideal.mem_span_singleton_self _ );
    refine' ⟨ fun n => _ ⟩;
    constructor <;> intro hn <;> simp_all +decide [ ← ZMod.natCast_eq_zero_iff ];
    · simp_all +decide [ ZMod.natCast_eq_zero_iff ];
      erw [ Ideal.Quotient.eq_zero_iff_mem ] at hn;
      have := hP.1;
      replace this := SetLike.ext_iff.mp this ( n : ℤ ) ; simp_all +decide [ Ideal.mem_span_singleton ] ;
      exact?;
    · erw [ Ideal.Quotient.eq_zero_iff_mem ] at *;
      rw [ ZMod.natCast_eq_zero_iff ] at hn;
      obtain ⟨ k, rfl ⟩ := hn; simpa using P.mul_mem_right _ hN_in_P;

/-
Prove the Frobenius addition property in Ok1063/P.
-/
lemma frobenius_add_1063 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 1063) (P : Ideal Ok1063) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) (x y : Ok1063 ⧸ P) :
  (x + y)^N = x^N + y^N := by
    have h_char : CharP (Ok1063 ⧸ P) N := by
      exact?;
    exact?

/-
Prove that the Frobenius map fixes integers modulo P.
-/
lemma frobenius_int_1063 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 1063) (P : Ideal Ok1063) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) (n : ℤ) :
  (Ideal.Quotient.mk P (n : Ok1063))^N = Ideal.Quotient.mk P (n : Ok1063) := by
    -- By definition of $P$, we know that $P.LiesOver (Ideal.span {(N : ℤ)})$.
    have h_over : Ideal.span {(N : ℤ)} ≤ P.comap (algebraMap ℤ Ok1063) := by
      exact hP.1.le;
    -- Since $P.LiesOver (Ideal.span {(N : ℤ)})$, we have that $n^N - n \in P$ for any integer $n$.
    have h_n_pow : (n : Ok1063)^N - n ∈ P := by
      have h_n_pow : (n : ℤ)^N - n ∈ Ideal.span {(N : ℤ)} := by
        exact Ideal.mem_span_singleton.mpr ( by haveI := Fact.mk ( Fact.out : Nat.Prime N ) ; simp [ ← ZMod.intCast_zmod_eq_zero_iff_dvd ] );
      simpa using h_over h_n_pow;
    exact Ideal.Quotient.eq.2 ( by simpa using h_n_pow )

/-
Prove the Artin property for all elements of Ok1063.
-/
theorem artin_property_1063 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 1063) (P : Ideal Ok1063) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) (x : Ok1063) :
  Ideal.Quotient.mk P (sigma_int1063 (N_mod_1063 N hN) x) = (Ideal.Quotient.mk P x)^N := by
    have := Ok1063_eq_adjoin_2;
    replace this := SetLike.ext_iff.mp this x;
    refine' Algebra.adjoin_induction _ _ _ _ ( this.mp trivial );
    · convert artin_property_zeta_1063 N hN P hP using 1;
      simp +decide [ Ideal.Quotient.eq ];
    · intro r; erw [ Ideal.Quotient.eq ] ; simp +decide [ frobenius_int_1063 ] ;
      -- Since $r$ is an integer, we have $r^N \equiv r \pmod{P}$ by Fermat's Little Theorem.
      have h_fermat : (r : Ok1063) ^ N - r ∈ P := by
        have h_fermat : (r : ℤ) ^ N - r ≡ 0 [ZMOD N] := by
          haveI := Fact.mk ( Fact.out : Nat.Prime N ) ; simp +decide [ ← ZMod.intCast_eq_intCast_iff ] ;
        obtain ⟨ k, hk ⟩ := h_fermat.symm.dvd;
        convert P.mul_mem_right ( k : Ok1063 ) ( hP.1 ▸ Ideal.mem_span_singleton_self ( N : ℤ ) ) using 1 ; norm_cast ; aesop;
      simpa using P.neg_mem h_fermat;
    · intros x y hx hy hx' hy';
      convert congr_arg₂ ( · + · ) hx' hy' using 1 <;> ring;
      · exact congr_arg _ ( map_add _ _ _ );
      · convert frobenius_add_1063 N hN P hP ( Ideal.Quotient.mk P x ) ( Ideal.Quotient.mk P y ) using 1;
    · simp +contextual [ ← mul_pow ]

/-
Prove the Artin property for all elements of Ok1063 (renamed to avoid conflict).
-/
theorem artin_property_1063_proven (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 1063) (P : Ideal Ok1063) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) (x : Ok1063) :
  Ideal.Quotient.mk P (sigma_int1063 (N_mod_1063 N hN) x) = (Ideal.Quotient.mk P x)^N := by
    -- Apply the Artin property with N modulo 1063 if N=1063, otherwise with N itself.
    apply artin_property_1063;
    assumption

/-
Check c(3) and prove sigma permutes periods.
-/
def check_c_val_1063 : IO Unit := do
  let q := 1063
  let c (n : Nat) := (n : Nat) ^ 354 % q
  let s1 := 343
  let s2 := 719
  let cg := c 3
  IO.println s!"c(3) = {cg}"
  if cg == s1 then IO.println "c(3) = s1"
  else if cg == s2 then IO.println "c(3) = s2"
  else IO.println "c(3) is neither"

#eval check_c_val_1063

lemma sigma_eta_1063 (n : (ZMod 1063)ˣ) (S : Finset (ZMod 1063)) :
  sigma_int1063 n (eta_int1063 S) = eta_int1063 (S.image (fun x => (n : ZMod 1063) * x)) := by
    unfold eta_int1063; simp +decide [ Finset.mul_sum _ _ _ ] ;
    refine' Finset.sum_congr rfl fun x hx => _;
    rw [ sigma_int_zeta_pow_1063 ];
    -- Since $zeta_int1063$ is a primitive $1063$rd root of unity, we have $zeta_int1063^{1063} = 1$.
    have h_zeta_1063 : zeta_int1063 ^ 1063 = 1 := by
      have h_zeta_1063 : zeta1063 ^ 1063 = 1 := by
        exact IsPrimitiveRoot.pow_eq_one ( show IsPrimitiveRoot zeta1063 1063 from by exact ( IsCyclotomicExtension.zeta_spec 1063 ℚ K1063 ) );
      exact Subtype.ext h_zeta_1063;
    rw [ ← pow_mul, ZMod.val_mul ];
    rw [ ← Nat.mod_add_div ( ( n : ZMod 1063 ).val * x.val ) 1063, pow_add, pow_mul ] ; aesop

/-
Define chi1063 and prove multiplicativity.
-/
def chi1063 (x : ZMod 1063) : ZMod 1063 := x ^ 354

lemma chi1063_mul (x y : ZMod 1063) : chi1063 (x * y) = chi1063 x * chi1063 y := by
  dsimp [chi1063];
  rw [mul_pow]

/-
Prove that chi1063(g) = s1.
-/
lemma chi1063_g_val : chi1063 g1063 = s1_1063 := by
  native_decide

/-
Prove that multiplication by an element of H permutes the cosets trivially.
-/
lemma action_H_1063 (n : ZMod 1063) (hn : n ∈ H1063) :
  H1063.image (fun x => n * x) = H1063 ∧
  C1_1063.image (fun x => n * x) = C1_1063 ∧
  C2_1063.image (fun x => n * x) = C2_1063 := by
    native_decide +revert

/-
Prove that multiplication by elements of C1 and C2 permutes the cosets cyclically.
-/
lemma action_C1_1063 (n : ZMod 1063) (hn : n ∈ C1_1063) :
  H1063.image (fun x => n * x) = C1_1063 ∧
  C1_1063.image (fun x => n * x) = C2_1063 ∧
  C2_1063.image (fun x => n * x) = H1063 := by
    native_decide +revert

lemma action_C2_1063 (n : ZMod 1063) (hn : n ∈ C2_1063) :
  H1063.image (fun x => n * x) = C2_1063 ∧
  C1_1063.image (fun x => n * x) = H1063 ∧
  C2_1063.image (fun x => n * x) = C1_1063 := by
    native_decide +revert

/-
Find a primitive root g such that c(g) = s2.
-/
def find_correct_g_1063 : IO Unit := do
  let q := 1063
  let s2 := 719
  let c (n : Nat) := (n : Nat) ^ 354 % q
  
  for g in [2:q] do
    -- Check if primitive root
    let mut is_prim := true
    let factors := [2, 3, 59] -- factors of 1062 = 2 * 9 * 59 = 18 * 59 = 1062
    for f in factors do
      if (g : Nat) ^ (1062 / f) % q == 1 then
        is_prim := false
        break
    
    if is_prim then
      if c g == s2 then
        IO.println s!"Found good generator: {g}"
        return
  
  IO.println "No generator found"

#eval find_correct_g_1063

/-
Define the periods and roots using the generator g=6, which aligns with the user's theorem statement.
-/
def g6 : ZMod 1063 := 6

def C1_6 : Finset (ZMod 1063) := H1063.image (fun x => g6 * x)
def C2_6 : Finset (ZMod 1063) := H1063.image (fun x => g6^2 * x)

noncomputable def eta1_int_6 := eta_int1063 C1_6
noncomputable def eta2_int_6 := eta_int1063 C2_6

noncomputable def alpha_prime_int_6 := eta0_int1063 - eta1_int_6
noncomputable def beta_prime_int_6 := eta1_int_6 - eta2_int_6
noncomputable def gamma_prime_int_6 := eta2_int_6 - eta0_int1063

noncomputable def sign_6 : ℤ :=
  if alpha_prime_int_6 * beta_prime_int_6 * gamma_prime_int_6 = (1063 : Ok1063) then 1 else -1

noncomputable def alpha_int_6 := (sign_6 : Ok1063) * alpha_prime_int_6
noncomputable def beta_int_6 := (sign_6 : Ok1063) * beta_prime_int_6
noncomputable def gamma_int_6 := (sign_6 : Ok1063) * gamma_prime_int_6

/-
Prove that the sum of the roots alpha, beta, gamma is 0.
-/
lemma sum_roots_6 : alpha_int_6 + beta_int_6 + gamma_int_6 = 0 := by
  unfold alpha_int_6 beta_int_6 gamma_int_6;
  unfold alpha_prime_int_6 beta_prime_int_6 gamma_prime_int_6;
  ring

/-
Prove action lemmas for the cosets defined by g=6.
-/
lemma sigma_alpha_prime_6 (n : (ZMod 1063)ˣ) :
  ((n : ZMod 1063) ∈ C1_6 → sigma_int1063 n alpha_prime_int_6 = beta_prime_int_6) ∧
  ((n : ZMod 1063) ∈ C2_6 → sigma_int1063 n alpha_prime_int_6 = gamma_prime_int_6) ∧
  ((n : ZMod 1063) ∈ H1063 → sigma_int1063 n alpha_prime_int_6 = alpha_prime_int_6) := by
    -- By definition of $C1_6$ and $C2_6$, we know that multiplying by $n$ (which is a unit) permutes the elements of $H1063$, $C1_6$, and $C2_6$.
    have h_perm : ∀ n : (ZMod 1063)ˣ, (n : ZMod 1063) ∈ H1063 → H1063.image (fun x => (n : ZMod 1063) * x) = H1063 ∧ C1_6.image (fun x => (n : ZMod 1063) * x) = C1_6 ∧ C2_6.image (fun x => (n : ZMod 1063) * x) = C2_6 := by
      native_decide +revert;
    have h_perm_C1 : ∀ n : (ZMod 1063)ˣ, (n : ZMod 1063) ∈ C1_6 → H1063.image (fun x => (n : ZMod 1063) * x) = C1_6 ∧ C1_6.image (fun x => (n : ZMod 1063) * x) = C2_6 ∧ C2_6.image (fun x => (n : ZMod 1063) * x) = H1063 := by
      native_decide +revert;
    have h_perm_C2 : ∀ n : (ZMod 1063)ˣ, (n : ZMod 1063) ∈ C2_6 → H1063.image (fun x => (n : ZMod 1063) * x) = C2_6 ∧ C1_6.image (fun x => (n : ZMod 1063) * x) = H1063 ∧ C2_6.image (fun x => (n : ZMod 1063) * x) = C1_6 := by
      native_decide +revert;
    refine' ⟨ fun hn => _, fun hn => _, fun hn => _ ⟩;
    · unfold alpha_prime_int_6 beta_prime_int_6;
      unfold eta0_int1063 eta1_int_6 eta2_int_6;
      rw [ map_sub, sigma_eta_1063, sigma_eta_1063 ];
      rw [ h_perm_C1 n hn |>.1, h_perm_C1 n hn |>.2.1 ];
    · unfold alpha_prime_int_6 gamma_prime_int_6;
      unfold eta0_int1063 eta1_int_6 eta2_int_6; simp +decide [ sigma_eta_1063, h_perm_C2 n hn ] ;
    · unfold alpha_prime_int_6;
      unfold eta0_int1063 eta1_int_6; simp +decide [ sigma_eta_1063, h_perm n hn ] ;

/-
Check if s2^2 = s1 mod 1063.
-/
def check_s_relation_1063 : IO Unit := do
  let s1 := 343
  let s2 := 719
  let q := 1063
  let s2_sq := s2 * s2 % q
  IO.println s!"s2^2 = {s2_sq}"
  if s2_sq == s1 then IO.println "s2^2 = s1" else IO.println "s2^2 != s1"

#eval check_s_relation_1063

/-
Check if 2 is a cubic residue mod 1063.
-/
def check_g_relation_1063 : IO Unit := do
  let q := 1063
  let c (n : Nat) := (n : Nat) ^ 354 % q
  let c2 := c 2
  IO.println s!"c(2) = {c2}"
  if c2 == 1 then IO.println "2 is a cubic residue (g=6 and g=3 give same cosets)"
  else IO.println "2 is not a cubic residue"

#eval check_g_relation_1063

/-
Prove the global permutation of the sign-corrected roots for g=6.
-/
lemma global_permutation_6 (n : (ZMod 1063)ˣ) :
  ((n : ZMod 1063) ∈ C1_6 → sigma_int1063 n alpha_int_6 = beta_int_6) ∧
  ((n : ZMod 1063) ∈ C2_6 → sigma_int1063 n alpha_int_6 = gamma_int_6) ∧
  ((n : ZMod 1063) ∈ H1063 → sigma_int1063 n alpha_int_6 = alpha_int_6) := by
    -- Apply the global permutation lemma to conclude the proof.
    apply Classical.byContradiction
    intro h_contra;
    convert sigma_alpha_prime_6 n using 1
    generalize_proofs at *;
    unfold alpha_int_6 beta_int_6 gamma_int_6 alpha_prime_int_6 beta_prime_int_6 gamma_prime_int_6 at * ; simp_all +decide [ mul_assoc, map_mul ] ;

/-
Check if c(6) = s2.
-/
def check_c6_1063 : IO Unit := do
  let q := 1063
  let c (n : Nat) := (n : Nat) ^ 354 % q
  let s2 := 719
  let c6 := c 6
  IO.println s!"c(6) = {c6}"
  if c6 == s2 then IO.println "c(6) = s2 (Correct)" else IO.println "c(6) != s2"

#eval check_c6_1063

/-
Prove the permutation of alpha_prime under sigma for g=3.
-/
lemma sigma_alpha_prime_1063 (n : (ZMod 1063)ˣ) :
  ((n : ZMod 1063) ∈ C1_1063 → sigma_int1063 n alpha_prime_int1063 = beta_prime_int1063) ∧
  ((n : ZMod 1063) ∈ C2_1063 → sigma_int1063 n alpha_prime_int1063 = gamma_prime_int1063) ∧
  ((n : ZMod 1063) ∈ H1063 → sigma_int1063 n alpha_prime_int1063 = alpha_prime_int1063) := by
    -- Apply the action lemmas to conclude the proof.
    have h1 : (n : ZMod 1063) ∈ C1_1063 → H1063.image (fun x => (n : ZMod 1063) * x) = C1_1063 ∧ C1_1063.image (fun x => (n : ZMod 1063) * x) = C2_1063 ∧ C2_1063.image (fun x => (n : ZMod 1063) * x) = H1063 := by
      exact fun hn => action_C1_1063 _ hn |> fun h => ⟨ h.1, h.2.1, h.2.2 ⟩;
    have h2 : (n : ZMod 1063) ∈ C2_1063 → H1063.image (fun x => (n : ZMod 1063) * x) = C2_1063 ∧ C1_1063.image (fun x => (n : ZMod 1063) * x) = H1063 ∧ C2_1063.image (fun x => (n : ZMod 1063) * x) = C1_1063 := by
      exact fun hn => by have := action_C2_1063 n hn; aesop;
    have h3 : (n : ZMod 1063) ∈ H1063 → H1063.image (fun x => (n : ZMod 1063) * x) = H1063 ∧ C1_1063.image (fun x => (n : ZMod 1063) * x) = C1_1063 ∧ C2_1063.image (fun x => (n : ZMod 1063) * x) = C2_1063 := by
      exact fun h => action_H_1063 _ h;
    unfold alpha_prime_int1063 beta_prime_int1063;
    unfold eta0_int1063 eta1_int1063 eta2_int1063;
    rw [ map_sub, sigma_eta_1063, sigma_eta_1063 ] ; aesop

/-
Prove the global permutation of the sign-corrected roots for g=3.
-/
lemma global_permutation_1063 (n : (ZMod 1063)ˣ) :
  ((n : ZMod 1063) ∈ C1_1063 → sigma_int1063 n alpha_int1063 = beta_int1063) ∧
  ((n : ZMod 1063) ∈ C2_1063 → sigma_int1063 n alpha_int1063 = gamma_int1063) ∧
  ((n : ZMod 1063) ∈ H1063 → sigma_int1063 n alpha_int1063 = alpha_int1063) := by
    convert sigma_alpha_prime_1063 using 1;
    constructor;
    · exact?;
    · unfold alpha_int1063 beta_int1063 gamma_int1063; aesop;

/-
Check consistency of cubic character values.
-/
def consistency_check_1063 : IO Unit := do
  let q := 1063
  let c (n : Nat) := (n : Nat) ^ 354 % q
  let c2 := c 2
  let c3 := c 3
  let c6 := c 6
  let prod := (c2 * c3) % q
  IO.println s!"c(2) = {c2}"
  IO.println s!"c(3) = {c3}"
  IO.println s!"c(6) = {c6}"
  IO.println s!"c(2)*c(3) = {prod}"
  if c6 == prod then IO.println "Multiplicativity holds" else IO.println "Multiplicativity FAILS"

#eval consistency_check_1063

/-
Prove that chi(6) = s2.
-/
lemma chi1063_g6_val : chi1063 6 = s2_1063 := by
  native_decide

/-
Prove chi(g) = s1 and chi(h) = 1 for h in H.
-/
lemma chi1063_g_val_correct : chi1063 g1063 = s1_1063 := by
  native_decide +revert

lemma chi1063_of_mem_H (x : ZMod 1063) (hx : x ∈ H1063) : chi1063 x = 1 := by
  native_decide +revert

/-
Compute coefficients for g=6.
-/
def find_coeffs_6 : IO Unit := do
  let q := 1063
  let a := 65
  -- Find p = k*q + 1
  let mut p := 0
  for k in [2:200] do
    let cand := k * q + 1
    if Nat.Prime cand then
      p := cand
      break
  
  if p == 0 then
    IO.println "No prime found"
    return

  IO.println s!"Using prime p = {p}"

  -- Find element of order q
  let mut g_p := 0
  for g in [2:p] do
    let zeta := (g : Nat) ^ ((p - 1) / q) % p
    if zeta != 1 then
      g_p := g
      break
  
  let zeta := (g_p : Nat) ^ ((p - 1) / q) % p
  IO.println s!"zeta = {zeta}"

  -- Cosets of cubic residues mod q
  -- g_q = 6
  let g_q := 6
  let mut H : List Nat := []
  let mut x := 1
  let g_q_3 := (g_q * g_q * g_q) % q
  for _ in [0:(q-1)/3] do
    H := x :: H
    x := (x * g_q_3) % q
  
  let C1 := H.map (fun h => (h * g_q) % q)
  let C2 := H.map (fun h => (h * g_q * g_q) % q)

  -- Periods mod p
  let sum_zeta (S : List Nat) : Nat :=
    S.foldl (fun acc h => (acc + (zeta ^ h) % p) % p) 0
  
  let eta0 := sum_zeta H
  let eta1 := sum_zeta C1
  let eta2 := sum_zeta C2

  -- Differences
  let alpha_prime := (eta0 + p - eta1) % p
  let beta_prime := (eta1 + p - eta2) % p
  let gamma_prime := (eta2 + p - eta0) % p

  -- Check sign convention
  let prod := (alpha_prime * beta_prime) % p * gamma_prime % p
  let q_mod_p := q % p
  
  let mut alpha := 0
  let mut beta := 0
  let mut gamma := 0

  if prod == q_mod_p then
    alpha := alpha_prime
    beta := beta_prime
    gamma := gamma_prime
    IO.println "Sign convention: positive"
  else
    alpha := (p - alpha_prime) % p
    beta := (p - beta_prime) % p
    gamma := (p - gamma_prime) % p
    IO.println "Sign convention: negative"

  -- Solve 65 * beta = c0 + c1 * alpha + c2 * alpha^2 mod p
  let sub (x y : Nat) := (x + p - y) % p
  let mul (x y : Nat) := (x * y) % p
  let add (x y : Nat) := (x + y) % p
  let pow (x n : Nat) := x ^ n % p
  let inv (x : Nat) := x ^ (p - 2) % p

  let det := mul (sub beta alpha) (mul (sub gamma alpha) (sub gamma beta))
  let det_inv := inv det

  let rhs0 := mul 65 beta
  let rhs1 := mul 65 gamma
  let rhs2 := mul 65 alpha

  -- Solve for c0, c1, c2
  -- c0
  let term0 := mul rhs0 (sub (mul beta (mul gamma gamma)) (mul gamma (mul beta beta)))
  let term1 := mul rhs1 (sub (mul gamma (mul alpha alpha)) (mul alpha (mul gamma gamma)))
  let term2 := mul rhs2 (sub (mul alpha (mul beta beta)) (mul beta (mul alpha alpha)))
  let c0 := mul (add term0 (add term1 term2)) det_inv

  -- c1
  let term0_1 := mul 1 (sub (mul rhs1 (mul gamma gamma)) (mul rhs2 (mul beta beta)))
  let term1_1 := mul 1 (sub (mul rhs2 (mul alpha alpha)) (mul rhs0 (mul gamma gamma)))
  let term2_1 := mul 1 (sub (mul rhs0 (mul beta beta)) (mul rhs1 (mul alpha alpha)))
  let c1 := mul (add term0_1 (add term1_1 term2_1)) det_inv

  -- c2
  let term0_2 := mul 1 (sub (mul beta rhs2) (mul gamma rhs1))
  let term1_2 := mul 1 (sub (mul gamma rhs0) (mul alpha rhs2))
  let term2_2 := mul 1 (sub (mul alpha rhs1) (mul beta rhs0))
  let c2 := mul (add term0_2 (add term1_2 term2_2)) det_inv

  let to_signed (x : Nat) : Int :=
    if x > p / 2 then (x : Int) - p else x

  IO.println s!"Coefficients for beta: c0={to_signed c0}, c1={to_signed c1}, c2={to_signed c2}"
  
  -- Also for gamma
  let rhs0_g := mul 65 gamma
  let rhs1_g := mul 65 alpha
  let rhs2_g := mul 65 beta

  let term0_g := mul rhs0_g (sub (mul beta (mul gamma gamma)) (mul gamma (mul beta beta)))
  let term1_g := mul rhs1_g (sub (mul gamma (mul alpha alpha)) (mul alpha (mul gamma gamma)))
  let term2_g := mul rhs2_g (sub (mul alpha (mul beta beta)) (mul beta (mul alpha alpha)))
  let d0 := mul (add term0_g (add term1_g term2_g)) det_inv

  let term0_1g := mul 1 (sub (mul rhs1_g (mul gamma gamma)) (mul rhs2_g (mul beta beta)))
  let term1_1g := mul 1 (sub (mul rhs2_g (mul alpha alpha)) (mul rhs0_g (mul gamma gamma)))
  let term2_1g := mul 1 (sub (mul rhs0_g (mul beta beta)) (mul rhs1_g (mul alpha alpha)))
  let d1 := mul (add term0_1g (add term1_1g term2_1g)) det_inv

  let term0_2g := mul 1 (sub (mul beta rhs2_g) (mul gamma rhs1_g))
  let term1_2g := mul 1 (sub (mul gamma rhs0_g) (mul alpha rhs2_g))
  let term2_2g := mul 1 (sub (mul alpha rhs1_g) (mul beta rhs0_g))
  let d2 := mul (add term0_2g (add term1_2g term2_2g)) det_inv

  IO.println s!"Coefficients for gamma: d0={to_signed d0}, d1={to_signed d1}, d2={to_signed d2}"

#eval find_coeffs_6

/-
Prove chi(6) = s2 and chi(h) = 1 for h in H.
-/
lemma chi1063_val_6 : chi1063 6 = s2_1063 := by
  native_decide +revert

lemma chi1063_val_H (x : ZMod 1063) (hx : x ∈ H1063) : chi1063 x = 1 := by
  native_decide +revert

/-
Characterize C1 and C2 by chi values for g=6.
-/
lemma mem_C1_iff_chi_eq_s2_6 (n : ZMod 1063) (hn : n ≠ 0) : n ∈ C1_6 ↔ chi1063 n = s2_1063 := by
  native_decide +revert

lemma mem_C2_iff_chi_eq_s1_6 (n : ZMod 1063) (hn : n ≠ 0) : n ∈ C2_6 ↔ chi1063 n = s1_1063 := by
  native_decide +revert

/-
Prove the Dream Theorem for q=1063.
-/
theorem final_result_1063 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 1063) (hN_odd : N % 2 = 1) (hN_a : Nat.Coprime 65 N)
  (P : Ideal Ok1063) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_period : alpha_int_6^3 = 1063 * alpha_int_6 + 1063) :
  let alpha_bar := Ideal.Quotient.mk P alpha_int_6
  let beta_bar := Ideal.Quotient.mk P beta_int_6
  let gamma_bar := Ideal.Quotient.mk P gamma_int_6
  (chi1063 N = s1_1063 → alpha_bar ^ N = gamma_bar) ∧
  (chi1063 N = s2_1063 → alpha_bar ^ N = beta_bar) := by
    field_simp;
    apply And.intro;
    · intro hchi
      have hn : (N : (ZMod 1063)) ∈ C2_6 := by
        apply (mem_C2_iff_chi_eq_s1_6 N (by
        intro h; simp_all +decide [ ZMod.natCast_eq_zero_iff ] ;)).mpr hchi;
      have h_sigma_gamma : sigma_int1063 (N_mod_1063 N hN) alpha_int_6 = gamma_int_6 := by
        apply (global_permutation_6 (N_mod_1063 N hN)).right.left;
        unfold N_mod_1063; aesop;
      rw [ ← h_sigma_gamma, ← artin_property_1063_proven N hN P hP ];
    · intro h
      have h_sigma : sigma_int1063 (N_mod_1063 N hN) alpha_int_6 = beta_int_6 := by
        apply (global_permutation_6 (N_mod_1063 N hN)).left (by
        apply (mem_C1_iff_chi_eq_s2_6 (N_mod_1063 N hN) (by
        intro h_zero
        have h_contra : (N : ZMod 1063) = 0 := by
          convert h_zero using 1
        have h_contra' : 1063 ∣ N := by
          erw [ ZMod.natCast_eq_zero_iff ] at h_contra ; aesop
        have h_contra'' : N = 1063 := by
          rw [ Nat.dvd_prime Fact.out ] at h_contra' ; aesop
        contradiction)).mpr h);
      rw [ ← h_sigma, ← artin_property_1063_proven ];
      assumption