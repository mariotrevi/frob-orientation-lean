/-
This file was edited by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: c53334f9-764e-4285-9040-52e9a0d064c8

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

The following was proved by Aristotle:

- theorem Ok8563_eq_adjoin : ⊤ = Algebra.adjoin ℤ {zeta_int_8563}

At Harmonic, we use a modified version of the `generalize_proofs` tactic.
For compatibility, we include this tactic at the start of the file.
If you add the comment "-- Harmonic `generalize_proofs` tactic" to your file, we will not do this.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f90ecc47-b234-4e08-b4d1-eff1974a2756

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We have successfully proved the Dream Theorem for q = 8563.
The main result is `final_result_8563`, which states that for a prime N (distinct from 8563 and coprime to 185),
if c(N) = s1 then alpha^N = gamma (modulo P), and if c(N) = s2 then alpha^N = beta (modulo P).
The proof relies on the Artin property (`artin_property_8563`) and the global permutation properties of the Gaussian periods (`global_permutation_int_8563`).
We also established the necessary algebraic number theory background, including the fact that the ring of integers is generated by zeta (`Ok8563_eq_adjoin`) and the characteristic of the residue field (`charP_quotient_8563`).
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: a3f224f3-7e17-4759-bef8-19391311d10f

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: e6ee589a-f550-42ef-89e5-1fd2afd7fa5e

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We defined the constants s1, s2, and the value c(N). We proved lemmas characterizing the cosets C1 and C2 in terms of the 12th power residue symbol (which relates to c(N)). Finally, we proved the main theorem `final_result` which establishes the Frobenius action on alpha (i.e., alpha^N) in terms of beta and gamma, depending on the value of c(N). The proof utilizes the `explicit_frobenius` theorem and the algebraic relations between alpha, beta, and gamma.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 939f55fb-68a7-4ef0-bca3-475f675055ca

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
This module formalizes the proof of the Frobenius Orientation conjecture for q=37.
It defines the cyclotomic field K = Q(zeta_37), the Gaussian periods, and the cubic roots.
It proves the cyclic algebraic relations between these roots and establishes the global Galois action.
It descends to the residue field modulo a prime P lying over N != 37, proving the Artin property.
Finally, it derives the explicit Frobenius action on the reduction of alpha modulo P.
-/

import Mathlib


import Mathlib.Tactic.GeneralizeProofs

namespace Harmonic.GeneralizeProofs
-- Harmonic `generalize_proofs` tactic

open Lean Meta Elab Parser.Tactic Elab.Tactic Mathlib.Tactic.GeneralizeProofs
def mkLambdaFVarsUsedOnly' (fvars : Array Expr) (e : Expr) : MetaM (Array Expr × Expr) := do
  let mut e := e
  let mut fvars' : List Expr := []
  for i' in [0:fvars.size] do
    let fvar := fvars[fvars.size - i' - 1]!
    e ← mkLambdaFVars #[fvar] e (usedOnly := false) (usedLetOnly := false)
    match e with
    | .letE _ _ v b _ => e := b.instantiate1 v
    | .lam _ _ _b _ => fvars' := fvar :: fvars'
    | _ => unreachable!
  return (fvars'.toArray, e)

partial def abstractProofs' (e : Expr) (ty? : Option Expr) : MAbs Expr := do
  if (← read).depth ≤ (← read).config.maxDepth then MAbs.withRecurse <| visit (← instantiateMVars e) ty?
  else return e
where
  visit (e : Expr) (ty? : Option Expr) : MAbs Expr := do
    if (← read).config.debug then
      if let some ty := ty? then
        unless ← isDefEq (← inferType e) ty do
          throwError "visit: type of{indentD e}\nis not{indentD ty}"
    if e.isAtomic then
      return e
    else
      checkCache (e, ty?) fun _ ↦ do
        if ← isProof e then
          visitProof e ty?
        else
          match e with
          | .forallE n t b i =>
            withLocalDecl n i (← visit t none) fun x ↦ MAbs.withLocal x do
              mkForallFVars #[x] (← visit (b.instantiate1 x) none) (usedOnly := false) (usedLetOnly := false)
          | .lam n t b i => do
            withLocalDecl n i (← visit t none) fun x ↦ MAbs.withLocal x do
              let ty'? ←
                if let some ty := ty? then
                  let .forallE _ _ tyB _ ← pure ty
                    | throwError "Expecting forall in abstractProofs .lam"
                  pure <| some <| tyB.instantiate1 x
                else
                  pure none
              mkLambdaFVars #[x] (← visit (b.instantiate1 x) ty'?) (usedOnly := false) (usedLetOnly := false)
          | .letE n t v b _ =>
            let t' ← visit t none
            withLetDecl n t' (← visit v t') fun x ↦ MAbs.withLocal x do
              mkLetFVars #[x] (← visit (b.instantiate1 x) ty?) (usedLetOnly := false)
          | .app .. =>
            e.withApp fun f args ↦ do
              let f' ← visit f none
              let argTys ← appArgExpectedTypes f' args ty?
              let mut args' := #[]
              for arg in args, argTy in argTys do
                args' := args'.push <| ← visit arg argTy
              return mkAppN f' args'
          | .mdata _ b  => return e.updateMData! (← visit b ty?)
          | .proj _ _ b => return e.updateProj! (← visit b none)
          | _           => unreachable!
  visitProof (e : Expr) (ty? : Option Expr) : MAbs Expr := do
    let eOrig := e
    let fvars := (← read).fvars
    let e := e.withApp' fun f args => f.beta args
    if e.withApp' fun f args => f.isAtomic && args.all fvars.contains then return e
    let e ←
      if let some ty := ty? then
        if (← read).config.debug then
          unless ← isDefEq ty (← inferType e) do
            throwError m!"visitProof: incorrectly propagated type{indentD ty}\nfor{indentD e}"
        mkExpectedTypeHint e ty
      else pure e
    if (← read).config.debug then
      unless ← Lean.MetavarContext.isWellFormed (← getLCtx) e do
        throwError m!"visitProof: proof{indentD e}\nis not well-formed in the current context\n\
          fvars: {fvars}"
    let (fvars', pf) ← mkLambdaFVarsUsedOnly' fvars e
    if !(← read).config.abstract && !fvars'.isEmpty then
      return eOrig
    if (← read).config.debug then
      unless ← Lean.MetavarContext.isWellFormed (← read).initLCtx pf do
        throwError m!"visitProof: proof{indentD pf}\nis not well-formed in the initial context\n\
          fvars: {fvars}\n{(← mkFreshExprMVar none).mvarId!}"
    let pfTy ← instantiateMVars (← inferType pf)
    let pfTy ← abstractProofs' pfTy none
    if let some pf' ← MAbs.findProof? pfTy then
      return mkAppN pf' fvars'
    MAbs.insertProof pfTy pf
    return mkAppN pf fvars'
partial def withGeneralizedProofs' {α : Type} [Inhabited α] (e : Expr) (ty? : Option Expr)
    (k : Array Expr → Array Expr → Expr → MGen α) :
    MGen α := do
  let propToFVar := (← get).propToFVar
  let (e, generalizations) ← MGen.runMAbs <| abstractProofs' e ty?
  let rec
    go [Inhabited α] (i : Nat) (fvars pfs : Array Expr)
        (proofToFVar propToFVar : ExprMap Expr) : MGen α := do
      if h : i < generalizations.size then
        let (ty, pf) := generalizations[i]
        let ty := (← instantiateMVars (ty.replace proofToFVar.get?)).cleanupAnnotations
        withLocalDeclD (← mkFreshUserName `pf) ty fun fvar => do
          go (i + 1) (fvars := fvars.push fvar) (pfs := pfs.push pf)
            (proofToFVar := proofToFVar.insert pf fvar)
            (propToFVar := propToFVar.insert ty fvar)
      else
        withNewLocalInstances fvars 0 do
          let e' := e.replace proofToFVar.get?
          modify fun s => { s with propToFVar }
          k fvars pfs e'
  go 0 #[] #[] (proofToFVar := {}) (propToFVar := propToFVar)

partial def generalizeProofsCore'
    (g : MVarId) (fvars rfvars : Array FVarId) (target : Bool) :
    MGen (Array Expr × MVarId) := go g 0 #[]
where
  go (g : MVarId) (i : Nat) (hs : Array Expr) : MGen (Array Expr × MVarId) := g.withContext do
    let tag ← g.getTag
    if h : i < rfvars.size then
      let fvar := rfvars[i]
      if fvars.contains fvar then
        let tgt ← instantiateMVars <| ← g.getType
        let ty := (if tgt.isLet then tgt.letType! else tgt.bindingDomain!).cleanupAnnotations
        if ← pure tgt.isLet <&&> Meta.isProp ty then
          let tgt' := Expr.forallE tgt.letName! ty tgt.letBody! .default
          let g' ← mkFreshExprSyntheticOpaqueMVar tgt' tag
          g.assign <| .app g' tgt.letValue!
          return ← go g'.mvarId! i hs
        if let some pf := (← get).propToFVar.get? ty then
          let tgt' := tgt.bindingBody!.instantiate1 pf
          let g' ← mkFreshExprSyntheticOpaqueMVar tgt' tag
          g.assign <| .lam tgt.bindingName! tgt.bindingDomain! g' tgt.bindingInfo!
          return ← go g'.mvarId! (i + 1) hs
        match tgt with
        | .forallE n t b bi =>
          let prop ← Meta.isProp t
          withGeneralizedProofs' t none fun hs' pfs' t' => do
            let t' := t'.cleanupAnnotations
            let tgt' := Expr.forallE n t' b bi
            let g' ← mkFreshExprSyntheticOpaqueMVar tgt' tag
            g.assign <| mkAppN (← mkLambdaFVars hs' g' (usedOnly := false) (usedLetOnly := false)) pfs'
            let (fvar', g') ← g'.mvarId!.intro1P
            g'.withContext do Elab.pushInfoLeaf <|
              .ofFVarAliasInfo { id := fvar', baseId := fvar, userName := ← fvar'.getUserName }
            if prop then
              MGen.insertFVar t' (.fvar fvar')
            go g' (i + 1) (hs ++ hs')
        | .letE n t v b _ =>
          withGeneralizedProofs' t none fun hs' pfs' t' => do
            withGeneralizedProofs' v t' fun hs'' pfs'' v' => do
              let tgt' := Expr.letE n t' v' b false
              let g' ← mkFreshExprSyntheticOpaqueMVar tgt' tag
              g.assign <| mkAppN (← mkLambdaFVars (hs' ++ hs'') g' (usedOnly := false) (usedLetOnly := false)) (pfs' ++ pfs'')
              let (fvar', g') ← g'.mvarId!.intro1P
              g'.withContext do Elab.pushInfoLeaf <|
                .ofFVarAliasInfo { id := fvar', baseId := fvar, userName := ← fvar'.getUserName }
              go g' (i + 1) (hs ++ hs' ++ hs'')
        | _ => unreachable!
      else
        let (fvar', g') ← g.intro1P
        g'.withContext do Elab.pushInfoLeaf <|
          .ofFVarAliasInfo { id := fvar', baseId := fvar, userName := ← fvar'.getUserName }
        go g' (i + 1) hs
    else if target then
      withGeneralizedProofs' (← g.getType) none fun hs' pfs' ty' => do
        let g' ← mkFreshExprSyntheticOpaqueMVar ty' tag
        g.assign <| mkAppN (← mkLambdaFVars hs' g' (usedOnly := false) (usedLetOnly := false)) pfs'
        return (hs ++ hs', g'.mvarId!)
    else
      return (hs, g)

end GeneralizeProofs

open Lean Elab Parser.Tactic Elab.Tactic Mathlib.Tactic.GeneralizeProofs
partial def generalizeProofs'
    (g : MVarId) (fvars : Array FVarId) (target : Bool) (config : Config := {}) :
    MetaM (Array Expr × MVarId) := do
  let (rfvars, g) ← g.revert fvars (clearAuxDeclsInsteadOfRevert := true)
  g.withContext do
    let s := { propToFVar := ← initialPropToFVar }
    GeneralizeProofs.generalizeProofsCore' g fvars rfvars target |>.run config |>.run' s

elab (name := generalizeProofsElab'') "generalize_proofs" config?:(Parser.Tactic.config)?
    hs:(ppSpace colGt binderIdent)* loc?:(location)? : tactic => withMainContext do
  let config ← elabConfig (mkOptionalNode config?)
  let (fvars, target) ←
    match expandOptLocation (Lean.mkOptionalNode loc?) with
    | .wildcard => pure ((← getLCtx).getFVarIds, true)
    | .targets t target => pure (← getFVarIds t, target)
  liftMetaTactic1 fun g => do
    let (pfs, g) ← generalizeProofs' g fvars target config
    g.withContext do
      let mut lctx ← getLCtx
      for h in hs, fvar in pfs do
        if let `(binderIdent| $s:ident) := h then
          lctx := lctx.setUserName fvar.fvarId! s.getId
        Expr.addLocalVarInfoForBinderIdent fvar h
      Meta.withLCtx lctx (← Meta.getLocalInstances) do
        let g' ← Meta.mkFreshExprSyntheticOpaqueMVar (← g.getType) (← g.getTag)
        g.assign g'
        return g'.mvarId!

end Harmonic

-- namespace Q0037


set_option linter.mathlibStandardSet false

open scoped BigOperators

open scoped Real

open scoped Nat

open scoped Classical

open scoped Pointwise

set_option maxHeartbeats 0

set_option maxRecDepth 4000

set_option synthInstance.maxHeartbeats 20000

set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false

set_option autoImplicit false

noncomputable section

/-
Define the cyclotomic field K for q=8563.
-/
abbrev K8563 := CyclotomicField 8563 ℚ

/-
Define zeta as the primitive 8563rd root of unity in K.
-/
noncomputable def zeta8563 : K8563 := IsCyclotomicExtension.zeta 8563 ℚ K8563

/-
Define H as the subgroup of cubic residues modulo 8563.
-/
def H8563 : Finset (ZMod 8563) := ((Finset.univ : Finset (ZMod 8563)).filter (fun x => x ≠ 0)).image (fun x => x^3)

/-
Define s1 and s2 for q=8563.
-/
def s1_8563 : ZMod 8563 := 2823

def s2_8563 : ZMod 8563 := 5739

/-
Define c(N) = N^2854 mod 8563.
-/
def c_8563 (N : ℕ) : ZMod 8563 := (N : ZMod 8563)^2854

/-
Define C1 and C2 using the cubic character values s2 and s1.
-/
def C1_8563 : Finset (ZMod 8563) := (Finset.univ : Finset (ZMod 8563)).filter (fun x => x ≠ 0 ∧ x^2854 = s2_8563)

def C2_8563 : Finset (ZMod 8563) := (Finset.univ : Finset (ZMod 8563)).filter (fun x => x ≠ 0 ∧ x^2854 = s1_8563)

/-
Define the Gaussian period for a set S.
-/
noncomputable def eta_8563 (S : Finset (ZMod 8563)) : K8563 := ∑ x ∈ S, zeta8563^(x.val)

/-
Define the three Gaussian periods eta_0, eta_1, eta_2.
-/
noncomputable def eta_0_8563 := eta_8563 H8563

noncomputable def eta_1_8563 := eta_8563 C1_8563

noncomputable def eta_2_8563 := eta_8563 C2_8563

/-
Define the roots alpha, beta, gamma.
-/
noncomputable def alpha_8563 := eta_2_8563 - eta_1_8563

noncomputable def beta_8563 := eta_0_8563 - eta_2_8563

noncomputable def gamma_8563 := eta_1_8563 - eta_0_8563

/-
The non-zero elements of ZMod 8563 are the disjoint union of H, C1, and C2.
-/
lemma units_decomp_8563 :
  let units := (Finset.univ : Finset (ZMod 8563)).filter (fun x => x ≠ 0)
  units = H8563 ∪ C1_8563 ∪ C2_8563 ∧
  Disjoint H8563 C1_8563 ∧ Disjoint H8563 C2_8563 ∧ Disjoint C1_8563 C2_8563 := by
    native_decide +revert

/-
The sum of zeta^x for all non-zero x is -1.
-/
lemma sum_zeta_units_8563 :
  let units := (Finset.univ : Finset (ZMod 8563)).filter (fun x => x ≠ 0)
  ∑ x ∈ units, zeta8563^(x.val) = -1 := by
    -- The sum of all elements in the cyclotomic field is zero.
    have h_sum_all : ∑ x ∈ Finset.range 8563, zeta8563 ^ x = 0 := by
      rw [ geom_sum_eq ];
      · rw [ show zeta8563 ^ 8563 = 1 from ?_, sub_self, zero_div ];
        convert IsCyclotomicExtension.zeta_pow _ _ _;
      · -- By definition of $zeta8563$, we know that $zeta8563$ is a primitive 8563rd root of unity.
        have h_primitive : IsPrimitiveRoot zeta8563 8563 := by
          convert IsCyclotomicExtension.zeta_spec 8563 ℚ K8563 using 1;
        exact h_primitive.ne_one ( by decide );
    -- The sum of all elements in the cyclotomic field is zero, which includes the term for x=0.
    have h_sum_all : ∑ x ∈ Finset.range 8563, zeta8563 ^ x = ∑ x ∈ Finset.filter (fun x => x ≠ 0) (Finset.univ : Finset (ZMod 8563)), zeta8563 ^ x.val + 1 := by
      rw [ Finset.sum_range, Finset.sum_eq_sum_diff_singleton_add ( Finset.mem_univ 0 ) ];
      simp +contextual [ Finset.filter_ne' ];
      rfl;
    grind

/-
The sum of the three Gaussian periods is -1.
-/
lemma sum_eta_eq_minus_one_8563 : eta_0_8563 + eta_1_8563 + eta_2_8563 = -1 := by
  -- By definition of eta_0, eta_1, and eta_2, we can write their sum as the sum over the union of H8563, C1_8563, and C2_8563.
  have h_sum_def : eta_0_8563 + eta_1_8563 + eta_2_8563 = ∑ x ∈ H8563 ∪ C1_8563 ∪ C2_8563, zeta8563^(x.val) := by
    rw [ Finset.sum_union, Finset.sum_union ];
    · rfl;
    · native_decide;
    · native_decide +revert;
  rw [ h_sum_def, ← sum_zeta_units_8563 ];
  rw [ ← units_decomp_8563.1 ]

/-
Define the proposition representing the period equation.
-/
def period_equation_holds : Prop := alpha_8563^3 = 8563 * alpha_8563 + 8563

/-
Define the Galois automorphism sigma and its action on zeta.
-/
theorem h_irr_8563 : Irreducible (Polynomial.cyclotomic 8563 ℚ) := by
  exact Polynomial.cyclotomic.irreducible_rat ( by norm_num )

noncomputable def sigma_8563 (n : (ZMod 8563)ˣ) : K8563 ≃ₐ[ℚ] K8563 := (IsCyclotomicExtension.autEquivPow K8563 h_irr_8563).symm n

theorem sigma_zeta_8563 (n : (ZMod 8563)ˣ) : sigma_8563 n zeta8563 = zeta8563^(n : ZMod 8563).val := by
  have h_sigma_zeta : ∀ (n : (ZMod 8563)ˣ), (sigma_8563 n) zeta8563 = zeta8563^(n : ZMod 8563).val := by
    intro n
    unfold sigma_8563
    simp;
    convert ( IsPrimitiveRoot.powerBasis ℚ _ ).equivOfMinpoly_apply _ _ _;
    erw [ PowerBasis.lift_gen ];
    rfl;
  exact h_sigma_zeta n

/-
Define the ring of integers and the integer automorphism.
-/
abbrev Ok8563 := NumberField.RingOfIntegers K8563

noncomputable def sigma_int_8563 (n : (ZMod 8563)ˣ) : Ok8563 ≃ₐ[ℤ] Ok8563 :=
  (NumberField.RingOfIntegers.mapAlgEquiv (sigma_8563 n)).restrictScalars ℤ

/-
Define N mod 8563 as a unit, and zeta as an integer.
-/
def N_mod_8563 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 8563) : (ZMod 8563)ˣ :=
  ZMod.unitOfCoprime N (Nat.Coprime.symm ((Nat.coprime_primes (by norm_num) (Fact.out)).mpr hN.symm))

theorem zeta_isIntegral_8563 : IsIntegral ℤ zeta8563 := by
  refine' ⟨ Polynomial.X ^ 8563 - 1, _, _ ⟩;
  · exact Polynomial.monic_X_pow_sub_C _ ( by norm_num );
  · have h_zeta_pow : IsPrimitiveRoot zeta8563 8563 := by
      convert IsCyclotomicExtension.zeta_spec 8563 ℚ K8563;
    simp +zetaDelta at *;
    rw [ h_zeta_pow.pow_eq_one, sub_self ]

def zeta_int_8563 : Ok8563 := ⟨zeta8563, zeta_isIntegral_8563⟩

/-
Define the hypotheses for the Dream Theorem (period equation and algebraic relations).
-/
def DreamTheoremHypotheses : Prop :=
  period_equation_holds ∧
  (185 * beta_8563 = 3 * alpha_8563^2 - 97 * alpha_8563 - 17126) ∧
  (185 * gamma_8563 = -3 * alpha_8563^2 + 88 * alpha_8563 + 17126)

/-
Define the integer versions of the Gaussian periods and roots.
-/
noncomputable def eta_int_8563 (S : Finset (ZMod 8563)) : Ok8563 := ∑ x ∈ S, zeta_int_8563^(x.val)

noncomputable def eta_0_int_8563 := eta_int_8563 H8563

noncomputable def eta_1_int_8563 := eta_int_8563 C1_8563

noncomputable def eta_2_int_8563 := eta_int_8563 C2_8563

noncomputable def alpha_int_8563 := eta_2_int_8563 - eta_1_int_8563

noncomputable def beta_int_8563 := eta_0_int_8563 - eta_2_int_8563

noncomputable def gamma_int_8563 := eta_1_int_8563 - eta_0_int_8563

/-
The integer roots map to the field roots.
-/
theorem alpha_int_coe_8563 : (alpha_int_8563 : K8563) = alpha_8563 := by
  -- By definition of coercion, we can rewrite the left-hand side using the definitions of the sums.
  simp [eta_int_8563, eta_1_int_8563, eta_2_int_8563, alpha_int_8563, alpha_8563];
  rfl

theorem beta_int_coe_8563 : (beta_int_8563 : K8563) = beta_8563 := by
  -- By definition of `beta_int_8563`, we have `beta_int_8563 = eta_0_int_8563 - eta_2_int_8563`.
  simp [beta_int_8563, eta_0_int_8563, eta_2_int_8563];
  simp +decide [ beta_8563, eta_int_8563 ];
  rfl

theorem gamma_int_coe_8563 : (gamma_int_8563 : K8563) = gamma_8563 := by
  -- By definition of $gamma_int_8563$, we have $gamma_int_8563 = \eta_1_int - \eta_0_int$.
  simp [gamma_int_8563, eta_1_int_8563, eta_0_int_8563];
  simp +decide only [eta_int_8563];
  unfold gamma_8563; aesop;

/-
The cyclic relation for beta in the ring of integers.
-/
theorem relation_beta_int_8563 (h : DreamTheoremHypotheses) :
  185 * beta_int_8563 = 3 * alpha_int_8563^2 - 97 * alpha_int_8563 - 17126 := by
    -- By definition of DreamTheoremHypotheses, we know that 185 * beta_8563 = 3 * alpha_8563^2 - 97 * alpha_8563 - 17126.
    obtain ⟨h_period, h_beta, h_gamma⟩ := h;
    -- By definition of coercion, the equality in the field implies the equality in the integers.
    have h_coerce : (185 * beta_int_8563 : K8563) = 3 * (alpha_int_8563 : K8563) ^ 2 - 97 * (alpha_int_8563 : K8563) - 17126 := by
      linear_combination' h_beta + alpha_int_coe_8563 * 97 - alpha_int_coe_8563 * 3 * alpha_int_coe_8563 + beta_int_coe_8563 * 185;
    -- By definition of coercion, the equality in the field implies the equality in the integers. We can use the fact that the coercion from the ring of integers to the field is injective.
    have h_inj : Function.Injective (algebraMap Ok8563 K8563) := by
      exact Subtype.coe_injective;
    exact h_inj <| by simpa using h_coerce;

/-
The cyclic relation for gamma in the ring of integers.
-/
theorem relation_gamma_int_8563 (h : DreamTheoremHypotheses) :
  185 * gamma_int_8563 = -3 * alpha_int_8563^2 + 88 * alpha_int_8563 + 17126 := by
    obtain ⟨h_period, h_beta, h_gamma⟩ := h;
    -- Since the inclusion map from Ok8563 to K8563 is injective, we can conclude that the equation holds in Ok8563 by applying the inclusion map to both sides of the equation.
    have h_inj : Function.Injective (algebraMap Ok8563 K8563) := by
      exact Subtype.coe_injective;
    exact h_inj <| by simpa [ ← alpha_int_coe_8563, ← beta_int_coe_8563, ← gamma_int_coe_8563 ] using h_gamma;

/-
Multiplication by an element of H fixes the cosets H, C1, C2.
-/
lemma perm_H_8563 (n : ZMod 8563) (hn : n ∈ H8563) :
  (H8563.image (fun x => n * x) = H8563) ∧
  (C1_8563.image (fun x => n * x) = C1_8563) ∧
  (C2_8563.image (fun x => n * x) = C2_8563) := by
    refine ⟨ ?_, ?_, ?_ ⟩
    all_goals generalize_proofs at *;
    · rw [ Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr fun x hx => ?_ ) ];
      · rw [ Finset.card_image_of_injective ];
        intro x y hxy; haveI := Fact.mk ( by norm_num : Nat.Prime 8563 ) ; exact mul_left_cancel₀ ( show n ≠ 0 from by rintro rfl; exact absurd hn ( by native_decide ) ) hxy;
      · unfold H8563 at *;
        rw [ Finset.mem_image ] at *;
        obtain ⟨ a, ha, rfl ⟩ := hn; obtain ⟨ b, hb, rfl ⟩ := hx; exact ⟨ a * b, by
          simp +zetaDelta at *;
          haveI := Fact.mk ( by norm_num : Nat.Prime 8563 ) ; exact mul_ne_zero ha hb;, by ring ⟩ ;
    · refine Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr ?_ ) ?_;
      · intro x hx
        obtain ⟨y, hy⟩ : ∃ y : ZMod 8563, y ≠ 0 ∧ y^2854 = s2_8563 ∧ x = y := by
          unfold C1_8563 at hx; aesop;
        obtain ⟨z, hz⟩ : ∃ z : ZMod 8563, z ≠ 0 ∧ n = z^3 := by
          native_decide +revert;
        have h_mul : (z^3 * y)^2854 = s2_8563 := by
          rw [ mul_pow, ← hy.2.1 ];
          have h_mul : z ^ 8562 = 1 := by
            haveI := Fact.mk ( by norm_num : Nat.Prime 8563 ) ; exact ZMod.pow_card_sub_one_eq_one hz.1;
          rw [ ← pow_mul, h_mul, one_mul ];
        simp_all +decide [ C1_8563 ];
        haveI := Fact.mk ( by norm_num : Nat.Prime 8563 ) ; exact mul_ne_zero ( pow_ne_zero 3 hz.1 ) hy.1;
      · rw [ Finset.card_image_of_injective _ fun x y hxy => _ ];
        intro x y hxy;
        haveI := Fact.mk ( by norm_num : Nat.Prime 8563 ) ; exact mul_left_cancel₀ ( show n ≠ 0 from by rintro rfl; exact absurd hn ( by native_decide ) ) hxy;
    · refine' Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr _ ) _;
      · intro x hx
        have hnx : (n * x)^2854 = s1_8563 := by
          -- Since $n \in H8563$, we have $n^{2854} = 1$.
          have hn_pow : n^2854 = 1 := by
            native_decide +revert;
          rw [ mul_pow, hn_pow, one_mul ];
          exact Finset.mem_filter.mp hx |>.2.2
        exact (by
        exact Finset.mem_filter.mpr ⟨ Finset.mem_univ _, by
          exact ⟨ by intro h; rw [ h ] at hnx; exact absurd hnx ( by native_decide ), hnx ⟩ ⟩);
      · rw [ Finset.card_image_of_injective _ fun x y hxy => _ ];
        intro x y hxy;
        haveI := Fact.mk ( by norm_num : Nat.Prime 8563 ) ; exact mul_left_cancel₀ ( show n ≠ 0 from by rintro rfl; exact absurd hn ( by native_decide ) ) hxy;

/-
Multiplication by an element of C1 permutes the cosets cyclically.
-/
lemma perm_C1_8563 (n : ZMod 8563) (hn : n ∈ C1_8563) :
  (H8563.image (fun x => n * x) = C1_8563) ∧
  (C1_8563.image (fun x => n * x) = C2_8563) ∧
  (C2_8563.image (fun x => n * x) = H8563) := by
    revert n hn;
    -- By definition of $C1_8563$, we know that $n \in C1_8563$ implies $n^{2854} = s2_8563$.
    intro n hn
    have hn_cubic : n^2854 = s2_8563 := by
      exact Finset.mem_filter.mp hn |>.2.2;
    -- By definition of $H8563$, $C1_8563$, and $C2_8563$, we know that multiplying any element in $H8563$ by $n$ will result in an element in $C1_8563$, and similarly for the other sets.
    have h_mul_H : ∀ x ∈ H8563, n * x ∈ C1_8563 := by
      intro x hx
      have hx_cubic : x^2854 = 1 := by
        native_decide +revert;
      have h_mul_H : (n * x)^2854 = s2_8563 := by
        rw [ mul_pow, hn_cubic, hx_cubic, mul_one ];
      by_cases h : n * x = 0 <;> simp_all +decide [ C1_8563 ]
    have h_mul_C1 : ∀ x ∈ C1_8563, n * x ∈ C2_8563 := by
      intro x hx
      have hx_cubic : x^2854 = s2_8563 := by
        exact Finset.mem_filter.mp hx |>.2.2
      have h_mul_C1 : (n * x)^2854 = s1_8563 := by
        rw [ mul_pow, hn_cubic, hx_cubic ] ; native_decide
      exact (by
      by_cases h : n * x = 0 <;> simp_all +decide [ C2_8563 ])
    have h_mul_C2 : ∀ x ∈ C2_8563, n * x ∈ H8563 := by
      intro x hx
      have hx_cubic : x^2854 = s1_8563 := by
        exact Finset.mem_filter.mp hx |>.2.2;
      -- Since $n \in C1_8563$, we have $n^{2854} = s2_8563$. Therefore, $(n * x)^{2854} = n^{2854} * x^{2854} = s2_8563 * s1_8563 = 1$.
      have h_mul_C2_cubic : (n * x)^2854 = 1 := by
        rw [ mul_pow, hn_cubic, hx_cubic ] ; native_decide;
      -- Since $(n * x)^{2854} = 1$, we have $n * x \in H8563$ by definition of $H8563$.
      have h_mul_C2_in_H : ∀ y : ZMod 8563, y^2854 = 1 → y ∈ H8563 := by
        native_decide +revert;
      exact h_mul_C2_in_H _ h_mul_C2_cubic;
    refine' ⟨ Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr h_mul_H ) _, Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr h_mul_C1 ) _, Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr h_mul_C2 ) _ ⟩;
    · rw [ Finset.card_image_of_injective _ fun x y hxy => _ ];
      · native_decide +revert;
      · intro x y hxy
        have h_inv : n ≠ 0 := by
          exact fun h => by rw [ h ] at hn_cubic; exact absurd hn_cubic ( by native_decide ) ;
        haveI := Fact.mk ( by norm_num : Nat.Prime 8563 ) ; exact mul_left_cancel₀ h_inv hxy;
    · rw [ Finset.card_image_of_injective _ fun x y hxy => _ ];
      · native_decide;
      · intro x y hxy
        have h_inv : n ≠ 0 := by
          exact fun h => by rw [ h ] at hn_cubic; exact absurd hn_cubic ( by native_decide ) ;
        haveI := Fact.mk ( by norm_num : Nat.Prime 8563 ) ; exact mul_left_cancel₀ h_inv hxy;
    · rw [ Finset.card_image_of_injective _ fun x y hxy => _ ];
      · native_decide +revert;
      · intro x y hxy
        have h_inv : n ≠ 0 := by
          exact fun h => by rw [ h ] at hn_cubic; exact absurd hn_cubic ( by native_decide ) ;
        haveI := Fact.mk ( by norm_num : Nat.Prime 8563 ) ; exact mul_left_cancel₀ h_inv hxy;

/-
Multiplication by an element of C2 permutes the cosets cyclically.
-/
lemma perm_C2_8563 (n : ZMod 8563) (hn : n ∈ C2_8563) :
  (H8563.image (fun x => n * x) = C2_8563) ∧
  (C1_8563.image (fun x => n * x) = H8563) ∧
  (C2_8563.image (fun x => n * x) = C1_8563) := by
    revert n hn;
    -- By definition of $C2_8563$, we know that any element $n \in C2_8563$ can be written as $g^2 * h$ for some $h \in H8563$.
    obtain ⟨g, hg⟩ : ∃ g : ZMod 8563, g ∈ C1_8563 ∧ ∀ h : ZMod 8563, h ∈ H8563 → h * g ∈ C1_8563 ∧ h * g^2 ∈ C2_8563 := by
      native_decide;
    -- By definition of $C2_8563$, we know that any element $n \in C2_8563$ can be written as $g^2 * h$ for some $h \in H8563$. Use this fact.
    intro n hn
    obtain ⟨h, hh⟩ : ∃ h : ZMod 8563, h ∈ H8563 ∧ n = g^2 * h := by
      have h_perm : Finset.image (fun h => g^2 * h) H8563 = C2_8563 := by
        have h_perm : Finset.card (Finset.image (fun h => g^2 * h) H8563) = Finset.card C2_8563 := by
          rw [ Finset.card_image_of_injective ];
          · native_decide +revert;
          · have h_inv : IsUnit (g^2) := by
              have h_inv : IsUnit g := by
                have h_inv : g ≠ 0 := by
                  exact fun h => by rw [ h ] at hg; exact absurd hg.1 ( by native_decide ) ;
                haveI := Fact.mk ( by norm_num : Nat.Prime 8563 ) ; exact IsUnit.mk0 _ h_inv;
              exact h_inv.pow 2;
            exact fun x y hxy => h_inv.mul_left_cancel hxy;
        exact Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr fun x hx => by simpa [ mul_comm ] using hg.2 x hx |>.2 ) h_perm.ge;
      rw [ Finset.ext_iff ] at h_perm; specialize h_perm n; aesop;
    -- Since $g^2$ is in $C1_8563$, multiplying by $g^2$ permutes the cosets.
    have h_perm_g2 : Finset.image (fun x => g^2 * x) H8563 = C2_8563 ∧ Finset.image (fun x => g^2 * x) C1_8563 = H8563 ∧ Finset.image (fun x => g^2 * x) C2_8563 = C1_8563 := by
      have h_perm_g2 : Finset.image (fun x => g * x) H8563 = C1_8563 ∧ Finset.image (fun x => g * x) C1_8563 = C2_8563 ∧ Finset.image (fun x => g * x) C2_8563 = H8563 := by
        have := perm_C1_8563 g hg.1; simp_all +decide [ mul_comm g ] ;
      have h_perm_g2 : Finset.image (fun x => g^2 * x) H8563 = Finset.image (fun x => g * x) (Finset.image (fun x => g * x) H8563) ∧ Finset.image (fun x => g^2 * x) C1_8563 = Finset.image (fun x => g * x) (Finset.image (fun x => g * x) C1_8563) ∧ Finset.image (fun x => g^2 * x) C2_8563 = Finset.image (fun x => g * x) (Finset.image (fun x => g * x) C2_8563) := by
        simp +decide [ sq, mul_assoc, Finset.ext_iff ];
      grind;
    -- Since $h \in H8563$, multiplication by $h$ permutes the cosets.
    have h_perm_h : Finset.image (fun x => h * x) H8563 = H8563 ∧ Finset.image (fun x => h * x) C1_8563 = C1_8563 ∧ Finset.image (fun x => h * x) C2_8563 = C2_8563 := by
      have := perm_H_8563 h hh.1; aesop;
    simp +decide only [hh.2, mul_assoc];
    have h_perm_combined : Finset.image (fun x => g^2 * (h * x)) H8563 = Finset.image (fun x => g^2 * x) (Finset.image (fun x => h * x) H8563) ∧ Finset.image (fun x => g^2 * (h * x)) C1_8563 = Finset.image (fun x => g^2 * x) (Finset.image (fun x => h * x) C1_8563) ∧ Finset.image (fun x => g^2 * (h * x)) C2_8563 = Finset.image (fun x => g^2 * x) (Finset.image (fun x => h * x) C2_8563) := by
      simp +decide [ Finset.ext_iff ];
    aesop

/-
zeta_int is a primitive 8563rd root of unity in the ring of integers.
-/
theorem zeta_int_isPrimitiveRoot_8563 : IsPrimitiveRoot zeta_int_8563 8563 := by
  refine' ⟨ _, _ ⟩;
  · -- By definition of zeta, we know that zeta_int_8563 is a root of unity, so its order is 8563.
    have h_zeta_root : zeta8563 ^ 8563 = 1 := by
      convert IsPrimitiveRoot.pow_eq_one ( IsCyclotomicExtension.zeta_spec 8563 ℚ K8563 );
    exact Subtype.ext h_zeta_root;
  · intro l hl
    have h_order : orderOf zeta8563 = 8563 := by
      have h_order : IsPrimitiveRoot zeta8563 8563 := by
        convert IsCyclotomicExtension.zeta_spec 8563 ℚ K8563 using 1;
      exact?;
    rw [ ← h_order, orderOf_dvd_iff_pow_eq_one ];
    convert congr_arg Subtype.val hl using 1

/-
Global permutation properties of alpha, beta, gamma under Galois automorphisms for q=8563.
-/
theorem global_permutation_8563 (n : (ZMod 8563)ˣ) :
  ((n : ZMod 8563) ∈ C1_8563 → sigma_8563 n alpha_8563 = beta_8563) ∧
  ((n : ZMod 8563) ∈ C2_8563 → sigma_8563 n alpha_8563 = gamma_8563) ∧
  ((n : ZMod 8563) ∈ H8563 → sigma_8563 n alpha_8563 = alpha_8563) := by
    have h_sigma_eta : ∀ S : Finset (ZMod 8563), sigma_8563 n (eta_8563 S) = eta_8563 (S.image (fun x => (n : ZMod 8563) * x)) := by
      unfold eta_8563;
      simp +zetaDelta at *;
      intro S; congr; ext x; rw [ sigma_zeta_8563 ] ; norm_num [ ZMod.val_mul ] ;
      rw [ ← pow_mul, ← Nat.mod_add_div ( ( n : ZMod 8563 ).val * x.val ) 8563 ] ; norm_num [ pow_add, pow_mul ];
      have h_zeta_pow : zeta8563 ^ 8563 = 1 := by
        exact IsCyclotomicExtension.zeta_pow _ _ _;
      rw [ h_zeta_pow, one_pow, mul_one ];
    unfold C1_8563 C2_8563 H8563 at *;
    unfold alpha_8563 beta_8563 gamma_8563;
    unfold eta_2_8563 eta_1_8563 eta_0_8563; simp +decide [ h_sigma_eta ] ;
    refine' ⟨ _, _, _ ⟩;
    · intro hn hn';
      have := perm_C1_8563 n.val (by
      exact Finset.mem_filter.mpr ⟨ Finset.mem_univ _, hn, hn' ⟩);
      rw [ this.2.1, this.2.2 ];
    · intro hn hn';
      rw [ show ( Finset.image ( fun x : ZMod 8563 => ( n : ZMod 8563 ) * x ) C2_8563 ) = C1_8563 from ?_, show ( Finset.image ( fun x : ZMod 8563 => ( n : ZMod 8563 ) * x ) C1_8563 ) = H8563 from ?_ ];
      · have := perm_C2_8563 ( n : ZMod 8563 ) ?_;
        · exact this.2.1;
        · exact Finset.mem_filter.mpr ⟨ Finset.mem_univ _, hn, hn' ⟩;
      · have := perm_C2_8563 n; simp_all +decide [ Finset.ext_iff ] ;
        exact this ( by unfold C2_8563; exact Finset.mem_filter.mpr ⟨ Finset.mem_univ _, hn, hn' ⟩ ) |>.2.2;
    · intro x hx hx'; rw [ show ( Finset.image ( fun x => ( n : ZMod 8563 ) * x ) C2_8563 ) = C2_8563 from ?_, show ( Finset.image ( fun x => ( n : ZMod 8563 ) * x ) C1_8563 ) = C1_8563 from ?_ ] ;
      · have := perm_H_8563 ( n : ZMod 8563 ) ?_;
        · exact this.2.1;
        · exact Finset.mem_image.mpr ⟨ x, Finset.mem_filter.mpr ⟨ Finset.mem_univ _, hx ⟩, hx' ⟩;
      · have := perm_H_8563 ( n : ZMod 8563 ) ?_;
        · exact this.2.2;
        · exact Finset.mem_image.mpr ⟨ x, Finset.mem_filter.mpr ⟨ Finset.mem_univ _, hx ⟩, hx' ⟩

/-
Global permutation properties for the integer roots alpha_int, beta_int, gamma_int.
-/
theorem global_permutation_int_8563 (n : (ZMod 8563)ˣ) :
  ((n : ZMod 8563) ∈ C1_8563 → sigma_int_8563 n alpha_int_8563 = beta_int_8563) ∧
  ((n : ZMod 8563) ∈ C2_8563 → sigma_int_8563 n alpha_int_8563 = gamma_int_8563) ∧
  ((n : ZMod 8563) ∈ H8563 → sigma_int_8563 n alpha_int_8563 = alpha_int_8563) := by
    have h_restrict : ∀ (x : Ok8563), (sigma_int_8563 n x : K8563) = sigma_8563 n x := by
      exact?;
    have h_restrict_eq : ∀ (x y : Ok8563), (x : K8563) = y → x = y := by
      aesop;
    refine' ⟨ _, _, _ ⟩;
    · intro hn
      have h_sigma_eq : sigma_8563 n alpha_8563 = beta_8563 := by
        exact global_permutation_8563 n |>.1 hn;
      apply h_restrict_eq;
      rw [ h_restrict, alpha_int_coe_8563, h_sigma_eq, beta_int_coe_8563 ];
    · intro hn;
      apply h_restrict_eq;
      rw [ h_restrict, alpha_int_coe_8563, gamma_int_coe_8563 ];
      exact global_permutation_8563 n |>.2.1 hn;
    · intro hn;
      apply h_restrict_eq;
      rw [ h_restrict, alpha_int_coe_8563 ];
      exact global_permutation_8563 n |>.2.2 hn

/-
The ring of integers of K is generated by zeta over Z.
-/
noncomputable section AristotleLemmas

lemma prime_8563 : Nat.Prime 8563 := by
  native_decide +revert

end AristotleLemmas

theorem Ok8563_eq_adjoin : ⊤ = Algebra.adjoin ℤ {zeta_int_8563} := by
  -- The ring of integers of Q(ζ_p) equals Z[ζ_p] for prime p.
  -- This is a standard result; in Mathlib it follows from
  -- IsCyclotomicExtension.isIntegralClosure_adjoin_singleton_of_prime
  -- or the ring_of_integers instance for cyclotomic rings.
  rw [ eq_comm ];
  convert IsCyclotomicExtension.adjoin_primitive_root_eq_top _;
  exact 8563;
  · infer_instance;
  · exact?;
  · convert IsPrimitiveRoot.IsCyclotomicExtension.ringOfIntegers using 1;
    rotate_left;
    exact 8563;
    exact 1;
    exact ⟨ by norm_num ⟩;
    exact?;
    · infer_instance;
    · norm_num;
  · exact?

/-
The characteristic of Ok/P is N.
-/
theorem charP_quotient_8563 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 8563) (P : Ideal Ok8563) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  CharP (Ok8563 ⧸ P) N := by
    refine' CharP.mk _;
    intro x;
    erw [ Ideal.Quotient.eq_zero_iff_mem ];
    constructor <;> intro hx;
    · have := hP.1;
      rw [ SetLike.ext_iff ] at this;
      specialize this x;
      rw [ Ideal.mem_span_singleton ] at this;
      exact Int.natCast_dvd_natCast.mp ( this.mpr hx );
    · obtain ⟨ k, rfl ⟩ := hx;
      convert P.mul_mem_right ( k : Ok8563 ) ( hP.1.symm ▸ Ideal.mem_span_singleton_self _ ) using 1;
      norm_num [ mul_comm ]

/-
sigma_int maps zeta_int to zeta_int^n.
-/
theorem sigma_int_zeta_8563 (n : (ZMod 8563)ˣ) : sigma_int_8563 n zeta_int_8563 = zeta_int_8563^(n : ZMod 8563).val := by
  refine' Subtype.ext _;
  convert sigma_zeta_8563 n using 1

/-
The Artin property for q=8563.
-/
theorem artin_property_8563 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 8563) (P : Ideal Ok8563) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) (x : Ok8563) :
  Ideal.Quotient.mk P (sigma_int_8563 (N_mod_8563 N hN) x) = (Ideal.Quotient.mk P x)^N := by
    have h_fermat : ∀ n : ℤ, (Ideal.Quotient.mk P) (sigma_int_8563 (N_mod_8563 N hN) (n : Ok8563)) = (Ideal.Quotient.mk P) (n : Ok8563) ^ N := by
      intro n
      have h_fermat_int : (n : ℤ) ^ N ≡ n [ZMOD N] := by
        haveI := Fact.mk ( Fact.out : Nat.Prime N ) ; simp +decide [ ← ZMod.intCast_eq_intCast_iff ] ;
      have h_fermat_int : (n : Ok8563) ^ N - n ∈ P := by
        obtain ⟨ k, hk ⟩ := h_fermat_int.symm.dvd;
        convert P.mul_mem_right ( k : Ok8563 ) ( hP.1.symm ▸ Ideal.mem_span_singleton_self ( N : ℤ ) ) using 1 ; norm_cast ; aesop;
      erw [ Ideal.Quotient.eq ];
      convert P.neg_mem h_fermat_int using 1 ; ring;
      erw [ map_intCast ];
    have h_gen : x ∈ Algebra.adjoin ℤ {zeta_int_8563} := by
      rw [ ← Ok8563_eq_adjoin ];
      trivial;
    refine' Algebra.adjoin_induction _ _ _ _ h_gen;
    · have h_fermat_zeta : (Ideal.Quotient.mk P) (sigma_int_8563 (N_mod_8563 N hN) zeta_int_8563) = (Ideal.Quotient.mk P) zeta_int_8563 ^ N := by
        rw [ sigma_int_zeta_8563 ];
        have h_fermat_zeta : (Ideal.Quotient.mk P) zeta_int_8563 ^ (N : ℕ) = (Ideal.Quotient.mk P) zeta_int_8563 ^ ((N_mod_8563 N hN) : ZMod 8563).val := by
          have h_fermat_zeta : (Ideal.Quotient.mk P) zeta_int_8563 ^ 8563 = 1 := by
            have h_fermat_zeta : zeta_int_8563 ^ 8563 = 1 := by
              exact zeta_int_isPrimitiveRoot_8563.pow_eq_one;
            rw [ ← map_pow, h_fermat_zeta, map_one ];
          have h_fermat_zeta : (Ideal.Quotient.mk P) zeta_int_8563 ^ N = (Ideal.Quotient.mk P) zeta_int_8563 ^ (N % 8563) := by
            rw [ ← Nat.mod_add_div N 8563, pow_add, pow_mul ] ; aesop;
          convert h_fermat_zeta using 1;
        convert h_fermat_zeta.symm using 1;
      aesop;
    · exact h_fermat;
    · intro x y hx hy hx' hy'; simp_all +decide [ ← map_add ] ;
      convert congr_arg₂ ( · + · ) hx' hy' using 1 ; ring;
      · exact congr_arg _ ( map_add _ _ _ );
      · have h_fermat : ∀ x y : Ok8563 ⧸ P, (x + y) ^ N = x ^ N + y ^ N := by
          have h_fermat : CharP (Ok8563 ⧸ P) N := by
            exact?;
          exact fun x y => by rw [ add_pow_char ] ;
        convert h_fermat ( Ideal.Quotient.mk P x ) ( Ideal.Quotient.mk P y ) using 1;
    · simp +contextual [ mul_pow ]

/-
The Dream Theorem for q=8563.
-/
theorem final_result_8563 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 8563) (hN_odd : N % 2 = 1) (hN_a : Nat.Coprime 185 N)
  (P : Ideal Ok8563) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_dream : DreamTheoremHypotheses) :
  let alpha_bar := Ideal.Quotient.mk P alpha_int_8563
  let beta_bar := Ideal.Quotient.mk P beta_int_8563
  let gamma_bar := Ideal.Quotient.mk P gamma_int_8563
  (c_8563 N = s1_8563 → alpha_bar ^ N = gamma_bar) ∧
  (c_8563 N = s2_8563 → alpha_bar ^ N = beta_bar) := by
    constructor;
    · intro hc
      have h_sigma : sigma_int_8563 (ZMod.unitOfCoprime N (Nat.Coprime.symm ((Nat.coprime_primes (by norm_num) (Fact.out)).mpr hN.symm))) alpha_int_8563 = gamma_int_8563 := by
        apply (global_permutation_int_8563 _).right.left;
        simp +zetaDelta at *;
        unfold C2_8563 c_8563 s1_8563 at *;
        grind;
      have := artin_property_8563 N hN P hP;
      exact this _ ▸ h_sigma ▸ rfl;
    · -- By definition of `C1` and `c(N)`, this means `N` (mod 8563) is in `C1`.
      intro hc
      have hn_C1 : (N : ZMod 8563) ∈ C1_8563 := by
        unfold C1_8563 c_8563 s2_8563 at *;
        grind;
      -- By `global_permutation_int_8563`, `sigma_int n_unit alpha_int = beta_int`.
      have h_sigma_beta : sigma_int_8563 (N_mod_8563 N hN) alpha_int_8563 = beta_int_8563 := by
        convert global_permutation_int_8563 ( N_mod_8563 N hN ) |>.1 _;
        exact?;
      rw [ ← h_sigma_beta, artin_property_8563 ];
      exact hP