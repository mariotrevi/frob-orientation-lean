/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 7b2c259d-6a32-43b3-b742-69c37d4f82a9

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We proved the main theorem relating the Frobenius action on the roots of the polynomial $f(x) = x^3 - 13x - 13$ modulo $N$ to the values of $c = N^{(13-1)/3} \pmod{13}$. Specifically, we showed that if $c \equiv s_1 \pmod{13}$, then $\alpha^N = \gamma$, and if $c \equiv s_2 \pmod{13}$, then $\alpha^N = \beta$, where $\alpha, \beta, \gamma$ are the roots of $f$ in the splitting field. The proof relies on the explicit Frobenius action on the periods of the cyclotomic field $L = \mathbb{Q}(\zeta_{13})$ and the identification of the roots $\alpha, \beta, \gamma$ with these periods.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 1702907a-097e-46eb-8341-956c0f47dd23

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We have formalized the sketch of the proof for the Frobenius Orientation conjecture in the case q=13.
We defined the cyclotomic field L = Q(Œ∂_13), the Gaussian periods Œ∑_0, Œ∑_1, Œ∑_2, and the cubic roots Œ±, Œ≤, Œ≥.
We verified the cyclic relations for Œ≤ and Œ≥.
We established the global Galois action on Œ±, showing how œÉ_N permutes the roots based on N mod 13.
We defined the residue field k_P and the reduction map œÄ.
We proved the Artin symbol property for Œ±: œÄ(œÉ_N(Œ±)) = œÄ(Œ±)^N.
Finally, we proved the Explicit Frobenius Action theorem, determining the action of the Frobenius automorphism on \bar{Œ±} in terms of \bar{Œ±} for each case of N mod 13.
-/

import Mathlib

namespace Q0013


set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definitions of L, Œ∂, and the periods, with explicit instances to help the type class inference.
-/
open Polynomial NumberField

def L := CyclotomicField 13 ‚Ñö

instance : Field L := CyclotomicField.instField 13 ‚Ñö
instance : CharZero L := CyclotomicField.instCharZero 13 ‚Ñö
instance : IsCyclotomicExtension {13} ‚Ñö L := CyclotomicField.isCyclotomicExtension 13 ‚Ñö

noncomputable def Œ∂ : L := IsCyclotomicExtension.zeta 13 ‚Ñö L

def Œ∑‚ÇÄ : L := Œ∂ + Œ∂^5 + Œ∂^8 + Œ∂^12
def Œ∑‚ÇÅ : L := Œ∂^2 + Œ∂^3 + Œ∂^10 + Œ∂^11
def Œ∑‚ÇÇ : L := Œ∂^4 + Œ∂^6 + Œ∂^7 + Œ∂^9

def Œ± : L := -(Œ∑‚ÇÇ - Œ∑‚ÇÅ)
def Œ≤ : L := -(Œ∑‚ÇÄ - Œ∑‚ÇÇ)
def Œ≥ : L := -(Œ∑‚ÇÅ - Œ∑‚ÇÄ)

/-
The cubic roots Œ±, Œ≤, Œ≥ satisfy the cyclic relation: 5Œ≤ = -3Œ±¬≤ + 2Œ± + 26.
-/
theorem cyclic_relation_beta : 5 * Œ≤ = -3 * Œ±^2 + 2 * Œ± + 26 := by
  -- Expand the definitions of Œ± and Œ≤, then simplify the right-hand side in terms of the powers of Œ∂.
  unfold Œ± Œ≤
  simp +decide
  ring_nf at *;
  unfold Œ∑‚ÇÄ Œ∑‚ÇÅ Œ∑‚ÇÇ;
  -- We know that $Œ∂$ is a primitive 13th root of unity, so $Œ∂^{13} = 1$ and $Œ∂^k ‚â† 1$ for $1 ‚â§ k < 13$.
  have h_primitive : Œ∂ ^ 13 = 1 ‚àß ‚àÄ k : ‚Ñï, 1 ‚â§ k ‚Üí k < 13 ‚Üí Œ∂ ^ k ‚â† 1 := by
    have h_primitive : IsPrimitiveRoot Œ∂ 13 := by
      convert IsCyclotomicExtension.zeta_spec 13 ‚Ñö L using 1
    generalize_proofs at *; (
    exact ‚ü® h_primitive.pow_eq_one, fun k hk‚ÇÅ hk‚ÇÇ hk‚ÇÉ => by have := h_primitive.pow_eq_one_iff_dvd k; interval_cases k <;> simp_all +decide ‚ü©)
  generalize_proofs at *; (
  grind +ring)

/-
The cubic roots Œ±, Œ≤, Œ≥ satisfy the cyclic relation: 5Œ≥ = 3Œ±¬≤ - 7Œ± - 26.
-/
theorem cyclic_relation_gamma : 5 * Œ≥ = 3 * Œ±^2 - 7 * Œ± - 26 := by
  simp +decide [ Œ≥, Œ±, Œ≤, Œ∑‚ÇÄ, Œ∑‚ÇÅ, Œ∑‚ÇÇ ];
  -- By definition of $Œ∂$, we know that $Œ∂^13 = 1$ and $Œ∂^k ‚â† 1$ for $1 ‚â§ k < 13$.
  have hŒ∂ : Œ∂ ^ 13 = 1 ‚àß ‚àÄ k : ‚Ñï, 1 ‚â§ k ‚Üí k < 13 ‚Üí Œ∂ ^ k ‚â† 1 := by
    have hŒ∂ : IsPrimitiveRoot Œ∂ 13 := by
      convert IsCyclotomicExtension.zeta_spec 13 ‚Ñö L using 1;
    exact ‚ü® hŒ∂.pow_eq_one, fun k hk‚ÇÅ hk‚ÇÇ => fun hk‚ÇÉ => by have := hŒ∂.2 k hk‚ÇÉ; interval_cases k <;> contradiction ‚ü©;
  grind +ring

/-
The 13th cyclotomic polynomial is irreducible over Q.
-/
theorem h_irr : Irreducible (cyclotomic 13 ‚Ñö) := Polynomial.cyclotomic.irreducible_rat (by norm_num)

/-
Checking the signature of autEquivPow to debug the type mismatch.
-/
#check @IsCyclotomicExtension.autEquivPow

/-
Definition of the Galois automorphism œÉ_u for u ‚àà (Z/13Z)À£.
-/
noncomputable def sigma (u : (ZMod 13)À£) : L ‚âÉ‚Çê[‚Ñö] L :=
  (IsCyclotomicExtension.autEquivPow L h_irr).symm u

/-
Global Permutation Theorem (Part 1): If u ‚â° 2, 3, 10, 11 (mod 13), then œÉ_u(Œ±) = Œ≤.
-/
theorem global_permutation_beta (u : (ZMod 13)À£) (h : (u : ZMod 13) ‚àà ({2, 3, 10, 11} : Set (ZMod 13))) :
  sigma u Œ± = Œ≤ := by
    simp +zetaDelta at *;
    -- We need to express the action of œÉ_u on Œ± = -(Œ∑‚ÇÇ - Œ∑‚ÇÅ) in terms of Œ∂.
    have h_sigma_u_eta : (sigma u) Œ∂ = Œ∂ ^ (u.val.val : ‚Ñï) := by
      unfold sigma;
      simp +decide [ IsCyclotomicExtension.autEquivPow ];
      erw [ PowerBasis.equivOfMinpoly_apply ];
      erw [ PowerBasis.lift_gen ] ; aesop;
    -- By definition of $Œ∑‚ÇÄ$, $Œ∑‚ÇÅ$, and $Œ∑‚ÇÇ$, we can expand $œÉ_u(Œ±)$ using the properties of exponents.
    have h_expand : (sigma u) Œ± = -( (Œ∂ ^ (4 * (u.val.val : ‚Ñï)) + Œ∂ ^ (6 * (u.val.val : ‚Ñï)) + Œ∂ ^ (7 * (u.val.val : ‚Ñï)) + Œ∂ ^ (9 * (u.val.val : ‚Ñï))) - (Œ∂ ^ (2 * (u.val.val : ‚Ñï)) + Œ∂ ^ (3 * (u.val.val : ‚Ñï)) + Œ∂ ^ (10 * (u.val.val : ‚Ñï)) + Œ∂ ^ (11 * (u.val.val : ‚Ñï))) ) := by
      unfold Œ±;
      unfold Œ∑‚ÇÇ Œ∑‚ÇÅ; norm_num [ h_sigma_u_eta, pow_mul ] ;
      ring;
    -- We'll use that Œ∂ is a primitive 13th root of unity to simplify the exponents modulo 13.
    have h_exp_mod : ‚àÄ (n : ‚Ñï), Œ∂ ^ n = Œ∂ ^ (n % 13) := by
      have h_exp_mod : Œ∂ ^ 13 = 1 := by
        exact IsCyclotomicExtension.zeta_pow _ _ _;
      exact fun n => by rw [ ‚Üê Nat.mod_add_div n 13, pow_add, pow_mul ] ; aesop;
    rcases h with ( h | h | h | h ) <;> simp +decide [ h, h_expand, h_exp_mod ];
    ¬∑ unfold Œ≤; ring;
      unfold Œ∑‚ÇÄ Œ∑‚ÇÇ; ring!;
      norm_num [ ZMod.val ] ; ring!;
    ¬∑ unfold Œ≤; norm_num [ ZMod.val ] ; ring;
      unfold Œ∑‚ÇÄ Œ∑‚ÇÇ; ring;
    ¬∑ unfold Œ≤; norm_num [ ZMod.val ] ; ring;
      unfold Œ∑‚ÇÄ Œ∑‚ÇÇ; ring;
    ¬∑ unfold Œ≤; ring;
      unfold Œ∑‚ÇÄ Œ∑‚ÇÇ; norm_num [ ZMod.val ] ; ring;

/-
Global Permutation Theorem (Part 2): If u ‚â° 4, 6, 7, 9 (mod 13), then œÉ_u(Œ±) = Œ≥.
-/
theorem global_permutation_gamma (u : (ZMod 13)À£) (h : (u : ZMod 13) ‚àà ({4, 6, 7, 9} : Set (ZMod 13))) :
  sigma u Œ± = Œ≥ := by
    unfold sigma Œ± Œ≥;
    -- Let's simplify the expression using the definitions of Œ∑‚ÇÄ, Œ∑‚ÇÅ, and Œ∑‚ÇÇ.
    simp [Œ∑‚ÇÄ, Œ∑‚ÇÅ, Œ∑‚ÇÇ];
    erw [ PowerBasis.equivOfMinpoly_apply ] ; ring;
    erw [ PowerBasis.lift_gen ] ; ring!;
    fin_cases u <;> simp +decide at h ‚ä¢;
    ¬∑ simp +decide [ ZMod.val ] ; ring!;
      -- Since $\zeta$ is a primitive 13th root of unity, we have $\zeta^{13} = 1$.
      have h_zeta_13 : IsCyclotomicExtension.zeta 13 ‚Ñö L ^ 13 = 1 := by
        exact IsCyclotomicExtension.zeta_pow 13 ‚Ñö L;
      grind +ring;
    ¬∑ simp +decide [ ZMod.val ] ; ring!;
      -- Since Œ∂ is a primitive 13th root of unity, we have Œ∂^13 = 1.
      have h_zeta_13 : IsCyclotomicExtension.zeta 13 ‚Ñö L ^ 13 = 1 := by
        exact IsCyclotomicExtension.zeta_pow 13 ‚Ñö L;
      grind +ring;
    ¬∑ simp +decide [ ZMod.val ] ; ring!;
      -- Since $\zeta$ is a primitive 13th root of unity, we have $\zeta^{13} = 1$.
      have h_zeta_13 : IsCyclotomicExtension.zeta 13 ‚Ñö L ^ 13 = 1 := by
        exact IsCyclotomicExtension.zeta_pow 13 ‚Ñö L;
      grind;
    ¬∑ simp +decide [ ZMod.val ] ; ring!;
      -- Since $\zeta$ is a primitive 13th root of unity, we have $\zeta^{13} = 1$.
      have h_zeta_13 : (IsCyclotomicExtension.zeta 13 ‚Ñö L) ^ 13 = 1 := by
        exact IsCyclotomicExtension.zeta_pow 13 ‚Ñö L;
      grind +ring

/-
We prove that Œ∂, Œ±, Œ≤, Œ≥ are algebraic integers and define them as elements of the ring of integers O_L.
-/
theorem zeta_mem_O : IsIntegral ‚Ñ§ Œ∂ := by
  -- Since $\zeta$ is a root of unity, it satisfies the polynomial $x^{13} - 1 = 0$, which is monic and has integer coefficients.
  use Polynomial.X ^ 13 - 1;
  simp +zetaDelta at *;
  exact ‚ü® Polynomial.monic_X_pow_sub_C _ ( by decide ), sub_eq_zero.mpr <| by simpa using IsCyclotomicExtension.zeta_pow 13 ‚Ñö L ‚ü©

theorem alpha_mem_O : IsIntegral ‚Ñ§ Œ± := by
  -- Since Œ∂ is a root of unity, Œ∂ is integral over ‚Ñ§.
  have hŒ∂_integral : IsIntegral ‚Ñ§ Œ∂ := by
    -- Since $\zeta$ is a root of unity, it satisfies the polynomial $x^{13} - 1 = 0$, which is monic and has integer coefficients.
    use Polynomial.X ^ 13 - 1;
    simp +zetaDelta at *;
    exact ‚ü® Polynomial.monic_X_pow_sub_C _ ( by decide ), sub_eq_zero.mpr <| by simpa using IsCyclotomicExtension.zeta_pow 13 ‚Ñö L ‚ü©;
  apply_rules [ IsIntegral.neg, IsIntegral.add, IsIntegral.sub, IsIntegral.pow, hŒ∂_integral ]

theorem beta_mem_O : IsIntegral ‚Ñ§ Œ≤ := by
  -- Since Œ∂ is a root of unity, it is integral over ‚Ñ§.
  have hŒ∂_integral : IsIntegral ‚Ñ§ Œ∂ := by
    -- Since $\zeta$ is a root of unity, it satisfies the polynomial $x^{13} - 1 = 0$, which is monic and has integer coefficients.
    use Polynomial.X ^ 13 - 1;
    simp +zetaDelta at *;
    exact ‚ü® Polynomial.monic_X_pow_sub_C _ ( by decide ), sub_eq_zero.mpr <| by simpa using IsCyclotomicExtension.zeta_pow 13 ‚Ñö L ‚ü©;
  refine' IsIntegral.neg _;
  refine' IsIntegral.sub _ _;
  ¬∑ exact IsIntegral.add ( IsIntegral.add ( IsIntegral.add hŒ∂_integral ( hŒ∂_integral.pow 5 ) ) ( hŒ∂_integral.pow 8 ) ) ( hŒ∂_integral.pow 12 );
  ¬∑ refine' IsIntegral.add _ _;
    ¬∑ exact IsIntegral.add ( IsIntegral.add ( hŒ∂_integral.pow 4 ) ( hŒ∂_integral.pow 6 ) ) ( hŒ∂_integral.pow 7 );
    ¬∑ exact hŒ∂_integral.pow 9

theorem gamma_mem_O : IsIntegral ‚Ñ§ Œ≥ := by
  -- Since Œ∂ is a root of the monic polynomial x^13 - 1 with integer coefficients, Œ∂ is an algebraic integer.
  have h_zeta_int : IsIntegral ‚Ñ§ Œ∂ := by
    -- Since $\zeta$ is a root of unity, it satisfies the polynomial $x^{13} - 1 = 0$, which is monic and has integer coefficients.
    use Polynomial.X ^ 13 - 1;
    simp +zetaDelta at *;
    exact ‚ü® Polynomial.monic_X_pow_sub_C _ ( by decide ), sub_eq_zero.mpr <| by simpa using IsCyclotomicExtension.zeta_pow 13 ‚Ñö L ‚ü©;
  have h_eta_int : IsIntegral ‚Ñ§ Œ∑‚ÇÄ ‚àß IsIntegral ‚Ñ§ Œ∑‚ÇÅ ‚àß IsIntegral ‚Ñ§ Œ∑‚ÇÇ := by
    exact ‚ü® IsIntegral.add ( IsIntegral.add ( IsIntegral.add h_zeta_int ( h_zeta_int.pow _ ) ) ( h_zeta_int.pow _ ) ) ( h_zeta_int.pow _ ), IsIntegral.add ( IsIntegral.add ( IsIntegral.add ( h_zeta_int.pow _ ) ( h_zeta_int.pow _ ) ) ( h_zeta_int.pow _ ) ) ( h_zeta_int.pow _ ), IsIntegral.add ( IsIntegral.add ( IsIntegral.add ( h_zeta_int.pow _ ) ( h_zeta_int.pow _ ) ) ( h_zeta_int.pow _ ) ) ( h_zeta_int.pow _ ) ‚ü©;
  exact IsIntegral.neg ( IsIntegral.sub h_eta_int.2.1 h_eta_int.1 )

def alpha_O : ùìû L := ‚ü®Œ±, alpha_mem_O‚ü©
def beta_O : ùìû L := ‚ü®Œ≤, beta_mem_O‚ü©
def gamma_O : ùìû L := ‚ü®Œ≥, gamma_mem_O‚ü©

/-
We prove that N is coprime to 13 and define the corresponding unit in (ZMod 13)À£.
-/
theorem coprime_N_13 (N : ‚Ñï) [Fact N.Prime] (hN : N ‚â† 13) : Nat.Coprime N 13 := by
  exact ( Fact.out : Nat.Prime N ) |> fun h => h.coprime_iff_not_dvd.mpr fun h' => hN <| by have := Nat.le_of_dvd ( by decide ) h'; interval_cases N <;> trivial;

def uN (N : ‚Ñï) [Fact N.Prime] (hN : N ‚â† 13) : (ZMod 13)À£ := ZMod.unitOfCoprime N (coprime_N_13 N hN)

/-
Defining unit_N as the element in (ZMod 13)À£ corresponding to N.
-/
def unit_N (N : ‚Ñï) [Fact N.Prime] (hN : N ‚â† 13) : (ZMod 13)À£ := ZMod.unitOfCoprime N (coprime_N_13 N hN)

/-
We register the NumberField instances for Q and L, and the DedekindDomain instance for O_L.
-/
instance : NumberField ‚Ñö := inferInstance
instance : NumberField L := CyclotomicField.instNumberField 13 ‚Ñö
instance : IsDedekindDomain (ùìû L) := inferInstance

/-
We define œÉ_O as the restriction of the automorphism œÉ to the ring of integers O_L, as a ring automorphism.
-/
noncomputable def sigma_O (u : (ZMod 13)À£) : (ùìû L) ‚âÉ+* (ùìû L) :=
  NumberField.RingOfIntegers.mapRingEquiv (sigma u)

/-
We define zeta_O as the element Œ∂ in the ring of integers.
We then state the Artin symbol property for Œ∂: œÄ(œÉ_N(Œ∂)) = œÄ(Œ∂)^N.
-/
def zeta_O : ùìû L := ‚ü®Œ∂, zeta_mem_O‚ü©

section ResidueField

variable (N : ‚Ñï) [Fact N.Prime] (hN : N ‚â† 13)
variable (P : Ideal (ùìû L)) [P.IsPrime] [P.LiesOver (Ideal.span { (N : ‚Ñ§) })] [P.IsMaximal]

def k_P := (ùìû L) ‚ß∏ P

noncomputable instance : Field (k_P P) := Ideal.Quotient.field P

def pi : ùìû L ‚Üí+* k_P P := Ideal.Quotient.mk P

theorem artin_symbol_zeta : pi P (sigma_O (unit_N N hN) zeta_O) = (pi P zeta_O) ^ N := by
  -- By definition of œÉ_O, we have œÉ_O (unit_N N hN) zeta_O = Œ∂^(unit_N N hN).
  have h_sigma_zeta : (sigma (unit_N N hN)) (Œ∂ : L) = Œ∂ ^ (unit_N N hN).val.val := by
    rw [sigma];
    simp +decide [ IsCyclotomicExtension.autEquivPow ];
    rw [ PowerBasis.equivOfMinpoly_apply ];
    convert ( IsPrimitiveRoot.powerBasis ‚Ñö ( show IsPrimitiveRoot ( IsCyclotomicExtension.zeta 13 ‚Ñö L ) 13 from ?_ ) ).lift_gen _ _;
    exact?;
  -- Since $Œ∂$ is a 13th root of unity, we have $Œ∂^N = Œ∂^{unit_N N hN}$.
  have h_zeta_pow : (Œ∂ : L) ^ N = (Œ∂ : L) ^ ((unit_N N hN).val.val : ‚Ñï) := by
    -- Since Œ∂ is a 13th root of unity, we have Œ∂^13 = 1. Therefore, Œ∂^N = Œ∂^(N mod 13).
    have h_zeta_pow : (Œ∂ : L) ^ N = (Œ∂ : L) ^ (N % 13) := by
      have h_zeta_pow : (Œ∂ : L) ^ 13 = 1 := by
        convert IsCyclotomicExtension.zeta_pow 13 ‚Ñö L using 1;
      rw [ ‚Üê Nat.mod_add_div N 13, pow_add, pow_mul ] ; aesop;
    exact?;
  convert congr_arg ( pi P ) ( show ( sigma_O ( unit_N N hN ) ) zeta_O = zeta_O ^ N from ?_ ) using 1;
  refine' Subtype.ext _;
  convert h_sigma_zeta using 1

end ResidueField

/-
We prove that the automorphism œÉ_N maps Œ∂ to Œ∂^N.
-/
lemma sigma_zeta_val (N : ‚Ñï) [Fact N.Prime] (hN : N ‚â† 13) :
  sigma (unit_N N hN) Œ∂ = Œ∂ ^ N := by
    -- By definition of `sigma`, we know that `sigma u (Œ∂) = Œ∂ ^ u`.
    have h_sigma_def : ‚àÄ u : (ZMod 13)À£, sigma u Œ∂ = Œ∂ ^ (u.val.val : ‚Ñï) := by
      unfold sigma;
      simp +zetaDelta at *;
      intro u;
      rw [ PowerBasis.equivOfMinpoly_apply ];
      erw [ PowerBasis.lift_gen ];
      rfl;
    -- Since $N)$ is coprime to 13, we have $\zeta^{N \mod 13} = \zeta^N$.
    have h_mod : Œ∂ ^ (N % 13) = Œ∂ ^ N := by
      -- Since Œ∂ is a 13th root of unity, we have Œ∂^13 = 1.
      have h_zeta_13 : Œ∂ ^ 13 = 1 := by
        exact IsCyclotomicExtension.zeta_pow _ _ _;
      rw [ ‚Üê Nat.mod_add_div N 13, pow_add, pow_mul ] ; aesop;
    convert h_mod using 1;
    convert h_sigma_def ( unit_N N hN ) using 1

/-
We prove that œÉ_O(Œ∂) = Œ∂^N.
-/
lemma sigma_O_zeta (N : ‚Ñï) [Fact N.Prime] (hN : N ‚â† 13) :
  sigma_O (unit_N N hN) zeta_O = zeta_O ^ N := by
    -- By definition of sigma_O, we have sigma_O (unit_N N hN) zeta_O = sigma (unit_N N hN) Œ∂.
    have h_sigma_O_zeta : sigma_O (unit_N N hN) zeta_O = sigma (unit_N N hN) Œ∂ := by
      exact?;
    refine' Subtype.ext _;
    convert h_sigma_O_zeta.trans ( sigma_zeta_val N hN ) using 1

/-
We prove that the residue field (O_L)/P has characteristic N.
-/
lemma char_k_P (N : ‚Ñï) [Fact N.Prime] (P : Ideal (ùìû L)) [P.IsPrime] [P.LiesOver (Ideal.span { (N : ‚Ñ§) })] [P.IsMaximal] : CharP ((ùìû L) ‚ß∏ P) N := by
  -- Since $P$ lies over $(N)$, the image of $N$ in the quotient ring is zero.
  have h_image_zero : (algebraMap ‚Ñ§ (ùìû L ‚ß∏ P)) N = 0 := by
    -- Since $P$ lies over $(N)$, the ideal $P$ contains $N$. Therefore, when we take the quotient $R/P$, the element $N$ is congruent to zero modulo $P$.
    have hN_in_P : (N : ùìû L) ‚àà P := by
      -- Use `liesOver_iff` to identify the comap of `P` with the ideal `(N)` in ‚Ñ§,
      -- then translate membership via `Ideal.mem_comap`.
      have h_span_comap :
          Ideal.span { (N : ‚Ñ§) } = Ideal.comap (algebraMap ‚Ñ§ (ùìû L)) P := by
        simpa using
          ((Ideal.liesOver_iff P (Ideal.span { (N : ‚Ñ§) })).mp
              (show P.LiesOver (Ideal.span { (N : ‚Ñ§) }) from inferInstance))
      have hN_mem_comap : (N : ‚Ñ§) ‚àà Ideal.comap (algebraMap ‚Ñ§ (ùìû L)) P := by
        have : (N : ‚Ñ§) ‚àà Ideal.span { (N : ‚Ñ§) } := by
          simpa using (Ideal.mem_span_singleton_self (N : ‚Ñ§))
        simpa [h_span_comap] using this
      simpa using (Ideal.mem_comap.mp hN_mem_comap)
    erw [ Ideal.Quotient.eq_zero_iff_mem ] ; aesop;
  refine' ‚ü® fun n => _ ‚ü©;
  constructor <;> intro hn <;> simp_all +decide [ ‚Üê ZMod.natCast_eq_zero_iff ];
  ¬∑ erw [ Ideal.Quotient.eq_zero_iff_mem ] at *;
    -- Since $P$ lies over $(N)$, we have that $N \mid n$.
    have h_div : (N : ‚Ñ§) ‚à£ n := by
      have h_div : (Ideal.span {(N : ‚Ñ§)}) = (Ideal.comap (algebraMap ‚Ñ§ (ùìû L)) P) := by
        simpa using
          ((Ideal.liesOver_iff P (Ideal.span { (N : ‚Ñ§) })).mp
              (show P.LiesOver (Ideal.span { (N : ‚Ñ§) }) from inferInstance))

      exact Ideal.mem_span_singleton.mp ( h_div.symm ‚ñ∏ Ideal.mem_comap.mpr hn );
    simpa [ ‚Üê ZMod.intCast_zmod_eq_zero_iff_dvd ] using h_div;
  ¬∑ rw [ ZMod.natCast_eq_zero_iff ] at hn;
    cases hn ; aesop

/-
We express Œ±_O as a polynomial in Œ∂_O.
-/
lemma alpha_O_eq_poly_zeta : alpha_O = -(zeta_O^4 + zeta_O^6 + zeta_O^7 + zeta_O^9 - (zeta_O^2 + zeta_O^3 + zeta_O^10 + zeta_O^11)) := by
  exact?

/-
We prove the Artin symbol property for Œ±: œÄ(œÉ_N(Œ±)) = œÄ(Œ±)^N.
We use the expansion of Œ± in terms of Œ∂, the action of œÉ_N on Œ∂, and the properties of the Frobenius map in characteristic N.
-/
theorem artin_symbol_alpha (N : ‚Ñï) [Fact N.Prime] (hN : N ‚â† 13) (P : Ideal (ùìû L)) [P.IsPrime] [P.LiesOver (Ideal.span { (N : ‚Ñ§) })] [P.IsMaximal] :
  pi P (sigma_O (unit_N N hN) alpha_O) = (pi P alpha_O) ^ N := by
    -- The Artin symbol property for Œ∂ gives us œÄ(œÉ_N(Œ∂)) = œÄ(Œ∂)^N.
    have h_artin_zeta : (pi P (sigma_O (unit_N N hN) zeta_O)) = (pi P zeta_O) ^ N := by
      exact?;
    -- By definition of $alpha_O$, we have $alpha_O = -(zeta_O^4 + zeta_O^6 + zeta_O^7 + zeta_O^9 - (zeta_O^2 + zeta_O^3 + zeta_O^10 + zeta_O^11))$.
    have h_alpha_def : alpha_O = -(zeta_O^4 + zeta_O^6 + zeta_O^7 + zeta_O^9 - (zeta_O^2 + zeta_O^3 + zeta_O^10 + zeta_O^11)) := by
      exact?;
    simp_all +decide [ pow_mul', ‚Üê mul_pow ];
    have h_frobenius : ‚àÄ (x y : (ùìû L) ‚ß∏ P), (x + y) ^ N = x ^ N + y ^ N := by
      have h_char : CharP ((ùìû L) ‚ß∏ P) N := by
        exact?;
      exact?;
    simp_all +decide [ add_mul, mul_add, pow_succ ];
    have h_frobenius : ‚àÄ (x y : (ùìû L) ‚ß∏ P), (x - y) ^ N = x ^ N - y ^ N := by
      intro x y; rw [ sub_eq_add_neg, h_frobenius ] ;
      rw [ neg_pow ] ; simp +decide [ Nat.Prime.even_iff Fact.out, sub_eq_add_neg ] ;
      by_cases h : Even N <;> simp_all +decide [ Nat.Prime.even_iff Fact.out ];
      ¬∑ grind;
      ¬∑ rw [ neg_one_pow_eq_pow_mod_two ] ; norm_num [ Nat.Prime.eq_two_or_odd ( Fact.out : Nat.Prime N ) |> Or.resolve_left <| h ];
    simp_all +decide [ ‚Üê mul_pow ]

/-
We prove that œÉ_O(Œ±_O) = Œ≤_O under the given congruence condition.
-/
lemma sigma_O_alpha_eq_beta_O (N : ‚Ñï) [Fact N.Prime] (hN : N ‚â† 13)
  (h_congr : (unit_N N hN : ZMod 13) ‚àà ({2, 3, 10, 11} : Set (ZMod 13))) :
  sigma_O (unit_N N hN) alpha_O = beta_O := by
  apply Subtype.ext
  simp only [sigma_O, alpha_O, beta_O, NumberField.RingOfIntegers.mapRingEquiv_apply, NumberField.RingOfIntegers.mapRingHom_apply, NumberField.RingOfIntegers.map_mk]
  exact global_permutation_beta (unit_N N hN) h_congr

/-
We prove Case 1 of the Explicit Frobenius Action theorem: if $N \equiv 2, 3, 10, 11 \pmod{13}$, then $\bar{\alpha}^N = (-3\bar{\alpha}^2 + 2\bar{\alpha} + 26)/5$.
-/
theorem explicit_frobenius_action_case1 (N : ‚Ñï) [Fact N.Prime] (hN : N ‚â† 13) (P : Ideal (ùìû L)) [P.IsPrime] [P.LiesOver (Ideal.span { (N : ‚Ñ§) })] [P.IsMaximal]
  (h_congr : (unit_N N hN : ZMod 13) ‚àà ({2, 3, 10, 11} : Set (ZMod 13))) :
  (pi P alpha_O) ^ N = (pi P (-3 * alpha_O^2 + 2 * alpha_O + 26)) * (5 : k_P P)‚Åª¬π := by
    -- By Lemma~\ref{lem:global_permutation_beta}, we know that $\sigma_N(\alpha) = \beta$.
    have h_sigma_beta : sigma_O (unit_N N hN) alpha_O = beta_O := by
      exact?;
    -- Using the Artin symbol property and the fact that the residue field'reduced versions of the algebraic relations.
    have h_beta_eq : (pi P beta_O) = (pi P (-3 * alpha_O^2 + 2 * alpha_O + 26)) * 5‚Åª¬π := by
      have h_beta_eq : (pi P beta_O) = (pi P (-3 * alpha_O^2 + 2 * alpha_O + 26)) * (pi P (5 : ùìû L))‚Åª¬π := by
        have h_beta_eq : (pi P beta_O) * (pi P (5 : ùìû L)) = (pi P (-3 * alpha_O^2 + 2 * alpha_O + 26)) := by
          have h_beta_eq : beta_O * (5 : ùìû L) = -3 * alpha_O^2 + 2 * alpha_O + 26 := by
            have h_beta_eq : (beta_O : L) * 5 = -3 * (alpha_O : L)^2 + 2 * (alpha_O : L) + 26 := by
              convert cyclic_relation_beta using 1;
              exact mul_comm _ _;
            exact Subtype.ext h_beta_eq;
          rw [ ‚Üê map_mul, h_beta_eq ];
        rw [ ‚Üê h_beta_eq, mul_assoc, mul_inv_cancel‚ÇÄ, mul_one ];
        intro h; have := Ideal.Quotient.eq_zero_iff_mem.mp h; simp_all +decide [ Ideal.mem_span_singleton ] ;
        -- Since $5 \in P$, we have $N \mid 5$.
        have h_div : (N : ‚Ñ§) ‚à£ 5 := by
          have h_div : (5 : ‚Ñ§) ‚àà Ideal.span {(N : ‚Ñ§)} := by
            -- Translate `(5 : ùìû L) ‚àà P` down to `(5 : ‚Ñ§) ‚àà (N)` using `liesOver_iff`.
            have h5_mem_comap : (5 : ‚Ñ§) ‚àà Ideal.comap (algebraMap ‚Ñ§ (ùìû L)) P := by
              refine Ideal.mem_comap.mpr ?_
              simpa using this
            have h_span_comap :
                Ideal.span {(N : ‚Ñ§)} = Ideal.comap (algebraMap ‚Ñ§ (ùìû L)) P := by
              simpa using
                ((Ideal.liesOver_iff P (Ideal.span {(N : ‚Ñ§)})).mp
                    (show P.LiesOver (Ideal.span {(N : ‚Ñ§)}) from inferInstance))
            exact (h_span_comap.symm ‚ñ∏ h5_mem_comap)

          exact Ideal.mem_span_singleton.mp h_div;
        norm_cast at h_div; have := Nat.le_of_dvd ( by decide ) h_div; interval_cases N <;> simp +decide at h_div h_congr ‚ä¢;
        ¬∑ exact Nat.not_prime_one Fact.out;
        ¬∑ simp_all +decide [ unit_N ];
      convert h_beta_eq using 1;
    rw [ ‚Üê h_beta_eq, ‚Üê h_sigma_beta, artin_symbol_alpha ]

/-
We prove that œÉ_O(Œ±_O) = Œ≥_O under the given congruence condition (Case 2).
-/
lemma sigma_O_alpha_eq_gamma_O (N : ‚Ñï) [Fact N.Prime] (hN : N ‚â† 13)
  (h_congr : (unit_N N hN : ZMod 13) ‚àà ({4, 6, 7, 9} : Set (ZMod 13))) :
  sigma_O (unit_N N hN) alpha_O = gamma_O := by
  apply Subtype.ext
  simp only [sigma_O, alpha_O, gamma_O, NumberField.RingOfIntegers.mapRingEquiv_apply, NumberField.RingOfIntegers.mapRingHom_apply, NumberField.RingOfIntegers.map_mk]
  exact global_permutation_gamma (unit_N N hN) h_congr

/-
We prove Case 2 of the Explicit Frobenius Action theorem: if $N \equiv 4, 6, 7, 9 \pmod{13}$, then $\bar{\alpha}^N = (3\bar{\alpha}^2 - 7\bar{\alpha} - 26)/5$.
-/
theorem explicit_frobenius_action_case2 (N : ‚Ñï) [Fact N.Prime] (hN : N ‚â† 13) (P : Ideal (ùìû L)) [P.IsPrime] [P.LiesOver (Ideal.span { (N : ‚Ñ§) })] [P.IsMaximal]
  (h_congr : (unit_N N hN : ZMod 13) ‚àà ({4, 6, 7, 9} : Set (ZMod 13))) :
  (pi P alpha_O) ^ N = (pi P (3 * alpha_O^2 - 7 * alpha_O - 26)) * (5 : k_P P)‚Åª¬π := by
    -- Using the fact that $œÉ_O(Œ±_O) = Œ≥_O$ in $k_P$, we can rewrite the right-hand side.
    have h_rewrite : (pi P (sigma_O (unit_N N hN) alpha_O)) = (pi P (gamma_O)) := by
      exact congr_arg _ ( sigma_O_alpha_eq_gamma_O N hN h_congr );
    -- Using the fact that $œÉ_O(Œ±_O) = Œ≥_O$ in $k_P$, we can rewrite the right-hand side of the equation.
    have h_rewrite_rhs : (pi P (gamma_O)) = (pi P (3 * alpha_O ^ 2 - 7 * alpha_O - 26)) * (5 : k_P P)‚Åª¬π := by
      have h_gamma : (gamma_O : ùìû L) * 5 = 3 * alpha_O ^ 2 - 7 * alpha_O - 26 := by
        have h_gamma : (gamma_O : L) * 5 = 3 * alpha_O ^ 2 - 7 * alpha_O - 26 := by
          have h_gamma_eq : (gamma_O : L) = (3 * alpha_O ^ 2 - 7 * alpha_O - 26) / 5 := by
            field_simp;
            convert cyclic_relation_gamma using 1;
            ¬∑ exact mul_comm _ _;
            ¬∑ ring!
          rw [ h_gamma_eq, div_mul_cancel‚ÇÄ _ ( by norm_num ) ];
        exact Subtype.ext h_gamma;
      have h_inv : (pi P (5 : ùìû L)) ‚â† 0 := by
        -- First, show that `5` is not in the ideal `(N)` of `‚Ñ§`.
        have h5_not_mem : (5 : ‚Ñ§) ‚àâ Ideal.span {(N : ‚Ñ§)} := by
          rw [ Ideal.mem_span_singleton ]
          norm_cast
          intro h
          have := Nat.le_of_dvd (by decide) h
          interval_cases N <;> simp_all +decide
          ¬∑ exact Nat.not_prime_one Fact.out
          ¬∑ simp_all +decide [ unit_N ]
        -- If `pi P 5 = 0`, then `5 ‚àà P`, hence `5 ‚àà (N)` by `liesOver_iff`, contradiction.
        intro hzero
        have h5_mem_P : (5 : ùìû L) ‚àà P := by
          exact Ideal.Quotient.eq_zero_iff_mem.mp hzero
        have h_span_comap :
            Ideal.span {(N : ‚Ñ§)} = Ideal.comap (algebraMap ‚Ñ§ (ùìû L)) P := by
          simpa using
            ((Ideal.liesOver_iff P (Ideal.span {(N : ‚Ñ§)})).mp
                (show P.LiesOver (Ideal.span {(N : ‚Ñ§)}) from inferInstance))
        have h5_mem_comap : (5 : ‚Ñ§) ‚àà Ideal.comap (algebraMap ‚Ñ§ (ùìû L)) P := by
          refine Ideal.mem_comap.mpr ?_
          simpa using h5_mem_P
        have h5_mem_span : (5 : ‚Ñ§) ‚àà Ideal.span {(N : ‚Ñ§)} := by
          exact (h_span_comap.symm ‚ñ∏ h5_mem_comap)
        exact h5_not_mem h5_mem_span

      rw [ ‚Üê h_gamma, map_mul ];
      exact?;
    rw [ ‚Üê h_rewrite_rhs, ‚Üê h_rewrite, artin_symbol_alpha ]

/-
Global Permutation Theorem (Split Case): If u ‚â° 1, 5, 8, 12 (mod 13), then œÉ_u(Œ±) = Œ±.
-/
theorem global_permutation_alpha (u : (ZMod 13)À£) (h : (u : ZMod 13) ‚àà ({1, 5, 8, 12} : Set (ZMod 13))) :
  sigma u Œ± = Œ± := by
    have h_sigma_zeta : sigma u Œ∂ = Œ∂ ^ (u : ZMod 13).val := by
      have h_sigma_zeta : ‚àÄ (u : (ZMod 13)À£), sigma u Œ∂ = Œ∂ ^ (u : ZMod 13).val := by
        intro u
        have h_sigma_zeta : sigma u Œ∂ = Œ∂ ^ (u : ZMod 13).val := by
          have h_sigma_zeta_def : sigma u = (IsCyclotomicExtension.autEquivPow L h_irr).symm u := by
            rfl
          simp +zetaDelta at *;
          rw [ h_sigma_zeta_def, PowerBasis.equivOfMinpoly_apply ];
          erw [ PowerBasis.lift_gen ];
          exact?;
        exact h_sigma_zeta;
      exact h_sigma_zeta u;
    -- By definition of Œ±, we have Œ± = -(Œ∑‚ÇÇ - Œ∑‚ÇÅ).
    have h_alpha : Œ± = -(Œ∂^4 + Œ∂^6 + Œ∂^7 + Œ∂^9 - (Œ∂^2 + Œ∂^3 + Œ∂^10 + Œ∂^11)) := by
      exact?;
    simp_all +decide [ pow_succ, mul_assoc ];
    -- Since Œ∂ is a primitive 13th root of unity, we have Œ∂^13 = 1.
    have h_zeta_13 : Œ∂ ^ 13 = 1 := by
      convert IsPrimitiveRoot.pow_eq_one ( IsCyclotomicExtension.zeta_spec 13 ‚Ñö L );
    rcases h with ( rfl | h | h | h ) <;> norm_num [ pow_succ, mul_assoc, h_zeta_13 ];
    ¬∑ simp +decide [ ZMod.val ];
    ¬∑ simp_all +decide [ ZMod.val ];
      grind +ring;
    ¬∑ simp_all +decide [ ZMod.val ];
      grind +ring;
    ¬∑ simp_all +decide [ ZMod.val ];
      grind

/-
We prove the split case of the Explicit Frobenius Action: if $N \equiv 1, 5, 8, 12 \pmod{13}$, then $\bar{\alpha}^N = \bar{\alpha}$.
-/
theorem explicit_frobenius_action_split (N : ‚Ñï) [Fact N.Prime] (hN : N ‚â† 13) (P : Ideal (ùìû L)) [P.IsPrime] [P.LiesOver (Ideal.span { (N : ‚Ñ§) })] [P.IsMaximal]
  (h_congr : (unit_N N hN : ZMod 13) ‚àà ({1, 5, 8, 12} : Set (ZMod 13))) :
  (pi P alpha_O) ^ N = pi P alpha_O := by
  rw [‚Üê artin_symbol_alpha N hN P]
  have h_global : sigma (unit_N N hN) Œ± = Œ± := global_permutation_alpha (unit_N N hN) h_congr
  have h_sigma_O : sigma_O (unit_N N hN) alpha_O = alpha_O := by
    ext
    simp only [sigma_O, alpha_O, NumberField.RingOfIntegers.mapRingEquiv_apply, NumberField.RingOfIntegers.mapRingHom_apply, NumberField.RingOfIntegers.map_mk]
    exact h_global
  rw [h_sigma_O]

/-
Calculation of s1 in ZMod 13.
-/
lemma s1_value : (‚Üë(-5 - 3 : ‚Ñ§) : ZMod 13) * (6 : ZMod 13)‚Åª¬π = 3 := by
  native_decide +revert

/-
Calculation of s2 in ZMod 13.
-/
lemma s2_value : (‚Üë(5 - 3 : ‚Ñ§) : ZMod 13) * (6 : ZMod 13)‚Åª¬π = 9 := by
  native_decide +revert

/-
Characterization of elements with 4th power equal to 3 in ZMod 13.
-/
lemma N_pow_4_eq_3 (n : ZMod 13) : n^4 = 3 ‚Üî n ‚àà ({2, 3, 10, 11} : Set (ZMod 13)) := by
  decide +revert

/-
Characterization of elements with 4th power equal to 9 in ZMod 13.
-/
lemma N_pow_4_eq_9 (n : ZMod 13) : n^4 = 9 ‚Üî n ‚àà ({4, 6, 7, 9} : Set (ZMod 13)) := by
  native_decide +revert

/-
The sum of the roots alpha, beta, gamma is zero.
-/
lemma sum_roots_zero : Œ± + Œ≤ + Œ≥ = 0 := by
  unfold Œ± Œ≤ Œ≥; ring;

/-
The cyclic relation for gamma holds in the ring of integers O_L.
-/
lemma cyclic_relation_gamma_O : 5 * gamma_O = 3 * alpha_O^2 - 7 * alpha_O - 26 := by
  exact Subtype.ext <| cyclic_relation_gamma.trans <| by norm_cast;

/-
Identification of beta_bar_expr with pi P gamma_O using the cyclic relation and invertibility of 10.
-/
lemma beta_bar_identification (N : ‚Ñï) [Fact N.Prime] (hN_odd : N % 2 ‚â† 0) (hN_q : N ‚â† 13) (hN_a : Nat.Coprime 5 N)
  (P : Ideal (ùìû L)) [P.IsPrime] [P.LiesOver (Ideal.span { (N : ‚Ñ§) })] [P.IsMaximal] :
  let alpha_bar := pi P alpha_O
  let beta_bar_expr := (6 * alpha_bar^2 - (14 : k_P P) * alpha_bar - (52 : k_P P)) * (10 : k_P P)‚Åª¬π
  beta_bar_expr = pi P gamma_O := by
    -- Applying the cyclic relation to gamma_O, we get 5 * pi P gamma_O = 3 * alpha_bar^2 - 7 * alpha_bar - 26 in k_P P.
    have h_gamma_O : 5 * (pi P) gamma_O = 3 * ((pi P) alpha_O)^2 - 7 * ((pi P) alpha_O) - 26 := by
      convert congr_arg ( pi P ) ( cyclic_relation_gamma_O ) using 1;
    -- Since $N$ is coprime to $10$, $10$ is invertible in $k_P$.
    have h_inv : (10 : k_P P) ‚â† 0 := by
      -- Since $N$ is coprime to $10$, $N$ does not divide $10$, hence $10$ is non-zero in $k_P$.
      have h_not_div : ¬¨(N : ‚Ñ§) ‚à£ 10 := by
        norm_cast; intro h; have := Nat.le_of_dvd ( by decide ) h; interval_cases N <;> trivial;
      contrapose! h_not_div;
      erw [ Ideal.Quotient.eq_zero_iff_mem ] at h_not_div;
      have := ‚ÄπP.LiesOver ( Ideal.span { ( N : ‚Ñ§ ) } ) ‚Ä∫.1;
      rw [ SetLike.ext_iff ] at this;
      exact Ideal.mem_span_singleton.mp ( this _ |>.2 <| by simpa using h_not_div );
    field_simp;
    linear_combination' -h_gamma_O * 2

/-
Identification of gamma_bar with pi P beta_O.
-/
lemma gamma_bar_identification (N : ‚Ñï) [Fact N.Prime] (hN_odd : N % 2 ‚â† 0) (hN_q : N ‚â† 13) (hN_a : Nat.Coprime 5 N)
  (P : Ideal (ùìû L)) [P.IsPrime] [P.LiesOver (Ideal.span { (N : ‚Ñ§) })] [P.IsMaximal] :
  let alpha_bar := pi P alpha_O
  let beta_bar := (6 * alpha_bar^2 - (‚Üë(5 + 9) : k_P P) * alpha_bar - (‚Üë(4 * 13) : k_P P)) * (‚Üë(2 * 5) : k_P P)‚Åª¬π
  let gamma_bar := -alpha_bar - beta_bar
  gamma_bar = pi P beta_O := by
    have h_beta_bar_eq_pi_gamma_O : (pi P) gamma_O = ((6 * (pi P) alpha_O^2 - (14 : k_P P) * (pi P) alpha_O - (52 : k_P P)) * (10 : k_P P)‚Åª¬π) := by
      convert beta_bar_identification N hN_odd hN_q hN_a P |> Eq.symm using 1;
    have h_gamma_bar_eq_pi_beta_O : (pi P) beta_O = -(pi P) alpha_O - (pi P) gamma_O := by
      convert congr_arg ( pi P ) ( show beta_O = -alpha_O - gamma_O from ?_ ) using 1;
      have h_gamma_bar_eq_pi_beta_O : (alpha_O : ùìû L) + (beta_O : ùìû L) + (gamma_O : ùìû L) = 0 := by
        exact Subtype.ext <| sum_roots_zero;
      linear_combination' h_gamma_bar_eq_pi_beta_O;
    rw [ h_gamma_bar_eq_pi_beta_O, h_beta_bar_eq_pi_gamma_O ] ; ring

/-
Proof of the first case of the main theorem: if c = s1, then alpha^N = gamma.
-/
lemma main_theorem_case1 (N : ‚Ñï) [Fact N.Prime] (hN_odd : N % 2 ‚â† 0) (hN_q : N ‚â† 13) (hN_a : Nat.Coprime 5 N)
  (P : Ideal (ùìû L)) [P.IsPrime] [P.LiesOver (Ideal.span { (N : ‚Ñ§) })] [P.IsMaximal]
  (h_irr_N : Irreducible (Polynomial.X^3 - Polynomial.C (13 : ZMod N) * Polynomial.X - Polynomial.C (13 : ZMod N))) :
  let q : ‚Ñï := 13
  let a : ‚Ñï := 5
  let s1 : ZMod 13 := (‚Üë(-5 - 3 : ‚Ñ§) : ZMod 13) * (6 : ZMod 13)‚Åª¬π
  let c : ZMod 13 := (N : ZMod 13) ^ ((q - 1) / 3)
  let alpha_bar := pi P alpha_O
  let beta_bar := (6 * alpha_bar^2 - (‚Üë(a + 9) : k_P P) * alpha_bar - (‚Üë(4 * q) : k_P P)) * (‚Üë(2 * a) : k_P P)‚Åª¬π
  let gamma_bar := -alpha_bar - beta_bar
  c = s1 ‚Üí alpha_bar ^ N = gamma_bar := by
    -- By the properties of the Frobenius map in characteristic N, we have that œÄ(Œ±)^N = œÄ(Œ±^N).
    intro q a s1 c alpha_bar beta_bar gamma_bar hc
    have h_frobenius : (pi P alpha_O) ^ N = (pi P (sigma_O (unit_N N hN_q) alpha_O)) := by
      exact?;
    -- By the properties of the Frobenius map in characteristic N, we have that œÄ(Œ±^N) = œÄ(Œ≤).
    have h_frobenius_beta : (pi P (sigma_O (unit_N N hN_q) alpha_O)) = (pi P beta_O) := by
      rw [ sigma_O_alpha_eq_beta_O ];
      have h_congr : (N : ZMod 13) ^ 4 = 3 := by
        convert hc using 1;
        ¬∑ norm_num +zetaDelta at *;
        ¬∑ native_decide;
      exact?;
    convert h_frobenius_beta using 1;
    convert gamma_bar_identification N hN_odd hN_q hN_a P using 1;
    norm_num +zetaDelta at *

/-
Proof of the second case of the main theorem: if c = s2, then alpha^N = beta.
-/
lemma main_theorem_case2 (N : ‚Ñï) [Fact N.Prime] (hN_odd : N % 2 ‚â† 0) (hN_q : N ‚â† 13) (hN_a : Nat.Coprime 5 N)
  (P : Ideal (ùìû L)) [P.IsPrime] [P.LiesOver (Ideal.span { (N : ‚Ñ§) })] [P.IsMaximal]
  (h_irr_N : Irreducible (Polynomial.X^3 - Polynomial.C (13 : ZMod N) * Polynomial.X - Polynomial.C (13 : ZMod N))) :
  let q : ‚Ñï := 13
  let a : ‚Ñï := 5
  let s2 : ZMod 13 := (‚Üë(5 - 3 : ‚Ñ§) : ZMod 13) * (6 : ZMod 13)‚Åª¬π
  let c : ZMod 13 := (N : ZMod 13) ^ ((q - 1) / 3)
  let alpha_bar := pi P alpha_O
  let beta_bar := (6 * alpha_bar^2 - (‚Üë(a + 9) : k_P P) * alpha_bar - (‚Üë(4 * q) : k_P P)) * (‚Üë(2 * a) : k_P P)‚Åª¬π
  c = s2 ‚Üí alpha_bar ^ N = beta_bar := by
    field_simp;
    intro h
    have hc : (unit_N N hN_q : ZMod 13) ‚àà ({4, 6, 7, 9} : Set (ZMod 13)) := by
      have h_unit : (N : ZMod 13) ^ 4 = 9 := by
        have h_unit : (‚ÜëN ^ 4 : ZMod 13) = (‚Üë(5 - 3) * 6‚Åª¬π : ZMod 13) := by
          convert h using 1;
        exact h_unit.trans ( by native_decide );
      exact?
    have h_alpha_gamma : (pi P alpha_O) ^ N = (pi P gamma_O) := by
      convert explicit_frobenius_action_case2 N hN_q P hc using 1;
      have h_gamma_O : 5 * gamma_O = 3 * alpha_O^2 - 7 * alpha_O - 26 := by
        convert cyclic_relation_gamma_O using 1;
      rw [ ‚Üê h_gamma_O, mul_comm ];
      erw [ map_mul ];
      erw [ show ( 5 : ùìû L ) = ( 5 : ‚Ñ§ ) ‚Ä¢ 1 from by norm_num, map_zsmul ] ; norm_num;
      have h_inv : (5 : k_P P) ‚â† 0 := by
        intro h_zero
        have h_char : CharP (ùìû L ‚ß∏ P) N := by
          exact?;
        have := CharP.cast_eq_zero_iff ( ùìû L ‚ß∏ P ) N 5; simp_all +decide ;
        have := Nat.le_of_dvd ( by decide ) this; interval_cases N <;> trivial;
      rw [ ‚Üê mul_assoc, inv_mul_cancel‚ÇÄ h_inv, one_mul ]
    have h_beta_gamma : (pi P gamma_O) = ((6 * (pi P alpha_O)^2 - (‚Üë(5 + 9) : k_P P) * (pi P alpha_O) - (‚Üë(4 * 13) : k_P P)) * (‚Üë(2 * 5) : k_P P)‚Åª¬π) := by
      convert beta_bar_identification N hN_odd hN_q hN_a P |> Eq.symm using 1 ; ring!;
    rw [h_alpha_gamma, h_beta_gamma];
    ring

/-
The main theorem relating the Frobenius action on alpha to beta and gamma.
-/
theorem main_theorem (N : ‚Ñï) [Fact N.Prime] (hN_odd : N % 2 ‚â† 0) (hN_q : N ‚â† 13) (hN_a : Nat.Coprime 5 N)
  (P : Ideal (ùìû L)) [P.IsPrime] [P.LiesOver (Ideal.span { (N : ‚Ñ§) })] [P.IsMaximal]
  (h_irr_N : Irreducible (Polynomial.X^3 - Polynomial.C (13 : ZMod N) * Polynomial.X - Polynomial.C (13 : ZMod N))) :
  let q : ‚Ñï := 13
  let a : ‚Ñï := 5
  let s1 : ZMod 13 := (‚Üë(-5 - 3 : ‚Ñ§) : ZMod 13) * (6 : ZMod 13)‚Åª¬π
  let s2 : ZMod 13 := (‚Üë(5 - 3 : ‚Ñ§) : ZMod 13) * (6 : ZMod 13)‚Åª¬π
  let c : ZMod 13 := (N : ZMod 13) ^ ((q - 1) / 3)
  let alpha_bar := pi P alpha_O
  let beta_bar := (6 * alpha_bar^2 - (‚Üë(a + 9) : k_P P) * alpha_bar - (‚Üë(4 * q) : k_P P)) * (‚Üë(2 * a) : k_P P)‚Åª¬π
  let gamma_bar := -alpha_bar - beta_bar
  (c = s1 ‚Üí alpha_bar ^ N = gamma_bar) ‚àß
  (c = s2 ‚Üí alpha_bar ^ N = beta_bar) := by
    exact ‚ü® main_theorem_case1 N hN_odd hN_q hN_a P h_irr_N, main_theorem_case2 N hN_odd hN_q hN_a P h_irr_N ‚ü©
