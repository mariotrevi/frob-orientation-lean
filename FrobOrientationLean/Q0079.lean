/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f5d38240-e483-4256-a4c7-a62cfb39b8c8

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We formalized the problem for q=79 and a=17.
We defined the constants s1, s2, and the character c(N).
We proved that c(N) = s1 iff N is in C1, and c(N) = s2 iff N is in C2.
We defined the roots alpha, beta, gamma in the residue field Case79_Ok / P.
We proved the final result:
If c(N) = s1, then alpha^N = gamma.
If c(N) = s2, then alpha^N = beta.
This confirms the user's claim.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: a782bb47-15c2-45bb-8dd1-88077895f69f

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We have formalized the proof of the Frobenius Orientation conjecture for q=79.
We defined the cyclotomic field K = Q(zeta_79), the Gaussian periods eta_0, eta_1, eta_2, and the roots alpha, beta, gamma.
We proved the global permutation of the roots under the Galois group.
We established the Artin property for the reduction map.
Finally, we proved the explicit Frobenius action on the roots in the finite field F_{N^3}.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 939f55fb-68a7-4ef0-bca3-475f675055ca

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
This module formalizes the proof of the Frobenius Orientation conjecture for q=37.
It defines the cyclotomic field K = Q(zeta_37), the Gaussian periods, and the cubic roots.
It proves the cyclic algebraic relations between these roots and establishes the global Galois action.
It descends to the residue field modulo a prime P lying over N != 37, proving the Artin property.
Finally, it derives the explicit Frobenius action on the reduction of alpha modulo P.
-/

import Mathlib

namespace Q0079


set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Let L = Q(zeta_37) be the 37th cyclotomic field.
-/
abbrev K := CyclotomicField 37 ℚ

/-
zeta is the primitive 37th root of unity in K.
-/
noncomputable def zeta : K := IsCyclotomicExtension.zeta 37 ℚ K

/-
H is the subgroup of cubic residues modulo 37.
-/
def H : Finset (ZMod 37) := ((Finset.univ : Finset (ZMod 37)).filter (fun x => x ≠ 0)).image (fun x => x^3)

/-
g = 2 is a primitive root modulo 37.
-/
def g : ZMod 37 := 2

/-
C1 is the coset of H with index 1.
-/
def C1 : Finset (ZMod 37) := H.image (fun x => g * x)

/-
C2 is the coset of H with index 2.
-/
def C2 : Finset (ZMod 37) := H.image (fun x => g^2 * x)

/-
Open BigOperators for sum notation.
-/
open BigOperators

/-
The Gaussian period for a set S is the sum of zeta^x for x in S.
-/
noncomputable def eta (S : Finset (ZMod 37)) : K := ∑ x ∈ S, zeta^(x.val)

/-
Define the three Gaussian periods eta_0, eta_1, eta_2.
-/
noncomputable def eta_0 := eta H
noncomputable def eta_1 := eta C1
noncomputable def eta_2 := eta C2

/-
Define the roots alpha, beta, gamma.
-/
noncomputable def alpha := eta_2 - eta_1
noncomputable def beta := eta_0 - eta_2
noncomputable def gamma := eta_1 - eta_0

/-
The non-zero elements of ZMod 37 are the disjoint union of H, C1, and C2.
-/
lemma units_decomp :
  let units := (Finset.univ : Finset (ZMod 37)).filter (fun x => x ≠ 0)
  units = H ∪ C1 ∪ C2 ∧
  Disjoint H C1 ∧ Disjoint H C2 ∧ Disjoint C1 C2 := by
    native_decide

/-
The sum of zeta^x for all non-zero x is -1.
-/
lemma sum_zeta_units :
  let units := (Finset.univ : Finset (ZMod 37)).filter (fun x => x ≠ 0)
  ∑ x ∈ units, zeta^(x.val) = -1 := by
    -- Since $zeta$ is a primitive 37th root of unity, we know that $\sum_{x=0}^{36} zeta^x = 0$.
    have h_sum_zero : ∑ x ∈ Finset.range 37, zeta ^ x = 0 := by
      rw [ geom_sum_eq ] <;> norm_num [ zeta ];
      · exact Or.inl ( sub_eq_zero_of_eq <| by exact IsCyclotomicExtension.zeta_pow 37 ℚ K );
      · have h_order : orderOf (IsCyclotomicExtension.zeta 37 ℚ K) = 37 := by
          rw [ orderOf_eq_of_pow_and_pow_div_prime ] <;> norm_num;
          · exact IsCyclotomicExtension.zeta_pow 37 ℚ K;
          · intro p pp dp; have := Nat.le_of_dvd ( by decide ) dp; interval_cases p <;> norm_num at *;
            have h_order : IsPrimitiveRoot (IsCyclotomicExtension.zeta 37 ℚ K) 37 := by
              exact?;
            exact h_order.ne_one ( by decide );
        aesop;
    simp_all +decide [ Finset.sum_range, ZMod, Fin.sum_univ_succ ];
    simp_all +decide [ Fin.sum_univ_succ, Finset.sum_filter, ZMod.val ];
    linear_combination' h_sum_zero

/-
The sum of the three Gaussian periods is -1.
-/
lemma sum_eta_eq_minus_one : eta_0 + eta_1 + eta_2 = -1 := by
  -- Using the decomposition of the units into H, C1, and C2, we can split the sum into three parts.
  have h_split : ∑ x ∈ (Finset.univ : Finset (ZMod 37)).filter (fun x => x ≠ 0), zeta^(x.val) = ∑ x ∈ H, zeta^(x.val) + ∑ x ∈ C1, zeta^(x.val) + ∑ x ∈ C2, zeta^(x.val) := by
    rw [ ← Finset.sum_union, ← Finset.sum_union ];
    · rw [ ← units_decomp.1 ];
    · decide +revert;
    · native_decide +revert;
  convert sum_zeta_units using 1 ; aesop

/-
Explicit enumeration of the cosets H, C1, C2.
-/
lemma H_explicit : H = {1, 6, 8, 10, 11, 14, 23, 26, 27, 29, 31, 36} := by
  native_decide
lemma C1_explicit : C1 = {2, 9, 12, 15, 16, 17, 20, 21, 22, 25, 28, 35} := by
  native_decide
lemma C2_explicit : C2 = {3, 4, 5, 7, 13, 18, 19, 24, 30, 32, 33, 34} := by
  native_decide +revert

/-
The algebraic relation 11β = 3α² - 10α - 74 holds.
-/
theorem relation_beta : 11 * beta = 3 * alpha^2 - 10 * alpha - 74 := by
  -- Let's simplify the left-hand side of the equation.
  simp +decide only [alpha, beta] at *; (
  -- By definition of eta, we can expand the left-hand side and right-hand side of the equation.
  have h_expand : 11 * (∑ x ∈ ({1, 6, 8, 10, 11, 14, 23, 26, 27, 29, 31, 36} : Finset (ZMod 37)), zeta^(x.val) - ∑ x ∈ ({3, 4, 5, 7, 13, 18, 19, 24, 30, 32, 33, 34} : Finset (ZMod 37)), zeta^(x.val)) =
                (∑ x ∈ ({3, 4, 5, 7, 13, 18, 19, 24, 30, 32, 33, 34} : Finset (ZMod 37)), zeta^(x.val) - ∑ x ∈ ({2, 9, 12, 15, 16, 17, 20, 21, 22, 25, 28, 35} : Finset (ZMod 37)), zeta^(x.val)) *
                ((∑ x ∈ ({3, 4, 5, 7, 13, 18, 19, 24, 30, 32, 33, 34} : Finset (ZMod 37)), zeta^(x.val) - ∑ x ∈ ({2, 9, 12, 15, 16, 17, 20, 21, 22, 25, 28, 35} : Finset (ZMod 37)), zeta^(x.val)) * 3 - 10) - 74 := by
                  -- By definition of $zeta$, we know that $zeta^{37} = 1$ and $zeta^k \neq 1$ for $1 \leq k < 37$.
                  have h_zeta_prop : zeta ^ 37 = 1 ∧ ∀ k : ℕ, 1 ≤ k → k < 37 → zeta ^ k ≠ 1 := by
                    have h_zeta_prop : zeta ^ 37 = 1 := by
                      convert IsCyclotomicExtension.zeta_pow 37 ℚ K using 1;
                    have h_zeta_order : IsPrimitiveRoot zeta 37 := by
                      convert IsCyclotomicExtension.zeta_spec 37 ℚ K using 1;
                    exact ⟨ h_zeta_prop, fun k hk₁ hk₂ hk₃ => by have := h_zeta_order.pow_eq_one_iff_dvd k; interval_cases k <;> simp_all +decide ⟩;
                  simp_all +decide [ ZMod.val ];
                  grind +ring;
  convert h_expand using 1;
  · congr! 2;
    · exact H_explicit ▸ rfl;
    · exact C2_explicit ▸ rfl;
  · unfold eta_1 eta_2;
    unfold eta C1 C2; simp +decide ;
    rw [ show ( Finset.image ( fun x : ZMod 37 => g ^ 2 * x ) H : Finset ( ZMod 37 ) ) = { 3, 4, 5, 7, 13, 18, 19, 24, 30, 32, 33, 34 } from ?_, show ( Finset.image ( fun x : ZMod 37 => g * x ) H : Finset ( ZMod 37 ) ) = { 2, 9, 12, 15, 16, 17, 20, 21, 22, 25, 28, 35 } from ?_ ] ; simp +decide [ Finset.sum ] ; ring!;
    · native_decide +revert;
    · native_decide +revert);

/-
The algebraic relation 11γ = -3α² - α + 74 holds.
-/
theorem relation_gamma : 11 * gamma = -3 * alpha^2 - alpha + 74 := by
  have h_gamma : 11 * gamma = 11 * (eta_1 - eta_0) := by
    rfl
  have h_alpha : 11 * alpha = 11 * (eta_2 - eta_1) := by
    rfl
  have h_beta : 11 * beta = 11 * (eta_0 - eta_2) := by
    rfl
  have h_sum : eta_0 + eta_1 + eta_2 = -1 := by
    exact?
  have h_beta_eq : 11 * beta = 3 * alpha^2 - 10 * alpha - 74 := by
    convert relation_beta using 1
  have h_gamma_eq : 11 * gamma = -3 * alpha^2 - alpha + 74 := by
    grind
  exact h_gamma_eq.symm ▸ by ring;

/-
Checking availability of necessary theorems.
-/
#check Polynomial.cyclotomic.irreducible_rat
#check IsCyclotomicExtension.autEquivPow

/-
The 37th cyclotomic polynomial is irreducible over Q.
-/
theorem h_irr : Irreducible (Polynomial.cyclotomic 37 ℚ) := Polynomial.cyclotomic.irreducible_rat (by norm_num)

/-
sigma n is the Galois automorphism mapping zeta to zeta^n.
-/
noncomputable def sigma (n : (ZMod 37)ˣ) : K ≃ₐ[ℚ] K := (IsCyclotomicExtension.autEquivPow K h_irr).symm n

/-
sigma n maps zeta to zeta^n.
-/
theorem sigma_zeta (n : (ZMod 37)ˣ) : sigma n zeta = zeta^(n : ZMod 37).val := by
  -- By definition of automorphisms in the Galois group, $\sigma_n$ maps $zeta$ to $zeta^n$.
  have h_sigma_zeta : ∀ n : (ZMod 37)ˣ, (sigma n) zeta = zeta^(n.val.val) := by
    intro n
    simp [sigma];
    erw [ PowerBasis.equivOfMinpoly_apply ];
    erw [ PowerBasis.lift_gen ];
    exact?;
  exact h_sigma_zeta n

/-
The action of sigma n on alpha is determined by the cubic character of n.
-/
theorem global_permutation (n : (ZMod 37)ˣ) :
  ((n : ZMod 37) ∈ C1 → sigma n alpha = beta) ∧
  ((n : ZMod 37) ∈ C2 → sigma n alpha = gamma) ∧
  ((n : ZMod 37) ∈ H → sigma n alpha = alpha) := by
    -- Let's simplify the goal using the definitions of $C1$, $C2$, and $H$.
    suffices h_simp : ∀ n : (ZMod 37)ˣ, (n.val ∈ C1 → sigma n eta_0 = eta_1 ∧ sigma n eta_1 = eta_2 ∧ sigma n eta_2 = eta_0) ∧ (n.val ∈ C2 → sigma n eta_0 = eta_2 ∧ sigma n eta_1 = eta_0 ∧ sigma n eta_2 = eta_1) ∧ (n.val ∈ H → sigma n eta_0 = eta_0 ∧ sigma n eta_1 = eta_1 ∧ sigma n eta_2 = eta_2) by
      unfold alpha beta gamma; aesop;
    -- By definition of $sigma$, we know that $sigma n (zeta^x) = zeta^{n.val * x}$ for any $x \in \mathbb{Z}/37\mathbb{Z}$.
    have h_sigma_exp : ∀ n : (ZMod 37)ˣ, ∀ x : ZMod 37, (sigma n) (zeta^(x.val)) = zeta^((n.val * x).val) := by
      intro n x; exact (by
      convert congr_arg ( · ^ x.val ) ( sigma_zeta n ) using 1 ; norm_num [ pow_mul ];
      rw [ ← pow_mul, ZMod.val_mul ];
      -- Since $zeta$ is a primitive $37$th root of unity, we have $zeta^{37} = 1$.
      have h_zeta_37 : zeta ^ 37 = 1 := by
        convert IsCyclotomicExtension.zeta_pow 37 ℚ K;
      rw [ ← Nat.mod_add_div ( ( n : ZMod 37 ).val * x.val ) 37, pow_add, pow_mul ] ; aesop);
    -- Apply the definition of $sigma$ to each term in the sum.
    have h_sigma_sum : ∀ n : (ZMod 37)ˣ, ∀ S : Finset (ZMod 37), (sigma n) (∑ x ∈ S, zeta^(x.val)) = ∑ x ∈ S, zeta^((n.val * x).val) := by
      exact fun n S => by rw [ map_sum, Finset.sum_congr rfl fun x hx => h_sigma_exp n x ] ;
    intro n
    simp [h_sigma_sum, eta_0, eta_1, eta_2];
    unfold eta; simp +decide [ h_sigma_sum ] ;
    -- By definition of $C1$, $C2$, and $H$, we can rewrite the sums accordingly.
    have h_cosets : ∀ n : (ZMod 37)ˣ, (n.val ∈ C1 → Finset.image (fun x => (n.val * x : ZMod 37)) H = C1 ∧ Finset.image (fun x => (n.val * x : ZMod 37)) C1 = C2 ∧ Finset.image (fun x => (n.val * x : ZMod 37)) C2 = H) ∧ (n.val ∈ C2 → Finset.image (fun x => (n.val * x : ZMod 37)) H = C2 ∧ Finset.image (fun x => (n.val * x : ZMod 37)) C1 = H ∧ Finset.image (fun x => (n.val * x : ZMod 37)) C2 = C1) ∧ (n.val ∈ H → Finset.image (fun x => (n.val * x : ZMod 37)) H = H ∧ Finset.image (fun x => (n.val * x : ZMod 37)) C1 = C1 ∧ Finset.image (fun x => (n.val * x : ZMod 37)) C2 = C2) := by
      native_decide +revert;
    refine' ⟨ fun hn => _, fun hn => _, fun hn => _ ⟩;
    · have := h_cosets n |>.1 hn;
      exact ⟨ by rw [ ← this.1, Finset.sum_image ( Finset.card_image_iff.mp <| by simp +decide [ this ] ) ], by rw [ ← this.2.1, Finset.sum_image ( Finset.card_image_iff.mp <| by simp +decide [ this ] ) ], by rw [ ← this.2.2, Finset.sum_image ( Finset.card_image_iff.mp <| by simp +decide [ this ] ) ] ⟩;
    · have := h_cosets n |>.2.1 hn;
      exact ⟨ by rw [ ← this.1, Finset.sum_image ( Finset.card_image_iff.mp <| by simp +decide [ this ] ) ], by rw [ ← this.2.1, Finset.sum_image ( Finset.card_image_iff.mp <| by simp +decide [ this ] ) ], by rw [ ← this.2.2, Finset.sum_image ( Finset.card_image_iff.mp <| by simp +decide [ this ] ) ] ⟩;
    · have := h_cosets n |>.2.2 hn; simp_all +decide [ Finset.sum_image ] ;
      refine' ⟨ _, _, _ ⟩;
      · conv_rhs => rw [ ← this.1, Finset.sum_image ( Finset.card_image_iff.mp <| by simp +decide [ this.1 ] ) ] ;
      · conv_rhs => rw [ ← this.2.1, Finset.sum_image ( Finset.card_image_iff.mp <| by simp +decide [ * ] ) ] ;
      · conv_rhs => rw [ ← this.2.2, Finset.sum_image ( Finset.card_image_iff.mp <| by simp +decide [ * ] ) ] ;

/-
Ok is the ring of integers of K.
-/
abbrev Ok := NumberField.RingOfIntegers K

/-
sigma_int n is the restriction of sigma n to the ring of integers, viewed as a Z-algebra equivalence.
-/
noncomputable def sigma_int (n : (ZMod 37)ˣ) : Ok ≃ₐ[ℤ] Ok :=
  (NumberField.RingOfIntegers.mapAlgEquiv (sigma n)).restrictScalars ℤ

/-
N_mod_37 N is the element N in (ZMod 37)ˣ.
-/
def N_mod_37 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 37) : (ZMod 37)ˣ :=
  ZMod.unitOfCoprime N (Nat.Coprime.symm ((Nat.coprime_primes (by norm_num) (Fact.out)).mpr hN.symm))

/-
zeta is an algebraic integer.
-/
theorem zeta_isIntegral : IsIntegral ℤ zeta := IsPrimitiveRoot.isIntegral (IsCyclotomicExtension.zeta_spec 37 ℚ K) (by norm_num)

/-
zeta_int is zeta viewed as an element of the ring of integers.
-/
def zeta_int : Ok := ⟨zeta, zeta_isIntegral⟩

/-
The Artin property holds for zeta.
-/
theorem artin_property_zeta (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 37) (P : Ideal Ok) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) zeta_int) = (Ideal.Quotient.mk P zeta_int)^N := by
    have h_norm : ((Ideal.Quotient.mk P) (sigma_int (N_mod_37 N hN) zeta_int)) = ((Ideal.Quotient.mk P) (zeta_int)) ^ N := by
      have h_norm_eq : (sigma_int (N_mod_37 N hN) zeta_int) = zeta_int ^ N := by
        have h_sigma_zeta : sigma (N_mod_37 N hN) zeta = zeta ^ N := by
          convert sigma_zeta ( N_mod_37 N hN ) using 1;
          -- Since $N$ is coprime to $37$, we have $N \equiv N \mod 37 \pmod{37}$.
          have h_cong : (N : ZMod 37) = (N_mod_37 N hN : ZMod 37) := by
            exact?;
          rw [ ← h_cong, ZMod.val_natCast ];
          have h_order : zeta ^ 37 = 1 := by
            convert IsCyclotomicExtension.zeta_pow 37 ℚ K;
          rw [ ← Nat.mod_add_div N 37, pow_add, pow_mul ] ; aesop;
        exact?
      aesop;
    convert h_norm using 1

/-
zeta_int is a primitive 37th root of unity in the ring of integers.
-/
theorem zeta_int_isPrimitiveRoot : IsPrimitiveRoot zeta_int 37 := by
  have h_prim : IsPrimitiveRoot (zeta : K) 37 := by
    apply_rules [ IsCyclotomicExtension.zeta_spec ];
  simp_all +decide [ IsPrimitiveRoot.iff_def ];
  apply And.intro;
  · exact Subtype.ext h_prim.1;
  · intro l hl;
    convert h_prim.2 l _;
    convert congr_arg ( fun x : Ok => x : Ok → K ) hl using 1

/-
The ring of integers is generated by zeta.
-/
theorem Ok_eq_adjoin : ⊤ = Algebra.adjoin ℤ {zeta_int} := by
  have h_cyclotomic : IsCyclotomicExtension {37} ℤ (NumberField.RingOfIntegers (CyclotomicField 37 ℚ)) := by
    have h_cyclotomic : IsCyclotomicExtension {37} ℚ (CyclotomicField 37 ℚ) := by
      infer_instance;
    convert IsPrimitiveRoot.IsCyclotomicExtension.ringOfIntegers using 1;
    rotate_left;
    exacts [ 37, 1, ⟨ by norm_num ⟩, by infer_instance, by simpa using h_cyclotomic, by norm_num ];
  have h_primitive_root : IsPrimitiveRoot (zeta_int : NumberField.RingOfIntegers (CyclotomicField 37 ℚ)) 37 := by
    convert zeta_int_isPrimitiveRoot using 1;
  rw [ eq_comm ] ; exact IsCyclotomicExtension.adjoin_primitive_root_eq_top h_primitive_root;

/-
Define the integer versions of the Gaussian periods and roots.
-/
noncomputable def eta_int (S : Finset (ZMod 37)) : Ok := ∑ x ∈ S, zeta_int^(x.val)
noncomputable def eta_0_int := eta_int H
noncomputable def eta_1_int := eta_int C1
noncomputable def eta_2_int := eta_int C2
noncomputable def alpha_int := eta_2_int - eta_1_int
noncomputable def beta_int := eta_0_int - eta_2_int
noncomputable def gamma_int := eta_1_int - eta_0_int

/-
The integer roots map to the field roots.
-/
theorem alpha_int_coe : (alpha_int : K) = alpha := by
  exact?
theorem beta_int_coe : (beta_int : K) = beta := by
  unfold beta_int beta;
  unfold eta_0_int eta_2_int eta_0 eta_2; aesop;
theorem gamma_int_coe : (gamma_int : K) = gamma := by
  exact?

/-
The cyclic relations hold in the ring of integers.
-/
theorem cyclic_relations_int :
  11 * beta_int = 3 * alpha_int^2 - 10 * alpha_int - 74 ∧
  11 * gamma_int = -3 * alpha_int^2 - alpha_int + 74 := by
    -- By definition of alpha_int, beta_int, and gamma_int, we know that their images in K satisfy the same relations as their counterparts in K.
    have alpha_int_eq : (alpha_int : K) = alpha := by
      exact?
    have beta_int_eq : (beta_int : K) = beta := by
      exact?
    have gamma_int_eq : (gamma_int : K) = gamma := by
      exact?;
    -- Since these are equalities in K, we can conclude that the relations hold in the ring of integers as well.
    have h_rel : (11 * beta_int : K) = 3 * alpha_int^2 - 10 * alpha_int - 74 ∧ (11 * gamma_int : K) = -3 * alpha_int^2 - alpha_int + 74 := by
      exact ⟨ by rw [ alpha_int_eq, beta_int_eq, relation_beta ], by rw [ alpha_int_eq, gamma_int_eq, relation_gamma ] ⟩;
    have h_inj : Function.Injective (algebraMap (NumberField.RingOfIntegers K) K) := by
      exact?;
    exact ⟨ h_inj <| by simpa using h_rel.1, h_inj <| by simpa using h_rel.2 ⟩

/-
The global permutation holds in the ring of integers.
-/
theorem global_permutation_int (n : (ZMod 37)ˣ) :
  ((n : ZMod 37) ∈ C1 → sigma_int n alpha_int = beta_int) ∧
  ((n : ZMod 37) ∈ C2 → sigma_int n alpha_int = gamma_int) ∧
  ((n : ZMod 37) ∈ H → sigma_int n alpha_int = alpha_int) := by
    have := @global_permutation n;
    refine' ⟨ _, _, _ ⟩;
    · intro hn
      have h_eq : (sigma_int n alpha_int : K) = beta := by
        convert this.1 hn using 1;
      exact ( by rw [ ← beta_int_coe ] at *; exact Subtype.ext h_eq );
    · intro hn;
      have h_sigma_int_gamma : (sigma n : K → K) alpha = gamma := by
        exact this.2.1 hn;
      exact?;
    · intro hn;
      have := this.2.2 hn;
      exact?

/-
The automorphism sigma N reduces to the Frobenius map x |-> x^N modulo P.
-/
theorem artin_property (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 37) (P : Ideal Ok) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) (x : Ok) :
  Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) x) = (Ideal.Quotient.mk P x)^N := by
    -- The set of x satisfying the property is a subalgebra of Ok.
    have h_subalgebra : ∀ x y : Ok, ((Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) x)) = (Ideal.Quotient.mk P x) ^ N) → ((Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) y)) = (Ideal.Quotient.mk P y) ^ N) → ((Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) (x + y))) = (Ideal.Quotient.mk P (x + y)) ^ N) ∧ ((Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) (x * y))) = (Ideal.Quotient.mk P (x * y)) ^ N) := by
      intro x y hx hy;
      have h_frobenius_mul : ∀ (x y : Ok ⧸ P), (x + y) ^ N = x ^ N + y ^ N ∧ (x * y) ^ N = x ^ N * y ^ N := by
        intro x y; haveI := Fact.mk ( Fact.out : Nat.Prime N ) ; simp +decide [ add_pow_char, mul_pow ] ;
        -- Since $P$ is a prime ideal lying over $N$, the quotient ring $Ok/P$ has characteristic $N$.
        have h_char : ringChar (Ok ⧸ P) = N := by
          have h_char : Ideal.Quotient.mk P (N : Ok) = 0 := by
            rw [ Ideal.Quotient.eq_zero_iff_mem ];
            have := hP.1;
            rw [ Ideal.ext_iff ] at this;
            specialize this N; simp_all +decide [ Ideal.mem_span_singleton ] ;
          rw [ ringChar.eq_iff ];
          constructor;
          intro x; rw [ ← Nat.modEq_zero_iff_dvd ] ; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ] ;
          erw [ ZMod.natCast_eq_zero_iff ];
          erw [ Ideal.Quotient.eq_zero_iff_mem ] at *;
          constructor <;> intro hx;
          · have := hP.1;
            rw [ SetLike.ext_iff ] at this;
            specialize this x;
            simp_all +decide [ Ideal.mem_span_singleton, Ideal.mem_comap ];
            exact_mod_cast this;
          · obtain ⟨ k, rfl ⟩ := hx; simp +decide [ h_char, Ideal.mul_mem_right ] ;
        haveI := ringChar.of_eq h_char; simp +decide [ add_pow_char ] ;
      have h_frobenius_mul : ∀ (x y : Ok), (Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) x)) = (Ideal.Quotient.mk P x) ^ N → (Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) y)) = (Ideal.Quotient.mk P y) ^ N → (Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) (x + y))) = (Ideal.Quotient.mk P (x + y)) ^ N ∧ (Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) (x * y))) = (Ideal.Quotient.mk P (x * y)) ^ N := by
        intros x y hx hy; exact ⟨by
        convert h_frobenius_mul ( Ideal.Quotient.mk P x ) ( Ideal.Quotient.mk P y ) |>.1 using 1;
        · convert congr_arg₂ ( · + · ) hx hy using 1;
          · exact congr_arg _ ( map_add _ _ _ );
          · exact h_frobenius_mul _ _ |>.1;
        · convert h_frobenius_mul ( Ideal.Quotient.mk P x ) ( Ideal.Quotient.mk P y ) |>.1 using 1, by
          convert h_frobenius_mul ( Ideal.Quotient.mk P x ) ( Ideal.Quotient.mk P y ) |>.2 using 1;
          · convert congr_arg₂ ( · * · ) hx hy using 1;
            · exact congr_arg _ ( map_mul _ _ _ );
            · ring;
          · rw [ ← h_frobenius_mul ( Ideal.Quotient.mk P x ) ( Ideal.Quotient.mk P y ) |>.2 ];
            exact?⟩;
      exact h_frobenius_mul x y hx hy;
    -- Since Ok is generated by zeta_int (Ok_eq_adjoin), and the property holds for zeta_int (artin_property_zeta), it holds for all x.
    have h_generate : ∀ x ∈ Algebra.adjoin ℤ {zeta_int}, ((Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) x)) = (Ideal.Quotient.mk P x) ^ N) := by
      refine' fun x hx => Algebra.adjoin_induction _ _ _ _ hx;
      · exact fun x hx => by rw [ Set.mem_singleton_iff.mp hx ] ; exact artin_property_zeta N hN P hP;
      · intro r; erw [ map_intCast ] ; simp +decide [ pow_succ ] ;
        -- Since $P$ lies over $(N)$, we have $N \in P$.
        have hN_in_P : (N : Ok) ∈ P := by
          have := hP.1;
          exact Ideal.mem_comap.mp ( this ▸ Ideal.mem_span_singleton_self _ );
        erw [ Ideal.Quotient.eq ];
        -- Since $N$ is prime, we have $r^N \equiv r \pmod{N}$.
        have h_r_pow_N : (r : Ok) ^ N - r ∈ Ideal.span {(N : Ok)} := by
          rw [ Ideal.mem_span_singleton ];
          have h_r_pow_N : (r : ℤ) ^ N ≡ r [ZMOD N] := by
            haveI := Fact.mk ( Fact.out : Nat.Prime N ) ; simp +decide [ ← ZMod.intCast_eq_intCast_iff ] ;
          obtain ⟨ k, hk ⟩ := h_r_pow_N.symm.dvd;
          exact ⟨ k, by simpa [ ← @Int.cast_inj Ok ] using hk ⟩;
        simpa using P.neg_mem ( Ideal.span_le.mpr ( Set.singleton_subset_iff.mpr hN_in_P ) h_r_pow_N );
      · exact fun x y hx hy hx' hy' => h_subalgebra x y hx' hy' |>.1;
      · exact fun x y hx hy hx' hy' => h_subalgebra x y hx' hy' |>.2;
    convert h_generate x ?_;
    convert Ok_eq_adjoin ▸ Algebra.mem_top

/-
The polynomial f(X) = X^3 - 37X - 37.
-/
def f_poly : Polynomial ℤ := Polynomial.X^3 - 37 * Polynomial.X - 37

/-
P is a maximal ideal.
-/
theorem P_is_maximal (N : ℕ) [Fact (Nat.Prime N)] (P : Ideal Ok) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) : P.IsMaximal := by
  -- Since $P$ is a prime ideal in the ring of integers $Ok$ and $Ok$ is integral over $\mathbb{Z}$, $P$ must be maximal in $Ok$.
  have h_max : P.IsPrime → P ≠ ⊥ → P.IsMaximal := by
    exact?;
  refine h_max ‹_› ?_;
  intro h; have := hP.1; simp_all +decide [ Ideal.span_singleton_eq_bot ] ;

/-
The explicit Frobenius action on alpha_bar is given by the formulas (multiplied by 11 to avoid division).
-/
theorem explicit_frobenius (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 37) (hN11 : N ≠ 11)
  (P : Ideal Ok) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  let alpha_bar := Ideal.Quotient.mk P alpha_int
  let beta_bar := Ideal.Quotient.mk P beta_int
  let gamma_bar := Ideal.Quotient.mk P gamma_int
  ((N : ZMod 37) ∈ C1 → 11 * alpha_bar ^ N = 3 * alpha_bar ^ 2 - 10 * alpha_bar - 74) ∧
  ((N : ZMod 37) ∈ C2 → 11 * alpha_bar ^ N = -3 * alpha_bar ^ 2 - alpha_bar + 74) := by
    refine' ⟨ _, _ ⟩;
    · intro hN1
      have h_beta : Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) alpha_int) = Ideal.Quotient.mk P beta_int := by
        have h_beta : sigma_int (N_mod_37 N hN) alpha_int = beta_int := by
          convert global_permutation_int ( N_mod_37 N hN ) |>.1 _;
          exact?;
        rw [h_beta];
      have h_beta_eq : 11 * Ideal.Quotient.mk P beta_int = 3 * (Ideal.Quotient.mk P alpha_int)^2 - 10 * (Ideal.Quotient.mk P alpha_int) - 74 := by
        have h_beta_eq : 11 * beta_int = 3 * alpha_int^2 - 10 * alpha_int - 74 := by
          exact cyclic_relations_int.left;
        convert congr_arg ( Ideal.Quotient.mk P ) h_beta_eq using 1;
      have h_beta_eq : Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) alpha_int) = (Ideal.Quotient.mk P alpha_int)^N := by
        convert artin_property N hN P hP alpha_int using 1;
      aesop;
    · intro hN2
      have h_gamma_bar : (Ideal.Quotient.mk P gamma_int) = (Ideal.Quotient.mk P alpha_int)^N := by
        convert artin_property N hN P hP alpha_int using 1;
        rw [ global_permutation_int ( N_mod_37 N hN ) |>.2.1 ];
        convert hN2 using 1;
      convert congr_arg ( Ideal.Quotient.mk P ) ( congr_arg ( fun x : Ok => x : Ok → Ok ) ( show 11 * gamma_int = -3 * alpha_int^2 - alpha_int + 74 from ( cyclic_relations_int ) |>.2 ) ) using 1;
      simp +decide [ ← h_gamma_bar ];
      exact Or.inl rfl

/-
Definitions for the case q=79: Field K, zeta, subgroups H, C1, C2. We use g=3 as the generator for the cosets.
-/
abbrev Case79_K := CyclotomicField 79 ℚ
noncomputable def Case79_zeta : Case79_K := IsCyclotomicExtension.zeta 79 ℚ Case79_K
def Case79_H : Finset (ZMod 79) := ((Finset.univ : Finset (ZMod 79)).filter (fun x => x ≠ 0)).image (fun x => x^3)
def Case79_g : ZMod 79 := 3
def Case79_C1 : Finset (ZMod 79) := Case79_H.image (fun x => Case79_g * x)
def Case79_C2 : Finset (ZMod 79) := Case79_H.image (fun x => Case79_g^2 * x)

/-
Definitions of Gaussian periods and roots alpha, beta, gamma for q=79.
-/
noncomputable def Case79_eta (S : Finset (ZMod 79)) : Case79_K := ∑ x ∈ S, Case79_zeta^(x.val)
noncomputable def Case79_eta_0 := Case79_eta Case79_H
noncomputable def Case79_eta_1 := Case79_eta Case79_C1
noncomputable def Case79_eta_2 := Case79_eta Case79_C2

noncomputable def Case79_alpha := -(Case79_eta_2 - Case79_eta_1)
noncomputable def Case79_beta := -(Case79_eta_0 - Case79_eta_2)
noncomputable def Case79_gamma := -(Case79_eta_1 - Case79_eta_0)

/-
Evaluate the explicit elements of H, C1, C2 as natural numbers.
-/
#eval (Case79_H.image (fun x => x.val)).sort (· ≤ ·)
#eval (Case79_C1.image (fun x => x.val)).sort (· ≤ ·)
#eval (Case79_C2.image (fun x => x.val)).sort (· ≤ ·)

/-
The sum of the Gaussian periods is -1. This follows from the fact that they partition the non-zero elements and the sum of all non-trivial roots of unity is -1.
-/
lemma Case79_sum_eta : Case79_eta_0 + Case79_eta_1 + Case79_eta_2 = -1 := by
  -- Summing the elements of H, C1, and C2, we get the sum of all non-zero elements of ZMod 79.
  have sum_H_C1_C2 : ∑ x ∈ Finset.univ.filter (fun x : ZMod 79 => x ≠ 0), (Case79_zeta : Case79_K) ^ x.val = -1 := by
    -- The sum of all elements in the cyclotomic field is zero.
    have h_sum_all : ∑ x ∈ Finset.range 79, (Case79_zeta : Case79_K) ^ x = 0 := by
      rw [ geom_sum_eq ] <;> norm_num [ Case79_zeta ];
      · exact Or.inl ( sub_eq_zero_of_eq <| IsCyclotomicExtension.zeta_pow 79 ℚ Case79_K );
      · -- By definition of zeta, we know that zeta_79 is a primitive 79th root of unity.
        have h_primitive : IsPrimitiveRoot (IsCyclotomicExtension.zeta 79 ℚ Case79_K) 79 := by
          convert IsCyclotomicExtension.zeta_spec 79 ℚ Case79_K;
        exact h_primitive.ne_one ( by decide );
    rw [ Finset.sum_eq_sum_diff_singleton_add ( Finset.mem_range.mpr ( Nat.succ_pos _ ) ) ] at h_sum_all;
    convert eq_neg_of_add_eq_zero_left h_sum_all using 1;
    norm_num;
  -- Since these are the only non-zero elements in $ZMod 79$, we can partition the sum into the sums over $H$, $C1$, and $C2$.
  have h_partition : ∑ x ∈ Finset.univ.filter (fun x : ZMod 79 => x ≠ 0), (Case79_zeta : Case79_K) ^ x.val = ∑ x ∈ Case79_H, (Case79_zeta : Case79_K) ^ x.val + ∑ x ∈ Case79_C1, (Case79_zeta : Case79_K) ^ x.val + ∑ x ∈ Case79_C2, (Case79_zeta : Case79_K) ^ x.val := by
    rw [ ← Finset.sum_union, ← Finset.sum_union ];
    · congr with x ; simp +decide [ Case79_H, Case79_C1, Case79_C2 ];
      native_decide +revert;
    · native_decide;
    · exact Finset.disjoint_left.mpr ( by native_decide );
  exact h_partition.symm.trans sum_H_C1_C2

/-
The sum of the roots alpha, beta, gamma is zero. This follows immediately from their definitions as differences of the periods.
-/
lemma Case79_sum_roots_zero : Case79_alpha + Case79_beta + Case79_gamma = 0 := by
  -- By definition of Case79_alpha, Case79_beta, and Case79_gamma, we can write
  simp [Case79_alpha, Case79_beta, Case79_gamma]

/-
The non-zero elements of ZMod 79 are the disjoint union of H, C1, and C2.
-/
lemma Case79_units_decomp :
  let units := (Finset.univ : Finset (ZMod 79)).filter (fun x => x ≠ 0)
  units = Case79_H ∪ Case79_C1 ∪ Case79_C2 ∧
  Disjoint Case79_H Case79_C1 ∧ Disjoint Case79_H Case79_C2 ∧ Disjoint Case79_C1 Case79_C2 := by
    simp +decide [ Finset.disjoint_left ]

/-
Definitions of index function, cyclotomic numbers, and indexed periods. Also a lemma relating the index function to the cosets.
-/
def Case79_ind (x : ZMod 79) : ZMod 3 :=
  if x ∈ Case79_H then 0
  else if x ∈ Case79_C1 then 1
  else if x ∈ Case79_C2 then 2
  else 0

def Case79_cyc_num (i j : ZMod 3) : ℕ :=
  (Finset.univ.filter (fun x : ZMod 79 => x ≠ 0 ∧ x ≠ -1 ∧ Case79_ind x = i ∧ Case79_ind (x + 1) = j)).card

noncomputable def Case79_eta_idx (i : ZMod 3) : Case79_K :=
  if i = 0 then Case79_eta_0
  else if i = 1 then Case79_eta_1
  else Case79_eta_2

lemma Case79_eta_idx_0 : Case79_eta_idx 0 = Case79_eta_0 := by
  rfl
lemma Case79_eta_idx_1 : Case79_eta_idx 1 = Case79_eta_1 := by
  -- By definition of Case79_eta_idx, we have Case79_eta_idx 1 = Case79_eta_1.
  simp [Case79_eta_idx]
lemma Case79_eta_idx_2 : Case79_eta_idx 2 = Case79_eta_2 := by
  rfl

lemma Case79_ind_spec (x : ZMod 79) (hx : x ≠ 0) :
  (Case79_ind x = 0 ↔ x ∈ Case79_H) ∧
  (Case79_ind x = 1 ↔ x ∈ Case79_C1) ∧
  (Case79_ind x = 2 ↔ x ∈ Case79_C2) := by
    native_decide +revert

/-
Evaluate the cyclotomic numbers (i, j) for q=79.
-/
#eval Case79_cyc_num 0 0
#eval Case79_cyc_num 0 1
#eval Case79_cyc_num 0 2
#eval Case79_cyc_num 1 0
#eval Case79_cyc_num 1 1
#eval Case79_cyc_num 1 2
#eval Case79_cyc_num 2 0
#eval Case79_cyc_num 2 1
#eval Case79_cyc_num 2 2

/-
Multiplication table for the squares of the Gaussian periods.
Derived from the cyclotomic numbers:
eta_0^2 = (0,0)eta_0 + (2,2)eta_1 + (1,1)eta_2 + 26
eta_1^2 = (1,1)eta_0 + (0,0)eta_1 + (2,2)eta_2 + 26
eta_2^2 = (2,2)eta_0 + (1,1)eta_1 + (0,0)eta_2 + 26
with values (0,0)=6, (1,1)=10, (2,2)=9.
-/
lemma Case79_eta_sq_0 : Case79_eta_0 ^ 2 = 6 * Case79_eta_0 + 9 * Case79_eta_1 + 10 * Case79_eta_2 + 26 := by
  simp [Case79_eta, Case79_eta_0] at *;
  -- By expanding the sum of squares and using the properties of the cyclotomic numbers, we can show that the equation holds.
  have h_expand : ∑ x ∈ Case79_H, ∑ y ∈ Case79_H, Case79_zeta ^ (x.val + y.val) = 6 * ∑ x ∈ Case79_H, Case79_zeta ^ x.val + 9 * ∑ x ∈ Case79_C1, Case79_zeta ^ x.val + 10 * ∑ x ∈ Case79_C2, Case79_zeta ^ x.val + 26 := by
    -- We'll use the fact that $zeta^{a+b} = zeta^{a+b \mod 79}$ to simplify the exponents.
    have h_exp_mod : ∀ x y : ZMod 79, Case79_zeta^(x.val + y.val) = Case79_zeta^( (x.val + y.val) % 79 ) := by
      have h_exp : Case79_zeta ^ 79 = 1 := by
        convert IsCyclotomicExtension.zeta_pow _ _ _;
      exact fun x y => by rw [ ← Nat.mod_add_div ( x.val + y.val ) 79, pow_add, pow_mul ] ; aesop;
    rw [ Finset.sum_congr rfl fun x hx => Finset.sum_congr rfl fun y hy => h_exp_mod x y ];
    -- Let's simplify the expression by factoring out common terms and using the properties of the roots of unity.
    have h_simplify : ∑ x ∈ Case79_H, ∑ y ∈ Case79_H, Case79_zeta ^ ((x.val + y.val) % 79) = ∑ x ∈ Finset.univ.filter (fun x => x ≠ 0), (Finset.filter (fun y => y ∈ Case79_H ∧ (x - y) ∈ Case79_H) (Finset.univ.filter (fun y => y ≠ 0))).card * Case79_zeta ^ x.val + (Finset.filter (fun y => y ∈ Case79_H ∧ (-y) ∈ Case79_H) (Finset.univ.filter (fun y => y ≠ 0))).card := by
      have h_simplify : ∑ x ∈ Case79_H, ∑ y ∈ Case79_H, Case79_zeta ^ ((x.val + y.val) % 79) = ∑ x ∈ Finset.univ.filter (fun x => x ≠ 0), ∑ y ∈ Case79_H, (if (x - y) ∈ Case79_H then Case79_zeta ^ x.val else 0) + ∑ y ∈ Case79_H, (if (-y) ∈ Case79_H then 1 else 0) := by
        have h_simplify : ∀ y ∈ Case79_H, ∑ x ∈ Case79_H, Case79_zeta ^ ((x.val + y.val) % 79) = ∑ x ∈ Finset.univ.filter (fun x => x ≠ 0), (if (x - y) ∈ Case79_H then Case79_zeta ^ x.val else 0) + (if (-y) ∈ Case79_H then 1 else 0) := by
          intro y hy
          have h_simplify : ∑ x ∈ Case79_H, Case79_zeta ^ ((x.val + y.val) % 79) = ∑ x ∈ Finset.univ.filter (fun x => x ≠ 0), (if (x - y) ∈ Case79_H then Case79_zeta ^ x.val else 0) + (if (-y) ∈ Case79_H then 1 else 0) := by
            have h_sum : ∑ x ∈ Case79_H, Case79_zeta ^ ((x.val + y.val) % 79) = ∑ x ∈ Finset.image (fun x => x + y) Case79_H, Case79_zeta ^ x.val := by
              rw [ Finset.sum_image ];
              · exact Finset.sum_congr rfl fun x hx => by rw [ ZMod.val_add ] ; ;
              · exact fun x hx y hy hxy => by simpa using hxy;
            rw [ h_sum, ← Finset.sum_filter ];
            rw [ show ( Finset.image ( fun x => x + y ) Case79_H : Finset ( ZMod 79 ) ) = Finset.filter ( fun x => x - y ∈ Case79_H ) ( Finset.univ.filter ( fun x => x ≠ 0 ) ) ∪ if -y ∈ Case79_H then { 0 } else ∅ from ?_, Finset.sum_union ] <;> norm_num;
            · split_ifs <;> simp +decide [ * ];
            · split_ifs <;> simp +decide [ *, Finset.disjoint_left ];
              exact?;
            · ext x; simp [Finset.mem_preimage, Finset.mem_filter];
              split_ifs <;> simp_all +decide [ sub_eq_add_neg ];
              · grind;
              · grind +ring;
          convert h_simplify using 1;
        rw [ Finset.sum_comm, Finset.sum_congr rfl fun y hy => h_simplify y hy ];
        rw [ Finset.sum_add_distrib, Finset.sum_comm ];
      simp_all +decide [ Finset.sum_ite ];
      congr! 2;
      congr! 2;
      congr 1 with y ; simp +decide [ sub_eq_iff_eq_add ];
      exact fun hy₁ hy₂ => by rintro rfl; contradiction;
    rw [ h_simplify ];
    -- By evaluating the sum of the cardinalities, we can see that it matches the right-hand side of the equation.
    have h_card : ∑ x ∈ Finset.univ.filter (fun x => x ≠ 0), (Finset.filter (fun y => y ∈ Case79_H ∧ (x - y) ∈ Case79_H) (Finset.univ.filter (fun y => y ≠ 0))).card * Case79_zeta ^ x.val = 6 * ∑ x ∈ Case79_H, Case79_zeta ^ x.val + 9 * ∑ x ∈ Case79_C1, Case79_zeta ^ x.val + 10 * ∑ x ∈ Case79_C2, Case79_zeta ^ x.val := by
      have h_card : ∀ x ∈ Finset.univ.filter (fun x => x ≠ 0), (Finset.filter (fun y => y ∈ Case79_H ∧ (x - y) ∈ Case79_H) (Finset.univ.filter (fun y => y ≠ 0))).card = if x ∈ Case79_H then 6 else if x ∈ Case79_C1 then 9 else 10 := by
        native_decide +revert;
      rw [ Finset.sum_congr rfl fun x hx => by rw [ h_card x hx ] ] ; norm_num [ Finset.sum_ite ] ; ring;
      rw [ show ( Finset.filter ( fun x => x ∈ Case79_H ) ( Finset.filter ( fun x => ¬x = 0 ) Finset.univ ) ) = Case79_H from ?_, show ( Finset.filter ( fun x => x ∈ Case79_C1 ) ( Finset.filter ( fun x => ¬x = 0 ) Finset.univ |> Finset.filter ( fun x => ¬x ∈ Case79_H ) ) ) = Case79_C1 from ?_, show ( Finset.filter ( fun x => ¬x ∈ Case79_C1 ) ( Finset.filter ( fun x => ¬x = 0 ) Finset.univ |> Finset.filter ( fun x => ¬x ∈ Case79_H ) ) ) = Case79_C2 from ?_ ] <;> norm_num [ Finset.sum_mul _ _ _ ];
      · native_decide +revert;
      · native_decide +revert;
      · native_decide +revert;
    rw [ h_card ];
    simp +zetaDelta at *;
    exact_mod_cast by native_decide;
  convert h_expand using 1 ; ring!;
  simp +decide only [pow_two, ← Finset.mul_sum _ _ _, ← Finset.sum_mul]
lemma Case79_eta_sq_1 : Case79_eta_1 ^ 2 = 10 * Case79_eta_0 + 6 * Case79_eta_1 + 9 * Case79_eta_2 + 26 := by
  -- Expand the product using the distributive property.
  have h_expand : ∑ x ∈ Case79_C1, ∑ y ∈ Case79_C1, ((Case79_zeta : Case79_K) : Case79_K) ^ (x.val + y.val) = ∑ x ∈ Case79_C1, ∑ y ∈ Case79_C1, ((Case79_zeta : Case79_K) : Case79_K) ^ ((x + y).val) := by
    refine' Finset.sum_congr rfl fun x hx => Finset.sum_congr rfl fun y hy => _;
    -- Since $x$ and $y$ are elements of $ZMod 79$, their values are between $0$ and $78$. Adding them together and taking modulo $79$ gives the same result as adding their values directly.
    have h_mod : (x.val + y.val) % 79 = (x + y).val := by
      native_decide +revert;
    rw [ ← h_mod, ← Nat.mod_add_div ( x.val + y.val ) 79, pow_add, pow_mul ] ; norm_num [ show Case79_zeta ^ 79 = 1 from by { exact ( IsCyclotomicExtension.zeta_pow 79 ℚ _ ) } ];
  -- By partitioning the sum over pairs (x, y) in C1 based on the value of (x + y) modulo 79, we can express the double sum as a sum over the cosets H, C1, and C2.
  have h_partition : ∑ x ∈ Case79_C1, ∑ y ∈ Case79_C1, ((Case79_zeta : Case79_K) : Case79_K) ^ ((x + y).val) = ∑ k ∈ Finset.range 79, (Finset.filter (fun p => (p.1 + p.2 : ZMod 79) = k) (Case79_C1 ×ˢ Case79_C1)).card * ((Case79_zeta : Case79_K) : Case79_K) ^ k := by
    have h_partition : ∑ x ∈ Case79_C1, ∑ y ∈ Case79_C1, ((Case79_zeta : Case79_K) : Case79_K) ^ ((x + y).val) = ∑ k ∈ Finset.range 79, ∑ p ∈ Finset.filter (fun p => (p.1 + p.2 : ZMod 79) = k) (Case79_C1 ×ˢ Case79_C1), ((Case79_zeta : Case79_K) : Case79_K) ^ k := by
      have h_partition : ∑ x ∈ Case79_C1, ∑ y ∈ Case79_C1, ((Case79_zeta : Case79_K) : Case79_K) ^ ((x + y).val) = ∑ p ∈ Case79_C1 ×ˢ Case79_C1, ((Case79_zeta : Case79_K) : Case79_K) ^ ((p.1 + p.2).val) := by
        erw [ Finset.sum_product ];
      rw [ h_partition, Finset.sum_sigma' ];
      refine' Finset.sum_bij ( fun p hp => ⟨ ( p.1 + p.2 : ZMod 79 ).val, p ⟩ ) _ _ _ _ <;> simp +contextual;
      · exact fun a b ha hb => ZMod.val_lt _;
      · exact fun b hb₁ hb₂ hb₃ hb₄ => ⟨ _, _, ⟨ hb₂, hb₃ ⟩, by aesop ⟩;
    simp_all +decide [ Finset.sum_filter ];
  -- By definition of $Case79_eta_0$, $Case79_eta_1$, and $Case79_eta_2$, we can rewrite the right-hand side of the equation.
  have h_rhs : 10 * Case79_eta_0 + 6 * Case79_eta_1 + 9 * Case79_eta_2 + 26 = ∑ k ∈ Finset.range 79, (if k = 0 then 26 else if (k : ZMod 79) ∈ Case79_H then 10 else if (k : ZMod 79) ∈ Case79_C1 then 6 else 9) * ((Case79_zeta : Case79_K) : Case79_K) ^ k := by
    unfold Case79_eta_0 Case79_eta_1 Case79_eta_2; norm_num [ Finset.sum_add_distrib, Finset.mul_sum _ _ _ ] ; ring;
    unfold Case79_eta; simp +decide [ Finset.sum_ite ] ; ring;
    rw [ show ( Case79_H : Finset ( ZMod 79 ) ) = Finset.image ( fun x : ℕ => x : ℕ → ZMod 79 ) ( Finset.filter ( fun x : ℕ => ( x : ZMod 79 ) ∈ Case79_H ) ( Finset.range 79 ) ) from ?_, show ( Case79_C1 : Finset ( ZMod 79 ) ) = Finset.image ( fun x : ℕ => x : ℕ → ZMod 79 ) ( Finset.filter ( fun x : ℕ => ( x : ZMod 79 ) ∈ Case79_C1 ) ( Finset.range 79 ) ) from ?_, show ( Case79_C2 : Finset ( ZMod 79 ) ) = Finset.image ( fun x : ℕ => x : ℕ → ZMod 79 ) ( Finset.filter ( fun x : ℕ => ( x : ZMod 79 ) ∈ Case79_C2 ) ( Finset.range 79 ) ) from ?_ ] ; simp +decide [ Finset.sum_image ] ; ring;
    · simp +decide [ Finset.sum_mul _ _ _ ];
      congr! 2;
      · refine' congr rfl ( Finset.sum_bij ( fun x hx => x.val ) _ _ _ _ ) <;> simp +decide;
        · rintro a x hx hx' rfl; exact ⟨ ⟨ by interval_cases x <;> trivial, by interval_cases x <;> trivial ⟩, x, ⟨ hx, hx' ⟩, rfl ⟩ ;
        · grind;
      · refine' Finset.sum_bij ( fun x hx => x.val ) _ _ _ _ <;> simp +decide;
        · rintro a x hx₁ hx₂ rfl; refine' ⟨ _, x, ⟨ hx₁, hx₂ ⟩, rfl ⟩ ; simp +decide [ hx₁, hx₂ ] ;
          native_decide +revert;
        · grind;
    · native_decide +revert;
    · native_decide +revert;
    · native_decide +revert;
  -- By definition of $Case79_eta_1$, we can rewrite the left-hand side of the equation.
  have h_lhs : Case79_eta_1 ^ 2 = ∑ x ∈ Case79_C1, ∑ y ∈ Case79_C1, ((Case79_zeta : Case79_K) : Case79_K) ^ (x.val + y.val) := by
    simp +decide only [Case79_eta_1, sq];
    simp +decide only [Case79_eta, Finset.sum_mul _ _ _];
    simp +decide only [Finset.mul_sum _ _ _, pow_add];
  rw [h_lhs, h_expand, h_partition, h_rhs];
  refine' Finset.sum_congr rfl fun k hk => _;
  rw [ show ( Finset.filter ( fun p : ZMod 79 × ZMod 79 => p.1 + p.2 = ↑k ) ( Case79_C1 ×ˢ Case79_C1 ) ) = Finset.filter ( fun p : ZMod 79 × ZMod 79 => p.1 + p.2 = ↑k ) ( Case79_C1 ×ˢ Case79_C1 ) from rfl, show ( Finset.filter ( fun p : ZMod 79 × ZMod 79 => p.1 + p.2 = ↑k ) ( Case79_C1 ×ˢ Case79_C1 ) ).card = if k = 0 then 26 else if ( k : ZMod 79 ) ∈ Case79_H then 10 else if ( k : ZMod 79 ) ∈ Case79_C1 then 6 else 9 from ?_ ];
  · split_ifs <;> norm_num;
  · native_decide +revert
lemma Case79_eta_sq_2 : Case79_eta_2 ^ 2 = 9 * Case79_eta_0 + 10 * Case79_eta_1 + 6 * Case79_eta_2 + 26 := by
  unfold Case79_eta_2 Case79_eta_0 Case79_eta_1;
  unfold Case79_eta;
  -- By definition of $C2$, we can expand the square of the sum.
  have h_expand : (∑ x ∈ Case79_C2.image (fun x => x.val), Case79_zeta ^ x) ^ 2 = ∑ x ∈ Case79_C2.image (fun x => x.val), ∑ y ∈ Case79_C2.image (fun x => x.val), Case79_zeta ^ (x + y) := by
    simp +decide only [sq, pow_add, ← Finset.mul_sum _ _ _, ← Finset.sum_mul];
  -- Let's simplify the expression $\sum_{x \in C2} \sum_{y \in C2} \zeta^{x+y}$ by considering the possible values of $x+y \mod 79$.
  have h_simplify : ∑ x ∈ Case79_C2.image (fun x => x.val), ∑ y ∈ Case79_C2.image (fun x => x.val), Case79_zeta ^ (x + y) = ∑ x ∈ Finset.range 79, (Finset.card (Finset.filter (fun p => p.1 + p.2 ≡ x [MOD 79]) (Case79_C2.image (fun x => x.val) ×ˢ Case79_C2.image (fun x => x.val)))) * Case79_zeta ^ x := by
    have h_simplify : ∑ x ∈ Case79_C2.image (fun x => x.val), ∑ y ∈ Case79_C2.image (fun x => x.val), Case79_zeta ^ (x + y) = ∑ x ∈ Finset.range 79, ∑ p ∈ Finset.filter (fun p => p.1 + p.2 ≡ x [MOD 79]) (Case79_C2.image (fun x => x.val) ×ˢ Case79_C2.image (fun x => x.val)), Case79_zeta ^ x := by
      have h_simplify : ∑ x ∈ Case79_C2.image (fun x => x.val), ∑ y ∈ Case79_C2.image (fun x => x.val), Case79_zeta ^ (x + y) = ∑ p ∈ Finset.image (fun x => x.val) Case79_C2 ×ˢ Finset.image (fun x => x.val) Case79_C2, Case79_zeta ^ (p.1 + p.2) := by
        rw [ Finset.sum_product ];
      rw [ h_simplify, Finset.sum_sigma' ];
      refine' Finset.sum_bij ( fun p hp => ⟨ ( p.1 + p.2 ) % 79, p ⟩ ) _ _ _ _ <;> simp +contextual;
      · exact fun a b x hx hx' y hy hy' => ⟨ Nat.mod_lt _ ( by decide ), Nat.ModEq.symm ( Nat.mod_modEq _ _ ) ⟩;
      · exact fun b hb x hx hx' y hy hy' h => ⟨ _, _, ⟨ ⟨ x, hx, hx' ⟩, ⟨ y, hy, hy' ⟩ ⟩, by simp +decide [ Nat.ModEq, Nat.mod_eq_of_lt hb ] at h ⊢; aesop ⟩;
      · intro a b x hx ha y hy hb; rw [ ← Nat.mod_add_div ( a + b ) 79 ] ; norm_num [ pow_add, pow_mul, Nat.mul_mod, Nat.pow_mod ] ;
        have h_zeta_79 : Case79_zeta ^ 79 = 1 := by
          exact IsCyclotomicExtension.zeta_pow _ _ _;
        rw [ h_zeta_79, one_pow, mul_one ];
    simp_all +decide [ Finset.sum_filter ];
  -- Let's simplify the expression $\sum_{x=0}^{78} \text{card}(\{p \in C2 \times C2 \mid p.1 + p.2 \equiv x \pmod{79}\}) \zeta^x$.
  have h_card : ∑ x ∈ Finset.range 79, (Finset.card (Finset.filter (fun p => p.1 + p.2 ≡ x [MOD 79]) (Case79_C2.image (fun x => x.val) ×ˢ Case79_C2.image (fun x => x.val)))) * Case79_zeta ^ x = ∑ x ∈ Finset.range 79, (if x = 0 then 26 else if x ∈ Case79_H.image (fun x => x.val) then 9 else if x ∈ Case79_C1.image (fun x => x.val) then 10 else 6) * Case79_zeta ^ x := by
    refine' Finset.sum_congr rfl fun x hx => _;
    exact congr_arg₂ _ ( mod_cast by revert x; native_decide ) rfl;
  convert h_expand.trans ( h_simplify.trans h_card ) using 1;
  simp +decide [ Finset.sum_ite, Finset.filter_ne', Finset.filter_eq' ];
  rw [ show ( Finset.filter ( fun x => ∃ a ∈ Case79_H, a.val = x ) ( Finset.erase ( Finset.range 79 ) 0 ) ) = Case79_H.image ( fun x => x.val ) from ?_, show ( Finset.filter ( fun x => ∃ a ∈ Case79_C1, a.val = x ) ( Finset.filter ( fun x => ∀ x_1 ∈ Case79_H, ¬x_1.val = x ) ( Finset.erase ( Finset.range 79 ) 0 ) ) ) = Case79_C1.image ( fun x => x.val ) from ?_, show ( Finset.filter ( fun x => ∀ x_1 ∈ Case79_C1, ¬x_1.val = x ) ( Finset.filter ( fun x => ∀ x_1 ∈ Case79_H, ¬x_1.val = x ) ( Finset.erase ( Finset.range 79 ) 0 ) ) ) = Case79_C2.image ( fun x => x.val ) from ?_ ];
  · rw [ Finset.sum_image, Finset.sum_image, Finset.sum_image ] <;> norm_num [ Finset.sum_add_distrib, mul_add, add_assoc, add_left_comm, add_comm ];
    · rw [ Finset.mul_sum _ _ _, Finset.mul_sum _ _ _, Finset.mul_sum _ _ _ ];
    · native_decide +revert;
    · native_decide +revert;
    · native_decide +revert;
  · native_decide +revert;
  · native_decide +revert;
  · native_decide +revert

/-
Multiplication table for the mixed products of the Gaussian periods.
Derived from the cyclotomic numbers:
eta_0 * eta_1 = (1,0)eta_0 + (1,1)eta_1 + (1,2)eta_2
eta_0 * eta_2 = (2,0)eta_0 + (2,1)eta_1 + (2,2)eta_2
eta_1 * eta_2 = (1,2)eta_0 + (1,0)eta_1 + (1,1)eta_2
with values (1,0)=9, (1,1)=10, (1,2)=7, (2,0)=10, (2,1)=7, (2,2)=9.
The constant terms are 0 because -1 is in H (index 0), so x+y=0 implies x,y in same coset, but here they are in different cosets.
-/
lemma Case79_eta_mul_01 : Case79_eta_0 * Case79_eta_1 = 9 * Case79_eta_0 + 10 * Case79_eta_1 + 7 * Case79_eta_2 := by
  -- By definition of $Case79_eta_0$, $Case79_eta_1$, and $Case79_eta_2$, we can write
  have h_expand : Case79_eta_0 * Case79_eta_1 = ∑ x ∈ Case79_H, ∑ y ∈ Case79_C1, Case79_zeta^(x.val + y.val) := by
    simp +decide only [pow_add, ← Finset.mul_sum, ← Finset.sum_mul];
    rfl;
  -- Group the terms in the sum according to the value of $x + y$ modulo 79.
  have h_group : ∑ x ∈ Case79_H, ∑ y ∈ Case79_C1, Case79_zeta^(x.val + y.val) = ∑ k ∈ Finset.univ.filter (fun k : ZMod 79 => k ≠ 0), (Finset.card (Finset.filter (fun p : ZMod 79 × ZMod 79 => p.1 ∈ Case79_H ∧ p.2 ∈ Case79_C1 ∧ p.1 + p.2 = k) (Finset.univ : Finset (ZMod 79 × ZMod 79)))) • Case79_zeta^k.val := by
    have h_group : ∑ x ∈ Case79_H, ∑ y ∈ Case79_C1, Case79_zeta^(x.val + y.val) = ∑ k ∈ Finset.image (fun p : ZMod 79 × ZMod 79 => p.1 + p.2) (Case79_H ×ˢ Case79_C1), (Finset.card (Finset.filter (fun p : ZMod 79 × ZMod 79 => p.1 ∈ Case79_H ∧ p.2 ∈ Case79_C1 ∧ p.1 + p.2 = k) (Finset.univ : Finset (ZMod 79 × ZMod 79)))) • Case79_zeta^k.val := by
      rw [ Finset.sum_image' ];
      rw [ Finset.sum_product ];
      rotate_left;
      use fun p => Case79_zeta ^ ( p.1 + p.2 |> ZMod.val );
      · simp +contextual [ Finset.sum_filter ];
        simp +contextual [ Finset.sum_ite ];
        exact fun a b ha hb => Or.inl <| congr_arg Finset.card <| by ext; aesop;
      · refine' Finset.sum_congr rfl fun x hx => Finset.sum_congr rfl fun y hy => _;
        rw [ ← pow_mod_orderOf ];
        rw [ show orderOf Case79_zeta = 79 from ?_ ];
        · exact?;
        · have h_order : IsPrimitiveRoot Case79_zeta 79 := by
            convert IsCyclotomicExtension.zeta_spec 79 ℚ Case79_K;
          exact?;
    rw [ h_group ];
    refine' Finset.sum_subset _ _ <;> simp +contextual [ Finset.subset_iff ];
    rintro _ x y hx hy rfl; revert x; revert y; native_decide;
  -- By definition of $Case79_eta_0$, $Case79_eta_1$, and $Case79_eta_2$, we can rewrite the right-hand side of the equation.
  have h_rhs : 9 * Case79_eta_0 + 10 * Case79_eta_1 + 7 * Case79_eta_2 = ∑ k ∈ Finset.univ.filter (fun k : ZMod 79 => k ≠ 0), (if k ∈ Case79_H then 9 else if k ∈ Case79_C1 then 10 else 7) • Case79_zeta^k.val := by
    simp +decide [ Finset.sum_ite, Case79_eta_0, Case79_eta_1, Case79_eta_2 ];
    simp +decide [ Finset.sum_filter, Case79_eta ];
    simp +decide [ Finset.sum_ite, Finset.filter_ne', Finset.filter_and, Finset.filter_or, Finset.sum_add_distrib, Finset.mul_sum _ _ _ ];
    rw [ show ( Finset.univ.erase 0 : Finset ( ZMod 79 ) ) = Case79_H ∪ Case79_C1 ∪ Case79_C2 from by native_decide ] ; simp +decide [ Finset.sum_union, Finset.sum_erase ] ;
    exact?;
  rw [ h_expand, h_group, h_rhs ];
  refine' Finset.sum_congr rfl fun x hx => _;
  split_ifs <;> norm_num;
  · exact Or.inl <| mod_cast by revert x; native_decide;
  · exact Or.inl <| mod_cast by revert x; native_decide;
  · exact Or.inl <| mod_cast by revert x; native_decide;
lemma Case79_eta_mul_02 : Case79_eta_0 * Case79_eta_2 = 10 * Case79_eta_0 + 7 * Case79_eta_1 + 9 * Case79_eta_2 := by
  -- Let's simplify the expression using the definitions of the Gaussian periods.
  have h_simp : (Case79_eta_0 + Case79_eta_1 + Case79_eta_2)^2 = Case79_eta_0^2 + Case79_eta_1^2 + Case79_eta_2^2 + 2 * (Case79_eta_0 * Case79_eta_1 + Case79_eta_0 * Case79_eta_2 + Case79_eta_1 * Case79_eta_2) := by
    ring;
  rw [ Case79_eta_sq_0, Case79_eta_sq_1, Case79_eta_sq_2, Case79_sum_eta ] at h_simp;
  have := Case79_eta_sq_0; ( have := Case79_eta_sq_1; ( have := Case79_eta_sq_2; ( ring_nf at *; ) ) );
  grind +ring
lemma Case79_eta_mul_12 : Case79_eta_1 * Case79_eta_2 = 7 * Case79_eta_0 + 9 * Case79_eta_1 + 10 * Case79_eta_2 := by
  -- Substitute the cyclotomic number (1,2)=7 into the equation.
  have h_cyclotomic_12 : ∑ x ∈ Case79_C1, ∑ y ∈ Case79_C2, (Case79_zeta : Case79_K)^(x.val + y.val) = ∑ i ∈ Case79_H, 7 * (Case79_zeta : Case79_K)^i.val + ∑ i ∈ Case79_C1, 9 * (Case79_zeta : Case79_K)^i.val + ∑ i ∈ Case79_C2, 10 * (Case79_zeta : Case79_K)^i.val := by
    -- By definition of $C1$ and $C2$, we can rewrite the double sum as a sum over the products of elements in $C1$ and $C2$.
    have h_double_sum : ∑ x ∈ Case79_C1, ∑ y ∈ Case79_C2, (Case79_zeta : Case79_K)^(x.val + y.val) = ∑ z ∈ Finset.image (fun p : ZMod 79 × ZMod 79 => p.1 + p.2) (Case79_C1 ×ˢ Case79_C2), (Finset.filter (fun p => p.1 + p.2 = z) (Case79_C1 ×ˢ Case79_C2)).card * (Case79_zeta : Case79_K)^z.val := by
      rw [ Finset.sum_image' ];
      rw [ Finset.sum_product ];
      rotate_left;
      use fun p => Case79_zeta ^ ( p.1 + p.2 ).val;
      · simp +contextual [ Finset.sum_filter ];
        simp +contextual [ Finset.sum_ite ];
      · refine' Finset.sum_congr rfl fun x hx => Finset.sum_congr rfl fun y hy => _;
        rw [ ← Nat.mod_add_div ( x.val + y.val ) 79, pow_add, pow_mul ] ; norm_num [ pow_mul, pow_add, pow_one, pow_zero, mul_assoc, mul_left_comm, mul_comm ];
        erw [ show Case79_zeta ^ 79 = 1 from ?_ ] ; aesop;
        have h_zeta_79 : IsPrimitiveRoot Case79_zeta 79 := by
          convert IsCyclotomicExtension.zeta_spec 79 ℚ ( CyclotomicField 79 ℚ ) using 1;
        exact h_zeta_79.pow_eq_one;
    rw [ h_double_sum ];
    rw [ show ( Finset.image ( fun p : ZMod 79 × ZMod 79 => p.1 + p.2 ) ( Case79_C1 ×ˢ Case79_C2 ) ) = Case79_H ∪ Case79_C1 ∪ Case79_C2 from ?_, Finset.sum_union, Finset.sum_union ];
    · refine' congrArg₂ _ ( congrArg₂ _ ( Finset.sum_congr rfl fun x hx => _ ) ( Finset.sum_congr rfl fun x hx => _ ) ) ( Finset.sum_congr rfl fun x hx => _ ) <;> norm_num;
      · exact Or.inl <| mod_cast by fin_cases hx <;> native_decide;
      · exact Or.inl <| mod_cast by revert x hx; native_decide;;
      · exact Or.inl <| mod_cast by revert x hx; native_decide;;
    · native_decide;
    · native_decide;
    · native_decide +revert;
  convert h_cyclotomic_12 using 1;
  · unfold Case79_eta_1 Case79_eta_2; simp +decide only [pow_add] ;
    simp +decide only [Case79_eta, Finset.sum_mul _ _ _];
    simp +decide only [Finset.mul_sum _ _ _];
  · unfold Case79_eta_0 Case79_eta_1 Case79_eta_2;
    unfold Case79_eta; simp +decide [ Finset.mul_sum _ _ _ ] ;

/-
The algebraic relation for beta in terms of alpha for q=79: 17*beta = -3*alpha^2 - 4*alpha + 158.
Proof uses the multiplication table of Gaussian periods.
-/
theorem Case79_relation_beta : 17 * Case79_beta = -3 * Case79_alpha^2 - 4 * Case79_alpha + 158 := by
  unfold Case79_alpha Case79_beta;
  -- Substitute the multiplication table results into the equation.
  have h_sub : 17 * (-(Case79_eta_0 - Case79_eta_2)) = -3 * (Case79_eta_2^2 - 2 * Case79_eta_1 * Case79_eta_2 + Case79_eta_1^2) - 4 * (-(Case79_eta_2 - Case79_eta_1)) + 158 := by
    norm_num [ Case79_eta_sq_0, Case79_eta_sq_1, Case79_eta_sq_2, Case79_eta_mul_01, Case79_eta_mul_02, Case79_eta_mul_12 ] ; ring;
    rw [ show Case79_eta_2 = -1 - Case79_eta_0 - Case79_eta_1 by linear_combination' Case79_sum_eta ] ; ring;
    rw [ show Case79_eta_1 ^ 2 = 10 * Case79_eta_0 + 6 * Case79_eta_1 + 9 * Case79_eta_2 + 26 by exact Case79_eta_sq_1 ] ; rw [ show Case79_eta_2 = -1 - Case79_eta_0 - Case79_eta_1 by linear_combination' Case79_sum_eta ] ; ring;
    rw [ show Case79_eta_0 * Case79_eta_1 = 9 * Case79_eta_0 + 10 * Case79_eta_1 + 7 * Case79_eta_2 by exact Case79_eta_mul_01 ] ; rw [ show Case79_eta_2 = -1 - Case79_eta_0 - Case79_eta_1 by linear_combination' Case79_sum_eta ] ; ring;
  convert h_sub using 1 ; ring

/-
The algebraic relation for gamma in terms of alpha for q=79: 17*gamma = 3*alpha^2 - 13*alpha - 158.
Proof uses the multiplication table of Gaussian periods and the relation alpha + beta + gamma = 0 (implicitly via the eta sums).
-/
theorem Case79_relation_gamma : 17 * Case79_gamma = 3 * Case79_alpha^2 - 13 * Case79_alpha - 158 := by
  -- Substitute the definitions of Case79_alpha, Case79_beta, and Case79_gamma into the equation.
  have h_sub : 17 * (-(Case79_eta_1 - Case79_eta_0)) = 3 * (-(Case79_eta_2 - Case79_eta_1))^2 - 13 * (-(Case79_eta_2 - Case79_eta_1)) - 158 := by
    ring_nf at *;
    rw [ Case79_eta_sq_1, Case79_eta_sq_2, Case79_eta_mul_12 ] ; ring;
    rw [ show Case79_eta_2 = -Case79_eta_0 - Case79_eta_1 - 1 by linear_combination' Case79_sum_eta ] ; ring;
  exact?

/-
Define the Galois automorphism sigma_n and prove it maps zeta to zeta^n.
-/
theorem Case79_h_irr : Irreducible (Polynomial.cyclotomic 79 ℚ) := by
  exact Polynomial.cyclotomic.irreducible_rat ( by decide )

noncomputable def Case79_sigma (n : (ZMod 79)ˣ) : Case79_K ≃ₐ[ℚ] Case79_K :=
  (IsCyclotomicExtension.autEquivPow Case79_K Case79_h_irr).symm n

theorem Case79_sigma_zeta (n : (ZMod 79)ˣ) : Case79_sigma n Case79_zeta = Case79_zeta^(n : ZMod 79).val := by
  -- By definition of Case79_sigma, we know that it is the same as sigma n in the cyclotomic field.
  have h_sigma_eq : Case79_sigma n = (IsCyclotomicExtension.autEquivPow (CyclotomicField 79 ℚ) (by
  exact Polynomial.cyclotomic.irreducible_rat <| by decide;)).symm n := by
    unfold Case79_sigma; aesop;
  generalize_proofs at *;
  convert h_sigma_eq using 1;
  constructor <;> intro h <;> simp_all +decide [ IsCyclotomicExtension.autEquivPow ];
  erw [ PowerBasis.equivOfMinpoly_apply ];
  erw [ PowerBasis.lift_gen ] ; aesop

/-
If n is in H, then sigma_n fixes eta_0, eta_1, eta_2.
Proof idea: sigma_n(eta(S)) = eta(n*S). If n in H, then n*H=H, n*C1=C1, n*C2=C2.
These set equalities can be checked by computation since q=79 is small.
-/
lemma Case79_sigma_eta_H (n : (ZMod 79)ˣ) (hn : (n : ZMod 79) ∈ Case79_H) :
  Case79_sigma n Case79_eta_0 = Case79_eta_0 ∧
  Case79_sigma n Case79_eta_1 = Case79_eta_1 ∧
  Case79_sigma n Case79_eta_2 = Case79_eta_2 := by
    -- Since $n \in H$, we have $n * H = H$, $n * C1 = C1$, and $n * C2 = C2$.
    have h_cosets : ∀ x ∈ Case79_H, n * x ∈ Case79_H ∧ ∀ x ∈ Case79_C1, n * x ∈ Case79_C1 ∧ ∀ x ∈ Case79_C2, n * x ∈ Case79_C2 := by
      revert n hn;
      simp +decide [ Case79_H, Case79_C1, Case79_C2 ];
      intros n x hx hx' a ha;
      refine' ⟨ _, _ ⟩;
      · native_decide +revert;
      · native_decide +revert;
    -- Since $n \in H$, we have $n * H = H$, $n * C1 = C1$, and $n * C2 = C2$. Therefore, $\sigma_n(\eta_i) = \eta_i$ for $i = 0, 1, 2$.
    have h_sigma_eta : ∀ S : Finset (ZMod 79), (∀ x ∈ S, n * x ∈ S) → (Case79_sigma n) (∑ x ∈ S, Case79_zeta^(x.val)) = ∑ x ∈ S, Case79_zeta^(x.val) := by
      intro S hS
      have h_sigma_eta : (Case79_sigma n) (∑ x ∈ S, Case79_zeta^(x.val)) = ∑ x ∈ S, Case79_zeta^(n * x).val := by
        simp +decide [ Case79_sigma_zeta ];
        refine' Finset.sum_congr rfl fun x hx => _;
        rw [ ← pow_mul, ZMod.val_mul ];
        rw [ ← Nat.mod_add_div ( ( n : ZMod 79 ).val * x.val ) 79, pow_add, pow_mul ] ; norm_num [ Case79_zeta ];
        erw [ IsCyclotomicExtension.zeta_pow ] ; norm_num;
      -- Since $n \in H$, we have $n * H = H$, $n * C1 = C1$, and $n * C2 = C2$. Therefore, $\sigma_n(\eta_i) = \eta_i$ for $i = 0, 1, 2$ by definition of $H$, $C1$, and $C2$.
      have h_sigma_eta_eq : Finset.image (fun x : ZMod 79 => (n * x : ZMod 79)) S = S := by
        refine' Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr hS ) _;
        rw [ Finset.card_image_of_injective _ fun x y hxy => by simpa using hxy ];
      conv_rhs => rw [ ← h_sigma_eta_eq, Finset.sum_image ( Finset.card_image_iff.mp <| by aesop ) ] ;
      convert h_sigma_eta using 1;
    refine' ⟨ h_sigma_eta Case79_H _, h_sigma_eta Case79_C1 _, h_sigma_eta Case79_C2 _ ⟩;
    · exact fun x hx => h_cosets x hx |>.1;
    · exact fun x hx => h_cosets _ hn |>.2 _ hx |>.1;
    · exact fun x hx => h_cosets _ hn |>.2 _ ( Classical.choose_spec ( Finset.card_pos.mp ( by native_decide ) ) ) |>.2 _ hx

/-
Lemmas stating that multiplication by an element of H stabilizes H, C1, and C2.
These are proved by checking all cases (native_decide).
-/
lemma Case79_perm_H_H (n : ZMod 79) (hn : n ∈ Case79_H) (x : ZMod 79) (hx : x ∈ Case79_H) : n * x ∈ Case79_H := by
  revert n x
  native_decide

lemma Case79_perm_H_C1 (n : ZMod 79) (hn : n ∈ Case79_H) (x : ZMod 79) (hx : x ∈ Case79_C1) : n * x ∈ Case79_C1 := by
  revert n x
  native_decide

lemma Case79_perm_H_C2 (n : ZMod 79) (hn : n ∈ Case79_H) (x : ZMod 79) (hx : x ∈ Case79_C2) : n * x ∈ Case79_C2 := by
  revert n x
  native_decide

/-
Lemmas: Multiplication by n in C1 permutes the cosets: H->C1, C1->C2, C2->H.
-/
lemma Case79_perm_C1_H (n : ZMod 79) (hn : n ∈ Case79_C1) (x : ZMod 79) (hx : x ∈ Case79_H) : n * x ∈ Case79_C1 := by
  revert n x
  native_decide

lemma Case79_perm_C1_C1 (n : ZMod 79) (hn : n ∈ Case79_C1) (x : ZMod 79) (hx : x ∈ Case79_C1) : n * x ∈ Case79_C2 := by
  revert n x
  native_decide

lemma Case79_perm_C1_C2 (n : ZMod 79) (hn : n ∈ Case79_C1) (x : ZMod 79) (hx : x ∈ Case79_C2) : n * x ∈ Case79_H := by
  revert n x
  native_decide

/-
Lemmas: Multiplication by n in C2 permutes the cosets: H->C2, C1->H, C2->C1.
-/
lemma Case79_perm_C2_H (n : ZMod 79) (hn : n ∈ Case79_C2) (x : ZMod 79) (hx : x ∈ Case79_H) : n * x ∈ Case79_C2 := by
  revert n x
  native_decide

lemma Case79_perm_C2_C1 (n : ZMod 79) (hn : n ∈ Case79_C2) (x : ZMod 79) (hx : x ∈ Case79_C1) : n * x ∈ Case79_H := by
  revert n x
  native_decide

lemma Case79_perm_C2_C2 (n : ZMod 79) (hn : n ∈ Case79_C2) (x : ZMod 79) (hx : x ∈ Case79_C2) : n * x ∈ Case79_C1 := by
  revert n x
  native_decide

/-
Lemma: If n is in C1, then sigma_n permutes eta_0 -> eta_1 -> eta_2 -> eta_0.
Proof uses the fact that n*H=C1, n*C1=C2, n*C2=H.
-/
lemma Case79_sigma_eta_C1 (n : (ZMod 79)ˣ) (hn : (n : ZMod 79) ∈ Case79_C1) :
  Case79_sigma n Case79_eta_0 = Case79_eta_1 ∧
  Case79_sigma n Case79_eta_1 = Case79_eta_2 ∧
  Case79_sigma n Case79_eta_2 = Case79_eta_0 := by
    -- By definition of $Case79_sigma$, we know that $Case79_sigma n (Case79_eta S) = Case79_eta (n * S)$ for any subset $S$ of $ZMod 79$.
    have h_sigma_eta : ∀ S : Finset (ZMod 79), Case79_sigma n (∑ x ∈ S, Case79_zeta^(x.val)) = ∑ x ∈ S, Case79_zeta^(n.val.val * x.val) := by
      intro S
      have h_sigma_eta : ∀ x ∈ S, Case79_sigma n (Case79_zeta ^ x.val) = Case79_zeta ^ ((n : ZMod 79).val * x.val) := by
        intros x hx
        have h_sigma_eta : Case79_sigma n (Case79_zeta ^ x.val) = (Case79_sigma n Case79_zeta) ^ x.val := by
          exact map_pow _ _ _;
        rw [ h_sigma_eta, Case79_sigma_zeta, pow_mul ];
      rw [ map_sum, Finset.sum_congr rfl h_sigma_eta ];
    have h_perm : ∀ S : Finset (ZMod 79), Case79_sigma n (∑ x ∈ S, Case79_zeta^(x.val)) = ∑ x ∈ (S.image (fun x => n.val * x)), Case79_zeta^(x.val) := by
      intro S
      rw [h_sigma_eta]
      have h_perm : ∀ x ∈ S, Case79_zeta^(n.val.val * x.val) = Case79_zeta^( (n.val * x).val ) := by
        intro x hx
        have h_exp : (n.val.val * x.val : ℕ) ≡ (n.val * x).val [MOD 79] := by
          simp +decide [ ← ZMod.natCast_eq_natCast_iff ];
        rw [ ← Nat.mod_add_div ( ( n.val.val * x.val ) ) 79, ← Nat.mod_add_div ( ( n.val * x |> ZMod.val ) ) 79, h_exp ] ; norm_num [ pow_add, pow_mul ] ;
        have h_zeta_79 : Case79_zeta ^ 79 = 1 := by
          exact IsCyclotomicExtension.zeta_pow _ _ _;
        aesop
      simp [h_perm];
      exact Finset.sum_congr rfl h_perm;
    -- By definition of $Case79_eta$, we know that $Case79_eta S = \sum_{x \in S} \zeta^x$ for any subset $S$ of $ZMod 79$.
    have h_eta_def : ∀ S : Finset (ZMod 79), Case79_eta S = ∑ x ∈ S, Case79_zeta^(x.val) := by
      exact?;
    have h_perm_H : Finset.image (fun x => n.val * x) Case79_H = Case79_C1 := by
      have h_perm_H : ∀ x ∈ Case79_H, n.val * x ∈ Case79_C1 := by
        exact?;
      refine' Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr h_perm_H ) _;
      rw [ Finset.card_image_of_injective _ fun x y hxy => by simpa using hxy ] ; native_decide
    have h_perm_C1 : Finset.image (fun x => n.val * x) Case79_C1 = Case79_C2 := by
      refine' Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr _ ) _;
      · exact?;
      · rw [ Finset.card_image_of_injective _ fun x y hxy => by simpa using hxy ] ; native_decide
    have h_perm_C2 : Finset.image (fun x => n.val * x) Case79_C2 = Case79_H := by
      have h_perm_C2 : Finset.image (fun x => n.val * x) Case79_C2 ⊆ Case79_H := by
        exact Finset.image_subset_iff.mpr fun x hx => by have := Case79_perm_C1_C2 n.val hn x ( by simpa using hx ) ; aesop;
      refine' Finset.eq_of_subset_of_card_le h_perm_C2 _;
      rw [ Finset.card_image_of_injective _ fun x y hxy => by simpa using hxy ] ; native_decide;
    exact ⟨ by simpa only [ h_eta_def ] using h_perm Case79_H ▸ h_perm_H.symm ▸ rfl, by simpa only [ h_eta_def ] using h_perm Case79_C1 ▸ h_perm_C1.symm ▸ rfl, by simpa only [ h_eta_def ] using h_perm Case79_C2 ▸ h_perm_C2.symm ▸ rfl ⟩

/-
Lemma: If n is in C2, then sigma_n permutes eta_0 -> eta_2 -> eta_1 -> eta_0.
Proof uses the fact that n*H=C2, n*C1=H, n*C2=C1.
-/
lemma Case79_sigma_eta_C2 (n : (ZMod 79)ˣ) (hn : (n : ZMod 79) ∈ Case79_C2) :
  Case79_sigma n Case79_eta_0 = Case79_eta_2 ∧
  Case79_sigma n Case79_eta_1 = Case79_eta_0 ∧
  Case79_sigma n Case79_eta_2 = Case79_eta_1 := by
    -- By definition of $Case79_sigma$, we know that $Case79_sigma n Case79_zeta = Case79_zeta^(n : ZMod 79).val$.
    have h_sigma_zeta : Case79_sigma n Case79_zeta = Case79_zeta^(n : ZMod 79).val := by
      exact?;
    -- By definition of $Case79_sigma$, we know that $Case79_sigma n Case79_eta_0 = Case79_eta_2$, $Case79_sigma n Case79_eta_1 = Case79_eta_0$, and $Case79_sigma n Case79_eta_2 = Case79_eta_1$.
    have h_sigma_eta : ∀ S : Finset (ZMod 79), Case79_sigma n (∑ x ∈ S, Case79_zeta^(x.val)) = ∑ x ∈ S, Case79_zeta^(n.val * x).val := by
      intro S
      have h_sigma_eta : ∀ x ∈ S, Case79_sigma n (Case79_zeta^(x.val)) = Case79_zeta^(n.val * x).val := by
        intro x hx
        have h_sigma_eta : Case79_sigma n (Case79_zeta^(x.val)) = (Case79_sigma n Case79_zeta)^(x.val) := by
          exact map_pow _ _ _;
        rw [ h_sigma_eta, h_sigma_zeta, ← pow_mul ];
        simp +decide [ ZMod.val_mul ];
        rw [ ← Nat.mod_add_div ( ( n : ZMod 79 ).val * x.val ) 79, pow_add, pow_mul ] ; norm_num [ Case79_zeta ];
        erw [ IsCyclotomicExtension.zeta_pow ] ; norm_num;
      rw [ map_sum, Finset.sum_congr rfl h_sigma_eta ];
    -- By definition of $Case79_C2$, we know that $n * H = C2$, $n * C1 = H$, and $n * C2 = C1$.
    have h_perm_C2 : ∀ x ∈ Case79_H, (n : ZMod 79) * x ∈ Case79_C2 := by
      exact?
    have h_perm_C1 : ∀ x ∈ Case79_C1, (n : ZMod 79) * x ∈ Case79_H := by
      exact?
    have h_perm_C2_C2 : ∀ x ∈ Case79_C2, (n : ZMod 79) * x ∈ Case79_C1 := by
      exact?;
    -- By definition of $Case79_eta$, we know that $Case79_eta_0 = \sum_{x \in H} zeta^x$, $Case79_eta_1 = \sum_{x \in C1} zeta^x$, and $Case79_eta_2 = \sum_{x \in C2} zeta^x$.
    have h_eta_def : Case79_eta_0 = ∑ x ∈ Case79_H, Case79_zeta^(x.val) ∧ Case79_eta_1 = ∑ x ∈ Case79_C1, Case79_zeta^(x.val) ∧ Case79_eta_2 = ∑ x ∈ Case79_C2, Case79_zeta^(x.val) := by
      exact ⟨ rfl, rfl, rfl ⟩;
    have h_perm_C2 : Finset.image (fun x : ZMod 79 => (n : ZMod 79) * x) Case79_H = Case79_C2 := by
      refine' Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr h_perm_C2 ) _;
      rw [ Finset.card_image_of_injective _ fun x y hxy => by simpa using hxy ] ; native_decide
    have h_perm_C1 : Finset.image (fun x : ZMod 79 => (n : ZMod 79) * x) Case79_C1 = Case79_H := by
      exact Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr h_perm_C1 ) ( by simp +decide [ Finset.card_image_of_injective, Function.Injective, * ] )
    have h_perm_C2_C2 : Finset.image (fun x : ZMod 79 => (n : ZMod 79) * x) Case79_C2 = Case79_C1 := by
      refine' Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr h_perm_C2_C2 ) _;
      rw [ Finset.card_image_of_injective _ fun x y hxy => by simpa using hxy ] ; native_decide;
    simp_all +decide [ Finset.sum_image ];
    exact ⟨ by rw [ ← h_perm_C2, Finset.sum_image ( Finset.card_image_iff.mp <| by simp +decide [ h_perm_C2 ] ) ], by rw [ ← h_perm_C1, Finset.sum_image ( Finset.card_image_iff.mp <| by simp +decide [ h_perm_C1 ] ) ], by rw [ ← h_perm_C2_C2, Finset.sum_image ( Finset.card_image_iff.mp <| by simp +decide [ h_perm_C2_C2 ] ) ] ⟩

/-
Theorem: The Galois automorphism sigma_n permutes the roots alpha, beta, gamma based on the coset of n.
If n is in C1, sigma_n(alpha) = beta.
If n is in C2, sigma_n(alpha) = gamma.
If n is in H, sigma_n(alpha) = alpha.
-/
theorem Case79_global_permutation (n : (ZMod 79)ˣ) :
  ((n : ZMod 79) ∈ Case79_C1 → Case79_sigma n Case79_alpha = Case79_beta) ∧
  ((n : ZMod 79) ∈ Case79_C2 → Case79_sigma n Case79_alpha = Case79_gamma) ∧
  ((n : ZMod 79) ∈ Case79_H → Case79_sigma n Case79_alpha = Case79_alpha) := by
  constructor
  · intro hn
    obtain ⟨h0, h1, h2⟩ := Case79_sigma_eta_C1 n hn
    unfold Case79_alpha Case79_beta
    simp only [map_neg, map_sub, h1, h2]
  · constructor
    · intro hn
      obtain ⟨h0, h1, h2⟩ := Case79_sigma_eta_C2 n hn
      unfold Case79_alpha Case79_gamma
      simp only [map_neg, map_sub, h1, h2]
    · intro hn
      obtain ⟨h0, h1, h2⟩ := Case79_sigma_eta_H n hn
      unfold Case79_alpha
      simp only [map_neg, map_sub, h1, h2]

/-
Define the ring of integers Ok and the integral element zeta_int.
-/
abbrev Case79_Ok := NumberField.RingOfIntegers Case79_K

theorem Case79_zeta_isIntegral : IsIntegral ℤ Case79_zeta := by
  refine' ⟨ Polynomial.X ^ 79 - 1, _, _ ⟩;
  · erw [ Polynomial.Monic, Polynomial.leadingCoeff_X_pow_sub_C ] ; norm_num;
  · have h_zeta_pow : Case79_zeta ^ 79 = 1 := by
      convert IsPrimitiveRoot.pow_eq_one ( IsCyclotomicExtension.zeta_spec 79 ℚ Case79_K );
    aesop

def Case79_zeta_int : Case79_Ok := ⟨Case79_zeta, Case79_zeta_isIntegral⟩

/-
Define sigma_int as the restriction of sigma to the ring of integers.
-/
noncomputable def Case79_sigma_int (n : (ZMod 79)ˣ) : Case79_Ok ≃ₐ[ℤ] Case79_Ok :=
  (NumberField.RingOfIntegers.mapAlgEquiv (Case79_sigma n)).restrictScalars ℤ

/-
Define the integral Gaussian periods and roots.
-/
noncomputable def Case79_eta_int (S : Finset (ZMod 79)) : Case79_Ok := ∑ x ∈ S, Case79_zeta_int^(x.val)
noncomputable def Case79_eta_0_int := Case79_eta_int Case79_H
noncomputable def Case79_eta_1_int := Case79_eta_int Case79_C1
noncomputable def Case79_eta_2_int := Case79_eta_int Case79_C2

noncomputable def Case79_alpha_int := -(Case79_eta_2_int - Case79_eta_1_int)
noncomputable def Case79_beta_int := -(Case79_eta_0_int - Case79_eta_2_int)
noncomputable def Case79_gamma_int := -(Case79_eta_1_int - Case79_eta_0_int)

/-
Prove that the integral root alpha_int coerces to the field root alpha.
-/
theorem Case79_alpha_int_coe : (Case79_alpha_int : Case79_K) = Case79_alpha := by
  unfold Case79_alpha_int Case79_alpha
  unfold Case79_eta_2_int Case79_eta_1_int Case79_eta_int
  unfold Case79_eta_2 Case79_eta_1 Case79_eta
  simp only [map_neg, map_sub, map_sum]
  rfl

/-
Define N as a unit in ZMod 79, given that N is a prime not equal to 79.
-/
def Case79_N_mod_79 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 79) : (ZMod 79)ˣ :=
  ZMod.unitOfCoprime N (Nat.Coprime.symm ((Nat.coprime_primes (by norm_num) (Fact.out)).mpr hN.symm))

/-
Prove that zeta_int is a primitive 79th root of unity in Ok.
-/
theorem Case79_zeta_int_isPrimitiveRoot : IsPrimitiveRoot Case79_zeta_int 79 := by
  -- By definition of $zeta_int$, we know that $zeta_int$ is a primitive 79th root of unity.
  have h_primitive : IsPrimitiveRoot (Case79_zeta : Case79_K) 79 := by
    convert IsCyclotomicExtension.zeta_spec 79 ℚ Case79_K;
  simp_all +decide [ IsPrimitiveRoot.iff_def ];
  convert h_primitive;
  · -- Since the inclusion map from the ring of integers to the field is injective, the equivalence holds.
    have h_inj : Function.Injective (algebraMap Case79_Ok Case79_K) := by
      exact Subtype.coe_injective;
    exact ⟨ fun h => by simpa using congr_arg ( algebraMap Case79_Ok Case79_K ) h, fun h => h_inj <| by simpa using h ⟩;
  · erw [ Subtype.mk.injEq ] ; aesop

/-
Prove that the ring of integers Ok is generated by zeta_int over Z.
We use the theorem `IsCyclotomicExtension.adjoin_primitive_root_eq_top` and the fact that Ok is a cyclotomic extension of Z.
-/
theorem Case79_Ok_eq_adjoin : ⊤ = Algebra.adjoin ℤ {Case79_zeta_int} := by
  haveI : Fact (Nat.Prime 79) := ⟨by native_decide⟩
  have h_ext : IsCyclotomicExtension {79} ℤ Case79_Ok := IsPrimitiveRoot.IsCyclotomicExtension.ringOfIntegers (K := Case79_K) (p := 79) (k := 1)
  have h_prim : IsPrimitiveRoot Case79_zeta_int 79 := Case79_zeta_int_isPrimitiveRoot
  symm
  apply IsCyclotomicExtension.adjoin_primitive_root_eq_top h_prim

/-
Lemma: sigma_int n (zeta_int) = zeta_int ^ n.
Proof: This follows directly from the definition of sigma_int as the restriction of sigma, and the property of sigma on zeta.
-/
theorem Case79_sigma_int_zeta (n : (ZMod 79)ˣ) :
  Case79_sigma_int n Case79_zeta_int = Case79_zeta_int ^ (n : ZMod 79).val := by
    convert Case79_sigma_zeta n using 1;
    erw [ Subtype.mk_eq_mk ];
    exact?

/-
The Artin property holds for zeta: sigma_N(zeta) = zeta^N mod P.
This is actually an equality in Ok, not just mod P.
sigma_N(zeta) = zeta^(N mod 79).
zeta^N = zeta^(N mod 79) because zeta^79 = 1.
-/
theorem Case79_artin_property_zeta (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 79) (P : Ideal Case79_Ok) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  Ideal.Quotient.mk P (Case79_sigma_int (Case79_N_mod_79 N hN) Case79_zeta_int) = (Ideal.Quotient.mk P Case79_zeta_int)^N := by
    rw [ show ( Ideal.Quotient.mk P ) = ( Ideal.Quotient.mk P ) from rfl, show ( Case79_sigma_int ( Case79_N_mod_79 N hN ) ) Case79_zeta_int = Case79_zeta_int ^ ( N % 79 ) from ?_, ← Nat.mod_add_div N 79 ] ; norm_num [ pow_add, pow_mul, pow_one ];
    · -- Since $zeta_int$ is a primitive 79th root of unity, we have $zeta_int^{79} = 1$.
      have h_zeta_int_79 : Case79_zeta_int ^ 79 = 1 := by
        convert Case79_zeta_int_isPrimitiveRoot.pow_eq_one;
      erw [ Ideal.Quotient.eq ] ; aesop;
    · convert Case79_sigma_int_zeta ( Case79_N_mod_79 N hN ) using 1

/-
Prove the Artin property for any x in Ok.
We use the fact that Ok is generated by zeta_int.
The base case is x = zeta_int, which we already proved.
The integer case follows from Fermat's Little Theorem (CharP.cast_pow_char).
The inductive steps follow from the fact that sigma and the N-th power map are ring homomorphisms (modulo P).
We establish CharP (Ok/P) N using the fact that P lies over (N).
-/
theorem Case79_artin_property (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 79) (P : Ideal Case79_Ok) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) (x : Case79_Ok) :
  Ideal.Quotient.mk P (Case79_sigma_int (Case79_N_mod_79 N hN) x) = (Ideal.Quotient.mk P x)^N := by
    have h_artin : ∀ x : Case79_Ok, (Ideal.Quotient.mk P ((Case79_sigma_int (Case79_N_mod_79 N hN)) x)) = (Ideal.Quotient.mk P x)^N := by
      intro x
      have h_gen : x ∈ Algebra.adjoin ℤ {Case79_zeta_int} := by
        have h_gen : ⊤ = Algebra.adjoin ℤ {Case79_zeta_int} := by
          exact?;
        exact h_gen ▸ Algebra.mem_top
      refine' Algebra.adjoin_induction _ _ _ _ h_gen;
      · simp +zetaDelta at *;
        convert Case79_artin_property_zeta N hN P hP using 1;
      · intro r
        simp [Case79_sigma_int];
        have h_char : ∀ (x : Case79_Ok), (↑N : Case79_Ok) * x ∈ P := by
          have h_char : (↑N : Case79_Ok) ∈ P := by
            have := hP.1;
            exact Ideal.mem_comap.mp ( this ▸ Ideal.mem_span_singleton_self _ );
          exact fun x => P.mul_mem_right x h_char;
        have h_char : ∀ (r : ℤ), (r : Case79_Ok) ^ N - r ∈ P := by
          intro r
          have h_char : (r : Case79_Ok) ^ N - r ∈ Ideal.span {(↑N : Case79_Ok)} := by
            have h_char : (r : ℤ) ^ N - r ≡ 0 [ZMOD N] := by
              haveI := Fact.mk ( Fact.out : Nat.Prime N ) ; simp +decide [ ← ZMod.intCast_eq_intCast_iff ] ;
            rw [ Int.modEq_zero_iff_dvd ] at h_char;
            exact Ideal.mem_span_singleton.mpr ( by obtain ⟨ k, hk ⟩ := h_char; exact ⟨ k, by simpa [ ← @Int.cast_inj ( Case79_Ok ) ] using hk ⟩ );
          have h_char : Ideal.span {(↑N : Case79_Ok)} ≤ P := by
            exact fun x hx => by obtain ⟨ y, hy ⟩ := Ideal.mem_span_singleton.mp hx; aesop;
          exact h_char ‹_›;
        exact Eq.symm ( Ideal.Quotient.eq.2 <| by simpa using h_char r );
      · intro x y hx hy hx' hy'; simp_all +decide [ ← map_pow, ← map_add ] ;
        convert congr_arg₂ ( · + · ) hx' hy' using 1 <;> ring;
        · exact congr_arg _ ( map_add _ _ _ );
        · have h_char : ∀ (x : Case79_Ok), (Ideal.Quotient.mk P (x ^ N)) = (Ideal.Quotient.mk P x) ^ N := by
            exact?;
          have h_char : ∀ (x y : Case79_Ok), (Ideal.Quotient.mk P ((x + y) ^ N)) = (Ideal.Quotient.mk P x) ^ N + (Ideal.Quotient.mk P y) ^ N := by
            intro x y
            have h_char : (x + y) ^ N ≡ x ^ N + y ^ N [SMOD P] := by
              have h_char : (x + y) ^ N - x ^ N - y ^ N ∈ P := by
                have h_char : (x + y) ^ N - x ^ N - y ^ N = ∑ k ∈ Finset.Ico 1 N, Nat.choose N k * x ^ k * y ^ (N - k) := by
                  rw [ add_pow ];
                  rw [ Finset.sum_Ico_eq_sub _ ] <;> norm_num [ mul_assoc, mul_comm, mul_left_comm, Finset.sum_range_succ ];
                  exact Nat.Prime.pos Fact.out
                rw [h_char];
                refine' P.sum_mem _;
                intro k hk;
                have h_char : (Nat.choose N k : ℤ) ∈ Ideal.span {(N : ℤ)} := by
                  exact Ideal.mem_span_singleton.mpr ( mod_cast Nat.dvd_of_mod_eq_zero ( by rw [ Nat.mod_eq_zero_of_dvd ] ; exact Nat.Prime.dvd_choose_self ( Fact.out : Nat.Prime N ) ( by linarith [ Finset.mem_Ico.mp hk ] ) ( by linarith [ Finset.mem_Ico.mp hk ] ) ) );
                have h_char : (Nat.choose N k : ℤ) ∈ Ideal.span {(N : ℤ)} → (Nat.choose N k : Case79_Ok) ∈ P := by
                  intro h_char;
                  have h_char : Ideal.span {(N : ℤ)} ≤ Ideal.comap (algebraMap ℤ Case79_Ok) P := by
                    exact hP.1.le;
                  exact h_char ‹_›;
                exact P.mul_mem_right _ ( P.mul_mem_right _ ( h_char ‹_› ) );
              rw [ SModEq ];
              rw [ Submodule.Quotient.eq ];
              simpa only [ sub_add_eq_sub_sub ] using h_char
            exact?;
          grind;
      · simp +contextual [ ← mul_pow ];
    exact h_artin x

/-
Define the polynomial f(X) = X^3 - 79X - 79.
-/
def Case79_f_poly : Polynomial ℤ := Polynomial.X^3 - 79 * Polynomial.X - 79

/-
Prove that P is a maximal ideal.
This follows from the fact that P lies over a maximal ideal in Z (generated by a prime N) and Ok is integral over Z.
-/
theorem Case79_P_is_maximal (N : ℕ) [Fact (Nat.Prime N)] (P : Ideal Case79_Ok) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) : P.IsMaximal := by
  have h_nonzero : P ≠ ⊥ := by
    intro h; have := hP.1; simp_all +decide [ Ideal.span_singleton_eq_bot ] ;
  exact?

/-
Theorem: Explicit Frobenius action.
If N in C1, 17 * alpha^N = -3 * alpha^2 - 4 * alpha + 158 (mod P).
If N in C2, 17 * alpha^N = 3 * alpha^2 - 13 * alpha - 158 (mod P).
Proof:
1. Use `Case79_artin_property` to show `alpha_bar^N = sigma_N(alpha_int) mod P`.
2. Use `Case79_global_permutation` to show `sigma_N(alpha) = beta` (if N in C1) or `gamma` (if N in C2).
3. Use `Case79_relation_beta` and `Case79_relation_gamma` to express `beta` and `gamma` in terms of `alpha`.
4. Combine these to get the result. Note that 17 is invertible mod P since N != 17.
-/
theorem Case79_explicit_frobenius (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 79) (hN17 : N ≠ 17)
  (P : Ideal Case79_Ok) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  let alpha_bar := Ideal.Quotient.mk P Case79_alpha_int
  ((N : ZMod 79) ∈ Case79_C1 → 17 * alpha_bar ^ N = -3 * alpha_bar ^ 2 - 4 * alpha_bar + 158) ∧
  ((N : ZMod 79) ∈ Case79_C2 → 17 * alpha_bar ^ N = 3 * alpha_bar ^ 2 - 13 * alpha_bar - 158) := by
    refine' ⟨ fun h1 => _, fun h2 => _ ⟩;
    · -- Use `Case79_artin_property` to show `alpha_bar^N = sigma_N(alpha_int) mod P`.
      have h_alphaN : (Ideal.Quotient.mk P Case79_alpha_int) ^ N = Ideal.Quotient.mk P (Case79_sigma_int (Case79_N_mod_79 N hN) Case79_alpha_int) := by
        convert Case79_artin_property N hN P hP Case79_alpha_int |> Eq.symm using 1;
      -- Use `Case79_global_permutation` to show `sigma_N(alpha) = beta` (if N in C1).
      have h_sigma_beta : Case79_sigma_int (Case79_N_mod_79 N hN) Case79_alpha_int = Case79_beta_int := by
        have h_sigma_beta : Case79_sigma (Case79_N_mod_79 N hN) Case79_alpha = Case79_beta := by
          apply (Case79_global_permutation (Case79_N_mod_79 N hN)).left;
          exact?;
        exact?;
      -- Use `Case79_relation_beta` to express `beta` in terms of `alpha`.
      have h_beta : 17 * Case79_beta_int = -3 * Case79_alpha_int ^ 2 - 4 * Case79_alpha_int + 158 := by
        convert Case79_relation_beta using 1;
        erw [ ← Subtype.coe_inj ] ; norm_num [ Case79_alpha_int_coe ];
        exact?;
      replace h_beta := congr_arg ( Ideal.Quotient.mk P ) h_beta ; aesop;
    · -- Using the Artin property and the global permutation property, we have:
      have h_artin : (Ideal.Quotient.mk P) (Case79_sigma_int (Case79_N_mod_79 N hN) Case79_alpha_int) = (Ideal.Quotient.mk P Case79_alpha_int)^N := by
        exact?;
      -- Using the global permutation property, we have:
      have h_global : (Case79_sigma_int (Case79_N_mod_79 N hN)) Case79_alpha_int = Case79_gamma_int := by
        have h_global : (Case79_sigma (Case79_N_mod_79 N hN)) Case79_alpha = Case79_gamma := by
          convert Case79_global_permutation ( Case79_N_mod_79 N hN ) |>.2.1 _;
          unfold Case79_N_mod_79; aesop;
        exact?;
      have h_gamma : 17 * Case79_gamma_int = 3 * Case79_alpha_int^2 - 13 * Case79_alpha_int - 158 := by
        convert Case79_relation_gamma using 1;
        erw [ ← Subtype.coe_inj ] ; norm_num;
        exact?;
      replace h_gamma := congr_arg ( Ideal.Quotient.mk P ) h_gamma; aesop;

/-
Theorem: Explicit Frobenius action.
If N in C1, 17 * alpha^N = -3 * alpha^2 - 4 * alpha + 158 (mod P).
If N in C2, 17 * alpha^N = 3 * alpha^2 - 13 * alpha - 158 (mod P).
Proof combines global permutation, Artin property, and algebraic relations.
-/
theorem Case79_explicit_frobenius_final (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 79) (hN17 : N ≠ 17)
  (P : Ideal Case79_Ok) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  let alpha_bar := Ideal.Quotient.mk P Case79_alpha_int
  ((N : ZMod 79) ∈ Case79_C1 → 17 * alpha_bar ^ N = -3 * alpha_bar ^ 2 - 4 * alpha_bar + 158) ∧
  ((N : ZMod 79) ∈ Case79_C2 → 17 * alpha_bar ^ N = 3 * alpha_bar ^ 2 - 13 * alpha_bar - 158) := by
    convert Case79_explicit_frobenius N hN hN17 P hP using 1

/-
s1 is 23 mod 79. s2 is 55 mod 79. c(N) is N^26 mod 79.
-/
def s1 : ZMod 79 := 23
def s2 : ZMod 79 := 55
def c (N : ℕ) : ZMod 79 := (N : ZMod 79) ^ 26

/-
c(N) = s1 iff N is in C1.
-/
lemma c_eq_s1_iff_N_in_C1 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 79) :
  c N = s1 ↔ (N : ZMod 79) ∈ Case79_C1 := by
    have h_cubic_residue : ∀ x : ZMod 79, x^26 = 23 ↔ x ∈ Case79_C1 := by
      native_decide;
    exact h_cubic_residue _

/-
c(N) = s2 iff N is in C2.
-/
lemma c_eq_s2_iff_N_in_C2 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 79) :
  c N = s2 ↔ (N : ZMod 79) ∈ Case79_C2 := by
    constructor <;> intro h;
    · -- By definition of $c$, we know that $c(N) = N^{26} \mod 79$.
      have h_c_def : c N = (N : ZMod 79) ^ 26 := by
        rfl;
      -- By definition of $C2$, we know that $N \in C2$ if and only if $N^{26} = 55$.
      have h_C2_def : ∀ x : ZMod 79, x^26 = 55 ↔ x ∈ Case79_C2 := by
        native_decide;
      exact h_C2_def _ |>.1 ( h_c_def ▸ h );
    · -- Since $N \in C2$, we have $N^{26} = 9^{26}$.
      have hN_pow : (N : ZMod 79) ^ 26 = 9 ^ 26 := by
        have hN_pow : ∀ x ∈ Case79_C2, (x : ZMod 79) ^ 26 = 9 ^ 26 := by
          native_decide;
        convert hN_pow _ h;
      exact hN_pow

/-
If c(N) = s1, then alpha^N = gamma. If c(N) = s2, then alpha^N = beta.
-/
instance Case79_residue_field (P : Ideal Case79_Ok) [P.IsMaximal] : Field (Case79_Ok ⧸ P) := Ideal.Quotient.field P

def alpha_bar (N : ℕ) [Fact (Nat.Prime N)] (P : Ideal Case79_Ok) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) : Case79_Ok ⧸ P :=
  Ideal.Quotient.mk P Case79_alpha_int

noncomputable def user_beta (N : ℕ) [Fact (Nat.Prime N)] (P : Ideal Case79_Ok) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) : Case79_Ok ⧸ P :=
  (17 : Case79_Ok ⧸ P)⁻¹ * (3 * (alpha_bar N P hP)^2 - 13 * (alpha_bar N P hP) - 158)

noncomputable def user_gamma (N : ℕ) [Fact (Nat.Prime N)] (P : Ideal Case79_Ok) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) : Case79_Ok ⧸ P :=
  (17 : Case79_Ok ⧸ P)⁻¹ * (-3 * (alpha_bar N P hP)^2 - 4 * (alpha_bar N P hP) + 158)

theorem final_result (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 79) (hN17 : N ≠ 17)
  (P : Ideal Case79_Ok) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  (c N = s1 → (alpha_bar N P hP) ^ N = user_gamma N P hP) ∧
  (c N = s2 → (alpha_bar N P hP) ^ N = user_beta N P hP) := by
    constructor <;> intro h <;> have := Case79_explicit_frobenius_final N hN hN17 P hP <;> simp_all +decide [ Case79_relation_beta, Case79_relation_gamma ];
    · -- Since $17$ is invertible in $F_N$, we can divide both sides of the equation by $17$.
      have h_inv : (17 : Case79_Ok ⧸ P) ≠ 0 := by
        erw [ Ne.eq_def, Ideal.Quotient.eq_zero_iff_mem ];
        intro h17_P
        have h17_in_span : (17 : ℤ) ∈ Ideal.span {(N : ℤ)} := by
          have h17_in_span : (17 : ℤ) ∈ Ideal.comap (algebraMap ℤ Case79_Ok) P := by
            exact h17_P;
          exact hP.1 ▸ h17_in_span;
        rw [ Ideal.mem_span_singleton ] at h17_in_span;
        norm_cast at h17_in_span; have := Nat.le_of_dvd ( by decide ) h17_in_span; interval_cases N <;> trivial;
      have h_div : 17 * (alpha_bar N P hP) ^ N = -3 * (alpha_bar N P hP) ^ 2 - 4 * (alpha_bar N P hP) + 158 := by
        convert this.1 _ using 1;
        · ring!;
        · exact c_eq_s1_iff_N_in_C1 N hN |>.1 h;
      have h_div : 17 * (user_gamma N P hP) = -3 * (alpha_bar N P hP) ^ 2 - 4 * (alpha_bar N P hP) + 158 := by
        exact?;
      exact mul_left_cancel₀ h_inv <| by linear_combination' ‹17 * alpha_bar N P hP ^ N = -3 * alpha_bar N P hP ^ 2 - 4 * alpha_bar N P hP + 158› - h_div;
    · -- Since $17$ is invertible in $F_N$, we can divide both sides of the equation by $17$.
      have h_inv : IsUnit (17 : Case79_Ok ⧸ P) := by
        have h_inv : (Ideal.Quotient.mk P (17 : Case79_Ok)) ≠ 0 := by
          have h_inv : ¬(17 : ℤ) ∈ Ideal.span {(N : ℤ)} := by
            rw [ Ideal.mem_span_singleton ];
            exact_mod_cast fun h => hN17 <| by have := Nat.le_of_dvd ( by decide ) h; interval_cases N <;> trivial;
          rw [ Ne.eq_def, Ideal.Quotient.eq_zero_iff_mem ];
          exact fun h => h_inv <| hP.1 ▸ Ideal.mem_comap.mpr h;
        have h_inv : IsField (Case79_Ok ⧸ P) := by
          exact @Field.toIsField _ ( Ideal.Quotient.field P );
        have := h_inv.mul_inv_cancel ‹_›; aesop;
      convert congr_arg ( fun x => h_inv.unit.inv * x ) ( this.2 ( by simpa [ h ] using ( c_eq_s2_iff_N_in_C2 N hN ) |>.1 h ) ) using 1 <;> ring!;
      · simp +decide [ mul_assoc, h_inv.unit.inv_mul ];
        rw [ inv_mul_cancel₀ ( by exact h_inv.ne_zero ), mul_one ];
      · -- By definition of user_beta, we have user_beta = -(beta_int : Case79_Ok ⧸ P).
        simp [user_beta];
        ring!end Q0079
