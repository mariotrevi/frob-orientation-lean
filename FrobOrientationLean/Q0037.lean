/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: e6ee589a-f550-42ef-89e5-1fd2afd7fa5e

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We defined the constants s1, s2, and the value c(N). We proved lemmas characterizing the cosets C1 and C2 in terms of the 12th power residue symbol (which relates to c(N)). Finally, we proved the main theorem `final_result` which establishes the Frobenius action on alpha (i.e., alpha^N) in terms of beta and gamma, depending on the value of c(N). The proof utilizes the `explicit_frobenius` theorem and the algebraic relations between alpha, beta, and gamma.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 939f55fb-68a7-4ef0-bca3-475f675055ca

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
This module formalizes the proof of the Frobenius Orientation conjecture for q=37.
It defines the cyclotomic field K = Q(zeta_37), the Gaussian periods, and the cubic roots.
It proves the cyclic algebraic relations between these roots and establishes the global Galois action.
It descends to the residue field modulo a prime P lying over N != 37, proving the Artin property.
Finally, it derives the explicit Frobenius action on the reduction of alpha modulo P.
-/

import Mathlib

namespace Q0037


set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Let L = Q(zeta_37) be the 37th cyclotomic field.
-/
abbrev K := CyclotomicField 37 ℚ

/-
zeta is the primitive 37th root of unity in K.
-/
noncomputable def zeta : K := IsCyclotomicExtension.zeta 37 ℚ K

/-
H is the subgroup of cubic residues modulo 37.
-/
def H : Finset (ZMod 37) := ((Finset.univ : Finset (ZMod 37)).filter (fun x => x ≠ 0)).image (fun x => x^3)

/-
g = 2 is a primitive root modulo 37.
-/
def g : ZMod 37 := 2

/-
C1 is the coset of H with index 1.
-/
def C1 : Finset (ZMod 37) := H.image (fun x => g * x)

/-
C2 is the coset of H with index 2.
-/
def C2 : Finset (ZMod 37) := H.image (fun x => g^2 * x)

/-
Open BigOperators for sum notation.
-/
open BigOperators

/-
The Gaussian period for a set S is the sum of zeta^x for x in S.
-/
noncomputable def eta (S : Finset (ZMod 37)) : K := ∑ x ∈ S, zeta^(x.val)

/-
Define the three Gaussian periods eta_0, eta_1, eta_2.
-/
noncomputable def eta_0 := eta H
noncomputable def eta_1 := eta C1
noncomputable def eta_2 := eta C2

/-
Define the roots alpha, beta, gamma.
-/
noncomputable def alpha := eta_2 - eta_1
noncomputable def beta := eta_0 - eta_2
noncomputable def gamma := eta_1 - eta_0

/-
The non-zero elements of ZMod 37 are the disjoint union of H, C1, and C2.
-/
lemma units_decomp :
  let units := (Finset.univ : Finset (ZMod 37)).filter (fun x => x ≠ 0)
  units = H ∪ C1 ∪ C2 ∧
  Disjoint H C1 ∧ Disjoint H C2 ∧ Disjoint C1 C2 := by
    native_decide

/-
The sum of zeta^x for all non-zero x is -1.
-/
lemma sum_zeta_units :
  let units := (Finset.univ : Finset (ZMod 37)).filter (fun x => x ≠ 0)
  ∑ x ∈ units, zeta^(x.val) = -1 := by
    -- Since $zeta$ is a primitive 37th root of unity, we know that $\sum_{x=0}^{36} zeta^x = 0$.
    have h_sum_zero : ∑ x ∈ Finset.range 37, zeta ^ x = 0 := by
      rw [ geom_sum_eq ] <;> norm_num [ zeta ];
      · exact Or.inl ( sub_eq_zero_of_eq <| by exact IsCyclotomicExtension.zeta_pow 37 ℚ K );
      · have h_order : orderOf (IsCyclotomicExtension.zeta 37 ℚ K) = 37 := by
          rw [ orderOf_eq_of_pow_and_pow_div_prime ] <;> norm_num;
          · exact IsCyclotomicExtension.zeta_pow 37 ℚ K;
          · intro p pp dp; have := Nat.le_of_dvd ( by decide ) dp; interval_cases p <;> norm_num at *;
            have h_order : IsPrimitiveRoot (IsCyclotomicExtension.zeta 37 ℚ K) 37 := by
              exact?;
            exact h_order.ne_one ( by decide );
        aesop;
    simp_all +decide [ Finset.sum_range, ZMod, Fin.sum_univ_succ ];
    simp_all +decide [ Fin.sum_univ_succ, Finset.sum_filter, ZMod.val ];
    linear_combination' h_sum_zero

/-
The sum of the three Gaussian periods is -1.
-/
lemma sum_eta_eq_minus_one : eta_0 + eta_1 + eta_2 = -1 := by
  -- Using the decomposition of the units into H, C1, and C2, we can split the sum into three parts.
  have h_split : ∑ x ∈ (Finset.univ : Finset (ZMod 37)).filter (fun x => x ≠ 0), zeta^(x.val) = ∑ x ∈ H, zeta^(x.val) + ∑ x ∈ C1, zeta^(x.val) + ∑ x ∈ C2, zeta^(x.val) := by
    rw [ ← Finset.sum_union, ← Finset.sum_union ];
    · rw [ ← units_decomp.1 ];
    · decide +revert;
    · native_decide +revert;
  convert sum_zeta_units using 1 ; aesop

/-
Explicit enumeration of the cosets H, C1, C2.
-/
lemma H_explicit : H = {1, 6, 8, 10, 11, 14, 23, 26, 27, 29, 31, 36} := by
  native_decide
lemma C1_explicit : C1 = {2, 9, 12, 15, 16, 17, 20, 21, 22, 25, 28, 35} := by
  native_decide
lemma C2_explicit : C2 = {3, 4, 5, 7, 13, 18, 19, 24, 30, 32, 33, 34} := by
  native_decide +revert

/-
The algebraic relation 11β = 3α² - 10α - 74 holds.
-/
theorem relation_beta : 11 * beta = 3 * alpha^2 - 10 * alpha - 74 := by
  -- Let's simplify the left-hand side of the equation.
  simp +decide only [alpha, beta] at *; (
  -- By definition of eta, we can expand the left-hand side and right-hand side of the equation.
  have h_expand : 11 * (∑ x ∈ ({1, 6, 8, 10, 11, 14, 23, 26, 27, 29, 31, 36} : Finset (ZMod 37)), zeta^(x.val) - ∑ x ∈ ({3, 4, 5, 7, 13, 18, 19, 24, 30, 32, 33, 34} : Finset (ZMod 37)), zeta^(x.val)) =
                (∑ x ∈ ({3, 4, 5, 7, 13, 18, 19, 24, 30, 32, 33, 34} : Finset (ZMod 37)), zeta^(x.val) - ∑ x ∈ ({2, 9, 12, 15, 16, 17, 20, 21, 22, 25, 28, 35} : Finset (ZMod 37)), zeta^(x.val)) *
                ((∑ x ∈ ({3, 4, 5, 7, 13, 18, 19, 24, 30, 32, 33, 34} : Finset (ZMod 37)), zeta^(x.val) - ∑ x ∈ ({2, 9, 12, 15, 16, 17, 20, 21, 22, 25, 28, 35} : Finset (ZMod 37)), zeta^(x.val)) * 3 - 10) - 74 := by
                  -- By definition of $zeta$, we know that $zeta^{37} = 1$ and $zeta^k \neq 1$ for $1 \leq k < 37$.
                  have h_zeta_prop : zeta ^ 37 = 1 ∧ ∀ k : ℕ, 1 ≤ k → k < 37 → zeta ^ k ≠ 1 := by
                    have h_zeta_prop : zeta ^ 37 = 1 := by
                      convert IsCyclotomicExtension.zeta_pow 37 ℚ K using 1;
                    have h_zeta_order : IsPrimitiveRoot zeta 37 := by
                      convert IsCyclotomicExtension.zeta_spec 37 ℚ K using 1;
                    exact ⟨ h_zeta_prop, fun k hk₁ hk₂ hk₃ => by have := h_zeta_order.pow_eq_one_iff_dvd k; interval_cases k <;> simp_all +decide ⟩;
                  simp_all +decide [ ZMod.val ];
                  grind +ring;
  convert h_expand using 1;
  · congr! 2;
    · exact H_explicit ▸ rfl;
    · exact C2_explicit ▸ rfl;
  · unfold eta_1 eta_2;
    unfold eta C1 C2; simp +decide ;
    rw [ show ( Finset.image ( fun x : ZMod 37 => g ^ 2 * x ) H : Finset ( ZMod 37 ) ) = { 3, 4, 5, 7, 13, 18, 19, 24, 30, 32, 33, 34 } from ?_, show ( Finset.image ( fun x : ZMod 37 => g * x ) H : Finset ( ZMod 37 ) ) = { 2, 9, 12, 15, 16, 17, 20, 21, 22, 25, 28, 35 } from ?_ ] ; simp +decide [ Finset.sum ] ; ring!;
    · native_decide +revert;
    · native_decide +revert);

/-
The algebraic relation 11γ = -3α² - α + 74 holds.
-/
theorem relation_gamma : 11 * gamma = -3 * alpha^2 - alpha + 74 := by
  have h_gamma : 11 * gamma = 11 * (eta_1 - eta_0) := by
    rfl
  have h_alpha : 11 * alpha = 11 * (eta_2 - eta_1) := by
    rfl
  have h_beta : 11 * beta = 11 * (eta_0 - eta_2) := by
    rfl
  have h_sum : eta_0 + eta_1 + eta_2 = -1 := by
    exact?
  have h_beta_eq : 11 * beta = 3 * alpha^2 - 10 * alpha - 74 := by
    convert relation_beta using 1
  have h_gamma_eq : 11 * gamma = -3 * alpha^2 - alpha + 74 := by
    grind
  exact h_gamma_eq.symm ▸ by ring;

/-
Checking availability of necessary theorems.
-/
#check Polynomial.cyclotomic.irreducible_rat
#check IsCyclotomicExtension.autEquivPow

/-
The 37th cyclotomic polynomial is irreducible over Q.
-/
theorem h_irr : Irreducible (Polynomial.cyclotomic 37 ℚ) := Polynomial.cyclotomic.irreducible_rat (by norm_num)

/-
sigma n is the Galois automorphism mapping zeta to zeta^n.
-/
noncomputable def sigma (n : (ZMod 37)ˣ) : K ≃ₐ[ℚ] K := (IsCyclotomicExtension.autEquivPow K h_irr).symm n

/-
sigma n maps zeta to zeta^n.
-/
theorem sigma_zeta (n : (ZMod 37)ˣ) : sigma n zeta = zeta^(n : ZMod 37).val := by
  -- By definition of automorphisms in the Galois group, $\sigma_n$ maps $zeta$ to $zeta^n$.
  have h_sigma_zeta : ∀ n : (ZMod 37)ˣ, (sigma n) zeta = zeta^(n.val.val) := by
    intro n
    simp [sigma];
    erw [ PowerBasis.equivOfMinpoly_apply ];
    erw [ PowerBasis.lift_gen ];
    exact?;
  exact h_sigma_zeta n

/-
The action of sigma n on alpha is determined by the cubic character of n.
-/
theorem global_permutation (n : (ZMod 37)ˣ) :
  ((n : ZMod 37) ∈ C1 → sigma n alpha = beta) ∧
  ((n : ZMod 37) ∈ C2 → sigma n alpha = gamma) ∧
  ((n : ZMod 37) ∈ H → sigma n alpha = alpha) := by
    -- Let's simplify the goal using the definitions of $C1$, $C2$, and $H$.
    suffices h_simp : ∀ n : (ZMod 37)ˣ, (n.val ∈ C1 → sigma n eta_0 = eta_1 ∧ sigma n eta_1 = eta_2 ∧ sigma n eta_2 = eta_0) ∧ (n.val ∈ C2 → sigma n eta_0 = eta_2 ∧ sigma n eta_1 = eta_0 ∧ sigma n eta_2 = eta_1) ∧ (n.val ∈ H → sigma n eta_0 = eta_0 ∧ sigma n eta_1 = eta_1 ∧ sigma n eta_2 = eta_2) by
      unfold alpha beta gamma; aesop;
    -- By definition of $sigma$, we know that $sigma n (zeta^x) = zeta^{n.val * x}$ for any $x \in \mathbb{Z}/37\mathbb{Z}$.
    have h_sigma_exp : ∀ n : (ZMod 37)ˣ, ∀ x : ZMod 37, (sigma n) (zeta^(x.val)) = zeta^((n.val * x).val) := by
      intro n x; exact (by
      convert congr_arg ( · ^ x.val ) ( sigma_zeta n ) using 1 ; norm_num [ pow_mul ];
      rw [ ← pow_mul, ZMod.val_mul ];
      -- Since $zeta$ is a primitive $37$th root of unity, we have $zeta^{37} = 1$.
      have h_zeta_37 : zeta ^ 37 = 1 := by
        convert IsCyclotomicExtension.zeta_pow 37 ℚ K;
      rw [ ← Nat.mod_add_div ( ( n : ZMod 37 ).val * x.val ) 37, pow_add, pow_mul ] ; aesop);
    -- Apply the definition of $sigma$ to each term in the sum.
    have h_sigma_sum : ∀ n : (ZMod 37)ˣ, ∀ S : Finset (ZMod 37), (sigma n) (∑ x ∈ S, zeta^(x.val)) = ∑ x ∈ S, zeta^((n.val * x).val) := by
      exact fun n S => by rw [ map_sum, Finset.sum_congr rfl fun x hx => h_sigma_exp n x ] ;
    intro n
    simp [h_sigma_sum, eta_0, eta_1, eta_2];
    unfold eta; simp +decide [ h_sigma_sum ] ;
    -- By definition of $C1$, $C2$, and $H$, we can rewrite the sums accordingly.
    have h_cosets : ∀ n : (ZMod 37)ˣ, (n.val ∈ C1 → Finset.image (fun x => (n.val * x : ZMod 37)) H = C1 ∧ Finset.image (fun x => (n.val * x : ZMod 37)) C1 = C2 ∧ Finset.image (fun x => (n.val * x : ZMod 37)) C2 = H) ∧ (n.val ∈ C2 → Finset.image (fun x => (n.val * x : ZMod 37)) H = C2 ∧ Finset.image (fun x => (n.val * x : ZMod 37)) C1 = H ∧ Finset.image (fun x => (n.val * x : ZMod 37)) C2 = C1) ∧ (n.val ∈ H → Finset.image (fun x => (n.val * x : ZMod 37)) H = H ∧ Finset.image (fun x => (n.val * x : ZMod 37)) C1 = C1 ∧ Finset.image (fun x => (n.val * x : ZMod 37)) C2 = C2) := by
      native_decide +revert;
    refine' ⟨ fun hn => _, fun hn => _, fun hn => _ ⟩;
    · have := h_cosets n |>.1 hn;
      exact ⟨ by rw [ ← this.1, Finset.sum_image ( Finset.card_image_iff.mp <| by simp +decide [ this ] ) ], by rw [ ← this.2.1, Finset.sum_image ( Finset.card_image_iff.mp <| by simp +decide [ this ] ) ], by rw [ ← this.2.2, Finset.sum_image ( Finset.card_image_iff.mp <| by simp +decide [ this ] ) ] ⟩;
    · have := h_cosets n |>.2.1 hn;
      exact ⟨ by rw [ ← this.1, Finset.sum_image ( Finset.card_image_iff.mp <| by simp +decide [ this ] ) ], by rw [ ← this.2.1, Finset.sum_image ( Finset.card_image_iff.mp <| by simp +decide [ this ] ) ], by rw [ ← this.2.2, Finset.sum_image ( Finset.card_image_iff.mp <| by simp +decide [ this ] ) ] ⟩;
    · have := h_cosets n |>.2.2 hn; simp_all +decide [ Finset.sum_image ] ;
      refine' ⟨ _, _, _ ⟩;
      · conv_rhs => rw [ ← this.1, Finset.sum_image ( Finset.card_image_iff.mp <| by simp +decide [ this.1 ] ) ] ;
      · conv_rhs => rw [ ← this.2.1, Finset.sum_image ( Finset.card_image_iff.mp <| by simp +decide [ * ] ) ] ;
      · conv_rhs => rw [ ← this.2.2, Finset.sum_image ( Finset.card_image_iff.mp <| by simp +decide [ * ] ) ] ;

/-
Ok is the ring of integers of K.
-/
abbrev Ok := NumberField.RingOfIntegers K

/-
sigma_int n is the restriction of sigma n to the ring of integers, viewed as a Z-algebra equivalence.
-/
noncomputable def sigma_int (n : (ZMod 37)ˣ) : Ok ≃ₐ[ℤ] Ok :=
  (NumberField.RingOfIntegers.mapAlgEquiv (sigma n)).restrictScalars ℤ

/-
N_mod_37 N is the element N in (ZMod 37)ˣ.
-/
def N_mod_37 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 37) : (ZMod 37)ˣ :=
  ZMod.unitOfCoprime N (Nat.Coprime.symm ((Nat.coprime_primes (by norm_num) (Fact.out)).mpr hN.symm))

/-
zeta is an algebraic integer.
-/
theorem zeta_isIntegral : IsIntegral ℤ zeta := IsPrimitiveRoot.isIntegral (IsCyclotomicExtension.zeta_spec 37 ℚ K) (by norm_num)

/-
zeta_int is zeta viewed as an element of the ring of integers.
-/
def zeta_int : Ok := ⟨zeta, zeta_isIntegral⟩

/-
The Artin property holds for zeta.
-/
theorem artin_property_zeta (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 37) (P : Ideal Ok) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) zeta_int) = (Ideal.Quotient.mk P zeta_int)^N := by
    have h_norm : ((Ideal.Quotient.mk P) (sigma_int (N_mod_37 N hN) zeta_int)) = ((Ideal.Quotient.mk P) (zeta_int)) ^ N := by
      have h_norm_eq : (sigma_int (N_mod_37 N hN) zeta_int) = zeta_int ^ N := by
        have h_sigma_zeta : sigma (N_mod_37 N hN) zeta = zeta ^ N := by
          convert sigma_zeta ( N_mod_37 N hN ) using 1;
          -- Since $N$ is coprime to $37$, we have $N \equiv N \mod 37 \pmod{37}$.
          have h_cong : (N : ZMod 37) = (N_mod_37 N hN : ZMod 37) := by
            exact?;
          rw [ ← h_cong, ZMod.val_natCast ];
          have h_order : zeta ^ 37 = 1 := by
            convert IsCyclotomicExtension.zeta_pow 37 ℚ K;
          rw [ ← Nat.mod_add_div N 37, pow_add, pow_mul ] ; aesop;
        exact?
      aesop;
    convert h_norm using 1

/-
zeta_int is a primitive 37th root of unity in the ring of integers.
-/
theorem zeta_int_isPrimitiveRoot : IsPrimitiveRoot zeta_int 37 := by
  have h_prim : IsPrimitiveRoot (zeta : K) 37 := by
    apply_rules [ IsCyclotomicExtension.zeta_spec ];
  simp_all +decide [ IsPrimitiveRoot.iff_def ];
  apply And.intro;
  · exact Subtype.ext h_prim.1;
  · intro l hl;
    convert h_prim.2 l _;
    convert congr_arg ( fun x : Ok => x : Ok → K ) hl using 1

/-
The ring of integers is generated by zeta.
-/
theorem Ok_eq_adjoin : ⊤ = Algebra.adjoin ℤ {zeta_int} := by
  have h_cyclotomic : IsCyclotomicExtension {37} ℤ (NumberField.RingOfIntegers (CyclotomicField 37 ℚ)) := by
    have h_cyclotomic : IsCyclotomicExtension {37} ℚ (CyclotomicField 37 ℚ) := by
      infer_instance;
    convert IsPrimitiveRoot.IsCyclotomicExtension.ringOfIntegers using 1;
    rotate_left;
    exacts [ 37, 1, ⟨ by norm_num ⟩, by infer_instance, by simpa using h_cyclotomic, by norm_num ];
  have h_primitive_root : IsPrimitiveRoot (zeta_int : NumberField.RingOfIntegers (CyclotomicField 37 ℚ)) 37 := by
    convert zeta_int_isPrimitiveRoot using 1;
  rw [ eq_comm ] ; exact IsCyclotomicExtension.adjoin_primitive_root_eq_top h_primitive_root;

/-
Define the integer versions of the Gaussian periods and roots.
-/
noncomputable def eta_int (S : Finset (ZMod 37)) : Ok := ∑ x ∈ S, zeta_int^(x.val)
noncomputable def eta_0_int := eta_int H
noncomputable def eta_1_int := eta_int C1
noncomputable def eta_2_int := eta_int C2
noncomputable def alpha_int := eta_2_int - eta_1_int
noncomputable def beta_int := eta_0_int - eta_2_int
noncomputable def gamma_int := eta_1_int - eta_0_int

/-
The integer roots map to the field roots.
-/
theorem alpha_int_coe : (alpha_int : K) = alpha := by
  exact?
theorem beta_int_coe : (beta_int : K) = beta := by
  unfold beta_int beta;
  unfold eta_0_int eta_2_int eta_0 eta_2; aesop;
theorem gamma_int_coe : (gamma_int : K) = gamma := by
  exact?

/-
The cyclic relations hold in the ring of integers.
-/
theorem cyclic_relations_int :
  11 * beta_int = 3 * alpha_int^2 - 10 * alpha_int - 74 ∧
  11 * gamma_int = -3 * alpha_int^2 - alpha_int + 74 := by
    -- By definition of alpha_int, beta_int, and gamma_int, we know that their images in K satisfy the same relations as their counterparts in K.
    have alpha_int_eq : (alpha_int : K) = alpha := by
      exact?
    have beta_int_eq : (beta_int : K) = beta := by
      exact?
    have gamma_int_eq : (gamma_int : K) = gamma := by
      exact?;
    -- Since these are equalities in K, we can conclude that the relations hold in the ring of integers as well.
    have h_rel : (11 * beta_int : K) = 3 * alpha_int^2 - 10 * alpha_int - 74 ∧ (11 * gamma_int : K) = -3 * alpha_int^2 - alpha_int + 74 := by
      exact ⟨ by rw [ alpha_int_eq, beta_int_eq, relation_beta ], by rw [ alpha_int_eq, gamma_int_eq, relation_gamma ] ⟩;
    have h_inj : Function.Injective (algebraMap (NumberField.RingOfIntegers K) K) := by
      exact?;
    exact ⟨ h_inj <| by simpa using h_rel.1, h_inj <| by simpa using h_rel.2 ⟩

/-
The global permutation holds in the ring of integers.
-/
theorem global_permutation_int (n : (ZMod 37)ˣ) :
  ((n : ZMod 37) ∈ C1 → sigma_int n alpha_int = beta_int) ∧
  ((n : ZMod 37) ∈ C2 → sigma_int n alpha_int = gamma_int) ∧
  ((n : ZMod 37) ∈ H → sigma_int n alpha_int = alpha_int) := by
    have := @global_permutation n;
    refine' ⟨ _, _, _ ⟩;
    · intro hn
      have h_eq : (sigma_int n alpha_int : K) = beta := by
        convert this.1 hn using 1;
      exact ( by rw [ ← beta_int_coe ] at *; exact Subtype.ext h_eq );
    · intro hn;
      have h_sigma_int_gamma : (sigma n : K → K) alpha = gamma := by
        exact this.2.1 hn;
      exact?;
    · intro hn;
      have := this.2.2 hn;
      exact?

/-
The automorphism sigma N reduces to the Frobenius map x |-> x^N modulo P.
-/
theorem artin_property (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 37) (P : Ideal Ok) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) (x : Ok) :
  Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) x) = (Ideal.Quotient.mk P x)^N := by
    -- The set of x satisfying the property is a subalgebra of Ok.
    have h_subalgebra : ∀ x y : Ok, ((Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) x)) = (Ideal.Quotient.mk P x) ^ N) → ((Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) y)) = (Ideal.Quotient.mk P y) ^ N) → ((Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) (x + y))) = (Ideal.Quotient.mk P (x + y)) ^ N) ∧ ((Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) (x * y))) = (Ideal.Quotient.mk P (x * y)) ^ N) := by
      intro x y hx hy;
      have h_frobenius_mul : ∀ (x y : Ok ⧸ P), (x + y) ^ N = x ^ N + y ^ N ∧ (x * y) ^ N = x ^ N * y ^ N := by
        intro x y; haveI := Fact.mk ( Fact.out : Nat.Prime N ) ; simp +decide [ add_pow_char, mul_pow ] ;
        -- Since $P$ is a prime ideal lying over $N$, the quotient ring $Ok/P$ has characteristic $N$.
        have h_char : ringChar (Ok ⧸ P) = N := by
          have h_char : Ideal.Quotient.mk P (N : Ok) = 0 := by
            rw [ Ideal.Quotient.eq_zero_iff_mem ];
            have := hP.1;
            rw [ Ideal.ext_iff ] at this;
            specialize this N; simp_all +decide [ Ideal.mem_span_singleton ] ;
          rw [ ringChar.eq_iff ];
          constructor;
          intro x; rw [ ← Nat.modEq_zero_iff_dvd ] ; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ] ;
          erw [ ZMod.natCast_eq_zero_iff ];
          erw [ Ideal.Quotient.eq_zero_iff_mem ] at *;
          constructor <;> intro hx;
          · have := hP.1;
            rw [ SetLike.ext_iff ] at this;
            specialize this x;
            simp_all +decide [ Ideal.mem_span_singleton, Ideal.mem_comap ];
            exact_mod_cast this;
          · obtain ⟨ k, rfl ⟩ := hx; simp +decide [ h_char, Ideal.mul_mem_right ] ;
        haveI := ringChar.of_eq h_char; simp +decide [ add_pow_char ] ;
      have h_frobenius_mul : ∀ (x y : Ok), (Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) x)) = (Ideal.Quotient.mk P x) ^ N → (Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) y)) = (Ideal.Quotient.mk P y) ^ N → (Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) (x + y))) = (Ideal.Quotient.mk P (x + y)) ^ N ∧ (Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) (x * y))) = (Ideal.Quotient.mk P (x * y)) ^ N := by
        intros x y hx hy; exact ⟨by
        convert h_frobenius_mul ( Ideal.Quotient.mk P x ) ( Ideal.Quotient.mk P y ) |>.1 using 1;
        · convert congr_arg₂ ( · + · ) hx hy using 1;
          · exact congr_arg _ ( map_add _ _ _ );
          · exact h_frobenius_mul _ _ |>.1;
        · convert h_frobenius_mul ( Ideal.Quotient.mk P x ) ( Ideal.Quotient.mk P y ) |>.1 using 1, by
          convert h_frobenius_mul ( Ideal.Quotient.mk P x ) ( Ideal.Quotient.mk P y ) |>.2 using 1;
          · convert congr_arg₂ ( · * · ) hx hy using 1;
            · exact congr_arg _ ( map_mul _ _ _ );
            · ring;
          · rw [ ← h_frobenius_mul ( Ideal.Quotient.mk P x ) ( Ideal.Quotient.mk P y ) |>.2 ];
            exact?⟩;
      exact h_frobenius_mul x y hx hy;
    -- Since Ok is generated by zeta_int (Ok_eq_adjoin), and the property holds for zeta_int (artin_property_zeta), it holds for all x.
    have h_generate : ∀ x ∈ Algebra.adjoin ℤ {zeta_int}, ((Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) x)) = (Ideal.Quotient.mk P x) ^ N) := by
      refine' fun x hx => Algebra.adjoin_induction _ _ _ _ hx;
      · exact fun x hx => by rw [ Set.mem_singleton_iff.mp hx ] ; exact artin_property_zeta N hN P hP;
      · intro r; erw [ map_intCast ] ; simp +decide [ pow_succ ] ;
        -- Since $P$ lies over $(N)$, we have $N \in P$.
        have hN_in_P : (N : Ok) ∈ P := by
          have := hP.1;
          exact Ideal.mem_comap.mp ( this ▸ Ideal.mem_span_singleton_self _ );
        erw [ Ideal.Quotient.eq ];
        -- Since $N$ is prime, we have $r^N \equiv r \pmod{N}$.
        have h_r_pow_N : (r : Ok) ^ N - r ∈ Ideal.span {(N : Ok)} := by
          rw [ Ideal.mem_span_singleton ];
          have h_r_pow_N : (r : ℤ) ^ N ≡ r [ZMOD N] := by
            haveI := Fact.mk ( Fact.out : Nat.Prime N ) ; simp +decide [ ← ZMod.intCast_eq_intCast_iff ] ;
          obtain ⟨ k, hk ⟩ := h_r_pow_N.symm.dvd;
          exact ⟨ k, by simpa [ ← @Int.cast_inj Ok ] using hk ⟩;
        simpa using P.neg_mem ( Ideal.span_le.mpr ( Set.singleton_subset_iff.mpr hN_in_P ) h_r_pow_N );
      · exact fun x y hx hy hx' hy' => h_subalgebra x y hx' hy' |>.1;
      · exact fun x y hx hy hx' hy' => h_subalgebra x y hx' hy' |>.2;
    convert h_generate x ?_;
    convert Ok_eq_adjoin ▸ Algebra.mem_top

/-
The polynomial f(X) = X^3 - 37X - 37.
-/
def f_poly : Polynomial ℤ := Polynomial.X^3 - 37 * Polynomial.X - 37

/-
P is a maximal ideal.
-/
theorem P_is_maximal (N : ℕ) [Fact (Nat.Prime N)] (P : Ideal Ok) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) : P.IsMaximal := by
  -- Since $P$ is a prime ideal in the ring of integers $Ok$ and $Ok$ is integral over $\mathbb{Z}$, $P$ must be maximal in $Ok$.
  have h_max : P.IsPrime → P ≠ ⊥ → P.IsMaximal := by
    exact?;
  refine h_max ‹_› ?_;
  intro h; have := hP.1; simp_all +decide [ Ideal.span_singleton_eq_bot ] ;

/-
The explicit Frobenius action on alpha_bar is given by the formulas (multiplied by 11 to avoid division).
-/
theorem explicit_frobenius (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 37) (hN11 : N ≠ 11)
  (P : Ideal Ok) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  let alpha_bar := Ideal.Quotient.mk P alpha_int
  let beta_bar := Ideal.Quotient.mk P beta_int
  let gamma_bar := Ideal.Quotient.mk P gamma_int
  ((N : ZMod 37) ∈ C1 → 11 * alpha_bar ^ N = 3 * alpha_bar ^ 2 - 10 * alpha_bar - 74) ∧
  ((N : ZMod 37) ∈ C2 → 11 * alpha_bar ^ N = -3 * alpha_bar ^ 2 - alpha_bar + 74) := by
    refine' ⟨ _, _ ⟩;
    · intro hN1
      have h_beta : Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) alpha_int) = Ideal.Quotient.mk P beta_int := by
        have h_beta : sigma_int (N_mod_37 N hN) alpha_int = beta_int := by
          convert global_permutation_int ( N_mod_37 N hN ) |>.1 _;
          exact?;
        rw [h_beta];
      have h_beta_eq : 11 * Ideal.Quotient.mk P beta_int = 3 * (Ideal.Quotient.mk P alpha_int)^2 - 10 * (Ideal.Quotient.mk P alpha_int) - 74 := by
        have h_beta_eq : 11 * beta_int = 3 * alpha_int^2 - 10 * alpha_int - 74 := by
          exact cyclic_relations_int.left;
        convert congr_arg ( Ideal.Quotient.mk P ) h_beta_eq using 1;
      have h_beta_eq : Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) alpha_int) = (Ideal.Quotient.mk P alpha_int)^N := by
        convert artin_property N hN P hP alpha_int using 1;
      aesop;
    · intro hN2
      have h_gamma_bar : (Ideal.Quotient.mk P gamma_int) = (Ideal.Quotient.mk P alpha_int)^N := by
        convert artin_property N hN P hP alpha_int using 1;
        rw [ global_permutation_int ( N_mod_37 N hN ) |>.2.1 ];
        convert hN2 using 1;
      convert congr_arg ( Ideal.Quotient.mk P ) ( congr_arg ( fun x : Ok => x : Ok → Ok ) ( show 11 * gamma_int = -3 * alpha_int^2 - alpha_int + 74 from ( cyclic_relations_int ) |>.2 ) ) using 1;
      simp +decide [ ← h_gamma_bar ];
      exact Or.inl rfl

/-
Definitions of s1, s2, and c.
-/
def s1 : ZMod 37 := 10
def s2 : ZMod 37 := 26
def c (N : ℕ) : ZMod 37 := (N : ZMod 37)^12

/-
Characterization of C1 and C2 by 12th powers.
-/
lemma mem_C1_iff (x : ZMod 37) (hx : x ≠ 0) : x ∈ C1 ↔ x^12 = s2 := by
  fin_cases x <;> trivial
lemma mem_C2_iff (x : ZMod 37) (hx : x ≠ 0) : x ∈ C2 ↔ x^12 = s1 := by
  native_decide +revert

/-
The main theorem: alpha^N = gamma if c == s1, and alpha^N = beta if c == s2.
-/
theorem final_result (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 37) (hN_odd : N % 2 = 1) (hN_a : Nat.Coprime 11 N)
  (P : Ideal Ok) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  let alpha_bar := Ideal.Quotient.mk P alpha_int
  let beta_bar := Ideal.Quotient.mk P beta_int
  let gamma_bar := Ideal.Quotient.mk P gamma_int
  (c N = s1 → alpha_bar ^ N = gamma_bar) ∧
  (c N = s2 → alpha_bar ^ N = beta_bar) := by
    have := explicit_frobenius N ( by aesop ) ( by aesop ) P hP;
    -- Since $11$ is invertible in $Ok/P$, we can cancel $11$ from the equations.
    have h_cancel : ∀ (x y : Ok ⧸ P), 11 * x = 11 * y → x = y := by
      -- Since $11$ is invertible in $Ok/P$, we can cancel $11$ from the equation $11 * x = 11 * y$.
      have h_inv : ∃ (inv_11 : Ok ⧸ P), inv_11 * 11 = 1 := by
        have h_inv : (11 : Ok ⧸ P) ≠ 0 := by
          intro h; have := hP.1; simp_all +decide [ Ideal.mem_span_singleton ] ;
          -- Since $11 \in P$, we have $11 \in \text{Ideal.under } \mathbb{Z} P$, which implies $11 \in \text{Ideal.span } \{N\}$.
          have h11_in_span : (11 : ℤ) ∈ Ideal.span {(N : ℤ)} := by
            convert Ideal.Quotient.eq_zero_iff_mem.mp h using 1;
            simp +decide [ Ideal.mem_span_singleton, this ];
          rw [ Ideal.mem_span_singleton ] at h11_in_span;
          norm_cast at h11_in_span; have := Nat.le_of_dvd ( by decide ) h11_in_span; interval_cases N <;> trivial;
        have h_inv : IsUnit (11 : Ok ⧸ P) := by
          have h_inv : IsField (Ok ⧸ P) := by
            exact @Field.toIsField _ ( Ideal.Quotient.field P );
          exact isUnit_iff_exists_inv.mpr ( h_inv.mul_inv_cancel ‹_› );
        exact h_inv.exists_left_inv;
      intro x y hxy; obtain ⟨ inv_11, h_inv ⟩ := h_inv; have := congr_arg ( · * inv_11 ) hxy; norm_num [ mul_assoc, mul_comm, mul_left_comm, h_inv ] at this; aesop;
    refine' ⟨ fun h => h_cancel _ _ _, fun h => h_cancel _ _ _ ⟩;
    · convert this.2 _ using 1;
      · convert congr_arg ( Ideal.Quotient.mk P ) ( cyclic_relations_int.2 ) using 1;
      · convert mem_C2_iff _ _ |>.2 _;
        · intro h; have := hP.1; simp_all +decide [ Ideal.span_singleton_eq_bot ] ;
          erw [ ZMod.natCast_eq_zero_iff ] at h ; have := Nat.dvd_gcd ( show 37 ∣ N from h ) ( show 37 ∣ 37 from dvd_refl 37 ) ; simp_all +decide;
          simp_all +decide [ Nat.Prime.dvd_iff_eq Fact.out ];
        · convert h using 1;
    · convert this.1 _ using 1;
      · convert congr_arg ( Ideal.Quotient.mk P ) ( cyclic_relations_int.1 ) using 1;
      · convert mem_C1_iff _ _ |>.2 h;
        rw [ Ne.eq_def, ZMod.natCast_eq_zero_iff ];
        exact fun h => hN <| by have := Nat.prime_dvd_prime_iff_eq ( by decide : Nat.Prime 37 ) ( Fact.out : Nat.Prime N ) ; tauto;end Q0037
