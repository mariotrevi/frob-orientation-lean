/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 3f65392f-6632-46d8-920a-aa3ae5f85400

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We have successfully proved the Dream Theorem for q = 9127.
The proof follows the structure of the q = 2659 proof.
Key components:
1.  **Setup**: Defined q = 9127, s1 = 3010, s2 = 6116, and the cubic character c(N).
2.  **Field and Rings**: Defined the cyclotomic field K = Q(zeta_9127) and its ring of integers Ok.
3.  **Galois Action**: Defined the automorphism sigma_n and proved its action on the periods eta0, eta1, eta2.
4.  **Artin Property**: Proved that the Artin map corresponds to the N-th power map modulo P for the ring of integers (using the fact that Ok is generated by zeta).
5.  **Permutation**: Proved that sigma_N permutes alpha, beta, gamma according to the cubic character of N (via the cosets C1, C2).
6.  **Final Result**: Combined the Artin property and the permutation lemma to prove the Dream Theorem:
    - If c(N) = s1, then alpha^N = gamma mod P.
    - If c(N) = s2, then alpha^N = beta mod P.

All theorems are proved without sorries.

-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 8011b3b0-5b9d-44a9-a431-7da2e7415d10

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We have successfully proved the Dream Theorem for the prime $q = 1567$.
The proof follows the structure of prior proofs for $q = 877, 937, 1063, 1129$.
We defined the field $K = \mathbb{Q}(\zeta_{1567})$, the ring of integers $\mathcal{O}_K$, and the Gaussian periods $\eta_0, \eta_1, \eta_2$.
We defined the period differences $\alpha, \beta, \gamma$ with the appropriate sign convention.
We established the algebraic relations between $\alpha, \beta, \gamma$ using the period equation and computation.
We proved the Artin property for the extension $K/\mathbb{Q}$.
We characterized the cosets $C_1, C_2$ using the cubic character $\chi$.
Finally, we proved `final_result_1567`, which states that for a prime $N \neq 1567$, the Frobenius action on $\alpha$ is determined by the value of the cubic character $\chi(N)$.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: ff94a4ce-df04-43b6-855b-2c35922c8831

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We define the cyclotomic field $K = \mathbb{Q}(\zeta_{1129})$, the ring of integers $\mathcal{O}_K$, and the Gaussian periods $\eta_0, \eta_1, \eta_2$. We define the period differences $\alpha, \beta, \gamma$ with the correct sign convention. We prove the Artin property for $\mathcal{O}_K$ and use it to prove the Dream Theorem for $q = 1129$, which relates the Frobenius action on $\alpha$ to the cubic character $c(N)$. The proof assumes the period equation for $\alpha$ as requested.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 49ab742d-7e60-49a0-9635-aa76ebf271b7

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Proof of the Dream Theorem for q = 1063.

We define the cyclotomic field K = Q(zeta_1063), the ring of integers Ok, and the Gaussian periods.
We identify a generator g = 6 such that the cubic character c(g) = s2 = 719.
We define the roots alpha, beta, gamma using this generator and the standard sign convention.
We prove the Artin property for the extension.
We prove the global permutation of roots under the Galois group.
Finally, we prove the Dream Theorem:
If c(N) = s1, then alpha^N = gamma mod P.
If c(N) = s2, then alpha^N = beta mod P.
This relies on the period equation alpha^3 = 1063*alpha + 1063, which is added as a hypothesis.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f1e85200-2efb-4b56-a019-1c5b75f4b05f

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Proof of the Dream Theorem for q = 937.

We define the cyclotomic field K = Q(zeta_937), its ring of integers Ok, and the Gaussian periods.
We identify a generator g = 7 for which the cubic character values match the s1/s2 definitions.
We prove the Artin property for the extension K/Q.
We prove the main theorem `dream_theorem_937` which states that for a prime N != 937:
- If c(N) = s1, then alpha^N = gamma mod P.
- If c(N) = s2, then alpha^N = beta mod P.
This assumes the period equation `alpha^3 = 937*alpha + 937`.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: b08f138a-15ed-40a2-a0c0-b8f4ce6443e1

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We define the cyclotomic field K for q = 877 and the Gaussian periods. We prove the Dream Theorem for q = 877, which states that the Frobenius automorphism maps the period difference α to β or γ depending on the cubic character of the prime N modulo 877. The proof relies on the Artin property of the Frobenius map and the explicit calculation of the Galois action on the periods.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f1f9f2e4-1b7a-4d8c-ad24-d62d489ea7c9

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: a7add749-96ca-48e2-a89d-fbb216918bc3

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 22a1ac83-9054-4f97-9a50-f0ea72bded01

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: e6ee589a-f550-42ef-89e5-1fd2afd7fa5e

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We defined the constants s1, s2, and the value c(N). We proved lemmas characterizing the cosets C1 and C2 in terms of the 12th power residue symbol (which relates to c(N)). Finally, we proved the main theorem `final_result` which establishes the Frobenius action on alpha (i.e., alpha^N) in terms of beta and gamma, depending on the value of c(N). The proof utilizes the `explicit_frobenius` theorem and the algebraic relations between alpha, beta, and gamma.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 939f55fb-68a7-4ef0-bca3-475f675055ca

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
This module formalizes the proof of the Frobenius Orientation conjecture for q=37.
It defines the cyclotomic field K = Q(zeta_37), the Gaussian periods, and the cubic roots.
It proves the cyclic algebraic relations between these roots and establishes the global Galois action.
It descends to the residue field modulo a prime P lying over N != 37, proving the Artin property.
Finally, it derives the explicit Frobenius action on the reduction of alpha modulo P.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section










/-
Definitions for q = 9127, s1, s2, and the cubic character c(N).
-/
def q9127 : ℕ := 9127

instance fact_prime_9127 : Fact (Nat.Prime 9127) := ⟨by native_decide⟩

def s1_9127 : ZMod 9127 := 3010
def s2_9127 : ZMod 9127 := 6116
def c9127 (N : ℕ) : ZMod 9127 := (N : ZMod 9127)^3042

/-
Find a generator g for ZMod 9127 such that c(g) = s2.
-/
def find_g_9127 : IO Unit := do
  let q := 9127
  let s2 := 6116
  let c (n : Nat) := (n : Nat) ^ 3042 % q
  let order := q - 1
  let factors := [2, 3, 13] -- 9126 = 2 * 3^3 * 13^2
  
  for g in [2:100] do
    let mut is_prim := true
    for f in factors do
      if (g ^ (order / f)) % q == 1 then
        is_prim := false
        break
    
    if is_prim then
      if c g == s2 then
        IO.println s!"Found good generator: {g}"
        return
  
  IO.println "No generator found in range"

#eval find_g_9127

/-
Definitions of the cyclotomic field K, zeta, the generator g, the subgroups H, C1, C2, and the periods eta0, eta1, eta2, and the differences alpha', beta', gamma'.
-/
abbrev K9127 := CyclotomicField 9127 ℚ

noncomputable def zeta9127 : K9127 := IsCyclotomicExtension.zeta 9127 ℚ K9127

def g9127 : ZMod 9127 := 12

def H9127 : Finset (ZMod 9127) := ((Finset.univ : Finset (ZMod 9127)).filter (fun x => x ≠ 0)).image (fun x => x^3)

def C1_9127 : Finset (ZMod 9127) := H9127.image (fun x => g9127 * x)

def C2_9127 : Finset (ZMod 9127) := H9127.image (fun x => g9127^2 * x)

open scoped BigOperators

noncomputable def eta9127 (S : Finset (ZMod 9127)) : K9127 := ∑ x ∈ S, zeta9127^(x.val)

noncomputable def eta0_9127 := eta9127 H9127
noncomputable def eta1_9127 := eta9127 C1_9127
noncomputable def eta2_9127 := eta9127 C2_9127

noncomputable def alpha_prime_9127 := eta0_9127 - eta1_9127
noncomputable def beta_prime_9127 := eta1_9127 - eta2_9127
noncomputable def gamma_prime_9127 := eta2_9127 - eta0_9127

/-
Define the ring of integers and state the irreducibility of the cyclotomic polynomial.
-/
abbrev Ok9127 := NumberField.RingOfIntegers K9127

theorem h_irr_9127 : Irreducible (Polynomial.cyclotomic 9127 ℚ) := by
  exact Polynomial.cyclotomic.irreducible_rat <| by decide;

/-
Define the Galois automorphism sigma for K9127.
-/
noncomputable def sigma9127 (n : (ZMod 9127)ˣ) : K9127 ≃ₐ[ℚ] K9127 :=
  (IsCyclotomicExtension.autEquivPow K9127 h_irr_9127).symm n

/-
Prove that zeta is an algebraic integer.
-/
theorem zeta_isIntegral_9127 : IsIntegral ℤ zeta9127 := by
  refine' ⟨ Polynomial.X ^ 9127 - 1, _, _ ⟩;
  · exact Polynomial.monic_X_pow_sub_C _ ( by norm_num );
  · have h_root : IsPrimitiveRoot zeta9127 9127 := by
      convert IsCyclotomicExtension.zeta_spec 9127 ℚ K9127 using 1;
    have := h_root.pow_eq_one; aesop;

/-
Define zeta as an integer and the restriction of sigma to the ring of integers.
-/
def zeta_int9127 : Ok9127 := ⟨zeta9127, zeta_isIntegral_9127⟩

noncomputable def sigma_int9127 (n : (ZMod 9127)ˣ) : Ok9127 ≃ₐ[ℤ] Ok9127 :=
  (NumberField.RingOfIntegers.mapAlgEquiv (sigma9127 n)).restrictScalars ℤ

/-
Define the integer periods and differences alpha', beta', gamma'.
-/
noncomputable def eta_int9127 (S : Finset (ZMod 9127)) : Ok9127 := ∑ x ∈ S, zeta_int9127^(x.val)

noncomputable def eta0_int9127 := eta_int9127 H9127
noncomputable def eta1_int9127 := eta_int9127 C1_9127
noncomputable def eta2_int9127 := eta_int9127 C2_9127

noncomputable def alpha_prime_int9127 := eta0_int9127 - eta1_int9127
noncomputable def beta_prime_int9127 := eta1_int9127 - eta2_int9127
noncomputable def gamma_prime_int9127 := eta2_int9127 - eta0_int9127

/-
Define the sign convention and the final alpha, beta, gamma.
-/
open Classical

noncomputable def sign_9127 : ℤ :=
  if alpha_prime_int9127 * beta_prime_int9127 * gamma_prime_int9127 = (9127 : Ok9127) then 1 else -1

noncomputable def alpha_int9127 := (sign_9127 : Ok9127) * alpha_prime_int9127
noncomputable def beta_int9127 := (sign_9127 : Ok9127) * beta_prime_int9127
noncomputable def gamma_int9127 := (sign_9127 : Ok9127) * gamma_prime_int9127

noncomputable def alpha9127_field : K9127 := alpha_int9127
noncomputable def beta9127_field : K9127 := beta_int9127
noncomputable def gamma9127_field : K9127 := gamma_int9127

/-
Compute the coefficients for the algebraic relations between alpha, beta, and gamma.
-/
def find_coeffs_9127 : IO Unit := do
  let q := 9127
  let a := 191
  -- Find p = k*q + 1
  let mut p := 0
  for k in [2:200] do
    let cand := k * q + 1
    if Nat.Prime cand then
      p := cand
      break
  
  if p == 0 then
    IO.println "No prime found"
    return

  IO.println s!"Using prime p = {p}"

  -- Find element of order q
  let mut g_p := 0
  for g in [2:p] do
    let zeta := (g : Nat) ^ ((p - 1) / q) % p
    if zeta != 1 then
      g_p := g
      break
  
  let zeta := (g_p : Nat) ^ ((p - 1) / q) % p
  IO.println s!"zeta = {zeta}"

  -- Cosets of cubic residues mod q
  -- g_q = 12
  let g_q := 12
  let mut H : List Nat := []
  let mut x := 1
  let g_q_3 := (g_q * g_q * g_q) % q
  for _ in [0:(q-1)/3] do
    H := x :: H
    x := (x * g_q_3) % q
  
  let C1 := H.map (fun h => (h * g_q) % q)
  let C2 := H.map (fun h => (h * g_q * g_q) % q)

  -- Periods mod p
  let sum_zeta (S : List Nat) : Nat :=
    S.foldl (fun acc h => (acc + (zeta ^ h) % p) % p) 0
  
  let eta0 := sum_zeta H
  let eta1 := sum_zeta C1
  let eta2 := sum_zeta C2

  -- Differences
  let alpha_prime := (eta0 + p - eta1) % p
  let beta_prime := (eta1 + p - eta2) % p
  let gamma_prime := (eta2 + p - eta0) % p

  -- Check sign convention
  let prod := (alpha_prime * beta_prime) % p * gamma_prime % p
  let q_mod_p := q % p
  
  let mut alpha := 0
  let mut beta := 0
  let mut gamma := 0

  if prod == q_mod_p then
    alpha := alpha_prime
    beta := beta_prime
    gamma := gamma_prime
    IO.println "Sign convention: positive"
  else
    alpha := (p - alpha_prime) % p
    beta := (p - beta_prime) % p
    gamma := (p - gamma_prime) % p
    IO.println "Sign convention: negative"

  -- Solve 191 * beta = c0 + c1 * alpha + c2 * alpha^2 mod p
  let sub (x y : Nat) := (x + p - y) % p
  let mul (x y : Nat) := (x * y) % p
  let add (x y : Nat) := (x + y) % p
  let pow (x n : Nat) := x ^ n % p
  let inv (x : Nat) := x ^ (p - 2) % p

  let det := mul (sub beta alpha) (mul (sub gamma alpha) (sub gamma beta))
  let det_inv := inv det

  let rhs0 := mul a beta
  let rhs1 := mul a gamma
  let rhs2 := mul a alpha

  -- Solve for c0, c1, c2
  -- c0
  let term0 := mul rhs0 (sub (mul beta (mul gamma gamma)) (mul gamma (mul beta beta)))
  let term1 := mul rhs1 (sub (mul gamma (mul alpha alpha)) (mul alpha (mul gamma gamma)))
  let term2 := mul rhs2 (sub (mul alpha (mul beta beta)) (mul beta (mul alpha alpha)))
  let c0 := mul (add term0 (add term1 term2)) det_inv

  -- c1
  let term0_1 := mul 1 (sub (mul rhs1 (mul gamma gamma)) (mul rhs2 (mul beta beta)))
  let term1_1 := mul 1 (sub (mul rhs2 (mul alpha alpha)) (mul rhs0 (mul gamma gamma)))
  let term2_1 := mul 1 (sub (mul rhs0 (mul beta beta)) (mul rhs1 (mul alpha alpha)))
  let c1 := mul (add term0_1 (add term1_1 term2_1)) det_inv

  -- c2
  let term0_2 := mul 1 (sub (mul beta rhs2) (mul gamma rhs1))
  let term1_2 := mul 1 (sub (mul gamma rhs0) (mul alpha rhs2))
  let term2_2 := mul 1 (sub (mul alpha rhs1) (mul beta rhs0))
  let c2 := mul (add term0_2 (add term1_2 term2_2)) det_inv

  let to_signed (x : Nat) : Int :=
    if x > p / 2 then (x : Int) - p else x

  IO.println s!"Coefficients for beta: c0={to_signed c0}, c1={to_signed c1}, c2={to_signed c2}"
  
  -- Also for gamma
  let rhs0_g := mul a gamma
  let rhs1_g := mul a alpha
  let rhs2_g := mul a beta

  let term0_g := mul rhs0_g (sub (mul beta (mul gamma gamma)) (mul gamma (mul beta beta)))
  let term1_g := mul rhs1_g (sub (mul gamma (mul alpha alpha)) (mul alpha (mul gamma gamma)))
  let term2_g := mul rhs2_g (sub (mul alpha (mul beta beta)) (mul beta (mul alpha alpha)))
  let d0 := mul (add term0_g (add term1_g term2_g)) det_inv

  let term0_1g := mul 1 (sub (mul rhs1_g (mul gamma gamma)) (mul rhs2_g (mul beta beta)))
  let term1_1g := mul 1 (sub (mul rhs2_g (mul alpha alpha)) (mul rhs0_g (mul gamma gamma)))
  let term2_1g := mul 1 (sub (mul rhs0_g (mul beta beta)) (mul rhs1_g (mul alpha alpha)))
  let d1 := mul (add term0_1g (add term1_1g term2_1g)) det_inv

  let term0_2g := mul 1 (sub (mul beta rhs2_g) (mul gamma rhs1_g))
  let term1_2g := mul 1 (sub (mul gamma rhs0_g) (mul alpha rhs2_g))
  let term2_2g := mul 1 (sub (mul alpha rhs1_g) (mul beta rhs0_g))
  let d2 := mul (add term0_2g (add term1_2g term2_2g)) det_inv

  IO.println s!"Coefficients for gamma: d0={to_signed d0}, d1={to_signed d1}, d2={to_signed d2}"

#eval find_coeffs_9127

/-
Define the Dream Assumptions for q = 9127, including the period equation and algebraic relations.
-/
def DreamAssumptions_9127 : Prop :=
  alpha_int9127^3 = 9127 * alpha_int9127 + 9127 ∧
  alpha_int9127 * beta_int9127 * gamma_int9127 = 9127 ∧
  191 * beta_int9127 = 3 * alpha_int9127^2 - 100 * alpha_int9127 - 18254 ∧
  191 * gamma_int9127 = -3 * alpha_int9127^2 - 91 * alpha_int9127 + 18254

/-
Define N as a unit in ZMod 9127 given that N is prime and not 9127.
-/
def N_mod_9127 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 9127) : (ZMod 9127)ˣ :=
  ZMod.unitOfCoprime N (Nat.Coprime.symm ((Nat.coprime_primes (by norm_num) (Fact.out)).mpr hN.symm))

/-
Lemma: The automorphism sigma_n maps zeta to zeta^n.
-/
lemma sigma_int_zeta_pow_9127 (n : (ZMod 9127)ˣ) :
  sigma_int9127 n zeta_int9127 = zeta_int9127 ^ (n : ZMod 9127).val := by
    unfold sigma_int9127;
    unfold sigma9127; norm_num;
    erw [ Subtype.mk_eq_mk ];
    erw [ PowerBasis.equivOfMinpoly_gen ];
    rfl

/-
Theorem: The Artin map on zeta corresponds to the N-th power map modulo P.
-/
theorem artin_property_zeta_9127 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 9127) (P : Ideal Ok9127) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  Ideal.Quotient.mk P (sigma_int9127 (N_mod_9127 N hN) zeta_int9127) = (Ideal.Quotient.mk P zeta_int9127)^N := by
    -- By definition of N_mod_9127, we know that N_mod_9127 N hN is the unit in ZMod 9127 corresponding to N.
    set n := N_mod_9127 N hN with hn_def
    have hn : (n : ZMod 9127) = N := by
      unfold N_mod_9127 at * ; aesop;
    rw [sigma_int_zeta_pow_9127];
    rw [ hn, ZMod.val_natCast ];
    rw [ ← Nat.mod_add_div N 9127 ] ; norm_num [ pow_add, pow_mul ] ;
    have h_zeta_pow : (Ideal.Quotient.mk P zeta_int9127) ^ 9127 = 1 := by
      have h_zeta_pow : zeta_int9127 ^ 9127 = 1 := by
        have hzeta_pow : zeta9127 ^ 9127 = 1 := by
          exact IsCyclotomicExtension.zeta_pow _ _ _;
        exact Subtype.ext hzeta_pow;
      rw [ ← map_pow, h_zeta_pow, map_one ];
    rw [ h_zeta_pow, one_pow, mul_one ]

/-
Prove that zeta is a primitive 9127-th root of unity.
-/
theorem zeta_isPrimitiveRoot_9127 : IsPrimitiveRoot zeta9127 9127 := by
  exact IsCyclotomicExtension.zeta_spec 9127 ℚ K9127

/-
Theorem: The ring of integers is generated by zeta.
-/
theorem Ok9127_eq_adjoin : (⊤ : Subalgebra ℤ Ok9127) = Algebra.adjoin ℤ {zeta_int9127} := by
  have := @IsCyclotomicExtension.Rat.isIntegralClosure_adjoin_singleton_of_prime;
  specialize @this 9127 K9127 _ zeta9127 _ _ _ _;
  · exact?;
  · obtain ⟨ _, h ⟩ := this;
    ext x;
    convert h.mp _;
    rotate_left;
    exact ↑x;
    · exact x.2;
    · simp +decide [ Algebra.adjoin_singleton_eq_range_aeval ];
      constructor <;> rintro ⟨ p, hp ⟩ <;> use p <;> simp_all +decide [ Polynomial.aeval_def ];
      · convert congr_arg ( fun x : Ok9127 => ( x : K9127 ) ) hp using 1;
        simp +decide [ Polynomial.eval₂_eq_sum_range ];
        rfl;
      · convert hp using 1;
        constructor <;> intro <;> aesop

/-
Theorem: The ring of integers is generated by zeta (version 2).
-/
theorem Ok9127_eq_adjoin_2 : (⊤ : Subalgebra ℤ Ok9127) = Algebra.adjoin ℤ {zeta_int9127} := by
  exact?

/-
Theorem: The Artin property holds for all elements of the ring of integers.
-/
theorem artin_property_9127 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 9127) (P : Ideal Ok9127) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) (x : Ok9127) :
  Ideal.Quotient.mk P (sigma_int9127 (N_mod_9127 N hN) x) = (Ideal.Quotient.mk P x)^N := by
    -- Let's choose any $x \in \mathcal{O}_{K_{9127}}$ and apply the Artin property.
    have h_artin : ∀ x : Ok9127, Ideal.Quotient.mk P (sigma_int9127 (N_mod_9127 N hN) x) = (Ideal.Quotient.mk P x) ^ N := by
      have := @Ok9127_eq_adjoin_2;
      intro x
      have hx : x ∈ Algebra.adjoin ℤ {zeta_int9127} := by
        exact this ▸ Algebra.mem_top;
      refine' Algebra.adjoin_induction _ _ _ _ hx;
      · convert artin_property_zeta_9127 N hN P hP using 1;
        simp +decide [ Ideal.Quotient.eq_zero_iff_mem ];
      · intro r; erw [ Ideal.Quotient.eq ] ;
        -- Since $r$ is an integer, we have $r^N \equiv r \pmod{P}$ by Fermat's Little Theorem.
        have h_fermat : (r : Ok9127) ^ N - r ∈ P := by
          have h_fermat : (r : Ok9127) ^ N - r ∈ Ideal.span {(N : ℤ) • 1} := by
            have h_fermat : (r : ℤ) ^ N - r ≡ 0 [ZMOD N] := by
              haveI := Fact.mk ( Fact.out : Nat.Prime N ) ; simp +decide [ ← ZMod.intCast_eq_intCast_iff ] ;
            rw [ Int.modEq_zero_iff_dvd ] at h_fermat;
            obtain ⟨ k, hk ⟩ := h_fermat;
            exact Ideal.mem_span_singleton.mpr ⟨ k, by simpa [ ← @Int.cast_inj ( Ok9127 ) ] using hk ⟩
          have h_fermat : (N : ℤ) • 1 ∈ P := by
            have := hP.1;
            rw [ SetLike.ext_iff ] at this;
            specialize this N; simp_all +decide [ Ideal.mem_span_singleton ] ;
          exact Ideal.span_le.mpr ( Set.singleton_subset_iff.mpr h_fermat ) ‹_›;
        simpa using P.neg_mem h_fermat;
      · intro x y hx hy hx' hy';
        convert congr_arg₂ ( · + · ) hx' hy' using 1;
        · exact congr_arg _ ( map_add _ _ _ );
        · have h_char : ringChar (Ok9127 ⧸ P) = N := by
            have h_char : ringChar (Ok9127 ⧸ P) = ringChar (ℤ ⧸ Ideal.span {(N : ℤ)}) := by
              have h_char : Ideal.span {(N : ℤ)} = Ideal.comap (algebraMap ℤ Ok9127) P := by
                exact hP.1.symm ▸ rfl;
              rw [ h_char ];
              rw [ ringChar.eq_iff ];
              convert CharP.mk _;
              intro x; rw [ ← ringChar.spec ] ;
              erw [ Ideal.Quotient.eq_zero_iff_mem, Ideal.Quotient.eq_zero_iff_mem ];
              simp +decide [ Ideal.mem_comap ];
            rw [ h_char ];
            rw [ ringChar.eq_iff ];
            constructor;
            intro x; erw [ Ideal.Quotient.eq_zero_iff_mem ] ; erw [ Ideal.mem_span_singleton ] ; norm_cast;
          have h_char : ∀ (a b : Ok9127 ⧸ P), (a + b) ^ N = a ^ N + b ^ N := by
            haveI := Fact.mk ( show Nat.Prime ( ringChar ( Ok9127 ⧸ P ) ) from h_char.symm ▸ Fact.out ) ; simp +decide [ ← h_char, add_pow_char ] ;
          convert h_char _ _ using 1;
          exact?;
      · simp +contextual [ mul_pow ];
    exact h_artin x

/-
Define the cubic character chi and prove it is multiplicative.
-/
def chi9127 (x : ZMod 9127) : ZMod 9127 := x ^ 3042

lemma chi9127_mul (x y : ZMod 9127) : chi9127 (x * y) = chi9127 x * chi9127 y := by
  unfold chi9127;
  rw [ mul_pow ]

/-
Check the value of chi(g) against s1 and s2.
-/
def check_chi_values_9127 : IO Unit := do
  let q := 9127
  let s1 := 3010
  let s2 := 6116
  let g := 12
  let chi (n : Nat) := (n : Nat) ^ 3042 % q
  let chig := chi g
  IO.println s!"chi(g) = {chig}"
  if chig == s1 then IO.println "chi(g) = s1"
  else if chig == s2 then IO.println "chi(g) = s2"
  else IO.println "chi(g) is neither"

#eval check_chi_values_9127

/-
Lemma: The action of sigma on eta corresponds to multiplying the set S by n.
-/
lemma sigma_eta_9127 (n : (ZMod 9127)ˣ) (S : Finset (ZMod 9127)) :
  sigma_int9127 n (eta_int9127 S) = eta_int9127 (S.image (fun x => (n : ZMod 9127) * x)) := by
    unfold eta_int9127;
    simp +zetaDelta at *;
    refine' Finset.sum_congr rfl fun x hx => _;
    rw [ sigma_int_zeta_pow_9127 ];
    rw [ ← pow_mul, ZMod.val_mul ];
    -- Since $zeta_int9127$ is a root of unity, we have $zeta_int9127^{9127} = 1$.
    have h_root_of_unity : zeta_int9127 ^ 9127 = 1 := by
      have h_root_of_unity : zeta9127 ^ 9127 = 1 := by
        exact IsPrimitiveRoot.pow_eq_one ( zeta_isPrimitiveRoot_9127 );
      exact Subtype.ext h_root_of_unity;
    rw [ ← Nat.mod_add_div ( ( n : ZMod 9127 ).val * x.val ) 9127, pow_add, pow_mul ] ; aesop

/-
Lemma: Multiplication by an element of H fixes H, C1, and C2 set-wise.
-/
lemma action_H_9127 (n : ZMod 9127) (hn : n ∈ H9127) :
  H9127.image (fun x => n * x) = H9127 ∧
  C1_9127.image (fun x => n * x) = C1_9127 ∧
  C2_9127.image (fun x => n * x) = C2_9127 := by
    revert n hn;
    -- Since $H9127$ is a subgroup, multiplying by an element of $H9127$ fixes $H9127$.
    intro n hn
    have hH : Finset.image (fun x => n * x) H9127 = H9127 := by
      refine' Finset.eq_of_subset_of_card_le _ _;
      · intro x hx
        obtain ⟨y, hy, rfl⟩ := Finset.mem_image.mp hx
        have hyH : y ∈ H9127 := hy
        have hnH : n ∈ H9127 := hn
        have hxyH : n * y ∈ H9127 := by
          obtain ⟨ x, hx, rfl ⟩ := Finset.mem_image.mp hnH; obtain ⟨ y, hy, rfl ⟩ := Finset.mem_image.mp hyH; ring_nf;
          rw [ ← mul_pow ] ; exact Finset.mem_image.mpr ⟨ x * y, by aesop ⟩ ;
        exact hxyH;
      · rw [ Finset.card_image_of_injective _ fun x y hxy => _ ];
        rw [ show H9127 = Finset.image ( fun x : ZMod 9127 => x ^ 3 ) ( Finset.univ.filter ( fun x : ZMod 9127 => x ≠ 0 ) ) by rfl ] at hn; aesop;
    unfold C1_9127 C2_9127;
    simp +contextual [ Finset.ext_iff, Finset.mem_image, mul_assoc ] at hH ⊢;
    refine' ⟨ hH, _, _ ⟩ <;> intro a <;> constructor <;> intro ha <;> obtain ⟨ x, hx, rfl ⟩ := ha <;> simp +decide [ ← mul_assoc, hH ];
    · exact ⟨ n * x, hH _ |>.1 ⟨ x, hx, by ring ⟩, by ring ⟩;
    · obtain ⟨ y, hy, rfl ⟩ := hH x |>.2 hx; use y; ring_nf at *; aesop;
    · exact ⟨ n * x, hH _ |>.1 ⟨ x, hx, by ring ⟩, by ring ⟩;
    · grind

/-
Lemma: Multiplication by an element of C1 permutes the sets cyclically (H -> C1 -> C2 -> H).
-/
lemma action_C1_9127 (n : ZMod 9127) (hn : n ∈ C1_9127) :
  H9127.image (fun x => n * x) = C1_9127 ∧
  C1_9127.image (fun x => n * x) = C2_9127 ∧
  C2_9127.image (fun x => n * x) = H9127 := by
    have hn.arg1 : ∃ h ∈ H9127, n = g9127 * h := by
      native_decide +revert;
    have h_mul_H : Finset.image (fun x => g9127 * x) H9127 = C1_9127 ∧ Finset.image (fun x => g9127 * x) C1_9127 = C2_9127 ∧ Finset.image (fun x => g9127 * x) C2_9127 = H9127 := by
      native_decide +revert;
    rcases hn.arg1 with ⟨ h, hh, rfl ⟩;
    have h_mul_H : Finset.image (fun x => h * x) H9127 = H9127 ∧ Finset.image (fun x => h * x) C1_9127 = C1_9127 ∧ Finset.image (fun x => h * x) C2_9127 = C2_9127 := by
      exact action_H_9127 h hh;
    have h_mul_H : Finset.image (fun x => g9127 * h * x) H9127 = Finset.image (fun x => g9127 * x) (Finset.image (fun x => h * x) H9127) ∧ Finset.image (fun x => g9127 * h * x) C1_9127 = Finset.image (fun x => g9127 * x) (Finset.image (fun x => h * x) C1_9127) ∧ Finset.image (fun x => g9127 * h * x) C2_9127 = Finset.image (fun x => g9127 * x) (Finset.image (fun x => h * x) C2_9127) := by
      simp +decide [ mul_assoc, Finset.ext_iff ];
    grind +ring

/-
Lemma: Multiplication by an element of C2 permutes the sets cyclically (H -> C2 -> H -> C1).
-/
lemma action_C2_9127 (n : ZMod 9127) (hn : n ∈ C2_9127) :
  H9127.image (fun x => n * x) = C2_9127 ∧
  C1_9127.image (fun x => n * x) = H9127 ∧
  C2_9127.image (fun x => n * x) = C1_9127 := by
    revert hn;
    -- Since $n \in C2_9127$, we have $n = g^2h$ for some $h \in H9127$.
    have hn_form : ∀ n ∈ C2_9127, ∃ h ∈ H9127, n = g9127^2 * h := by
      native_decide +revert;
    intro hn
    obtain ⟨h, hhH, rfl⟩ := hn_form n hn;
    have h_mul_H : Finset.image (fun x => h * x) H9127 = H9127 := by
      exact action_H_9127 h hhH |>.1.symm ▸ rfl
    have h_mul_C1 : Finset.image (fun x => h * x) C1_9127 = C1_9127 := by
      have := action_H_9127 h hhH; aesop;
    have h_mul_C2 : Finset.image (fun x => h * x) C2_9127 = C2_9127 := by
      have h_mul_C2 : Finset.image (fun x => h * x) C2_9127 = Finset.image (fun x => g9127^2 * x) (Finset.image (fun x => h * x) H9127) := by
        ext; simp [C2_9127, Finset.mem_image];
        simp +decide only [mul_left_comm];
      rw [h_mul_C2, h_mul_H];
      native_decide +revert;
    have h_mul_g2 : Finset.image (fun x => g9127^2 * x) H9127 = C2_9127 ∧ Finset.image (fun x => g9127^2 * x) C1_9127 = H9127 ∧ Finset.image (fun x => g9127^2 * x) C2_9127 = C1_9127 := by
      native_decide;
    simp_all +contextual [ mul_assoc, Finset.ext_iff ];
    refine' ⟨ fun a => _, fun a => _, fun a => _ ⟩;
    · convert h_mul_g2.1 a using 1;
      exact ⟨ fun ⟨ x, hx, hx' ⟩ => ⟨ h * x, h_mul_H _ |>.1 ⟨ x, hx, rfl ⟩, hx' ⟩, fun ⟨ x, hx, hx' ⟩ => by obtain ⟨ y, hy, rfl ⟩ := h_mul_H _ |>.2 hx; exact ⟨ y, hy, by linear_combination' hx' ⟩ ⟩;
    · convert h_mul_g2.2.1 a using 1;
      exact ⟨ fun ⟨ x, hx, hx' ⟩ => ⟨ h * x, by simpa [ mul_assoc ] using h_mul_C1 _ |>.1 ⟨ x, hx, rfl ⟩, hx' ⟩, fun ⟨ x, hx, hx' ⟩ => by obtain ⟨ y, hy, rfl ⟩ := h_mul_C1 _ |>.2 hx; exact ⟨ y, hy, by simpa [ mul_assoc ] using hx' ⟩ ⟩;
    · convert h_mul_g2.2.2 a using 1;
      constructor <;> rintro ⟨ x, hx, rfl ⟩;
      · exact ⟨ h * x, h_mul_C2 _ |>.1 ⟨ x, hx, rfl ⟩, rfl ⟩;
      · obtain ⟨ y, hy, rfl ⟩ := h_mul_C2 x |>.2 hx;
        exact ⟨ y, hy, rfl ⟩

/-
Lemma: The automorphism sigma_n permutes alpha, beta, gamma according to the coset of n.
-/
lemma global_permutation_9127 (n : (ZMod 9127)ˣ) :
  ((n : ZMod 9127) ∈ C1_9127 → sigma_int9127 n alpha_int9127 = beta_int9127) ∧
  ((n : ZMod 9127) ∈ C2_9127 → sigma_int9127 n alpha_int9127 = gamma_int9127) ∧
  ((n : ZMod 9127) ∈ H9127 → sigma_int9127 n alpha_int9127 = alpha_int9127) := by
    constructor;
    · intro hn
      have h_sigma_eta : sigma_int9127 n eta0_int9127 = eta1_int9127 ∧ sigma_int9127 n eta1_int9127 = eta2_int9127 ∧ sigma_int9127 n eta2_int9127 = eta0_int9127 := by
        have h_sigma_eta : sigma_int9127 n eta0_int9127 = eta_int9127 (H9127.image (fun x => (n : ZMod 9127) * x)) ∧ sigma_int9127 n eta1_int9127 = eta_int9127 (C1_9127.image (fun x => (n : ZMod 9127) * x)) ∧ sigma_int9127 n eta2_int9127 = eta_int9127 (C2_9127.image (fun x => (n : ZMod 9127) * x)) := by
          exact ⟨ sigma_eta_9127 n H9127, sigma_eta_9127 n C1_9127, sigma_eta_9127 n C2_9127 ⟩;
        have := action_C1_9127 n hn; simp_all +decide [ Finset.ext_iff ] ;
        exact ⟨ rfl, rfl, rfl ⟩;
      unfold alpha_int9127 beta_int9127;
      unfold alpha_prime_int9127 beta_prime_int9127; aesop;
    · constructor <;> intro hn
      generalize_proofs at *;
      · -- By definition of $alpha_int9127$, we know that
        have h_alpha_def : (sigma_int9127 n) alpha_int9127 = (sign_9127 : Ok9127) * ((sigma_int9127 n) eta0_int9127 - (sigma_int9127 n) eta1_int9127) := by
          rw [ show alpha_int9127 = ( sign_9127 : Ok9127 ) * ( eta0_int9127 - eta1_int9127 ) by rfl ] ; simp +decide [ map_mul, map_sub ] ;
        -- By definition of $eta_int9127$, we know that
        have h_eta_def : (sigma_int9127 n) eta0_int9127 = eta_int9127 (H9127.image (fun x => (n : ZMod 9127) * x)) ∧ (sigma_int9127 n) eta1_int9127 = eta_int9127 (C1_9127.image (fun x => (n : ZMod 9127) * x)) := by
          exact ⟨ sigma_eta_9127 n H9127, sigma_eta_9127 n C1_9127 ⟩
        generalize_proofs at *;
        rw [ h_alpha_def, h_eta_def.1, h_eta_def.2 ];
        rw [ action_C2_9127 _ hn |>.1, action_C2_9127 _ hn |>.2.1 ] ; rfl;
      · unfold alpha_int9127;
        unfold alpha_prime_int9127;
        unfold eta0_int9127 eta1_int9127; simp +decide [ sigma_eta_9127, action_H_9127 _ hn ] ;

/-
Check if s2^2 = s1 mod 9127.
-/
def check_s_relation_9127 : IO Unit := do
  let s1 := 3010
  let s2 := 6116
  let q := 9127
  let s2_sq := s2 * s2 % q
  IO.println s!"s2^2 = {s2_sq}"
  if s2_sq == s1 then IO.println "s2^2 = s1" else IO.println "s2^2 != s1"

#eval check_s_relation_9127

/-
Lemma: An element n is in C1 if and only if its cubic character is s2.
-/
lemma mem_C1_iff_chi_eq_s2_9127 (n : ZMod 9127) (hn : n ≠ 0) : n ∈ C1_9127 ↔ chi9127 n = s2_9127 := by
  native_decide +revert

/-
Lemma: An element n is in C2 if and only if its cubic character is s1.
-/
lemma mem_C2_iff_chi_eq_s1_9127 (n : ZMod 9127) (hn : n ≠ 0) : n ∈ C2_9127 ↔ chi9127 n = s1_9127 := by
  native_decide +revert

/-
The Dream Theorem for q = 9127.
-/
theorem final_result_9127 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 9127) (hN_odd : N % 2 = 1) (hN_a : Nat.Coprime 191 N)
  (P : Ideal Ok9127) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)}))
  (h_assum : DreamAssumptions_9127) :
  let alpha_bar := Ideal.Quotient.mk P alpha_int9127
  let beta_bar := Ideal.Quotient.mk P beta_int9127
  let gamma_bar := Ideal.Quotient.mk P gamma_int9127
  (chi9127 N = s1_9127 → alpha_bar ^ N = gamma_bar) ∧
  (chi9127 N = s2_9127 → alpha_bar ^ N = beta_bar) := by
    constructor;
    · intro hchi
      have hN_C2 : (N_mod_9127 N hN : ZMod 9127) ∈ C2_9127 := by
        apply (mem_C2_iff_chi_eq_s1_9127 (N_mod_9127 N hN) (by
        intro h; simp_all +decide [ ZMod.natCast_eq_zero_iff ] ;)).mpr hchi;
      have h_sigma_gamma : sigma_int9127 (N_mod_9127 N hN) alpha_int9127 = gamma_int9127 := by
        exact global_permutation_9127 _ |>.2.1 hN_C2;
      rw [ ← h_sigma_gamma, artin_property_9127 N hN P hP ];
    · intro hchi
      have hsigma : sigma_int9127 (N_mod_9127 N hN) alpha_int9127 = beta_int9127 := by
        apply (global_permutation_9127 (N_mod_9127 N hN)).left;
        have := mem_C1_iff_chi_eq_s2_9127 ( N_mod_9127 N hN ) ?_;
        · unfold N_mod_9127 at *; simp_all +decide [ ZMod.val_natCast ] ;
        · haveI := Fact.mk ( Fact.out : Nat.Prime N ) ; simp +decide [ ZMod.natCast_eq_zero_iff ] ;
      rw [ ← hsigma, ← artin_property_9127 N hN P hP ]