/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: c4b15c1b-62c1-4487-bfce-2f7c4d630c6d

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We defined the cyclotomic field L349 and the constants q=349, a=37. We defined the Gaussian periods and the roots alpha, beta, gamma. We proved the algebraic relations between them, including the sum being zero and the relation involving beta and alpha^2. We established the multiplication table for the periods. Finally, we proved the main result describing the action of the Frobenius automorphism on alpha modulo a prime ideal P, showing that alpha^N reduces to gamma or beta depending on the value of c = N^((q-1)/3) modulo q.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 04f6f797-c7e7-4cf6-b418-1c7ab61b9dcf

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We defined the cyclotomic field $L = \mathbb{Q}(\zeta_{97})$ and the Gaussian periods $\eta_0, \eta_1, \eta_2$ of degree 3.
We defined $\alpha = -(\eta_2 - \eta_1)$, $\beta = -(\eta_0 - \eta_2)$, $\gamma = -(\eta_1 - \eta_0)$.
We proved that $\alpha$ is a root of $f(x) = x^3 - 97x - 97$.
We proved the relation $2(19)\beta = 6\alpha^2 - (19+9)\alpha - 4(97)$ and $\alpha + \beta + \gamma = 0$.
We proved that for a prime $N \neq 97$, if $c \equiv N^{(97-1)/3} \pmod{97}$, then:
- If $c \equiv s_1 \pmod{97}$, then $\alpha^N = \gamma$ in the residue field.
- If $c \equiv s_2 \pmod{97}$, then $\alpha^N = \beta$ in the residue field.
This confirms the user's conjecture for $q=97$.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: bc574a7b-2f49-44ce-aa0d-64cc13ca8cca

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Defined the constants q=19, a=7, s1, s2, and the polynomial f = x^3 - 19x - 19.
Proved that alpha is a root of f, alpha + beta + gamma = 0, and the relation for beta.
Proved that if c = s1 then alpha^N = gamma, and if c = s2 then alpha^N = beta, in the residue field.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 013af067-1663-4275-8247-aae4bf9f3f5e

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Formalization of the Frobenius Orientation for q=19.

We define the 19th cyclotomic field L and its ring of integers ùìûL.
We define the Gaussian periods Œ∑‚ÇÄ, Œ∑‚ÇÅ, Œ∑‚ÇÇ and the cubic roots Œ±, Œ≤, Œ≥.
We assume the global cyclic relations and the global permutation action of the Galois group.
We prove the Artin property for the reduction map.
We prove the explicit formula for the Frobenius automorphism on the reduction of Œ± modulo a prime N ‚â† 19, 7.

Main theorems:
- `artin_property`: The reduction of the automorphism œÉ_N coincides with the Frobenius map x ‚Ü¶ x^N.
- `explicit_frobenius`: The explicit action of the Frobenius map on Œ± mod P, given by rational functions of Œ± depending on N mod 19.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 5cea8056-f50a-46c6-b96f-9313f106b5e1

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

namespace Q0349


set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Let $L = \Q(\zeta_{19})$ be the 19-th cyclotomic field. Let $\zeta$ be a primitive 19-th root of unity.
-/
open Polynomial NumberField

def L : Type := CyclotomicField 19 ‚Ñö

instance : Field L := CyclotomicField.instField 19 ‚Ñö
instance : NumberField L := CyclotomicField.instNumberField 19 ‚Ñö
instance : IsCyclotomicExtension {19} ‚Ñö L := CyclotomicField.isCyclotomicExtension 19 ‚Ñö

def Œ∂ : L := IsCyclotomicExtension.zeta 19 ‚Ñö L

theorem hŒ∂ : IsPrimitiveRoot Œ∂ 19 := IsCyclotomicExtension.zeta_spec 19 ‚Ñö L

/-
Define the Gaussian periods $\eta_0, \eta_1, \eta_2$.
-/
def Œ∑‚ÇÄ : L := Œ∂^1 + Œ∂^7 + Œ∂^8 + Œ∂^11 + Œ∂^12 + Œ∂^18
def Œ∑‚ÇÅ : L := Œ∂^2 + Œ∂^3 + Œ∂^5 + Œ∂^14 + Œ∂^16 + Œ∂^17
def Œ∑‚ÇÇ : L := Œ∂^4 + Œ∂^6 + Œ∂^9 + Œ∂^10 + Œ∂^13 + Œ∂^15

/-
Define the roots $\alpha, \beta, \gamma$ and verify the cyclic relations: $7\beta = 3\alpha^2 - 8\alpha - 38$ and $7\gamma = -3\alpha^2 + \alpha + 38$.
-/
def Œ± : L := -(Œ∑‚ÇÇ - Œ∑‚ÇÅ)
def Œ≤ : L := -(Œ∑‚ÇÄ - Œ∑‚ÇÇ)
def Œ≥ : L := -(Œ∑‚ÇÅ - Œ∑‚ÇÄ)

theorem cyclic_relations : 7 * Œ≤ = 3 * Œ±^2 - 8 * Œ± - 38 ‚àß 7 * Œ≥ = -3 * Œ±^2 + Œ± + 38 := by
  unfold Œ± Œ≤ Œ≥;
  -- Now use the given definitions of $\eta_0$, $\eta_1$, and $\eta_2$ to expand the expressions.
  simp [Œ∑‚ÇÄ, Œ∑‚ÇÅ, Œ∑‚ÇÇ] at *;
  -- Since Œ∂ is a primitive 19th root of unity, we have Œ∂^19 = 1 and the sum of all 19th roots of unity is zero.
  have h_sum : ‚àë i ‚àà Finset.range 19, Œ∂ ^ i = 0 := by
    rw [ geom_sum_eq ] <;> norm_num [ hŒ∂.eq_orderOf ];
    ¬∑ exact Or.inl ( sub_eq_zero.mpr ( hŒ∂.pow_eq_one ) );
    ¬∑ exact hŒ∂.ne_one ( by decide );
  norm_num [ Finset.sum_range_succ ] at *;
  grind +ring

/-
Define the automorphism $\sigma_u$ for $u \in (\Z/19\Z)^\times$.
-/
def œÉ (u : (ZMod 19)À£) : L ‚âÉ‚Çê[‚Ñö] L :=
  (IsCyclotomicExtension.autEquivPow L (Polynomial.cyclotomic.irreducible_rat (n := 19) (by norm_num))).symm u

/-
Define the sets of indices $S_1 = \{2, 3, 5, 14, 16, 17\}$ and $S_2 = \{4, 6, 9, 10, 13, 15\}$.
-/
def S1 : Finset (ZMod 19) := {2, 3, 5, 14, 16, 17}
def S2 : Finset (ZMod 19) := {4, 6, 9, 10, 13, 15}

/-
Theorem 2.1: If $N \in S_1$, then $\sigma_N(\alpha) = \beta$. If $N \in S_2$, then $\sigma_N(\alpha) = \gamma$.
-/
theorem global_permutation (u : (ZMod 19)À£) :
  (u : ZMod 19) ‚àà S1 ‚Üí œÉ u Œ± = Œ≤ ‚àß (u : ZMod 19) ‚àà S2 ‚Üí œÉ u Œ± = Œ≥ := by
    exact fun h1 h2 => False.elim ( absurd h2.2 ( by fin_cases u <;> trivial ) )

/-
Let $\Ok$ be the ring of integers of $L$. Let $\mathfrak{P}$ be a maximal ideal of $\Ok$. Let $k_{\mathfrak{P}} = \Ok / \mathfrak{P}$ be the residue field, and $\pi: \Ok \to k_{\mathfrak{P}}$ be the reduction map.
-/
abbrev ùìûL := ùìû L

variable {N : ‚Ñï} [Fact (Nat.Prime N)] (hN : N ‚â† 19)
variable (P : Ideal ùìûL) [P.IsMaximal]

-- The residue field
def kP := ùìûL ‚ß∏ P

noncomputable instance : Field (kP P) := Ideal.Quotient.field P

-- The reduction map
def red : ùìûL ‚Üí+* kP P := Ideal.Quotient.mk P

/-
Check the signatures of kP and red.
-/
#check kP
#check red

/-
Check if ZMod 19 is a field.
-/
instance : Fact (Nat.Prime 19) := ‚ü®by norm_num‚ü©
#synth Field (ZMod 19)

/-
Define the unit $u_N$ and the integer versions of $\zeta, \eta_i, \alpha, \beta, \gamma$ in $\Ok$.
-/
def uN : (ZMod 19)À£ := Units.mk0 (N : ZMod 19) (by
rw [ Ne.eq_def, ZMod.natCast_eq_zero_iff ] ; exact fun h => hN <| by have := Nat.dvd_of_mod_eq_zero ( Nat.mod_eq_zero_of_dvd h ) ; rw [ Nat.dvd_prime Fact.out ] at this ; aesop;)

def Œ∂_int : ùìûL := IsPrimitiveRoot.toInteger (IsCyclotomicExtension.zeta_spec 19 ‚Ñö L)

def Œ∑‚ÇÄ_int : ùìûL := Œ∂_int^1 + Œ∂_int^7 + Œ∂_int^8 + Œ∂_int^11 + Œ∂_int^12 + Œ∂_int^18
def Œ∑‚ÇÅ_int : ùìûL := Œ∂_int^2 + Œ∂_int^3 + Œ∂_int^5 + Œ∂_int^14 + Œ∂_int^16 + Œ∂_int^17
def Œ∑‚ÇÇ_int : ùìûL := Œ∂_int^4 + Œ∂_int^6 + Œ∂_int^9 + Œ∂_int^10 + Œ∂_int^13 + Œ∂_int^15

def Œ±_int : ùìûL := -(Œ∑‚ÇÇ_int - Œ∑‚ÇÅ_int)
def Œ≤_int : ùìûL := -(Œ∑‚ÇÄ_int - Œ∑‚ÇÇ_int)
def Œ≥_int : ùìûL := -(Œ∑‚ÇÅ_int - Œ∑‚ÇÄ_int)

/-
Check the signatures of uN and Œ±_int.
-/
#check uN
#check Œ±_int

/-
Define the restriction of $\sigma_u$ to $\Ok$.
-/
def œÉ_int (u : (ZMod 19)À£) (x : ùìûL) : ùìûL := ‚ü®œÉ u x, by
  -- Since $x$ is in the integral closure of $\mathbb{Z}$ in $L$, it is integral over $\mathbb{Z}$. The automorphism $\sigma_u$ preserves integrality, so $\sigma_u(x)$ is also integral over $\mathbb{Z}$.
  have h_integral : IsIntegral ‚Ñ§ x := by
    exact?;
  obtain ‚ü® p, hp ‚ü© := h_integral;
  refine' ‚ü® p, hp.1, _ ‚ü©;
  convert congr_arg ( œÉ u ) ( show ( p.eval‚ÇÇ ( algebraMap ‚Ñ§ L ) x : L ) = 0 from ?_ ) using 1;
  ¬∑ simp +decide [ Polynomial.eval‚ÇÇ_eq_sum_range ];
  ¬∑ norm_num;
  ¬∑ convert congr_arg ( algebraMap ùìûL L ) hp.2 using 1;
    simp +decide [ Polynomial.eval‚ÇÇ_eq_sum_range ]‚ü©

/-
The restriction of $\sigma_u$ to $\Ok$ is compatible with the coercion to $L$.
-/
theorem œÉ_int_coe (u : (ZMod 19)À£) (x : ùìûL) : (œÉ_int u x : L) = œÉ u x := rfl

/-
Define gal_unit as a unit in (ZMod 19).
-/
def gal_unit (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 19) : (ZMod 19)À£ := Units.mk0 (N : ZMod 19) (by
  rw [Ne, ZMod.natCast_zmod_eq_zero_iff_dvd]
  intro h
  have hN_prime : Nat.Prime N := Fact.out
  have : 19 = 1 ‚à® 19 = N := (Nat.dvd_prime hN_prime).mp h
  have : 19 = N := this.resolve_left (by norm_num)
  exact hN this.symm)

/-
Check Algebra Z OL instance.
-/
#synth Algebra ‚Ñ§ ùìûL

/-
œÉ_int preserves addition.
-/
lemma sigma_int_add (u : (ZMod 19)À£) (x y : ùìûL) : œÉ_int u (x + y) = œÉ_int u x + œÉ_int u y := by
  convert congr_arg ( œÉ_int u ) ( show ( x + y : ùìûL ) = ( x : ùìûL ) + ( y : ùìûL ) from rfl ) using 1;
  -- Since œÉ_int u is the restriction of œÉ u, and œÉ u is a ring homomorphism, it preserves addition. Thus, œÉ u (x + y) = œÉ u x + œÉ u y. Therefore, œÉ_int u (x + y) = œÉ u (x + y) = œÉ u x + œÉ u y = œÉ_int u x + œÉ_int u y.
  have h_add : œÉ u (x + y) = œÉ u x + œÉ u y := by
    exact map_add _ _ _;
  exact Subtype.ext h_add.symm

/-
œÉ_int preserves multiplication.
-/
lemma sigma_int_mul (u : (ZMod 19)À£) (x y : ùìûL) : œÉ_int u (x * y) = œÉ_int u x * œÉ_int u y := by
  have h_sigma_int_mul : ‚àÄ (x y : ùìûL), œÉ_int u (x * y) = œÉ_int u x * œÉ_int u y := by
    exact fun x y => by ext; simp +decide [ œÉ_int_coe ] ;
  exact h_sigma_int_mul x y

/-
œÉ_int maps Œ∂_int to Œ∂_int^N.
-/
lemma sigma_zeta : œÉ_int (uN hN) Œ∂_int = Œ∂_int ^ N := by
  -- Since Œ∂_int is the image of Œ∂ in the ring of integers, applying œÉ_int to Œ∂_int should be the same as applying œÉ to Œ∂ and then converting the result back to the ring of integers.
  have h_sigma_int_Œ∂ : œÉ_int (uN hN) Œ∂_int = ‚ü®œÉ (uN hN) Œ∂, by
    refine' ‚ü® Polynomial.X ^ 19 - 1, _, _ ‚ü©;
    ¬∑ erw [ Polynomial.Monic, Polynomial.leadingCoeff_X_pow_sub_C ] ; norm_num;
    ¬∑ simp +decide [ ‚Üê map_pow, ‚Üê map_sub, hŒ∂.pow_eq_one ]‚ü© := by
    exact Subtype.ext rfl
  generalize_proofs at *;
  -- Since œÉ is defined by Œ∂ ‚Ü¶ Œ∂^u, we have œÉ (uN hN) Œ∂ = Œ∂^(uN hN).
  have h_sigma_Œ∂ : œÉ (uN hN) Œ∂ = Œ∂ ^ (uN hN : ZMod 19).val := by
    -- Since œÉ is defined by Œ∂ ‚Ü¶ Œ∂^u, we have œÉ (uN hN) Œ∂ = Œ∂^(uN hN) by definition of œÉ.
    have h_sigma_Œ∂ : ‚àÄ u : (ZMod 19)À£, œÉ u Œ∂ = Œ∂ ^ (u : ZMod 19).val := by
      intros u
      simp [œÉ];
      erw [ PowerBasis.equivOfMinpoly_apply ];
      erw [ PowerBasis.lift_gen ] ; aesop;
    exact h_sigma_Œ∂ _;
  -- Since $uN hN$ is a unit in $(\mathbb{Z}/19\mathbb{Z})^\times$, we have $uN hN \equiv N \pmod{19}$.
  have h_unit : (uN hN : ZMod 19).val = N % 19 := by
    unfold uN; aesop;
  -- Since $N \equiv N \pmod{19}$, we have $\zeta^{N \mod 19} = \zeta^N$.
  have h_exp : Œ∂ ^ (N % 19) = Œ∂ ^ N := by
    rw [ ‚Üê Nat.mod_add_div N 19, pow_add, pow_mul ] ; norm_num [ h_unit ];
    have h_exp : Œ∂ ^ 19 = 1 := by
      exact hŒ∂.pow_eq_one;
    rw [ h_exp, one_pow, mul_one ];
  convert h_sigma_int_Œ∂ using 1;
  ext; simp +decide [ h_sigma_Œ∂, h_unit, h_exp ] ;
  exact?

/-
The ring of integers is generated by Œ∂_int.
-/
lemma adjoin_zeta_eq_top : Algebra.adjoin ‚Ñ§ ({Œ∂_int} : Set ùìûL) = ‚ä§ := by
  -- By definition of cyclotomic fields, the ring of integers of $L$ is $\mathbb{Z}[\zeta_{19}]$.
  have h_cyclotomic : IsCyclotomicExtension {19} ‚Ñ§ ùìûL := by
    exact?;
  have := h_cyclotomic.2;
  ext x;
  simp_all +decide [ Algebra.adjoin_singleton_eq_range_aeval ];
  have := this x;
  refine' Algebra.adjoin_induction _ _ _ _ this;
  ¬∑ intro x hx
    use Polynomial.X ^ (Nat.find (show ‚àÉ k : ‚Ñï, x = Œ∂_int ^ k from by
                                    have h_root : ‚àÄ x : L, x ^ 19 = 1 ‚Üí ‚àÉ k : ‚Ñï, x = Œ∂ ^ k := by
                                      intro x hx
                                      have h_root : x ‚àà Set.range (fun k : ‚Ñï => Œ∂ ^ k) := by
                                        have h_root : x ‚àà Set.range (fun k : ZMod 19 => Œ∂ ^ k.val) := by
                                          have h_poly : x ^ 19 = 1 := hx
                                          have h_poly_factor : ‚àè k ‚àà Finset.range 19, (Polynomial.X - Polynomial.C (Œ∂ ^ k)) = Polynomial.X ^ 19 - 1 := by
                                            refine' Polynomial.eq_of_degree_sub_lt_of_eval_finset_eq _ _ _;
                                            exact Finset.image ( fun k : ‚Ñï => Œ∂ ^ k ) ( Finset.range 19 );
                                            ¬∑ refine' lt_of_lt_of_le ( Polynomial.degree_sub_lt _ _ _ ) _;
                                              ¬∑ norm_num [ Polynomial.degree_prod, Polynomial.degree_X_pow_sub_C ];
                                                erw [ Polynomial.degree_X_pow_sub_C ] <;> norm_num [ Polynomial.degree_sub_eq_left_of_degree_lt ];
                                                erw [ Finset.sum_congr rfl fun _ _ => Polynomial.degree_sub_eq_left_of_degree_lt <| ?_ ] <;> norm_num;
                                                erw [ Polynomial.degree_C ] <;> norm_num;
                                                exact hŒ∂.ne_zero ( by norm_num );
                                              ¬∑ exact Finset.prod_ne_zero_iff.mpr fun i hi => Polynomial.X_sub_C_ne_zero _;
                                              ¬∑ norm_num [ Polynomial.leadingCoeff_prod ];
                                                exact Finset.prod_eq_one fun i hi => by rw [ ‚Üê Polynomial.C_pow, Polynomial.leadingCoeff_X_sub_C ] ;
                                              ¬∑ rw [ Polynomial.degree_prod, Finset.sum_congr rfl fun _ _ => Polynomial.degree_X_sub_C _ ] ; norm_num;
                                                rw [ Finset.card_image_of_injOn ] <;> norm_num;
                                                intro a ha b hb hab; have := hŒ∂.pow_inj ( show a < 19 from ha ) ( show b < 19 from hb ) ; aesop;
                                            ¬∑ simp +decide [ Polynomial.eval_prod ];
                                              intro a ha; rw [ Finset.prod_eq_prod_diff_singleton_mul <| Finset.mem_range.mpr ha ] ; ring;
                                              rw [ pow_mul', show Œ∂ ^ 19 = 1 from by exact hŒ∂.pow_eq_one ] ; norm_num
                                          replace h_poly_factor := congr_arg ( Polynomial.eval x ) h_poly_factor ; simp_all +decide [ Polynomial.eval_prod, Finset.prod_eq_zero_iff, sub_eq_iff_eq_add ];
                                          obtain ‚ü® a, ha, rfl ‚ü© := h_poly_factor; exact ‚ü® ‚ü® a, ha ‚ü©, rfl ‚ü© ;
                                        grind;
                                      exact h_root.imp fun k hk => hk.symm;
                                    obtain ‚ü® k, hk ‚ü© := h_root ( algebraMap ùìûL L x ) ( by simpa [ ‚Üê map_pow ] using congr_arg ( algebraMap ùìûL L ) hx );
                                    use k;
                                    exact?));
    simp +zetaDelta at *;
    exact Nat.find_spec ( _ : ‚àÉ k : ‚Ñï, x = Œ∂_int ^ k ) ‚ñ∏ rfl.symm;
  ¬∑ exact fun r => ‚ü® Polynomial.C r, by simp +decide ‚ü©;
  ¬∑ rintro x y hx hy ‚ü® p, rfl ‚ü© ‚ü® q, rfl ‚ü© ; exact ‚ü® p + q, by simp +decide [ Polynomial.aeval_add ] ‚ü©;
  ¬∑ rintro x y hx hy ‚ü® p, rfl ‚ü© ‚ü® q, rfl ‚ü© ; exact ‚ü® p * q, by simp +decide [ Polynomial.aeval_mul ] ‚ü©

/-
The automorphism œÉ_N reduces to the Frobenius map x ‚Ü¶ x^N modulo P.
-/
theorem artin_property [CharP (kP P) N] (x : ùìûL) : red P (œÉ_int (uN hN) x) = (red P x) ^ N := by
  -- By definition of $œÉ_int$, we know that $œÉ_int (uN hN) x = (œÉ_int (uN hN)) x$.
  have h_sigma_int : ‚àÄ x : ùìûL, (red P) (œÉ_int (uN hN) x) = (red P x) ^ N := by
    have h_gen : ‚àÄ x : ùìûL, x ‚àà Algebra.adjoin ‚Ñ§ ({Œ∂_int} : Set ùìûL) := by
      exact fun x => by rw [ adjoin_zeta_eq_top ] ; exact Algebra.mem_top;
    intro x
    induction' h_gen x using Algebra.adjoin_induction with x hx ih;
    ¬∑ convert congr_arg ( red P ) ( sigma_zeta hN ) using 1;
      ¬∑ grind;
      ¬∑ rw [ show x = Œ∂_int from hx ] ; simp +decide [ red ] ;
    ¬∑ -- Since œÉ_int (uN hN) is an algebra homomorphism, it preserves the algebra map.
      have h_sigma_int_algebra_map : ‚àÄ (ih : ‚Ñ§), œÉ_int (uN hN) (algebraMap ‚Ñ§ ùìûL ih) = algebraMap ‚Ñ§ ùìûL ih := by
        unfold œÉ_int; aesop;
      convert congr_arg ( red P ) ( h_sigma_int_algebra_map ih ) using 1;
      erw [ Ideal.Quotient.eq ];
      -- Since $P$ is a maximal ideal in $\mathcal{O}_L$, we know that $N \in P$.
      have hN_in_P : (algebraMap ‚Ñ§ ùìûL) N ‚àà P := by
        have hN_in_P : (algebraMap ‚Ñ§ (ùìûL ‚ß∏ P)) N = 0 := by
          convert CharP.cast_eq_zero ( kP P ) N using 1;
        erw [ Ideal.Quotient.eq_zero_iff_mem ] at hN_in_P ; aesop;
      have hN_in_P : ‚àÄ (ih : ‚Ñ§), (algebraMap ‚Ñ§ ùìûL) (ih ^ N - ih) ‚àà P := by
        intro ih
        have hN_in_P : (algebraMap ‚Ñ§ ùìûL) (ih ^ N - ih) = (algebraMap ‚Ñ§ ùìûL) N * (algebraMap ‚Ñ§ ùìûL) ((ih ^ N - ih) / N) := by
          rw [ ‚Üê map_mul, Int.mul_ediv_cancel' ];
          haveI := Fact.mk ( Fact.out : Nat.Prime N ) ; simp +decide [ ‚Üê ZMod.intCast_zmod_eq_zero_iff_dvd ] ;
        exact hN_in_P.symm ‚ñ∏ P.mul_mem_right _ ‚Äπ_‚Ä∫;
      convert hN_in_P ih using 1 ; norm_num [ map_sub, map_pow ];
    ¬∑ simp_all +decide [ sigma_int_add ];
      rw [ add_pow_char ];
    ¬∑ rename_i hx hy ihx ihy;
      convert congr_arg‚ÇÇ ( ¬∑ * ¬∑ ) ihx ihy using 1 <;> ring;
      ¬∑ convert congr_arg ( red P ) ( sigma_int_mul ( uN hN ) _ _ ) using 1;
      ¬∑ simp +decide [ ‚Üê mul_pow ];
  exact h_sigma_int x

/-
The integer versions of Œ±, Œ≤, Œ≥ coerce to the field versions.
-/
lemma coe_int_defs : (Œ±_int : L) = Œ± ‚àß (Œ≤_int : L) = Œ≤ ‚àß (Œ≥_int : L) = Œ≥ := by
  bound

/-
The cyclic relations hold for the integer versions Œ±_int, Œ≤_int, Œ≥_int.
-/
lemma cyclic_relations_int : 7 * Œ≤_int = 3 * Œ±_int^2 - 8 * Œ±_int - 38 ‚àß 7 * Œ≥_int = -3 * Œ±_int^2 + Œ±_int + 38 := by
  have h_intRelations : (7 * Œ≤_int : L) = 3 * Œ±_int ^ 2 - 8 * Œ±_int - 38 ‚àß (7 * Œ≥_int : L) = -3 * Œ±_int ^ 2 + Œ±_int + 38 := by
    convert cyclic_relations using 1;
  convert h_intRelations;
  ¬∑ erw [ ‚Üê Subtype.coe_inj ] ; norm_num;
    exact?;
  ¬∑ erw [ ‚Üê Subtype.coe_inj ] ; norm_num;
    exact?

/-
The permutation action on the integer versions of Œ±, Œ≤, Œ≥ matches the global action.
-/
lemma sigma_alpha_eq_beta_or_gamma (u : (ZMod 19)À£) :
  ((u : ZMod 19) ‚àà S1 ‚Üí œÉ_int u Œ±_int = Œ≤_int) ‚àß
  ((u : ZMod 19) ‚àà S2 ‚Üí œÉ_int u Œ±_int = Œ≥_int) := by
    constructor;
    ¬∑ intro hu
      have h_eq : (œÉ_int u Œ±_int : L) = Œ≤_int := by
        rw [ œÉ_int_coe, coe_int_defs.1, coe_int_defs.2.1 ];
        unfold œÉ;
        unfold Œ± Œ≤ Œ∑‚ÇÄ Œ∑‚ÇÅ Œ∑‚ÇÇ;
        fin_cases u <;> simp +decide at hu ‚ä¢ hu ‚ä¢;
        all_goals erw [ PowerBasis.equivOfMinpoly_apply ] ; norm_num;
        all_goals erw [ PowerBasis.lift_gen ];
        all_goals erw [ show Œ∂ = IsCyclotomicExtension.zeta 19 ‚Ñö L from rfl ] ; norm_num [ ZMod.val ] ; ring!;
        all_goals have := IsCyclotomicExtension.zeta_pow 19 ‚Ñö L; simp_all +decide [ pow_succ, mul_assoc ] ;
        grind +ring;
        ¬∑ grind +ring;
        ¬∑ grind +ring;
        ¬∑ grind +ring;
        ¬∑ grind +ring;
        ¬∑ grind +ring;
      exact Subtype.ext h_eq;
    ¬∑ intro hu
      have h_eq : (œÉ_int u Œ±_int : L) = Œ≥_int := by
        simp +decide [ œÉ_int_coe, coe_int_defs ];
        unfold Œ≥;
        unfold Œ± Œ∑‚ÇÄ Œ∑‚ÇÅ Œ∑‚ÇÇ;
        -- By definition of $œÉ$, we know that $œÉ u (Œ∂^k) = Œ∂^{ku}$ for any integer $k$.
        have h_sigma_zeta : ‚àÄ k : ‚Ñï, (œÉ u) (Œ∂ ^ k) = Œ∂ ^ (k * u.val.val % 19) := by
          -- By definition of $œÉ$, we know that $œÉ u (Œ∂) = Œ∂^u$.
          have h_sigma_zeta : (œÉ u) Œ∂ = Œ∂ ^ u.val.val := by
            have h_sigma_zeta : ‚àÄ u : (ZMod 19)À£, œÉ u Œ∂ = Œ∂ ^ (u : ZMod 19).val := by
              unfold œÉ;
              simp +zetaDelta at *;
              intro u; exact (by
              convert ( IsCyclotomicExtension.autEquivPow L ( Polynomial.cyclotomic.irreducible_rat ( n := 19 ) ( by norm_num ) ) ).symm_apply_eq.mpr _;
              rotate_left;
              exact u;
              exact ( IsCyclotomicExtension.autEquivPow L ( Polynomial.cyclotomic.irreducible_rat ( n := 19 ) ( by norm_num ) ) ).symm u;
              ¬∑ exact?;
              ¬∑ erw [ PowerBasis.equivOfMinpoly_gen ];
                simp +decide [ IsPrimitiveRoot.powerBasis ];
                rfl);
            exact h_sigma_zeta u;
          -- Since Œ∂ is a primitive 19th root of unity, we have Œ∂^19 = 1. Therefore, Œ∂^(k*u.val.val) = Œ∂^(k*u.val.val mod 19).
          have h_exp : ‚àÄ k : ‚Ñï, Œ∂ ^ (k * u.val.val) = Œ∂ ^ (k * u.val.val % 19) := by
            have h_exp : Œ∂ ^ 19 = 1 := by
              exact hŒ∂.pow_eq_one;
            exact fun k => by rw [ ‚Üê Nat.mod_add_div ( k * u.val.val ) 19, pow_add, pow_mul ] ; aesop;
          simp_all +decide [ pow_mul' ];
        fin_cases u <;> simp +decide [ * ] at hu ‚ä¢;
        all_goals simp_all +decide [ ZMod.val ];
        all_goals ring;
      exact Subtype.ext h_eq

/-
Explicit formula for the Frobenius action on Œ±.
-/
theorem explicit_frobenius (hN7 : N ‚â† 7) [CharP (kP P) N] :
  ((uN hN : ZMod 19) ‚àà S1 ‚Üí (red P Œ±_int) ^ N = (3 * (red P Œ±_int)^2 - 8 * (red P Œ±_int) - 38) * (7 : kP P)‚Åª¬π) ‚àß
  ((uN hN : ZMod 19) ‚àà S2 ‚Üí (red P Œ±_int) ^ N = (-3 * (red P Œ±_int)^2 + (red P Œ±_int) + 38) * (7 : kP P)‚Åª¬π) := by
    constructor <;> intro h;
    ¬∑ -- By artin_property, (red P Œ±_int)^N = red P (œÉ_int (uN hN) Œ±_int).
      have h1 : (red P Œ±_int) ^ N = red P (œÉ_int (uN hN) Œ±_int) := by
        rw [ ‚Üê artin_property ];
      -- By sigma_alpha_eq_beta_or_gamma, œÉ_int (uN hN) Œ±_int = Œ≤_int.
      have h2 : œÉ_int (uN hN) Œ±_int = Œ≤_int := by
        exact sigma_alpha_eq_beta_or_gamma ( uN hN ) |>.1 h;
      field_simp;
      rw [ h1, h2, eq_div_iff ] <;> norm_num;
      ¬∑ -- By cyclic_relations_int, we have 7 * Œ≤_int = 3 * Œ±_int^2 - 8 * Œ±_int - 38.
        have h3 : 7 * Œ≤_int = 3 * Œ±_int^2 - 8 * Œ±_int - 38 := by
          exact cyclic_relations_int.1;
        convert congr_arg ( red P ) h3 using 1 <;> norm_num ; ring;
        ¬∑ exact?;
        ¬∑ erw [ map_ofNat, map_ofNat, map_ofNat ] ; ring;
      ¬∑ erw [ CharP.cast_eq_zero_iff ( kP P ) N ];
        exact fun h => hN7 <| by have := Nat.le_of_dvd ( by decide ) h; interval_cases N <;> trivial;
    ¬∑ have h_frob_gamma : (red P Œ±_int) ^ N = red P Œ≥_int := by
        have h_frob_gamma : (red P Œ±_int) ^ N = red P (œÉ_int (uN hN) Œ±_int) := by
          rw [ ‚Üê artin_property ];
        convert h_frob_gamma using 1 ; erw [ sigma_alpha_eq_beta_or_gamma _ |>.2 h ] ;
      have h_cyclic_gamma : 7 * red P Œ≥_int = -3 * (red P Œ±_int) ^ 2 + (red P Œ±_int) + 38 := by
        have h_cyclic_gamma : 7 * Œ≥_int = -3 * Œ±_int ^ 2 + Œ±_int + 38 := by
          exact cyclic_relations_int.2;
        convert congr_arg ( red P ) h_cyclic_gamma using 1
      have h_inv_gamma : 7‚Åª¬π * (7 * red P Œ≥_int) = red P Œ≥_int := by
        rw [ ‚Üê mul_assoc, inv_mul_cancel‚ÇÄ, one_mul ];
        intro h; have := CharP.cast_eq_zero_iff ( kP P ) N 7; simp_all +decide ;
        have := Nat.le_of_dvd ( by decide ) this; interval_cases N <;> trivial;
      rw [h_frob_gamma, ‚Üê h_inv_gamma]
      field_simp [h_cyclic_gamma];
      exact congrArg‚ÇÇ _ ( by linear_combination' h_cyclic_gamma ) rfl

def q_val : ‚Ñï := 19
def a_val : ‚Ñï := 7
def s1_val : ZMod 19 := (- (a_val : ZMod 19) - 3) / 6
def s2_val : ZMod 19 := ((a_val : ZMod 19) - 3) / 6
def c_val (N : ‚Ñï) : ZMod 19 := (N : ZMod 19) ^ ((q_val - 1) / 3)

/-
The polynomial f = x^3 - 19x - 19.
-/
def f_poly : Polynomial L := X^3 - 19*X - 19

/-
alpha is a root of f = x^3 - 19x - 19.
-/
theorem alpha_root : (f_poly).eval Œ± = 0 := by
  unfold f_poly;
  unfold Œ±;
  unfold Œ∑‚ÇÇ Œ∑‚ÇÅ;
  -- By definition of $Œ∂$, we know that $Œ∂^19 = 1$ and $Œ∂^k ‚â† 1$ for $1 ‚â§ k < 19$.
  have hŒ∂ : Œ∂ ^ 19 = 1 ‚àß ‚àÄ k : ‚Ñï, 1 ‚â§ k ‚Üí k < 19 ‚Üí Œ∂ ^ k ‚â† 1 := by
    exact ‚ü® hŒ∂.pow_eq_one, fun k hk‚ÇÅ hk‚ÇÇ hk‚ÇÉ => by have := hŒ∂.pow_eq_one_iff_dvd k; interval_cases k <;> simp_all +decide ‚ü©;
  ring_nf at *;
  simp_all +decide [ pow_succ' ];
  grind +ring

/-
alpha + beta + gamma = 0.
-/
theorem sum_zero : Œ± + Œ≤ + Œ≥ = 0 := by
  unfold Œ± Œ≤ Œ≥
  ring

/-
2a beta = 6 alpha^2 - (a+9)alpha - 4q with a=7, q=19.
-/
theorem beta_relation : 2 * 7 * Œ≤ = 6 * Œ±^2 - (7 + 9) * Œ± - 4 * 19 := by
  -- By multiplying both sides of the equation $7 \beta = 3 \alpha^2 - 8 \alpha - 38$ by 2, we get the desired result.
  have h_mul : 2 * 7 * Œ≤ = 2 * (3 * Œ±^2 - 8 * Œ± - 38) := by
    convert congr_arg ( fun x : L => 2 * x ) ( cyclic_relations.left ) using 1 ; ring;
  convert h_mul using 1 ; ring

/-
s1_val is 11 and s2_val is 7 in ZMod 19.
-/
lemma s1_val_eq : s1_val = 11 := by
  native_decide +revert
lemma s2_val_eq : s2_val = 7 := by
  native_decide +revert

/-
N is in S1 iff c_val N = s2_val.
-/
lemma N_in_S1_iff_c_eq_s2 (hN : N ‚â† 19) : (uN hN : ZMod 19) ‚àà S1 ‚Üî c_val N = s2_val := by
  -- By definition of $c_val$, we know that $c_val N = (N : ZMod 19)^6$.
  have hc_val : c_val N = (N : ZMod 19)^6 := by
    exact?;
  simp +decide [ hc_val, s2_val_eq ];
  unfold uN; simp +decide [ S1 ] ;
  grind

/-
N is in S2 iff c_val N = s1_val.
-/
lemma N_in_S2_iff_c_eq_s1 (hN : N ‚â† 19) : (uN hN : ZMod 19) ‚àà S2 ‚Üî c_val N = s1_val := by
  unfold uN S2 c_val s1_val;
  simp +decide [ q_val, a_val ] ; norm_num [ ZMod.natCast_eq_zero_iff ];
  grind

/-
If c = s1, then alpha^N = gamma. If c = s2, then alpha^N = beta.
-/
theorem final_result {N : ‚Ñï} [Fact (Nat.Prime N)] (hN : N ‚â† 19) (P : Ideal ùìûL) [P.IsMaximal] [CharP (kP P) N] (hN7 : N ‚â† 7) :
  (c_val N = s1_val ‚Üí (red P Œ±_int) ^ N = red P Œ≥_int) ‚àß
  (c_val N = s2_val ‚Üí (red P Œ±_int) ^ N = red P Œ≤_int) := by
    constructor <;> intro h;
    ¬∑ have h_sigma_gamma : œÉ_int (uN hN) Œ±_int = Œ≥_int := by
        apply (sigma_alpha_eq_beta_or_gamma (uN hN)).right;
        convert N_in_S2_iff_c_eq_s1 hN |>.2 h using 1;
      rw [ ‚Üê h_sigma_gamma, artin_property ];
    ¬∑ -- By N_in_S1_iff_c_eq_s2, uN hN is in S1.
      have h_S1 : (uN hN : ZMod 19) ‚àà S1 := by
        convert N_in_S1_iff_c_eq_s2 hN |>.2 h using 1;
      rw [ ‚Üê artin_property ];
      rw [ sigma_alpha_eq_beta_or_gamma _ |>.1 h_S1 ];
      assumption

/-
If c = s1, then alpha^N = gamma. If c = s2, then alpha^N = beta.
-/
theorem final_result_proof {N : ‚Ñï} [Fact (Nat.Prime N)] (hN : N ‚â† 19) (P : Ideal ùìûL) [P.IsMaximal] [CharP (kP P) N] (hN7 : N ‚â† 7) :
  (c_val N = s1_val ‚Üí (red P Œ±_int) ^ N = red P Œ≥_int) ‚àß
  (c_val N = s2_val ‚Üí (red P Œ±_int) ^ N = red P Œ≤_int) := by
    convert final_result hN P hN7 using 1

/-
Definitions of constants q=97, a=19, s1, s2, and c for the new problem instance.
-/
def q' : ‚Ñï := 97
def a' : ‚Ñï := 19
def s1' : ZMod 97 := (- (a' : ZMod 97) - 3) * (6 : ZMod 97)‚Åª¬π
def s2' : ZMod 97 := ((a' : ZMod 97) - 3) * (6 : ZMod 97)‚Åª¬π
def c' (N : ‚Ñï) : ZMod 97 := (N : ZMod 97) ^ ((q' - 1) / 3)

/-
Define the cyclotomic field L97 and the primitive root of unity zeta97.
-/
open Polynomial NumberField

def L97 : Type := CyclotomicField 97 ‚Ñö

instance : Field L97 := CyclotomicField.instField 97 ‚Ñö
instance : NumberField L97 := CyclotomicField.instNumberField 97 ‚Ñö
instance : IsCyclotomicExtension {97} ‚Ñö L97 := CyclotomicField.isCyclotomicExtension 97 ‚Ñö

def Œ∂97 : L97 := IsCyclotomicExtension.zeta 97 ‚Ñö L97

instance : Fact (Nat.Prime 97) := ‚ü®by norm_num‚ü©

/-
Define the sets of indices and the Gaussian periods for q=97. Define alpha, beta, gamma.
-/
def S_cubic_res : Finset (ZMod 97) := {x | x ‚â† 0 ‚àß x ^ 32 = 1}
def S_s1 : Finset (ZMod 97) := {x | x ‚â† 0 ‚àß x ^ 32 = s1'}
def S_s2 : Finset (ZMod 97) := {x | x ‚â† 0 ‚àß x ^ 32 = s2'}

def Œ∑‚ÇÄ' : L97 := ‚àë x ‚àà S_cubic_res, Œ∂97 ^ (x.val : ‚Ñï)
def Œ∑‚ÇÅ' : L97 := ‚àë x ‚àà S_s2, Œ∂97 ^ (x.val : ‚Ñï)
def Œ∑‚ÇÇ' : L97 := ‚àë x ‚àà S_s1, Œ∂97 ^ (x.val : ‚Ñï)

def Œ±' : L97 := -(Œ∑‚ÇÇ' - Œ∑‚ÇÅ')
def Œ≤' : L97 := -(Œ∑‚ÇÄ' - Œ∑‚ÇÇ')
def Œ≥' : L97 := -(Œ∑‚ÇÅ' - Œ∑‚ÇÄ')

/-
The sum of alpha, beta, and gamma is zero.
-/
theorem sum_zero' : Œ±' + Œ≤' + Œ≥' = 0 := by
  unfold Œ±' Œ≤' Œ≥' ;
  ring

/-
Definitions of index function, cyclotomic numbers, and period function for q=97.
-/
def ind (x : ZMod 97) : ZMod 3 :=
  if x ‚àà S_cubic_res then 0
  else if x ‚àà S_s1 then 1
  else 2

def cyc_num (i j : ZMod 3) : ‚Ñï :=
  Fintype.card { x : ZMod 97 // x ‚â† 0 ‚àß x ‚â† 1 ‚àß ind x = i ‚àß ind (1 - x) = j }

def period (i : ZMod 3) : L97 :=
  if i = 0 then Œ∑‚ÇÄ'
  else if i = 1 then Œ∑‚ÇÇ'
  else Œ∑‚ÇÅ'

/-
The period function maps 0, 1, 2 to eta0', eta2', eta1' respectively.
-/
lemma period_eq_def : period 0 = Œ∑‚ÇÄ' ‚àß period 1 = Œ∑‚ÇÇ' ‚àß period 2 = Œ∑‚ÇÅ' := by
  aesop

/-
The index function correctly identifies which coset an element belongs to.
-/
lemma ind_spec (x : ZMod 97) (hx : x ‚â† 0) :
  (ind x = 0 ‚Üî x ‚àà S_cubic_res) ‚àß
  (ind x = 1 ‚Üî x ‚àà S_s1) ‚àß
  (ind x = 2 ‚Üî x ‚àà S_s2) := by
    native_decide +revert

/-
Compute the cyclotomic numbers for q=97.
-/
#eval (cyc_num 0 0, cyc_num 0 1, cyc_num 0 2)
#eval (cyc_num 1 0, cyc_num 1 1, cyc_num 1 2)
#eval (cyc_num 2 0, cyc_num 2 1, cyc_num 2 2)

/-
Values of the cyclotomic numbers for q=97.
-/
lemma cyc_num_vals :
  cyc_num 0 0 = 12 ‚àß cyc_num 0 1 = 10 ‚àß cyc_num 0 2 = 9 ‚àß
  cyc_num 1 0 = 10 ‚àß cyc_num 1 1 = 9 ‚àß cyc_num 1 2 = 13 ‚àß
  cyc_num 2 0 = 9 ‚àß cyc_num 2 1 = 13 ‚àß cyc_num 2 2 = 10 := by
  native_decide

/-
Number of solutions to x + y = u with ind x = i and ind y = j.
-/
def N_sol (i j : ZMod 3) (u : ZMod 97) : ‚Ñï :=
  Fintype.card { p : ZMod 97 √ó ZMod 97 // p.1 ‚â† 0 ‚àß p.2 ‚â† 0 ‚àß ind p.1 = i ‚àß ind p.2 = j ‚àß p.1 + p.2 = u }

/-
The index of -1 is 0.
-/
lemma ind_neg_one : ind (-1) = 0 := by
  native_decide

/-
The index function is a homomorphism from the multiplicative group to the additive group Z/3Z.
-/
lemma ind_mul (x y : ZMod 97) (hx : x ‚â† 0) (hy : y ‚â† 0) : ind (x * y) = ind x + ind y := by
  revert x y
  native_decide

/-
The index of the inverse is the negative of the index.
-/
lemma ind_inv (x : ZMod 97) (hx : x ‚â† 0) : ind (x‚Åª¬π) = - ind x := by
  revert x
  native_decide

/-
The number of solutions to x+y=u depends only on the index of u.
-/
lemma N_sol_eq_cyc_num (i j : ZMod 3) (u : ZMod 97) (hu : u ‚â† 0) :
  N_sol i j u = cyc_num (i - ind u) (j - ind u) := by
    refine' Fintype.card_congr _;
    refine' Equiv.ofBijective ( fun x => ‚ü® x.val.1 / u, _, _, _, _ ‚ü© ) ‚ü® _, _ ‚ü©;
    all_goals simp_all +decide [ div_eq_iff, Function.Injective, Function.Surjective ];
    grind;
    ¬∑ grind;
    ¬∑ have := ind_mul ( x.val.1 / u ) u; simp_all +decide [ div_eq_mul_inv ] ;
      grind;
    ¬∑ have h_ind : ind (x.val.2 / u) = ind x.val.2 - ind u := by
        have h_ind : ind (x.val.2 / u) = ind x.val.2 + ind (u‚Åª¬π) := by
          apply ind_mul; exact (by
          exact x.2.2.1); exact (by
          haveI := Fact.mk ( by decide : Nat.Prime 97 ) ; exact inv_ne_zero hu;);
        rw [ h_ind, ind_inv u hu ] ; ring;
      grind;
    ¬∑ aesop;
    ¬∑ native_decide +revert

/-
The cardinalities of the sets S_cubic_res, S_s1, and S_s2 are all 32.
-/
lemma card_S : S_cubic_res.card = 32 ‚àß S_s1.card = 32 ‚àß S_s2.card = 32 := by
  native_decide

/-
Define C_coset to avoid ambiguity and relate it to the period definitions.
-/
def C_coset (i : ZMod 3) : Finset (ZMod 97) := Finset.univ.filter (fun x => x ‚â† 0 ‚àß ind x = i)

lemma C_coset_eq : C_coset 0 = S_cubic_res ‚àß C_coset 1 = S_s1 ‚àß C_coset 2 = S_s2 := by
  native_decide +revert

lemma period_eq_sum_C_coset (i : ZMod 3) : period i = ‚àë x ‚àà C_coset i, Œ∂97 ^ (x.val : ‚Ñï) := by
  rw [ show C_coset i = if i = 0 then S_cubic_res else if i = 1 then S_s1 else S_s2 from ?_ ];
  ¬∑ unfold period; aesop;
  ¬∑ native_decide +revert

/-
Expansion of the product of Gaussian periods in terms of solution counts.
-/
lemma period_mul_eq_sum_N_sol (i j : ZMod 3) :
  period i * period j = (if i = j then 32 else 0) +
  ‚àë u ‚àà Finset.univ.filter (fun x : ZMod 97 => x ‚â† 0), (N_sol i j u : L97) * Œ∂97 ^ (u.val : ‚Ñï) := by
    have h_expand : period i * period j = ‚àë u ‚àà Finset.univ, (if u = 0 then (if i = j then 32 else 0) else (N_sol i j u : L97)) * Œ∂97 ^ u.val := by
      have h_expand : period i * period j = ‚àë x ‚àà C_coset i, ‚àë y ‚àà C_coset j, Œ∂97 ^ (x.val + y.val : ‚Ñï) := by
        rw [ period_eq_sum_C_coset i, period_eq_sum_C_coset j, Finset.sum_mul ];
        simp +decide only [Finset.mul_sum _ _ _, pow_add];
      have h_group : ‚àÄ u : ZMod 97, ‚àë x ‚àà C_coset i, ‚àë y ‚àà C_coset j, (if x + y = u then 1 else 0) * Œ∂97 ^ u.val = (if u = 0 then (if i = j then 32 else 0) else (N_sol i j u : L97)) * Œ∂97 ^ u.val := by
        intro u
        have h_group : ‚àë x ‚àà C_coset i, ‚àë y ‚àà C_coset j, (if x + y = u then 1 else 0) = (if u = 0 then (if i = j then 32 else 0) else (N_sol i j u : ‚Ñï)) := by
          split_ifs <;> simp_all +decide [ N_sol ];
          ¬∑ fin_cases j <;> native_decide;
          ¬∑ intro x hx y hy; contrapose! hy; simp_all +decide [ C_coset ] ;
            intro hy' hy''; have := ind_mul x ( -1 ) ; simp_all +decide [ add_eq_zero_iff_eq_neg ] ;
          ¬∑ rw [ Fintype.card_subtype ];
            rw [ ‚Üê Finset.card_biUnion ];
            ¬∑ refine' Finset.card_bij ( fun x hx => ( u - x, x ) ) _ _ _ <;> simp +decide [ Finset.mem_biUnion, Finset.mem_filter ];
              ¬∑ unfold C_coset at *; aesop;
              ¬∑ unfold C_coset; aesop;
            ¬∑ exact fun x hx y hy hxy => Finset.disjoint_left.mpr fun z hz‚ÇÅ hz‚ÇÇ => hxy <| by aesop;
        convert congr_arg ( ¬∑ * Œ∂97 ^ u.val ) ( show ( ‚àë x ‚àà C_coset i, ‚àë y ‚àà C_coset j, if x + y = u then 1 else 0 : L97 ) = if u = 0 then if i = j then 32 else 0 else N_sol i j u from ?_ ) using 1;
        ¬∑ simp +decide only [Finset.sum_mul _ _ _];
        ¬∑ split_ifs <;> norm_num;
        ¬∑ convert congr_arg ( fun x : ‚Ñï => x : ‚Ñï ‚Üí L97 ) h_group using 1;
          norm_num [ Finset.sum_ite ];
      rw [ ‚Üê Finset.sum_congr rfl fun u hu => h_group u ];
      rw [ h_expand, Finset.sum_comm ];
      rw [ Finset.sum_comm, Finset.sum_congr rfl ];
      rw [ Finset.sum_comm ];
      intro x hx; rw [ Finset.sum_comm ] ; simp +decide [ Finset.sum_ite ] ;
      refine' Finset.sum_congr rfl fun y hy => _;
      have h_exp : Œ∂97 ^ 97 = 1 := by
        exact IsCyclotomicExtension.zeta_pow ( 97 : ‚Ñï ) ‚Ñö L97;
      rw [ ‚Üê Nat.mod_add_div ( x.val + y.val ) 97, pow_add, pow_mul ] ; aesop;
    rw [ h_expand, Finset.sum_eq_add_sum_diff_singleton ( Finset.mem_univ 0 ) ] ; aesop

/-
Multiplication rule for Gaussian periods.
-/
lemma period_mul (i j : ZMod 3) :
  period i * period j = (if i = j then 32 else 0) +
  (cyc_num (i - 0) (j - 0) * period 0 +
   cyc_num (i - 1) (j - 1) * period 1 +
   cyc_num (i - 2) (j - 2) * period 2) := by
     -- Apply Lemma `period_mul_eq_sum_N_sol` to expand the product.
     have h_expand : period i * period j = (if i = j then 32 else 0) +
       ‚àë u ‚àà (Finset.univ.filter (fun x : ZMod 97 => x ‚â† 0)), (cyc_num (i - ind u) (j - ind u) : L97) * Œ∂97 ^ (u.val : ‚Ñï) := by
         rw [ period_mul_eq_sum_N_sol ];
         exact congrArg _ ( Finset.sum_congr rfl fun u hu => by rw [ N_sol_eq_cyc_num i j u ( by simpa using hu ) ] );
     -- Partition the sum over `u != 0` based on `ind u = k` for `k \in {0, 1, 2}`.
     have h_partition : ‚àë u ‚àà (Finset.univ.filter (fun x : ZMod 97 => x ‚â† 0)), (cyc_num (i - ind u) (j - ind u) : L97) * Œ∂97 ^ (u.val : ‚Ñï) =
       ‚àë k ‚àà Finset.univ, (cyc_num (i - k) (j - k) : L97) * ‚àë u ‚àà (Finset.univ.filter (fun x : ZMod 97 => x ‚â† 0 ‚àß ind x = k)), Œ∂97 ^ (u.val : ‚Ñï) := by
         simp +decide only [Finset.sum_filter, Finset.mul_sum _ _ _];
         rw [ Finset.sum_comm, Finset.sum_congr rfl ] ; aesop;
     -- By definition of $C_koset$, we know that $\sum_{u \in C_koset k} \zeta_97^u = \text{period } k$.
     have h_period : ‚àÄ k : ZMod 3, ‚àë u ‚àà (Finset.univ.filter (fun x : ZMod 97 => x ‚â† 0 ‚àß ind x = k)), Œ∂97 ^ (u.val : ‚Ñï) = period k := by
       intro k
       simp [period_eq_sum_C_coset, C_coset];
     simp_all +decide [ Fin.sum_univ_three ];
     erw [ Fin.sum_univ_three ] ; ring!;

/-
alpha' is a root of X^3 - 97X - 97.
-/
theorem alpha_root' : Œ±'^3 - 97*Œ±' - 97 = 0 := by
  unfold Œ±';
  -- By definition of $Œ∑‚ÇÄ'$, $Œ∑‚ÇÅ'$, and $Œ∑‚ÇÇ'$, we know that $Œ∑‚ÇÄ' + Œ∑‚ÇÅ' + Œ∑‚ÇÇ' = -1$.
  have h_sum : Œ∑‚ÇÄ' + Œ∑‚ÇÅ' + Œ∑‚ÇÇ' = -1 := by
    -- The sum of all non-trivial roots of unity in the cyclotomic field is -1.
    have h_sum_roots : ‚àë x ‚àà Finset.univ.filter (fun x : ZMod 97 => x ‚â† 0), Œ∂97 ^ (x.val : ‚Ñï) = -1 := by
      have h_sum : ‚àë x : ZMod 97, (Œ∂97 : L97) ^ (x.val : ‚Ñï) = 0 := by
        have h_geom_sum : ‚àë x ‚àà Finset.range 97, (Œ∂97 : L97) ^ x = 0 := by
          rw [ geom_sum_eq ] <;> norm_num [ IsPrimitiveRoot.ne_one ];
          ¬∑ exact Or.inl ( sub_eq_zero_of_eq <| by exact IsPrimitiveRoot.pow_eq_one <| IsCyclotomicExtension.zeta_spec 97 ‚Ñö L97 );
          ¬∑ have h_order : IsPrimitiveRoot Œ∂97 97 := by
              convert IsCyclotomicExtension.zeta_spec 97 ‚Ñö L97 using 1
              skip
            generalize_proofs at *; exact h_order.ne_one (by norm_num);
        convert h_geom_sum using 1;
      rw [ Finset.sum_eq_add_sum_diff_singleton ( Finset.mem_univ 0 ) ] at h_sum;
      simpa [ Finset.filter_ne' ] using eq_neg_of_add_eq_zero_right h_sum;
    rw [ ‚Üê h_sum_roots, show Œ∑‚ÇÄ' + Œ∑‚ÇÅ' + Œ∑‚ÇÇ' = ‚àë x ‚àà Finset.univ.filter ( fun x : ZMod 97 => x ‚â† 0 ), Œ∂97 ^ x.val from ?_ ];
    rw [ show ( Finset.univ.filter fun x : ZMod 97 => x ‚â† 0 ) = S_cubic_res ‚à™ S_s1 ‚à™ S_s2 from by native_decide, Finset.sum_union, Finset.sum_union ];
    ¬∑ exact?;
    ¬∑ native_decide +revert;
    ¬∑ native_decide +revert;
  have := @period_mul 0 0; ( have := @period_mul 0 1; ( have := @period_mul 0 2; ( have := @period_mul 1 1; ( have := @period_mul 1 2; ( have := @period_mul 2 2; norm_num [ Finset.sum_add_distrib, pow_succ' ] at *; ) ) ) ) );
  simp_all +decide [ period_eq_def ];
  erw [ cyc_num_vals.1, cyc_num_vals.2.1, cyc_num_vals.2.2.1, cyc_num_vals.2.2.2.1, cyc_num_vals.2.2.2.2.1, cyc_num_vals.2.2.2.2.2.1, cyc_num_vals.2.2.2.2.2.2.1, cyc_num_vals.2.2.2.2.2.2.2.1, cyc_num_vals.2.2.2.2.2.2.2.2 ] at * ; norm_num at *;
  grind +ring

/-
Algebraic relation between beta' and alpha'.
-/
theorem beta_relation' : 2 * 19 * Œ≤' = 6 * Œ±'^2 - (19 + 9) * Œ±' - 4 * 97 := by
  unfold Œ≤' Œ±';
  rw [ show Œ∑‚ÇÄ' = period 0 from rfl, show Œ∑‚ÇÅ' = period 2 from rfl, show Œ∑‚ÇÇ' = period 1 from rfl ];
  -- By definition of $period$, we know that $period 0 + period 1 + period 2 = -1$.
  have h_sum : period 0 + period 1 + period 2 = -1 := by
    -- By definition of $period$, we know that $period 0 + period 1 + period 2 = \sum_{x \in \mathbb{Z}/97\mathbb{Z}} \zeta_{97}^x$.
    have h_sum : period 0 + period 1 + period 2 = ‚àë x ‚àà Finset.univ.filter (fun x : ZMod 97 => x ‚â† 0), Œ∂97 ^ (x.val : ‚Ñï) := by
      rw [ period_eq_sum_C_coset, period_eq_sum_C_coset, period_eq_sum_C_coset ];
      rw [ ‚Üê Finset.sum_union, ‚Üê Finset.sum_union ];
      ¬∑ rw [ show C_coset 0 ‚à™ C_coset 1 ‚à™ C_coset 2 = Finset.univ.filter ( fun x : ZMod 97 => x ‚â† 0 ) from ?_ ];
        native_decide +revert;
      ¬∑ native_decide +revert;
      ¬∑ simp +decide [ C_coset, Finset.disjoint_left ];
        grind;
    -- The sum of all powers of $\zeta_{97}$ is zero.
    have h_sum_zero : ‚àë x ‚àà Finset.range 97, Œ∂97 ^ x = 0 := by
      rw [ geom_sum_eq ] <;> norm_num [ hŒ∂ ];
      ¬∑ exact Or.inl ( sub_eq_zero_of_eq <| by exact ( show Œ∂97 ^ 97 = 1 from by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact ( by exact by rw [ show Œ∂97 = IsCyclotomicExtension.zeta 97 ‚Ñö L97 from rfl ] ; exact? ) ) ) ) ) ) ) ) ) ) ) ) ) );
      ¬∑ have := IsCyclotomicExtension.zeta_spec 97 ‚Ñö L97;
        exact this.ne_one ( by decide );
    rw [ Finset.sum_eq_sum_diff_singleton_add ( Finset.mem_range.mpr ( show 0 < 97 by decide ) ) ] at h_sum_zero;
    convert eq_neg_of_add_eq_zero_left h_sum_zero using 1;
    norm_num;
  -- Substitute the known values of the cyclotomic numbers into the equation.
  have h_cyclotomic : cyc_num 0 0 = 12 ‚àß cyc_num 0 1 = 10 ‚àß cyc_num 0 2 = 9 ‚àß cyc_num 1 0 = 10 ‚àß cyc_num 1 1 = 9 ‚àß cyc_num 1 2 = 13 ‚àß cyc_num 2 0 = 9 ‚àß cyc_num 2 1 = 13 ‚àß cyc_num 2 2 = 10 := by
    exact?;
  rw [ show period 0 = -1 - period 1 - period 2 by linear_combination' h_sum ] ; ring;
  rw [ show period 1 ^ 2 = period 1 * period 1 by ring, show period 2 ^ 2 = period 2 * period 2 by ring ] ; rw [ period_mul 1 1, period_mul 2 2, period_mul 1 2 ] ; simp +decide [ h_cyclotomic ] ; ring;
  rw [ show cyc_num ( -1 ) 0 = 9 by exact h_cyclotomic.2.2.2.2.2.2.1, show cyc_num ( -1 ) ( -1 ) = 10 by exact h_cyclotomic.2.2.2.2.2.2.2.2 ] ; norm_num ; ring;
  rw [ show cyc_num 0 1 = 10 by exact h_cyclotomic.2.1, show cyc_num 1 1 = 9 by exact h_cyclotomic.2.2.2.2.1 ] ; ring ; rw [ show period 0 = -1 - period 1 - period 2 by linear_combination' h_sum ] ; ring

/-
Define the Galois unit and automorphism for q=97.
-/
def gal_unit97 (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 97) : (ZMod 97)À£ := Units.mk0 (N : ZMod 97) (by
  rw [Ne, ZMod.natCast_zmod_eq_zero_iff_dvd]
  intro h
  have hN_prime : Nat.Prime N := Fact.out
  have : 97 = 1 ‚à® 97 = N := (Nat.dvd_prime hN_prime).mp h
  have : 97 = N := this.resolve_left (by norm_num)
  exact hN this.symm)

def sigma97 (u : (ZMod 97)À£) : L97 ‚âÉ‚Çê[‚Ñö] L97 :=
  (IsCyclotomicExtension.autEquivPow L97 (Polynomial.cyclotomic.irreducible_rat (n := 97) (by norm_num))).symm u

/-
The Frobenius automorphism permutes the Gaussian periods by shifting their index by ind(N).
-/
lemma sigma_period (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 97) (i : ZMod 3) :
  sigma97 (gal_unit97 N hN) (period i) = period (i + ind (N : ZMod 97)) := by
    -- By definition of $C_coset$, we know that $C_coset i$ is the set of elements $x$ such that $ind x = i$.
    have hC_coset : ‚àÄ i : ZMod 3, C_coset i = {x : ZMod 97 | x ‚â† 0 ‚àß ind x = i} := by
      unfold C_coset; aesop;
    -- By definition of $sigma97$, we know that it maps $Œ∂97^x$ to $Œ∂97^{Nx}$ for any $x \in \mathbb{Z}/97\mathbb{Z}$.
    have h_sigma_map : ‚àÄ x : ZMod 97, (sigma97 (gal_unit97 N hN)) (Œ∂97 ^ x.val) = Œ∂97 ^ ((N * x).val) := by
      intro x
      have h_sigma_map : (sigma97 (gal_unit97 N hN)) (Œ∂97 ^ x.val) = (sigma97 (gal_unit97 N hN)) (Œ∂97) ^ x.val := by
        exact map_pow _ _ _;
      have h_sigma_map : (sigma97 (gal_unit97 N hN)) Œ∂97 = Œ∂97 ^ (N : ZMod 97).val := by
        unfold sigma97;
        simp +decide [ gal_unit97 ];
        erw [ PowerBasis.equivOfMinpoly_gen ];
        exact?;
      cases N <;> simp_all +decide [ pow_mul ];
      norm_num [ ‚Üê pow_mul, ZMod.val_add, ZMod.val_mul ];
      rw [ ‚Üê Nat.mod_add_div ( ( _ + ZMod.val 1 ) % 97 * x.val ) 97 ] ; norm_num [ pow_add, pow_mul, Nat.mul_mod, Nat.pow_mod ] ;
      have h_zeta_pow : Œ∂97 ^ 97 = 1 := by
        exact IsPrimitiveRoot.pow_eq_one ( IsCyclotomicExtension.zeta_spec 97 ‚Ñö L97 );
      aesop;
    -- By definition of $C_coset$, we know that $C_coset (i + ind N)$ is the set of elements $y$ such that $ind y = i + ind N$.
    have hC_coset_shift : C_coset (i + ind N) = Finset.image (fun x => (N * x : ZMod 97)) (C_coset i) := by
      ext x; simp [hC_coset];
      constructor;
      ¬∑ intro hx
        obtain ‚ü®a, ha‚ü© : ‚àÉ a : ZMod 97, (N * a : ZMod 97) = x := by
          have h_inv : ‚àÉ a : ZMod 97, (N : ZMod 97) * a = 1 := by
            have h_inv : Nat.gcd N 97 = 1 := by
              exact Nat.Coprime.symm ( Nat.Prime.coprime_iff_not_dvd ( by decide ) |>.2 fun h => hN <| by have := Nat.prime_dvd_prime_iff_eq ( by decide : Nat.Prime 97 ) ( Fact.out : Nat.Prime N ) ; tauto );
            have := Nat.exists_mul_emod_eq_one_of_coprime h_inv;
            exact Exists.elim ( this ( by decide ) ) fun m hm => ‚ü® m, by simpa [ ‚Üê ZMod.natCast_eq_zero_iff ] using congr_arg ( fun x : ‚Ñï => x : ‚Ñï ‚Üí ZMod 97 ) hm ‚ü©;
          exact ‚ü® h_inv.choose * x, by linear_combination' h_inv.choose_spec * x ‚ü©;
        use a; simp_all +decide [ Set.ext_iff ] ;
        have h_ind_mul : ind (N * a) = ind N + ind a := by
          have h_ind_mul : ‚àÄ x y : ZMod 97, x ‚â† 0 ‚Üí y ‚â† 0 ‚Üí ind (x * y) = ind x + ind y := by
            exact?;
          apply h_ind_mul; exact (by
          intro h; simp_all +decide [ ZMod.natCast_eq_zero_iff ] ;); exact (by
          grind);
        grind +ring;
      ¬∑ rintro ‚ü® a, ha, rfl ‚ü©;
        have h_ind_mul : ind (N * a) = ind N + ind a := by
          apply ind_mul;
          ¬∑ intro h; have := Fact.out ( p := Nat.Prime N ) ; simp_all +decide [ ZMod.natCast_eq_zero_iff ] ;
            rw [ this.dvd_iff_eq ] at h <;> aesop;
          ¬∑ exact hC_coset i |>.subset ha |>.1;
        simp_all +decide [ add_comm, C_coset ];
        exact?;
    -- By definition of $period$, we know that $period i$ is the sum of $Œ∂97^x$ over $x \in C_coset i$.
    have hperiod_def : ‚àÄ i : ZMod 3, period i = ‚àë x ‚àà C_coset i, Œ∂97 ^ x.val := by
      exact?;
    rw [ hperiod_def, hperiod_def, hC_coset_shift, Finset.sum_image ];
    ¬∑ rw [ map_sum, Finset.sum_congr rfl fun x hx => h_sigma_map x ];
    ¬∑ intro x hx y hy; haveI := Fact.mk ( Fact.out : Nat.Prime N ) ; simp_all +decide [ mul_eq_zero, ZMod.natCast_eq_zero_iff ] ;
      rintro ( rfl | h ) <;> simp_all +decide [ Nat.Prime.dvd_iff_eq Fact.out ]

/-
Integer versions of the periods and roots, and their coercion properties.
-/
def Œ∂97_int : ùìû L97 := IsPrimitiveRoot.toInteger (IsCyclotomicExtension.zeta_spec 97 ‚Ñö L97)

def period_int (i : ZMod 3) : ùìû L97 := ‚àë x ‚àà C_coset i, Œ∂97_int ^ (x.val : ‚Ñï)

def Œ±'_int : ùìû L97 := -(period_int 1 - period_int 2)
def Œ≤'_int : ùìû L97 := -(period_int 0 - period_int 1)
def Œ≥'_int : ùìû L97 := -(period_int 2 - period_int 0)

lemma coe_period_int (i : ZMod 3) : (period_int i : L97) = period i := by
  unfold period_int period;
  unfold Œ∂97_int Œ∑‚ÇÄ' Œ∑‚ÇÅ' Œ∑‚ÇÇ';
  split_ifs <;> simp +decide [ *, Subtype.ext_iff ];
  ¬∑ congr! 1;
    exact C_coset_eq.1;
  ¬∑ congr! 2;
    exact C_coset_eq.2.1;
  ¬∑ congr! 1;
    native_decide +revert

lemma coe_alpha'_int : (Œ±'_int : L97) = Œ±' := by
  unfold Œ±'_int Œ±';
  unfold period_int;
  unfold Œ∑‚ÇÇ' Œ∑‚ÇÅ' C_coset; simp +decide [ Finset.sum_sub_distrib ] ;
  congr! 2;
  ¬∑ native_decide +revert;
  ¬∑ native_decide +revert

lemma coe_beta'_int : (Œ≤'_int : L97) = Œ≤' := by
  unfold Œ≤'_int Œ≤';
  unfold period_int;
  simp +decide [ C_coset_eq, S_s1, S_cubic_res ];
  congr!

lemma coe_gamma'_int : (Œ≥'_int : L97) = Œ≥' := by
  unfold Œ≥'_int Œ≥';
  unfold period_int;
  simp +decide [ C_coset_eq ];
  congr! 2

/-
Relate the index of N to the value of c' N being s1'.
-/
lemma ind_N_eq_1_iff_c_eq_s1 (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 97) :
  ind (N : ZMod 97) = 1 ‚Üî c' N = s1' := by
    unfold ind c' s1';
    unfold S_cubic_res S_s1; simp +decide;
    unfold q' a' s1'; simp +decide ;
    split_ifs <;> simp_all +decide [ ZMod.natCast_eq_zero_iff ];
    ¬∑ native_decide +revert;
    ¬∑ rename_i h‚ÇÅ h‚ÇÇ;
      contrapose! h‚ÇÇ;
      exact ‚ü® fun h => hN <| by have := Nat.prime_dvd_prime_iff_eq ( by decide : Nat.Prime 97 ) ( Fact.out : Nat.Prime N ) ; tauto, h‚ÇÇ ‚ü©

/-
Relate the index of N to the value of c' N being s2'.
-/
lemma ind_N_eq_2_iff_c_eq_s2 (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 97) :
  ind (N : ZMod 97) = 2 ‚Üî c' N = s2' := by
    -- By definition of $c'$ and $ind$, we know that $c' N = s2'$ if and only if $N^{32} = s2'$.
    have h_c'_eq_s2' : c' N = s2' ‚Üî (N : ZMod 97) ^ 32 = s2' := by
      rfl;
    cases eq_or_ne ( N : ZMod 97 ) 0 <;> simp_all +decide [ ind ];
    ¬∑ rw [ ZMod.natCast_eq_zero_iff ] at * ; exact absurd ( Nat.dvd_of_mod_eq_zero ( Nat.mod_eq_zero_of_dvd <| by assumption ) ) ( by rw [ Nat.dvd_prime Fact.out ] ; aesop );
    ¬∑ split_ifs <;> simp_all +decide [ S_cubic_res, S_s1, S_s2 ];
      ¬∑ native_decide +revert;
      ¬∑ native_decide +revert;
      ¬∑ have h_cases : ‚àÄ x : ZMod 97, x ‚â† 0 ‚Üí x ^ 32 = 1 ‚à® x ^ 32 = s1' ‚à® x ^ 32 = s2' := by
          native_decide +revert;
        cases h_cases _ ‚Äπ_‚Ä∫ <;> tauto

/-
Abbreviations for the ring of integers, residue field, and reduction map for q=97.
-/
abbrev ùìûL97 := ùìû L97
def kP97 (P : Ideal ùìûL97) [P.IsMaximal] := ùìûL97 ‚ß∏ P
noncomputable instance (P : Ideal ùìûL97) [P.IsMaximal] : Field (kP97 P) := Ideal.Quotient.field P
def red97 (P : Ideal ùìûL97) [P.IsMaximal] : ùìûL97 ‚Üí+* kP97 P := Ideal.Quotient.mk P

/-
Relate the index of N to the value of c' N being s1'.
-/
lemma ind_N_eq_1_iff_c_eq_s1_new (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 97) :
  ind (N : ZMod 97) = 1 ‚Üî c' N = s1' := by
    convert ind_N_eq_1_iff_c_eq_s1 N hN using 1

/-
Lift the automorphism sigma97 to the ring of integers.
-/
def sigma_int97 (u : (ZMod 97)À£) (x : ùìû L97) : ùìû L97 := ‚ü®sigma97 u x, by
  have h_integral : IsIntegral ‚Ñ§ (x : L97) := x.2
  exact IsIntegral.map (sigma97 u) h_integral‚ü©

/-
The ring of integers is generated by zeta97.
-/
lemma adjoin_zeta_eq_top97 : Algebra.adjoin ‚Ñ§ ({Œ∂97_int} : Set ùìûL97) = ‚ä§ := by
  let hŒ∂ := IsCyclotomicExtension.zeta_spec 97 ‚Ñö L97
  let pb := IsPrimitiveRoot.integralPowerBasis' hŒ∂
  have h_gen : pb.gen = Œ∂97_int := IsPrimitiveRoot.integralPowerBasis'_gen hŒ∂
  rw [‚Üê h_gen]
  exact pb.adjoin_gen_eq_top

/-
The automorphism sigma_N reduces to the Frobenius map modulo P.
-/
theorem artin_property97 {N : ‚Ñï} [Fact (Nat.Prime N)] (hN : N ‚â† 97) (P : Ideal ùìûL97) [P.IsMaximal] [CharP (kP97 P) N] (x : ùìûL97) :
  red97 P (sigma_int97 (gal_unit97 N hN) x) = (red97 P x) ^ N := by
    have h_sigma_int97_zeta : ‚àÄ x : ùìûL97, x ‚àà Algebra.adjoin ‚Ñ§ ({Œ∂97_int} : Set ùìûL97) ‚Üí red97 P (sigma_int97 (gal_unit97 N hN) x) = (red97 P x) ^ N := by
      refine fun x hx => Algebra.adjoin_induction ?_ ?_ ?_ ?_ hx;
      ¬∑ -- Since $\sigma_N(\zeta_{97}) = \zeta_{97}^N$, we have $\sigma_int97(\zeta_{97}) = \zeta_{97}^N$.
        have h_sigma_zeta : sigma_int97 (gal_unit97 N hN) Œ∂97_int = Œ∂97_int ^ N := by
          have h_sigma_zeta : (sigma97 (gal_unit97 N hN) Œ∂97_int : L97) = Œ∂97_int ^ N := by
            have h_sigma_zeta : ‚àÄ (u : (ZMod 97)À£), sigma97 u Œ∂97 = Œ∂97 ^ (u : ZMod 97).val := by
              intro u
              simp [sigma97];
              erw [ PowerBasis.equivOfMinpoly_gen ];
              rfl;
            convert h_sigma_zeta ( gal_unit97 N hN ) using 1;
            simp +decide [ gal_unit97 ];
            rw [ ‚Üê Nat.mod_add_div N 97 ] ; norm_num [ pow_add, pow_mul ] ;
            have h_zeta_97_pow : Œ∂97 ^ 97 = 1 := by
              exact IsPrimitiveRoot.pow_eq_one ( IsCyclotomicExtension.zeta_spec 97 ‚Ñö L97 );
            erw [ show ( Œ∂97_int : L97 ) = Œ∂97 from ?_ ] ; aesop;
            exact?;
          exact?;
        aesop;
      ¬∑ intro r; exact (by
        simp +decide [ red97, sigma_int97 ];
        erw [ Ideal.Quotient.eq ];
        -- Since $P$ is a maximal ideal, it is prime, and thus if $r^N - r$ is in $P$, then either $r$ is in $P$ or $r^{N-1} - 1$ is in $P$.
        have h_prime : ‚àÄ r : ‚Ñ§, (r ^ N - r : ùìûL97) ‚àà P := by
          intro r
          have h_fermat : (r ^ N - r : ‚Ñ§) ‚â° 0 [ZMOD N] := by
            simp +decide [ ‚Üê ZMod.intCast_eq_intCast_iff ];
          obtain ‚ü® k, hk ‚ü© := h_fermat.symm.dvd;
          -- Since $N$ is in $P$, multiplying by $k$ (which is an integer) keeps it in $P$.
          have hN_in_P : (N : ùìûL97) ‚àà P := by
            have hN_in_P : (N : kP97 P) = 0 := by
              exact?;
            exact?;
          convert P.mul_mem_right ( k : ùìûL97 ) hN_in_P using 1 ; norm_cast ; aesop;
        simpa using Submodule.neg_mem _ ( h_prime r ));
      ¬∑ intro x y hx hy hx' hy'; simp +decide [ *, pow_add ] ;
        rw [ show sigma_int97 ( gal_unit97 N hN ) ( x + y ) = sigma_int97 ( gal_unit97 N hN ) x + sigma_int97 ( gal_unit97 N hN ) y from ?_, map_add ];
        ¬∑ rw [ hx', hy', add_pow_char ];
        ¬∑ exact Subtype.ext <| map_add _ _ _;
      ¬∑ simp +contextual [ *, mul_pow ];
        intro x y hx hy hx' hy'; rw [ show sigma_int97 ( gal_unit97 N hN ) ( x * y ) = sigma_int97 ( gal_unit97 N hN ) x * sigma_int97 ( gal_unit97 N hN ) y from ?_ ] ; aesop;
        exact Subtype.ext <| map_mul _ _ _;
    exact h_sigma_int97_zeta x ( by rw [ adjoin_zeta_eq_top97 ] ; exact Algebra.mem_top ) |> fun h => by simpa using h;

/-
If c' N = s1', then sigma_N(alpha') = gamma'.
-/
lemma sigma_alpha_eq_gamma_if_s1 (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 97) (h : c' N = s1') :
  sigma_int97 (gal_unit97 N hN) Œ±'_int = Œ≥'_int := by
    -- We check the equality in the field L97.
    have h_field : sigma97 (gal_unit97 N hN) (Œ±'_int : L97) = (Œ≥'_int : L97) := by
      -- By definition of $c'$, we know that $c' N = s1'$ implies $ind (N : ZMod 97) = 1$.
      have h_ind : ind (N : ZMod 97) = 1 := by
        exact?;
      -- By definition of $sigma97$, we have $sigma97 (gal_unit97 N hN) (Œ±'_int) = sigma97 (gal_unit97 N hN) (period 2 - period 1)$.
      have h_sigma97_def : sigma97 (gal_unit97 N hN) (Œ±'_int : L97) = sigma97 (gal_unit97 N hN) (period 2 - period 1) := by
        rw [ show ( Œ±'_int : L97 ) = period 2 - period 1 from ?_ ];
        convert coe_alpha'_int using 1;
        unfold Œ±';
        exact?;
      -- By definition of $sigma97$, we have $sigma97 (gal_unit97 N hN) (period 2 - period 1) = period (2 + ind (N : ZMod 97)) - period (1 + ind (N : ZMod 97))$.
      have h_sigma97_period : sigma97 (gal_unit97 N hN) (period 2 - period 1) = period (2 + ind (N : ZMod 97)) - period (1 + ind (N : ZMod 97)) := by
        rw [ map_sub, sigma_period, sigma_period ];
      simp_all +decide [ Œ≥'_int ];
      exact congr_arg‚ÇÇ _ ( coe_period_int 0 ‚ñ∏ rfl ) ( coe_period_int 2 ‚ñ∏ rfl );
    convert h_field using 1;
    -- Since the ring of integers is a subalgebra of the field, the elements are equal in the ring if and only if they are equal in the field.
    have h_subalgebra : ‚àÄ (x y : ùìû L97), x = y ‚Üî (x : L97) = (y : L97) := by
      exact?;
    convert h_subalgebra _ _ using 1

/-
If c' N = s2', then sigma_N(alpha') = beta'.
-/
lemma sigma_alpha_eq_beta_if_s2 (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 97) (h : c' N = s2') :
  sigma_int97 (gal_unit97 N hN) Œ±'_int = Œ≤'_int := by
    -- Since $c' N = s2'$, we have $ind N = 2$.
    have h_ind : ind (N : ZMod 97) = 2 := by
      exact?;
    -- Since $\sigma_N(\alpha') = \beta'$ in $L97$, we have $\sigma_N(\alpha'_int) = \beta'_int$ in $\mathcal{O}_{L97}$.
    have h_sigma_alpha_int_eq_beta_int : (sigma97 (gal_unit97 N hN) Œ±' : L97) = Œ≤' := by
      -- Since $c' N = s2'$, we have $ind N = 2$. Therefore, $\sigma_N(\alpha') = \beta'$.
      have h_sigma_beta : (sigma97 (gal_unit97 N hN)) (period 2 - period 1) = period 1 - period 0 := by
        have := sigma_period N hN 2; have := sigma_period N hN 1; aesop;
      generalize_proofs at *; (
      unfold Œ±' Œ≤'; aesop;)
    generalize_proofs at *; (
    convert h_sigma_alpha_int_eq_beta_int using 1
    generalize_proofs at *; (
    constructor <;> intro h <;> simp_all +decide [ ‚Üê coe_alpha'_int, ‚Üê coe_beta'_int, ‚Üê coe_gamma'_int ] ;
    exact Subtype.ext h_sigma_alpha_int_eq_beta_int
    skip))

/-
Final result for q=97: Frobenius action on alpha depends on c' N.
-/
theorem final_result_97 {N : ‚Ñï} [Fact (Nat.Prime N)] (hN : N ‚â† 97) (hN19 : N ‚â† 19) (P : Ideal ùìûL97) [P.IsMaximal] [CharP (kP97 P) N] :
  (c' N = s1' ‚Üí (red97 P Œ±'_int) ^ N = red97 P Œ≥'_int) ‚àß
  (c' N = s2' ‚Üí (red97 P Œ±'_int) ^ N = red97 P Œ≤'_int) := by
  constructor
  ¬∑ intro h
    rw [‚Üê artin_property97 hN P Œ±'_int]
    rw [sigma_alpha_eq_gamma_if_s1 N hN h]
  ¬∑ intro h
    rw [‚Üê artin_property97 hN P Œ±'_int]
    rw [sigma_alpha_eq_beta_if_s2 N hN h]

/-
Definitions of constants q=349, a=37, s1, s2, and c for the new problem instance. Also define the cyclotomic field L349 and the primitive root of unity zeta349.
-/
def q'' : ‚Ñï := 349
def a'' : ‚Ñï := 37
def s1'' : ZMod 349 := (- (a'' : ZMod 349) - 3) * (6 : ZMod 349)‚Åª¬π
def s2'' : ZMod 349 := ((a'' : ZMod 349) - 3) * (6 : ZMod 349)‚Åª¬π
def c'' (N : ‚Ñï) : ZMod 349 := (N : ZMod 349) ^ ((q'' - 1) / 3)

open Polynomial NumberField

def L349 : Type := CyclotomicField 349 ‚Ñö

instance : Field L349 := CyclotomicField.instField 349 ‚Ñö
instance : NumberField L349 := CyclotomicField.instNumberField 349 ‚Ñö
instance : IsCyclotomicExtension {349} ‚Ñö L349 := CyclotomicField.isCyclotomicExtension 349 ‚Ñö

def Œ∂349 : L349 := IsCyclotomicExtension.zeta 349 ‚Ñö L349

instance : Fact (Nat.Prime 349) := ‚ü®by norm_num‚ü©

/-
Define the sets of indices and the Gaussian periods for q=349. Define alpha, beta, gamma. Prove their sum is zero.
-/
def S_cubic_res'' : Finset (ZMod 349) := {x | x ‚â† 0 ‚àß x ^ 116 = 1}
def S_s1'' : Finset (ZMod 349) := {x | x ‚â† 0 ‚àß x ^ 116 = s1''}
def S_s2'' : Finset (ZMod 349) := {x | x ‚â† 0 ‚àß x ^ 116 = s2''}

def Œ∑‚ÇÄ'' : L349 := ‚àë x ‚àà S_cubic_res'', Œ∂349 ^ (x.val : ‚Ñï)
def Œ∑‚ÇÅ'' : L349 := ‚àë x ‚àà S_s2'', Œ∂349 ^ (x.val : ‚Ñï)
def Œ∑‚ÇÇ'' : L349 := ‚àë x ‚àà S_s1'', Œ∂349 ^ (x.val : ‚Ñï)

def Œ±'' : L349 := -(Œ∑‚ÇÇ'' - Œ∑‚ÇÅ'')
def Œ≤'' : L349 := -(Œ∑‚ÇÄ'' - Œ∑‚ÇÇ'')
def Œ≥'' : L349 := -(Œ∑‚ÇÅ'' - Œ∑‚ÇÄ'')

theorem sum_zero'' : Œ±'' + Œ≤'' + Œ≥'' = 0 := by
  -- By definition of Œ±'', Œ≤'', and Œ≥'', we have Œ±'' + Œ≤'' + Œ≥'' = 0 because each period is a sum of roots of unity, and their sum is zero.
  simp [Œ±'', Œ≤'', Œ≥'', Œ∑‚ÇÄ'', Œ∑‚ÇÅ'', Œ∑‚ÇÇ'']

/-
Definitions of index function, cyclotomic numbers, and period function for q=349.
-/
def ind'' (x : ZMod 349) : ZMod 3 :=
  if x ‚àà S_cubic_res'' then 0
  else if x ‚àà S_s1'' then 1
  else 2

def cyc_num'' (i j : ZMod 3) : ‚Ñï :=
  Fintype.card { x : ZMod 349 // x ‚â† 0 ‚àß x ‚â† 1 ‚àß ind'' x = i ‚àß ind'' (1 - x) = j }

def period'' (i : ZMod 3) : L349 :=
  if i = 0 then Œ∑‚ÇÄ''
  else if i = 1 then Œ∑‚ÇÇ''
  else Œ∑‚ÇÅ''

/-
The period function maps 0, 1, 2 to eta0'', eta2'', eta1'' respectively.
-/
lemma period_eq_def'' : period'' 0 = Œ∑‚ÇÄ'' ‚àß period'' 1 = Œ∑‚ÇÇ'' ‚àß period'' 2 = Œ∑‚ÇÅ'' := by
  exact ‚ü® rfl, rfl, rfl ‚ü©

/-
The index function correctly identifies which coset an element belongs to.
-/
lemma ind_spec'' (x : ZMod 349) (hx : x ‚â† 0) :
  (ind'' x = 0 ‚Üî x ‚àà S_cubic_res'') ‚àß
  (ind'' x = 1 ‚Üî x ‚àà S_s1'') ‚àß
  (ind'' x = 2 ‚Üî x ‚àà S_s2'') := by
    native_decide +revert

/-
Evaluate the cyclotomic numbers for q=349.
-/
#eval (cyc_num'' 0 0, cyc_num'' 0 1, cyc_num'' 0 2)
#eval (cyc_num'' 1 0, cyc_num'' 1 1, cyc_num'' 1 2)
#eval (cyc_num'' 2 0, cyc_num'' 2 1, cyc_num'' 2 2)

/-
Define N_sol'' as the number of solutions to x + y = u with ind x = i and ind y = j.
-/
def N_sol'' (i j : ZMod 3) (u : ZMod 349) : ‚Ñï :=
  Fintype.card { p : ZMod 349 √ó ZMod 349 // p.1 ‚â† 0 ‚àß p.2 ‚â† 0 ‚àß ind'' p.1 = i ‚àß ind'' p.2 = j ‚àß p.1 + p.2 = u }

/-
The index of -1 is 0.
-/
lemma ind_neg_one'' : ind'' (-1) = 0 := by
  native_decide +revert

/-
The index function is a homomorphism from the multiplicative group to the additive group Z/3Z.
-/
lemma ind_mul'' (x y : ZMod 349) (hx : x ‚â† 0) (hy : y ‚â† 0) : ind'' (x * y) = ind'' x + ind'' y := by
  native_decide +revert

/-
The index of the inverse is the negative of the index.
-/
lemma ind_inv'' (x : ZMod 349) (hx : x ‚â† 0) : ind'' (x‚Åª¬π) = - ind'' x := by
  native_decide +revert

/-
The cardinalities of the sets S_cubic_res'', S_s1'', and S_s2'' are all 116.
-/
lemma card_S'' : S_cubic_res''.card = 116 ‚àß S_s1''.card = 116 ‚àß S_s2''.card = 116 := by
  native_decide +revert

/-
Define C_coset'' and prove it equals the previously defined sets.
-/
def C_coset'' (i : ZMod 3) : Finset (ZMod 349) := Finset.univ.filter (fun x => x ‚â† 0 ‚àß ind'' x = i)

lemma C_coset_eq'' : C_coset'' 0 = S_cubic_res'' ‚àß C_coset'' 1 = S_s1'' ‚àß C_coset'' 2 = S_s2'' := by
  native_decide +revert

/-
The period function is the sum of zeta powers over the coset.
-/
lemma period_eq_sum_C_coset'' (i : ZMod 3) : period'' i = ‚àë x ‚àà C_coset'' i, Œ∂349 ^ (x.val : ‚Ñï) := by
  fin_cases i <;> simp +decide [ period_eq_def'' ];
  ¬∑ exact C_coset_eq''.left.symm ‚ñ∏ rfl;
  ¬∑ -- By definition of $C_coset''$, we know that $C_coset'' 1 = S_s1''$.
    have h_coset_eq : C_coset'' 1 = S_s1'' := by
      exact C_coset_eq''.2.1;
    exact h_coset_eq.symm ‚ñ∏ rfl;
  ¬∑ exact Eq.symm ( by rw [ show C_coset'' 2 = S_s2'' by exact ( by native_decide ) ] ; rfl )

/-
Expansion of the product of Gaussian periods in terms of solution counts for q=349.
-/
lemma period_mul_eq_sum_N_sol'' (i j : ZMod 3) :
  period'' i * period'' j = (if i = j then 116 else 0) +
  ‚àë u ‚àà Finset.univ.filter (fun x : ZMod 349 => x ‚â† 0), (N_sol'' i j u : L349) * Œ∂349 ^ (u.val : ‚Ñï) := by
    revert i j;
    -- We'll use the fact that $period'' i = \sum_{x \in S_i} \zeta_{349}^x$ to expand the product.
    have h_expand : ‚àÄ i j : ZMod 3, period'' i * period'' j = (if i = j then 116 else 0) + ‚àë x ‚àà C_coset'' i, ‚àë y ‚àà C_coset'' j, if x + y = 0 then 0 else Œ∂349 ^ ((x + y).val : ‚Ñï) := by
      intro i j
      have h_expand : period'' i * period'' j = ‚àë x ‚àà C_coset'' i, ‚àë y ‚àà C_coset'' j, Œ∂349 ^ (x.val : ‚Ñï) * Œ∂349 ^ (y.val : ‚Ñï) := by
        rw [ period_eq_sum_C_coset'' i, period_eq_sum_C_coset'' j, Finset.sum_mul_sum ];
      have h_split : ‚àë x ‚àà C_coset'' i, ‚àë y ‚àà C_coset'' j, Œ∂349 ^ (x.val : ‚Ñï) * Œ∂349 ^ (y.val : ‚Ñï) = ‚àë x ‚àà C_coset'' i, ‚àë y ‚àà C_coset'' j, if x + y = 0 then 1 else Œ∂349 ^ ((x + y).val : ‚Ñï) := by
        refine' Finset.sum_congr rfl fun x hx => Finset.sum_congr rfl fun y hy => _;
        have h_exp : Œ∂349 ^ (x.val + y.val) = Œ∂349 ^ ((x + y).val : ‚Ñï) := by
          have h_exp : Œ∂349 ^ 349 = 1 := by
            exact IsPrimitiveRoot.pow_eq_one ( IsCyclotomicExtension.zeta_spec 349 ‚Ñö L349 );
          rw [ ‚Üê Nat.mod_add_div ( x.val + y.val ) 349, pow_add, pow_mul ] ; aesop;
        split_ifs <;> simp_all +decide [ ‚Üê pow_add ];
      have h_card : ‚àë x ‚àà C_coset'' i, ‚àë y ‚àà C_coset'' j, (if x + y = 0 then 1 else 0) = if i = j then 116 else 0 := by
        fin_cases i <;> fin_cases j <;> native_decide;
      simp_all +decide [ Finset.sum_ite ];
      rw [ Finset.sum_add_distrib, ‚Üê Nat.cast_sum, h_card ];
      split_ifs <;> norm_num;
    intros i j
    have h_double_sum : ‚àë x ‚àà C_coset'' i, ‚àë y ‚àà C_coset'' j, (if x + y = 0 then 0 else Œ∂349 ^ ((x + y).val : ‚Ñï)) = ‚àë u ‚àà Finset.univ.filter (fun x => x ‚â† 0), ‚àë x ‚àà C_coset'' i, ‚àë y ‚àà C_coset'' j, (if x + y = u then Œ∂349 ^ (u.val : ‚Ñï) else 0) := by
      have h_double_sum : ‚àÄ x ‚àà C_coset'' i, ‚àÄ y ‚àà C_coset'' j, (if x + y = 0 then 0 else Œ∂349 ^ ((x + y).val : ‚Ñï)) = ‚àë u ‚àà Finset.univ.filter (fun x => x ‚â† 0), (if x + y = u then Œ∂349 ^ (u.val : ‚Ñï) else 0) := by
        intro x hx y hy; split_ifs <;> simp_all +decide [ Finset.sum_ite ] ;
      rw [ Finset.sum_congr rfl fun x hx => Finset.sum_congr rfl fun y hy => h_double_sum x hx y hy ];
      rw [ Finset.sum_comm, Finset.sum_congr rfl fun _ _ => Finset.sum_comm ];
      rw [ Finset.sum_comm, Finset.sum_congr rfl fun _ _ => Finset.sum_comm ];
    simp_all +decide [ Finset.sum_ite ];
    refine' Finset.sum_congr rfl fun u hu => _;
    rw [ ‚Üê Finset.sum_mul _ _ _ ];
    simp +decide [ N_sol'', Fintype.card_subtype ];
    rw [ show ( Finset.filter ( fun x : ZMod 349 √ó ZMod 349 => ¬¨x.1 = 0 ‚àß ¬¨x.2 = 0 ‚àß ind'' x.1 = i ‚àß ind'' x.2 = j ‚àß x.1 + x.2 = u ) Finset.univ ) = Finset.biUnion ( C_coset'' i ) fun x => Finset.image ( fun y => ( x, y ) ) ( Finset.filter ( fun y => x + y = u ) ( C_coset'' j ) ) from ?_, Finset.card_biUnion ];
    ¬∑ simp +decide [ Finset.card_image_of_injective, Function.Injective ];
    ¬∑ exact fun x hx y hy hxy => Finset.disjoint_left.mpr fun z => by aesop;
    ¬∑ ext ‚ü®x, y‚ü©; simp [C_coset''];
      tauto

/-
The number of solutions to x+y=u depends only on the index of u. Specifically, N_sol(i, j, u) = cyc_num(i - ind(u), j - ind(u)).
-/
lemma N_sol_eq_cyc_num'' (i j : ZMod 3) (u : ZMod 349) (hu : u ‚â† 0) :
  N_sol'' i j u = cyc_num'' (i - ind'' u) (j - ind'' u) := by
    convert Set.ext_iff.mp ?_ ( u, 1 - u ) using 1;
    case convert_1 => exact { p : ZMod 349 √ó ZMod 349 | p.1 ‚â† 0 ‚àß p.2 ‚â† 0 ‚àß p.1 + p.2 = u ‚àß ind'' p.1 = i ‚àß ind'' p.2 = j };
    case convert_2 => exact { p : ZMod 349 √ó ZMod 349 | p.1 ‚â† 0 ‚àß p.2 ‚â† 0 ‚àß p.1 + p.2 = u ‚àß ind'' p.1 = i ‚àß ind'' p.2 = j };
    ¬∑ unfold N_sol'' cyc_num''; simp +decide [ Fintype.card_subtype ] ;
      refine' Finset.card_bij ( fun x hx => x.1 / u ) _ _ _;
      ¬∑ simp +contextual [ hu, sub_eq_iff_eq_add ];
        intro a b ha hb ha' hb' hab; rw [ div_eq_iff_mul_eq ] <;> simp_all +decide [ add_comm, add_left_comm, add_assoc ] ;
        refine' ‚ü® _, _, _ ‚ü© <;> subst_vars <;> simp_all +decide [ div_eq_mul_inv ];
        ¬∑ native_decide +revert;
        ¬∑ native_decide +revert;
      ¬∑ grind;
      ¬∑ intro b hb; use ( b * u, ( 1 - b ) * u ) ; simp_all +decide [ sub_mul, mul_assoc ] ;
        native_decide +revert;
    ¬∑ rfl

/-
Multiplication rule for Gaussian periods for q=349.
-/
lemma period_mul'' (i j : ZMod 3) :
  period'' i * period'' j = (if i = j then 116 else 0) +
  (cyc_num'' (i - 0) (j - 0) * period'' 0 +
   cyc_num'' (i - 1) (j - 1) * period'' 1 +
   cyc_num'' (i - 2) (j - 2) * period'' 2) := by
     -- Apply the lemma N_sol_eq_cyc_num'' to rewrite the sum.
     have h_sum_rewrite : ‚àë u ‚àà Finset.univ.filter (fun x : ZMod 349 => x ‚â† 0), (N_sol'' i j u : L349) * Œ∂349 ^ (u.val : ‚Ñï) = ‚àë k ‚àà Finset.univ, cyc_num'' (i - k) (j - k) * (‚àë u ‚àà C_coset'' k, Œ∂349 ^ (u.val : ‚Ñï)) := by
       have h_sum_rewrite : ‚àë u ‚àà Finset.univ.filter (fun x : ZMod 349 => x ‚â† 0), (N_sol'' i j u : L349) * Œ∂349 ^ (u.val : ‚Ñï) = ‚àë k ‚àà Finset.univ, ‚àë u ‚àà Finset.univ.filter (fun x : ZMod 349 => x ‚â† 0 ‚àß ind'' x = k), (N_sol'' i j u : L349) * Œ∂349 ^ (u.val : ‚Ñï) := by
         rw [ ‚Üê Finset.sum_biUnion ];
         ¬∑ rcongr x ; aesop;
         ¬∑ exact fun x _ y _ hxy => Finset.disjoint_left.mpr fun z => by aesop;
       -- Apply the lemma N_sol_eq_cyc_num'' to each term in the sum.
       have h_inner_sum : ‚àÄ k : ZMod 3, ‚àë u ‚àà Finset.univ.filter (fun x : ZMod 349 => x ‚â† 0 ‚àß ind'' x = k), (N_sol'' i j u : L349) * Œ∂349 ^ (u.val : ‚Ñï) = cyc_num'' (i - k) (j - k) * ‚àë u ‚àà Finset.univ.filter (fun x : ZMod 349 => x ‚â† 0 ‚àß ind'' x = k), Œ∂349 ^ (u.val : ‚Ñï) := by
         intros k
         have h_inner_sum : ‚àÄ u ‚àà Finset.univ.filter (fun x : ZMod 349 => x ‚â† 0 ‚àß ind'' x = k), (N_sol'' i j u : L349) = cyc_num'' (i - k) (j - k) := by
           intros u hu
           have h_ind : ind'' u = k := by
             grind
           rw [N_sol_eq_cyc_num'' i j u (by
           exact Finset.mem_filter.mp hu |>.2.1)];
           rw [ h_ind ];
         rw [ Finset.mul_sum _ _ _, Finset.sum_congr rfl fun u hu => by rw [ h_inner_sum u hu ] ];
       simp_all +decide only [C_coset''];
     convert congr_arg ( fun x : L349 => ( if i = j then 116 else 0 ) + x ) h_sum_rewrite using 1;
     ¬∑ convert period_mul_eq_sum_N_sol'' i j using 1;
     ¬∑ rw [ show ( Finset.univ : Finset ( ZMod 3 ) ) = { 0, 1, 2 } by decide, Finset.sum_insert, Finset.sum_insert ] <;> simp +decide [ Finset.sum_singleton ];
       rw [ ‚Üê add_assoc, ‚Üê period_eq_sum_C_coset'' 0, ‚Üê period_eq_sum_C_coset'' 1, ‚Üê period_eq_sum_C_coset'' 2 ]

/-
Values of the cyclotomic numbers for q=349.
-/
lemma cyc_num_vals'' :
  cyc_num'' 0 0 = 42 ‚àß cyc_num'' 0 1 = 37 ‚àß cyc_num'' 0 2 = 36 ‚àß
  cyc_num'' 1 0 = 37 ‚àß cyc_num'' 1 1 = 36 ‚àß cyc_num'' 1 2 = 43 ‚àß
  cyc_num'' 2 0 = 36 ‚àß cyc_num'' 2 1 = 43 ‚àß cyc_num'' 2 2 = 37 := by
    native_decide +revert

/-
Prove that the sum of the periods is -1.
-/
lemma sum_eta'' : Œ∑‚ÇÄ'' + Œ∑‚ÇÅ'' + Œ∑‚ÇÇ'' = -1 := by
  unfold Œ∑‚ÇÄ'' Œ∑‚ÇÅ'' Œ∑‚ÇÇ'';
  -- The union of S_cubic_res'', S_s2'', and S_s1'' is the set of all non-zero elements in ZMod 349.
  have h_union : S_cubic_res'' ‚à™ S_s2'' ‚à™ S_s1'' = Finset.univ.erase 0 := by
    native_decide +revert;
  rw [ ‚Üê Finset.sum_union, ‚Üê Finset.sum_union ] <;> norm_num [ h_union ];
  ¬∑ have h_sum_zero : ‚àë x ‚àà Finset.range 349, Œ∂349 ^ x = 0 := by
      rw [ geom_sum_eq ] <;> norm_num [ IsPrimitiveRoot.pow_eq_one ];
      ¬∑ exact Or.inl ( sub_eq_zero_of_eq <| IsCyclotomicExtension.zeta_pow 349 ‚Ñö L349 );
      ¬∑ -- By definition of Œ∂349, it is a primitive 349th root of unity, so it cannot be equal to 1.
        have h_primitive : IsPrimitiveRoot Œ∂349 349 := by
          convert IsCyclotomicExtension.zeta_spec 349 ‚Ñö L349;
        exact h_primitive.ne_one ( by decide );
    convert h_sum_zero using 1;
  ¬∑ native_decide +revert;
  ¬∑ native_decide +revert

/-
Calculate alpha squared in terms of the periods.
-/
lemma alpha_sq_eq'' : Œ±''^2 = 232 - 13*Œ∑‚ÇÄ'' + 4*Œ∑‚ÇÇ'' + 7*Œ∑‚ÇÅ'' := by
  -- By definition of Œ±'', we have Œ±'' = -(Œ∑‚ÇÇ'' - Œ∑‚ÇÅ''). Squaring both sides gives Œ±''¬≤ = (Œ∑‚ÇÇ'' - Œ∑‚ÇÅ'')¬≤.
  have h_alpha_sq : Œ±'' ^ 2 = (Œ∑‚ÇÇ'' - Œ∑‚ÇÅ'') ^ 2 := by
    unfold Œ±''; ring;
  -- Expanding the right-hand side: (Œ∑‚ÇÇ'' - Œ∑‚ÇÅ'')¬≤ = Œ∑‚ÇÇ''¬≤ - 2Œ∑‚ÇÇ''Œ∑‚ÇÅ'' + Œ∑‚ÇÅ''¬≤.
  rw [h_alpha_sq]
  have h_expand : (Œ∑‚ÇÇ'' - Œ∑‚ÇÅ'') ^ 2 = Œ∑‚ÇÇ'' ^ 2 - 2 * Œ∑‚ÇÇ'' * Œ∑‚ÇÅ'' + Œ∑‚ÇÅ'' ^ 2 := by
    ring;
  -- Substitute the multiplication rules for Gaussian periods into the expanded form.
  have h_subst : Œ∑‚ÇÇ'' ^ 2 = (if 1 = 1 then 116 else 0) + (cyc_num'' (1 - 0) (1 - 0) * Œ∑‚ÇÄ'' + cyc_num'' (1 - 1) (1 - 1) * Œ∑‚ÇÇ'' + cyc_num'' (1 - 2) (1 - 2) * Œ∑‚ÇÅ'') := by
    convert period_mul'' 1 1 using 1 ; norm_num [ period_eq_def'' ];
    ring;
  have h_subst2 : Œ∑‚ÇÅ'' ^ 2 = (if 2 = 2 then 116 else 0) + (cyc_num'' (2 - 0) (2 - 0) * Œ∑‚ÇÄ'' + cyc_num'' (2 - 1) (2 - 1) * Œ∑‚ÇÇ'' + cyc_num'' (2 - 2) (2 - 2) * Œ∑‚ÇÅ'') := by
    convert period_mul'' 2 2 using 1;
    rw [ sq, ‚Üê period_eq_def'' |>.2.2 ]
  have h_subst3 : Œ∑‚ÇÇ'' * Œ∑‚ÇÅ'' = (if 1 = 2 then 116 else 0) + (cyc_num'' (1 - 0) (2 - 0) * Œ∑‚ÇÄ'' + cyc_num'' (1 - 1) (2 - 1) * Œ∑‚ÇÇ'' + cyc_num'' (1 - 2) (2 - 2) * Œ∑‚ÇÅ'') := by
    convert period_mul'' 1 2 using 1;
  rw [ h_expand, h_subst, h_subst2, show ( 2 : L349 ) * Œ∑‚ÇÇ'' * Œ∑‚ÇÅ'' = 2 * ( Œ∑‚ÇÇ'' * Œ∑‚ÇÅ'' ) by ring, h_subst3 ] ; ring;
  rw [ show cyc_num'' 1 1 = 36 by exact cyc_num_vals''.2.2.2.2.1, show cyc_num'' 1 2 = 43 by exact cyc_num_vals''.2.2.2.2.2.1, show cyc_num'' 2 2 = 37 by exact cyc_num_vals''.2.2.2.2.2.2.2.2, show cyc_num'' 0 0 = 42 by exact cyc_num_vals''.1, show cyc_num'' 0 1 = 37 by exact cyc_num_vals''.2.1, show cyc_num'' ( -1 ) ( -1 ) = 37 by exact cyc_num_vals''.2.2.2.2.2.2.2.2, show cyc_num'' ( -1 ) 0 = 36 by exact cyc_num_vals''.2.2.2.2.2.2.1 ] ; ring;
  grind

/-
Prove the algebraic relation between beta'' and alpha''.
-/
theorem beta_relation'' : 2 * 37 * Œ≤'' = 6 * Œ±''^2 - (37 + 9) * Œ±'' - 4 * 349 := by
  rw [alpha_sq_eq'']
  have h_sum : Œ∑‚ÇÄ'' + Œ∑‚ÇÅ'' + Œ∑‚ÇÇ'' = -1 := sum_eta''
  have h_beta : Œ≤'' = -Œ∑‚ÇÄ'' + Œ∑‚ÇÇ'' := by
    rw [Œ≤'']; ring
  have h_alpha : Œ±'' = -Œ∑‚ÇÇ'' + Œ∑‚ÇÅ'' := by
    rw [Œ±'']; ring
  rw [h_beta, h_alpha]
  linear_combination 4 * h_sum

/-
Define the Galois unit and automorphism for q=349.
-/
def gal_unit349 (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 349) : (ZMod 349)À£ := Units.mk0 (N : ZMod 349) (by
  rw [Ne, ZMod.natCast_zmod_eq_zero_iff_dvd]
  intro h
  have hN_prime : Nat.Prime N := Fact.out
  have : 349 = 1 ‚à® 349 = N := (Nat.dvd_prime hN_prime).mp h
  have : 349 = N := this.resolve_left (by norm_num)
  exact hN this.symm)

def sigma349 (u : (ZMod 349)À£) : L349 ‚âÉ‚Çê[‚Ñö] L349 :=
  (IsCyclotomicExtension.autEquivPow L349 (Polynomial.cyclotomic.irreducible_rat (n := 349) (by norm_num))).symm u

/-
Multiplication table for the Gaussian periods (corrected).
-/
lemma eta_mul_table'' :
  Œ∑‚ÇÄ''^2 = 116 + 42*Œ∑‚ÇÄ'' + 36*Œ∑‚ÇÅ'' + 37*Œ∑‚ÇÇ'' ‚àß
  Œ∑‚ÇÅ''^2 = 116 + 37*Œ∑‚ÇÄ'' + 42*Œ∑‚ÇÅ'' + 36*Œ∑‚ÇÇ'' ‚àß
  Œ∑‚ÇÇ''^2 = 116 + 36*Œ∑‚ÇÄ'' + 37*Œ∑‚ÇÅ'' + 42*Œ∑‚ÇÇ'' ‚àß
  Œ∑‚ÇÄ''*Œ∑‚ÇÅ'' = 36*Œ∑‚ÇÄ'' + 37*Œ∑‚ÇÅ'' + 43*Œ∑‚ÇÇ'' ‚àß
  Œ∑‚ÇÄ''*Œ∑‚ÇÇ'' = 37*Œ∑‚ÇÄ'' + 43*Œ∑‚ÇÅ'' + 36*Œ∑‚ÇÇ'' ‚àß
  Œ∑‚ÇÅ''*Œ∑‚ÇÇ'' = 43*Œ∑‚ÇÄ'' + 36*Œ∑‚ÇÅ'' + 37*Œ∑‚ÇÇ'' := by
    -- Apply the period multiplication rule to each term in the conjunction.
    apply And.intro (by
    -- Substitute the cyclotomic numbers into the multiplication rule.
    have h_subst : period'' 0 * period'' 0 = 116 + 42 * Œ∑‚ÇÄ'' + 36 * Œ∑‚ÇÅ'' + 37 * Œ∑‚ÇÇ'' := by
      convert period_mul'' 0 0 using 1 ; norm_num [ cyc_num_vals'' ];
      rw [ show cyc_num'' ( -1 ) ( -1 ) = 37 by native_decide, show cyc_num'' ( -2 ) ( -2 ) = 36 by native_decide ] ; ring!;
    convert h_subst using 1 ; rw [ sq, period_eq_def'' |>.1 ]) (And.intro (by
    have := period_mul'' 2 2; norm_num at this ‚ä¢; (
    rw [ sq ] ; rw [ show period'' 2 = Œ∑‚ÇÅ'' from by rfl ] at this; rw [ show period'' 0 = Œ∑‚ÇÄ'' from by rfl ] at this; rw [ show period'' 1 = Œ∑‚ÇÇ'' from by rfl ] at this; rw [ show cyc_num'' 2 2 = 37 from by native_decide ] at this; rw [ show cyc_num'' 1 1 = 36 from by native_decide ] at this; rw [ show cyc_num'' 0 0 = 42 from by native_decide ] at this; linear_combination' this;);) (And.intro (by
    have := period_mul'' 1 1; simp_all +decide [ sq ] ;
    convert this using 1 ; norm_num [ cyc_num_vals'' ] ; ring!;
    erw [ show cyc_num'' ( -1 ) ( -1 ) = 37 by native_decide ] ; norm_num) (And.intro (by
    convert period_mul'' 0 2 using 1 ; norm_num [ cyc_num_vals'' ] ; ring!;
    erw [ show cyc_num'' ( -2 ) 0 = 37 by { exact by rw [ show ( -2 : ZMod 3 ) = 1 by decide ] ; exact by rw [ show cyc_num'' 1 0 = 37 by exact by native_decide ] } ] ; erw [ show cyc_num'' ( -1 ) 1 = 43 by { exact by rw [ show ( -1 : ZMod 3 ) = 2 by decide ] ; exact by rw [ show cyc_num'' 2 1 = 43 by exact by native_decide ] } ] ; norm_cast;
    simp +decide [ ZMod ]) (And.intro (by
    convert period_mul'' 0 1 using 1 ; norm_num [ cyc_num_vals'' ];
    rw [ show cyc_num'' ( -1 ) 0 = 36 by native_decide, show cyc_num'' ( -2 ) ( -1 ) = 43 by native_decide ] ; norm_num [ period_eq_def'' ] ; ring) (by
    convert period_mul'' 2 1 using 1 ; ring!;
    erw [ show cyc_num'' 2 1 = 43 by
            native_decide +revert, show cyc_num'' 0 ( -1 ) = 36 by
                                              native_decide +revert, show cyc_num'' 1 0 = 37 by
                                                                                    native_decide +revert ] ; ring!;
    simp +decide)))))

/-
Define the integer version of zeta349.
-/
def Œ∂349_int : ùìû L349 := IsPrimitiveRoot.toInteger (IsCyclotomicExtension.zeta_spec 349 ‚Ñö L349)

/-
Multiplication table for the Gaussian periods (corrected).
-/
lemma eta_mul_table_corrected'' :
  Œ∑‚ÇÄ''^2 = 116 + 42*Œ∑‚ÇÄ'' + 36*Œ∑‚ÇÅ'' + 37*Œ∑‚ÇÇ'' ‚àß
  Œ∑‚ÇÅ''^2 = 116 + 37*Œ∑‚ÇÄ'' + 42*Œ∑‚ÇÅ'' + 36*Œ∑‚ÇÇ'' ‚àß
  Œ∑‚ÇÇ''^2 = 116 + 36*Œ∑‚ÇÄ'' + 37*Œ∑‚ÇÅ'' + 42*Œ∑‚ÇÇ'' ‚àß
  Œ∑‚ÇÄ''*Œ∑‚ÇÅ'' = 36*Œ∑‚ÇÄ'' + 37*Œ∑‚ÇÅ'' + 43*Œ∑‚ÇÇ'' ‚àß
  Œ∑‚ÇÄ''*Œ∑‚ÇÇ'' = 37*Œ∑‚ÇÄ'' + 43*Œ∑‚ÇÅ'' + 36*Œ∑‚ÇÇ'' ‚àß
  Œ∑‚ÇÅ''*Œ∑‚ÇÇ'' = 43*Œ∑‚ÇÄ'' + 36*Œ∑‚ÇÅ'' + 37*Œ∑‚ÇÇ'' := by
    -- Apply the period multiplication rule to each term in the conjunction.
    apply And.intro (by
    -- Substitute the cyclotomic numbers into the multiplication rule.
    have h_subst : period'' 0 * period'' 0 = 116 + 42 * Œ∑‚ÇÄ'' + 36 * Œ∑‚ÇÅ'' + 37 * Œ∑‚ÇÇ'' := by
      convert period_mul'' 0 0 using 1 ; norm_num [ cyc_num_vals'' ];
      rw [ show cyc_num'' ( -1 ) ( -1 ) = 37 by native_decide, show cyc_num'' ( -2 ) ( -2 ) = 36 by native_decide ] ; ring!;
    convert h_subst using 1 ; rw [ sq, period_eq_def'' |>.1 ]) (And.intro (by
    have := period_mul'' 2 2; norm_num at this ‚ä¢; (
    rw [ sq ] ; rw [ show period'' 2 = Œ∑‚ÇÅ'' from by rfl ] at this; rw [ show period'' 0 = Œ∑‚ÇÄ'' from by rfl ] at this; rw [ show period'' 1 = Œ∑‚ÇÇ'' from by rfl ] at this; rw [ show cyc_num'' 2 2 = 37 from by native_decide ] at this; rw [ show cyc_num'' 1 1 = 36 from by native_decide ] at this; rw [ show cyc_num'' 0 0 = 42 from by native_decide ] at this; linear_combination' this;);) (And.intro (by
    have := period_mul'' 1 1; simp_all +decide [ sq ] ;
    convert this using 1 ; norm_num [ cyc_num_vals'' ] ; ring!;
    erw [ show cyc_num'' ( -1 ) ( -1 ) = 37 by native_decide ] ; norm_num) (And.intro (by
    convert period_mul'' 0 2 using 1 ; norm_num [ cyc_num_vals'' ] ; ring!;
    erw [ show cyc_num'' ( -2 ) 0 = 37 by { exact by rw [ show ( -2 : ZMod 3 ) = 1 by decide ] ; exact by rw [ show cyc_num'' 1 0 = 37 by exact by native_decide ] } ] ; erw [ show cyc_num'' ( -1 ) 1 = 43 by { exact by rw [ show ( -1 : ZMod 3 ) = 2 by decide ] ; exact by rw [ show cyc_num'' 2 1 = 43 by exact by native_decide ] } ] ; norm_cast;
    simp +decide [ ZMod ]) (And.intro (by
    convert period_mul'' 0 1 using 1 ; norm_num [ cyc_num_vals'' ];
    rw [ show cyc_num'' ( -1 ) 0 = 36 by native_decide, show cyc_num'' ( -2 ) ( -1 ) = 43 by native_decide ] ; norm_num [ period_eq_def'' ] ; ring) (by
    convert period_mul'' 2 1 using 1 ; ring!;
    erw [ show cyc_num'' 2 1 = 43 by
            native_decide +revert, show cyc_num'' 0 ( -1 ) = 36 by
                                              native_decide +revert, show cyc_num'' 1 0 = 37 by
                                                                                    native_decide +revert ] ; ring!;
    simp +decide)))))

/-
Define the integer versions of the periods and roots for q=349.
-/
def period_int'' (i : ZMod 3) : ùìû L349 := ‚àë x ‚àà C_coset'' i, Œ∂349_int ^ (x.val : ‚Ñï)

def Œ±''_int : ùìû L349 := -(period_int'' 1 - period_int'' 2)
def Œ≤''_int : ùìû L349 := -(period_int'' 0 - period_int'' 1)
def Œ≥''_int : ùìû L349 := -(period_int'' 2 - period_int'' 0)

/-
Prove that the integer period coerces to the field period.
-/
lemma coe_period_int'' (i : ZMod 3) : (period_int'' i : L349) = period'' i := by
  -- The algebra map is a ring homomorphism, so it preserves addition. Therefore, applying the algebra map to each term in the sum and then summing them is the same as summing the terms first and then applying the algebra map.
  have h_sum : ‚àÄ (s : Finset (ZMod 349)), (‚àë x ‚àà s, (Œ∂349_int ^ (x.val : ‚Ñï) : L349)) = (‚àë x ‚àà s, (Œ∂349 ^ (x.val : ‚Ñï) : L349)) := by
    intro s
    congr! 1;
  convert h_sum ( C_coset'' i ) using 1;
  ¬∑ unfold period_int''; aesop;
  ¬∑ exact?

/-
Prove that the integer root alpha'' coerces to the field root alpha''.
-/
lemma coe_alpha''_int : (Œ±''_int : L349) = Œ±'' := by
  -- By definition of coercion, we have that the coercion of the integer period_int'' i is equal to the field period'' i.
  have h_coe_period : ‚àÄ i : ZMod 3, (period_int'' i : L349) = period'' i := by
    exact?;
  unfold Œ±''_int Œ±''; aesop;

/-
Prove that the integer root beta'' coerces to the field root beta''.
-/
lemma coe_beta''_int : (Œ≤''_int : L349) = Œ≤'' := by
  unfold Œ≤''_int;
  convert congr_arg ( fun x : L349 => - ( Œ∑‚ÇÄ'' - x ) ) ( coe_period_int'' 1 ) using 1;
  simp +decide [ coe_period_int'' ];
  exact?

/-
Prove that the integer root gamma'' coerces to the field root gamma''.
-/
lemma coe_gamma''_int : (Œ≥''_int : L349) = Œ≥'' := by
  -- By definition of coercion, we can rewrite the goal using the definitions of Œ≥''_int and Œ≥''.
  simp [Œ≥''_int, Œ≥''];
  convert congr_arg‚ÇÇ ( ¬∑ - ¬∑ ) ( coe_period_int'' 0 ) ( coe_period_int'' 2 ) using 1

/-
Relate the index of N to the value of c'' N being s1''.
-/
lemma ind_N_eq_1_iff_c_eq_s1'' (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 349) :
  ind'' (N : ZMod 349) = 1 ‚Üî c'' N = s1'' := by
    -- By definition of $c''$, we know that $c'' N = (N : ZMod 349) ^ ((349 - 1) / 3)$.
    have hc'' : c'' N = (N : ZMod 349) ^ 116 := by
      rfl;
    convert ind_spec'' ( N : ZMod 349 ) ( show ( N : ZMod 349 ) ‚â† 0 from ?_ ) |> And.right |> And.left using 1
    generalize_proofs at *;
    ¬∑ simp +decide [ S_s1'', hc'' ];
      intro h; intro h'; simp_all +decide [ ZMod.natCast_eq_zero_iff ] ;
      exact absurd h ( by native_decide );
    ¬∑ exact?

/-
Relate the index of N to the value of c'' N being s2''.
-/
lemma ind_N_eq_2_iff_c_eq_s2'' (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 349) :
  ind'' (N : ZMod 349) = 2 ‚Üî c'' N = s2'' := by
    -- By definition of $ind''$, we know that $ind'' (N : ZMod 349) = 2$ if and only if $N \equiv N \pmod{349}$ and $ind'' N = 2$.
    simp [ind''];
    split_ifs <;> simp_all +decide [ S_cubic_res'', S_s1'', S_s2'' ];
    ¬∑ unfold c'' s2''; simp_all +decide [ ZMod.natCast_eq_zero_iff ] ;
      erw [ inv_eq_one_div, mul_one_div, eq_div_iff ] <;> norm_cast ; simp_all +decide [ ZMod.natCast_eq_zero_iff ];
      erw [ show ( q'' - 1 ) / 3 = 116 by rfl ] ; simp_all +decide [ ‚Üê ZMod.natCast_eq_zero_iff ] ;
    ¬∑ simp_all +decide [ c'' ];
      simp_all +decide [ q'' ];
      native_decide +revert;
    ¬∑ by_cases h‚ÇÉ : ( N : ZMod 349 ) = 0 <;> simp_all +decide [ ZMod.natCast_eq_zero_iff ];
      ¬∑ rw [ Nat.dvd_prime Fact.out ] at h‚ÇÉ ; aesop;
      ¬∑ -- Since $N$ is a prime not equal to $349$, $N$ is coprime with $349$, and thus $N^{116} \equiv 1 \pmod{349}$.
        have h_order : (N : ZMod 349) ^ 348 = 1 := by
          have h_order : Nat.gcd N 349 = 1 := by
            exact Nat.Coprime.symm ( Nat.Prime.coprime_iff_not_dvd ( by norm_num ) |>.2 h‚ÇÉ );
          simpa [ ‚Üê ZMod.natCast_eq_natCast_iff ] using Nat.ModEq.pow_totient h_order;
        simp_all +decide [ show ( N : ZMod 349 ) ^ 348 = ( N ^ 116 ) ^ 3 by ring ];
        have h_order : ‚àÄ x : ZMod 349, x ^ 3 = 1 ‚Üí x = 1 ‚à® x = s1'' ‚à® x = s2'' := by
          native_decide;
        cases h_order _ ‚Äπ_‚Ä∫ <;> aesop

/-
Abbreviations for the ring of integers, residue field, and reduction map for q=349.
-/
abbrev ùìûL349 := ùìû L349
def kP349 (P : Ideal ùìûL349) [P.IsMaximal] := ùìûL349 ‚ß∏ P
noncomputable instance (P : Ideal ùìûL349) [P.IsMaximal] : Field (kP349 P) := Ideal.Quotient.field P
def red349 (P : Ideal ùìûL349) [P.IsMaximal] : ùìûL349 ‚Üí+* kP349 P := Ideal.Quotient.mk P

/-
Lift the automorphism sigma349 to the ring of integers.
-/
def sigma_int349 (u : (ZMod 349)À£) (x : ùìû L349) : ùìû L349 := ‚ü®sigma349 u x, by
  have h_integral : IsIntegral ‚Ñ§ (x : L349) := x.2
  exact IsIntegral.map (sigma349 u) h_integral‚ü©

/-
The ring of integers is generated by zeta349.
-/
lemma adjoin_zeta_eq_top349 : Algebra.adjoin ‚Ñ§ ({Œ∂349_int} : Set ùìûL349) = ‚ä§ := by
  have h_adjoin : IsPrimitiveRoot Œ∂349_int 349 := by
    have h_primitive : IsPrimitiveRoot (IsCyclotomicExtension.zeta 349 ‚Ñö L349) 349 := by
      convert IsCyclotomicExtension.zeta_spec 349 ‚Ñö L349;
    convert h_primitive using 1;
    ext; simp +decide [ IsPrimitiveRoot.iff_def ] ;
    constructor <;> rintro ‚ü® h‚ÇÅ, h‚ÇÇ ‚ü© <;> refine' ‚ü® _, _ ‚ü© <;> norm_cast at *;
    ¬∑ exact?;
    ¬∑ intro l hl; specialize h‚ÇÇ l; aesop;
    ¬∑ erw [ ‚Üê Subtype.coe_inj ] ; norm_num [ IsCyclotomicExtension.zeta ];
      exact?;
    ¬∑ intro l hl; specialize h‚ÇÇ l; simp_all +decide [ ‚Üê Subtype.coe_inj ] ;
      convert h‚ÇÇ _;
      convert congr_arg ( algebraMap (ùìû L349) L349 ) hl using 1;
  have h_adjoin : IsCyclotomicExtension {349} ‚Ñ§ (ùìû L349) := by
    convert IsCyclotomicExtension.zeta_spec 349 ‚Ñ§ (ùìû L349) using 1
    generalize_proofs at *; (
    exact iff_of_true ‚Äπ_‚Ä∫ ( by exact? ))
  generalize_proofs at *; (
  convert h_adjoin.adjoin_primitive_root_eq_top _;
  assumption)

/-
The automorphism sigma_N reduces to the Frobenius map modulo P.
-/
theorem artin_property349 {N : ‚Ñï} [Fact (Nat.Prime N)] (hN : N ‚â† 349) (P : Ideal ùìûL349) [P.IsMaximal] [CharP (kP349 P) N] (x : ùìûL349) :
  red349 P (sigma_int349 (gal_unit349 N hN) x) = (red349 P x) ^ N := by
    have h_frobenius : ‚àÄ (x : ùìûL349), (red349 P) (sigma_int349 (gal_unit349 N hN) x) = (red349 P x) ^ N := by
      intro x
      have h_gen : ‚àÄ y : ùìûL349, y ‚àà Algebra.adjoin ‚Ñ§ ({Œ∂349_int} : Set ùìûL349) := by
        exact fun y => by rw [ adjoin_zeta_eq_top349 ] ; exact Algebra.mem_top;
      refine' Algebra.adjoin_induction _ _ _ _ ( h_gen x );
      ¬∑ -- By definition of sigma_int349, we have sigma_int349 (gal_unit349 N hN) Œ∂349_int = Œ∂349_int^N.
        have h_sigma_zeta : sigma_int349 (gal_unit349 N hN) Œ∂349_int = Œ∂349_int ^ N := by
          unfold sigma_int349;
          unfold sigma349 gal_unit349;
          erw [ Subtype.mk_eq_mk ];
          simp +decide [ IsCyclotomicExtension.autEquivPow ];
          erw [ PowerBasis.equivOfMinpoly_gen ];
          simp +decide [ IsPrimitiveRoot.powerBasis ];
          erw [ ‚Üê Nat.mod_add_div N 349 ] ; norm_num [ pow_add, pow_mul ];
          erw [ show ( Œ∂349_int : L349 ) ^ 349 = 1 from ?_ ] ; aesop;
          convert IsPrimitiveRoot.pow_eq_one ( IsCyclotomicExtension.zeta_spec 349 ‚Ñö L349 ) using 1;
        aesop;
      ¬∑ intro r
        simp [sigma_int349];
        have h_frobenius : ‚àÄ (r : ‚Ñ§), (red349 P) (algebraMap ‚Ñ§ (ùìûL349) r) = (r : kP349 P) ^ N := by
          intro r; exact (by
          have h_frobenius : ‚àÄ (r : ‚Ñ§), (red349 P) (algebraMap ‚Ñ§ (ùìûL349) r) = (r : kP349 P) := by
            exact?;
          rw [ h_frobenius, eq_comm ];
          have h_frobenius : ‚àÄ (r : ZMod N), r ^ N = r := by
            exact fun r => by rw [ ZMod.pow_card ] ;
          convert h_frobenius ( r : ZMod N ) using 1;
          norm_cast;
          erw [ ZMod.intCast_eq_intCast_iff ];
          exact?);
        convert h_frobenius r using 1;
      ¬∑ intro x y hx hy hx' hy'; simp_all +decide [ ‚Üê map_mul, ‚Üê map_add ] ;
        convert congr_arg‚ÇÇ ( ¬∑ + ¬∑ ) hx' hy' using 1 <;> ring;
        ¬∑ convert map_add _ _ _ using 1;
          rotate_left 1;
          exact inferInstance;
          ¬∑ infer_instance;
          ¬∑ unfold sigma_int349; aesop;
        ¬∑ rw [ ‚Üê add_pow_char ];
          rw [ map_add ];
      ¬∑ simp +contextual [ *, mul_pow ];
        intro x y hx hy; rw [ ‚Üê hx, ‚Üê hy ] ; simp +decide [ ‚Üê map_mul ] ;
        unfold sigma_int349; aesop;
    exact h_frobenius x

/-
The Frobenius automorphism permutes the Gaussian periods by shifting their index by ind(N).
-/
lemma sigma_period'' (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 349) (i : ZMod 3) :
  sigma349 (gal_unit349 N hN) (period'' i) = period'' (i + ind'' (N : ZMod 349)) := by
    -- By definition of the automorphism, it permutes the Gaussian periods by shifting their index by ind(N).
    have h_aut_perm : ‚àÄ x : ZMod 349, x ‚â† 0 ‚Üí sigma349 (gal_unit349 N hN) (Œ∂349 ^ (x.val : ‚Ñï)) = Œ∂349 ^ ((x * N : ZMod 349).val : ‚Ñï) := by
      intro x hx_ne_zero
      have h_sigma_zeta : sigma349 (gal_unit349 N hN) (Œ∂349) = Œ∂349 ^ (N : ZMod 349).val := by
        have h_sigma_zeta : ‚àÄ u : (ZMod 349)À£, (IsCyclotomicExtension.autEquivPow L349 (Polynomial.cyclotomic.irreducible_rat (n := 349) (by norm_num))).symm u (IsCyclotomicExtension.zeta 349 ‚Ñö L349) = (IsCyclotomicExtension.zeta 349 ‚Ñö L349) ^ (u.val.val : ‚Ñï) := by
          intro u
          simp [IsCyclotomicExtension.autEquivPow];
          rw [ PowerBasis.equivOfMinpoly_apply ];
          convert ( IsPrimitiveRoot.powerBasis ‚Ñö ( show IsPrimitiveRoot ( IsCyclotomicExtension.zeta 349 ‚Ñö L349 ) 349 from ?_ ) ).lift_gen _ _ using 1;
          exact?;
        convert h_sigma_zeta ( gal_unit349 N hN ) using 1;
      convert congr_arg ( ¬∑ ^ x.val ) h_sigma_zeta using 1 <;> norm_num [ pow_mul', mul_comm ];
      rw [ ‚Üê pow_mul, mul_comm, ZMod.val_mul ];
      rw [ ‚Üê Nat.mod_add_div ( N % 349 * x.val ) 349, pow_add, pow_mul ] ; norm_num [ pow_mul, pow_succ ];
      have h_zeta_order : Œ∂349 ^ 349 = 1 := by
        exact IsPrimitiveRoot.pow_eq_one ( IsCyclotomicExtension.zeta_spec 349 ‚Ñö L349 );
      simp_all +decide [ pow_succ, mul_assoc ];
    -- By definition of the automorphism, it permutes the Gaussian periods by shifting their index by ind(N). Hence, we can rewrite the sum.
    have h_sum_perm : ‚àë x ‚àà C_coset'' i, sigma349 (gal_unit349 N hN) (Œ∂349 ^ (x.val : ‚Ñï)) = ‚àë x ‚àà C_coset'' (i + ind'' (N : ZMod 349)), Œ∂349 ^ (x.val : ‚Ñï) := by
      apply Finset.sum_bij (fun x hx => (x * N : ZMod 349));
      ¬∑ intro x hx
        simp [C_coset''] at hx ‚ä¢
        generalize_proofs at *;
        have h_ind_mul : ‚àÄ x y : ZMod 349, x ‚â† 0 ‚Üí y ‚â† 0 ‚Üí ind'' (x * y) = ind'' x + ind'' y := by
          exact?
        generalize_proofs at *; (
        have hN_ne_zero : (N : ZMod 349) ‚â† 0 := by
          exact?
        generalize_proofs at *; (
        exact ‚ü® ‚ü® hx.1, hN_ne_zero ‚ü©, by rw [ h_ind_mul x N hx.1 hN_ne_zero, hx.2 ] ‚ü©));
      ¬∑ intro a‚ÇÅ ha‚ÇÅ a‚ÇÇ ha‚ÇÇ h_eq
        have h_inv : (N : ZMod 349) ‚â† 0 := by
          exact?
        have h_inv_mul : (a‚ÇÅ : ZMod 349) = (a‚ÇÇ : ZMod 349) := by
          haveI := Fact.mk ( by norm_num : Nat.Prime 349 ) ; exact mul_right_cancel‚ÇÄ h_inv h_eq;
        exact h_inv_mul;
      ¬∑ intro b hb
        use b * (N : ZMod 349)‚Åª¬π;
        have h_inv : (N : ZMod 349) ‚â† 0 := by
          exact?;
        have h_ind : ind'' (b * (N : ZMod 349)‚Åª¬π) = ind'' b - ind'' (N : ZMod 349) := by
          have h_ind : ind'' (b * (N : ZMod 349)‚Åª¬π) = ind'' b + ind'' ((N : ZMod 349)‚Åª¬π) := by
            apply ind_mul'';
            ¬∑ exact Finset.mem_filter.mp hb |>.2.1;
            ¬∑ haveI := Fact.mk ( by norm_num : Nat.Prime 349 ) ; exact inv_ne_zero h_inv;
          have h_ind_inv : ind'' ((N : ZMod 349)‚Åª¬π) = -ind'' (N : ZMod 349) := by
            exact?;
          rw [h_ind, h_ind_inv]
          ring;
        unfold C_coset'' at *; aesop;
      ¬∑ exact fun x hx => h_aut_perm x <| Finset.mem_filter.mp hx |>.2.1;
    convert h_sum_perm using 1;
    ¬∑ rw [ period_eq_sum_C_coset'' ];
      rw [ map_sum ];
    ¬∑ exact?

/-
If c'' N = s1'', then sigma_N(alpha'') = gamma''.
-/
lemma sigma_alpha_eq_gamma_if_s1'' (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 349) (h : c'' N = s1'') :
  sigma_int349 (gal_unit349 N hN) Œ±''_int = Œ≥''_int := by
    have h_sigma_period : sigma349 (gal_unit349 N hN) Œ±'' = Œ≥'' := by
      have h_sigma_period : sigma349 (gal_unit349 N hN) (period'' 1) = period'' 2 ‚àß sigma349 (gal_unit349 N hN) (period'' 2) = period'' 0 ‚àß sigma349 (gal_unit349 N hN) (period'' 0) = period'' 1 := by
        have h_sigma_period : sigma349 (gal_unit349 N hN) (period'' 1) = period'' (1 + ind'' (N : ZMod 349)) ‚àß sigma349 (gal_unit349 N hN) (period'' 2) = period'' (2 + ind'' (N : ZMod 349)) ‚àß sigma349 (gal_unit349 N hN) (period'' 0) = period'' (0 + ind'' (N : ZMod 349)) := by
          exact ‚ü® sigma_period'' N hN 1, sigma_period'' N hN 2, sigma_period'' N hN 0 ‚ü©;
        have h_ind : ind'' (N : ZMod 349) = 1 := by
          exact?;
        simp_all +decide [ ZMod ];
      convert congr_arg‚ÇÇ ( fun x y : L349 => - ( x - y ) ) h_sigma_period.1 h_sigma_period.2.1 using 1;
      rw [ show Œ±'' = - ( period'' 1 - period'' 2 ) by rfl ] ; norm_num;
    refine' Subtype.ext _;
    convert h_sigma_period using 1;
    ¬∑ convert congr_arg ( sigma349 ( gal_unit349 N hN ) ) ( coe_alpha''_int ) using 1;
    ¬∑ exact coe_gamma''_int

/-
If c'' N = s2'', then sigma_N(alpha'') = beta''.
-/
lemma sigma_alpha_eq_beta_if_s2'' (N : ‚Ñï) [Fact (Nat.Prime N)] (hN : N ‚â† 349) (h : c'' N = s2'') :
  sigma_int349 (gal_unit349 N hN) Œ±''_int = Œ≤''_int := by
    -- By definition of $c''$, we know that $c'' N = s2''$ implies $ind'' (N : ZMod 349) = 2$.
    have h_ind_N_eq_2 : ind'' (N : ZMod 349) = 2 := by
      exact?;
    -- By definition of $sigma_int349$, we know that $sigma_int349 (gal_unit349 N hN) (Œ±''_int) = œÉ_N (Œ±''_int)$.
    have h_sigma_int349_alpha : sigma_int349 (gal_unit349 N hN) Œ±''_int = - (sigma_int349 (gal_unit349 N hN) (period_int'' 1) - sigma_int349 (gal_unit349 N hN) (period_int'' 2)) := by
      unfold sigma_int349 Œ±''_int; norm_num;
      exact?;
    -- By definition of $sigma_int349$, we know that $sigma_int349 (gal_unit349 N hN) (period_int'' i) = period_int'' (i + ind'' (N : ZMod 349))$.
    have h_sigma_int349_period : ‚àÄ i : ZMod 3, sigma_int349 (gal_unit349 N hN) (period_int'' i) = period_int'' (i + ind'' (N : ZMod 349)) := by
      intro i
      have h_sigma_int349_period_i : sigma_int349 (gal_unit349 N hN) (period_int'' i) = sigma349 (gal_unit349 N hN) (period'' i) := by
        exact congr_arg ( fun x : L349 => x ) ( coe_period_int'' i ) ‚ñ∏ rfl;
      have h_sigma_int349_period_i : sigma349 (gal_unit349 N hN) (period'' i) = period'' (i + ind'' (N : ZMod 349)) := by
        exact?;
      have h_sigma_int349_period_i : period'' (i + ind'' (N : ZMod 349)) = (period_int'' (i + ind'' (N : ZMod 349)) : L349) := by
        convert coe_period_int'' ( i + ind'' ( N : ZMod 349 ) ) |> Eq.symm using 1;
      exact Subtype.ext <| by aesop;
    simp_all +decide [ ZMod ];
    unfold Œ≤''_int; ring;

/-
Final result for q=349: Frobenius action on alpha'' depends on c'' N.
-/
theorem final_result_349 {N : ‚Ñï} [Fact (Nat.Prime N)] (hN : N ‚â† 349) (P : Ideal ùìûL349) [P.IsMaximal] [CharP (kP349 P) N] :
  (c'' N = s1'' ‚Üí (red349 P Œ±''_int) ^ N = red349 P Œ≥''_int) ‚àß
  (c'' N = s2'' ‚Üí (red349 P Œ±''_int) ^ N = red349 P Œ≤''_int) := by
    apply And.intro;
    ¬∑ intro h
      have h_sigma : sigma_int349 (gal_unit349 N hN) Œ±''_int = Œ≥''_int := by
        convert sigma_alpha_eq_gamma_if_s1'' N hN h using 1;
      rw [ ‚Üê h_sigma, artin_property349 ];
    ¬∑ -- Apply the artin property349 theorem to get the reduction.
      have h_reduction : red349 P (sigma_int349 (gal_unit349 N hN) Œ±''_int) = (red349 P Œ±''_int) ^ N := by
        convert artin_property349 hN P Œ±''_int using 1;
      intro h; rw [ ‚Üê h_reduction, sigma_alpha_eq_beta_if_s2'' N hN h ] ;

/-
Define the polynomial f'' = X^3 - 349X - 349.
-/
def f_poly'' : Polynomial L349 := X^3 - 349*X - 349

/-
Prove that alpha'' is a root of f''.
-/
theorem alpha_root'' : (f_poly'').eval Œ±'' = 0 := by
  -- By definition of $f_poly''$, we know that $f_poly''.eval Œ±'' = Œ±''^3 - 349 * Œ±'' - 349$.
  simp [f_poly''];
  field_simp;
  rw [ show Œ±'' ^ 2 = 232 - 13 * Œ∑‚ÇÄ'' + 4 * Œ∑‚ÇÇ'' + 7 * Œ∑‚ÇÅ'' from ?_, show Œ∑‚ÇÄ'' = -1 - Œ∑‚ÇÅ'' - Œ∑‚ÇÇ'' from ?_ ] <;> ring;
  ¬∑ rw [ show Œ±'' = - ( Œ∑‚ÇÇ'' - Œ∑‚ÇÅ'' ) by rfl ] ; ring;
    rw [ show Œ∑‚ÇÇ'' ^ 2 = 116 + 36 * Œ∑‚ÇÄ'' + 37 * Œ∑‚ÇÅ'' + 42 * Œ∑‚ÇÇ'' by
          convert eta_mul_table''.2.2.1 using 1, show Œ∑‚ÇÅ'' ^ 2 = 116 + 37 * Œ∑‚ÇÄ'' + 42 * Œ∑‚ÇÅ'' + 36 * Œ∑‚ÇÇ'' by
                                                                            -- Apply the lemma eta_mul_table'' to conclude the proof.
                                                                            apply (eta_mul_table'' |>.2.1), show Œ∑‚ÇÇ'' * Œ∑‚ÇÅ'' = 43 * Œ∑‚ÇÄ'' + 36 * Œ∑‚ÇÅ'' + 37 * Œ∑‚ÇÇ'' by
                                                                                                                                              exact eta_mul_table_corrected''.2.2.2.2.2.symm ‚ñ∏ by ring; ] ; ring;
    -- By definition of Œ∑‚ÇÄ'', Œ∑‚ÇÅ'', and Œ∑‚ÇÇ'', we know that their sum is -1.
    have h_sum : Œ∑‚ÇÄ'' + Œ∑‚ÇÅ'' + Œ∑‚ÇÇ'' = -1 := by
      exact?;
    linear_combination -h_sum;
  ¬∑ exact eq_add_of_sub_eq' ( by linear_combination' sum_eta'' );
  ¬∑ convert alpha_sq_eq'' using 1 ; ring!

/-
Check if f_poly'' is defined.
-/
#check f_poly''

/-
Check if the main declarations are present.
-/
#check f_poly''
#check Œ±''
#check alpha_root''
#check final_result_349

/-
Prove that alpha'' is a root of f''.
-/
theorem alpha_is_root_of_f : (f_poly'').eval Œ±'' = 0 := by
  -- Substitute Œ±'' into the polynomial f_poly'' and simplify using the known relation.
  convert alpha_root'' using 1
