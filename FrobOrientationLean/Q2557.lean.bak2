/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 09c6fcf1-c272-437d-b08b-ba85a0b8938c

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
This module defines the setting for the Dream Theorem for q = 2557, including the cyclotomic field, Gaussian periods, and auxiliary constants. It assumes the period equation and the explicit Frobenius action, and proves the Dream Theorem: for a prime N != 2557, the Frobenius automorphism maps alpha to gamma if c(N) = s1, and to beta if c(N) = s2.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: a986ec6a-782b-41cf-b32c-50f4ca257d0a

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 05842171-08bb-4be0-b8d7-b674af6fb530

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: e6ee589a-f550-42ef-89e5-1fd2afd7fa5e

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We defined the constants s1, s2, and the value c(N). We proved lemmas characterizing the cosets C1 and C2 in terms of the 12th power residue symbol (which relates to c(N)). Finally, we proved the main theorem `final_result` which establishes the Frobenius action on alpha (i.e., alpha^N) in terms of beta and gamma, depending on the value of c(N). The proof utilizes the `explicit_frobenius` theorem and the algebraic relations between alpha, beta, and gamma.
-/

/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 939f55fb-68a7-4ef0-bca3-475f675055ca

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
This module formalizes the proof of the Frobenius Orientation conjecture for q=37.
It defines the cyclotomic field K = Q(zeta_37), the Gaussian periods, and the cubic roots.
It proves the cyclic algebraic relations between these roots and establishes the global Galois action.
It descends to the residue field modulo a prime P lying over N != 37, proving the Artin property.
Finally, it derives the explicit Frobenius action on the reduction of alpha modulo P.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Let L = Q(zeta_37) be the 37th cyclotomic field.
-/
abbrev K := CyclotomicField 37 ℚ

/-
zeta is the primitive 37th root of unity in K.
-/
noncomputable def zeta : K := IsCyclotomicExtension.zeta 37 ℚ K

/-
H is the subgroup of cubic residues modulo 37.
-/
def H : Finset (ZMod 37) := ((Finset.univ : Finset (ZMod 37)).filter (fun x => x ≠ 0)).image (fun x => x^3)

/-
g = 2 is a primitive root modulo 37.
-/
def g : ZMod 37 := 2

/-
C1 is the coset of H with index 1.
-/
def C1 : Finset (ZMod 37) := H.image (fun x => g * x)

/-
C2 is the coset of H with index 2.
-/
def C2 : Finset (ZMod 37) := H.image (fun x => g^2 * x)

/-
Open BigOperators for sum notation.
-/
open BigOperators

/-
The Gaussian period for a set S is the sum of zeta^x for x in S.
-/
noncomputable def eta (S : Finset (ZMod 37)) : K := ∑ x ∈ S, zeta^(x.val)

/-
Define the three Gaussian periods eta_0, eta_1, eta_2.
-/
noncomputable def eta_0 := eta H
noncomputable def eta_1 := eta C1
noncomputable def eta_2 := eta C2

/-
Define the roots alpha, beta, gamma.
-/
noncomputable def alpha := eta_2 - eta_1
noncomputable def beta := eta_0 - eta_2
noncomputable def gamma := eta_1 - eta_0

/-
The non-zero elements of ZMod 37 are the disjoint union of H, C1, and C2.
-/
lemma units_decomp :
  let units := (Finset.univ : Finset (ZMod 37)).filter (fun x => x ≠ 0)
  units = H ∪ C1 ∪ C2 ∧
  Disjoint H C1 ∧ Disjoint H C2 ∧ Disjoint C1 C2 := by
    native_decide

/-
The sum of zeta^x for all non-zero x is -1.
-/
lemma sum_zeta_units :
  let units := (Finset.univ : Finset (ZMod 37)).filter (fun x => x ≠ 0)
  ∑ x ∈ units, zeta^(x.val) = -1 := by
    -- Since $zeta$ is a primitive 37th root of unity, we know that $\sum_{x=0}^{36} zeta^x = 0$.
    have h_sum_zero : ∑ x ∈ Finset.range 37, zeta ^ x = 0 := by
      rw [ geom_sum_eq ] <;> norm_num [ zeta ];
      · exact Or.inl ( sub_eq_zero_of_eq <| by exact IsCyclotomicExtension.zeta_pow 37 ℚ K );
      · have h_order : orderOf (IsCyclotomicExtension.zeta 37 ℚ K) = 37 := by
          rw [ orderOf_eq_of_pow_and_pow_div_prime ] <;> norm_num;
          · exact IsCyclotomicExtension.zeta_pow 37 ℚ K;
          · intro p pp dp; have := Nat.le_of_dvd ( by decide ) dp; interval_cases p <;> norm_num at *;
            have h_order : IsPrimitiveRoot (IsCyclotomicExtension.zeta 37 ℚ K) 37 := by
              exact?;
            exact h_order.ne_one ( by decide );
        aesop;
    simp_all +decide [ Finset.sum_range, ZMod, Fin.sum_univ_succ ];
    simp_all +decide [ Fin.sum_univ_succ, Finset.sum_filter, ZMod.val ];
    linear_combination' h_sum_zero

/-
The sum of the three Gaussian periods is -1.
-/
lemma sum_eta_eq_minus_one : eta_0 + eta_1 + eta_2 = -1 := by
  -- Using the decomposition of the units into H, C1, and C2, we can split the sum into three parts.
  have h_split : ∑ x ∈ (Finset.univ : Finset (ZMod 37)).filter (fun x => x ≠ 0), zeta^(x.val) = ∑ x ∈ H, zeta^(x.val) + ∑ x ∈ C1, zeta^(x.val) + ∑ x ∈ C2, zeta^(x.val) := by
    rw [ ← Finset.sum_union, ← Finset.sum_union ];
    · rw [ ← units_decomp.1 ];
    · decide +revert;
    · native_decide +revert;
  convert sum_zeta_units using 1 ; aesop

/-
Explicit enumeration of the cosets H, C1, C2.
-/
lemma H_explicit : H = {1, 6, 8, 10, 11, 14, 23, 26, 27, 29, 31, 36} := by
  native_decide
lemma C1_explicit : C1 = {2, 9, 12, 15, 16, 17, 20, 21, 22, 25, 28, 35} := by
  native_decide
lemma C2_explicit : C2 = {3, 4, 5, 7, 13, 18, 19, 24, 30, 32, 33, 34} := by
  native_decide +revert

/-
The algebraic relation 11β = 3α² - 10α - 74 holds.
-/
theorem relation_beta : 11 * beta = 3 * alpha^2 - 10 * alpha - 74 := by
  -- Let's simplify the left-hand side of the equation.
  simp +decide only [alpha, beta] at *; (
  -- By definition of eta, we can expand the left-hand side and right-hand side of the equation.
  have h_expand : 11 * (∑ x ∈ ({1, 6, 8, 10, 11, 14, 23, 26, 27, 29, 31, 36} : Finset (ZMod 37)), zeta^(x.val) - ∑ x ∈ ({3, 4, 5, 7, 13, 18, 19, 24, 30, 32, 33, 34} : Finset (ZMod 37)), zeta^(x.val)) =
                (∑ x ∈ ({3, 4, 5, 7, 13, 18, 19, 24, 30, 32, 33, 34} : Finset (ZMod 37)), zeta^(x.val) - ∑ x ∈ ({2, 9, 12, 15, 16, 17, 20, 21, 22, 25, 28, 35} : Finset (ZMod 37)), zeta^(x.val)) *
                ((∑ x ∈ ({3, 4, 5, 7, 13, 18, 19, 24, 30, 32, 33, 34} : Finset (ZMod 37)), zeta^(x.val) - ∑ x ∈ ({2, 9, 12, 15, 16, 17, 20, 21, 22, 25, 28, 35} : Finset (ZMod 37)), zeta^(x.val)) * 3 - 10) - 74 := by
                  -- By definition of $zeta$, we know that $zeta^{37} = 1$ and $zeta^k \neq 1$ for $1 \leq k < 37$.
                  have h_zeta_prop : zeta ^ 37 = 1 ∧ ∀ k : ℕ, 1 ≤ k → k < 37 → zeta ^ k ≠ 1 := by
                    have h_zeta_prop : zeta ^ 37 = 1 := by
                      convert IsCyclotomicExtension.zeta_pow 37 ℚ K using 1;
                    have h_zeta_order : IsPrimitiveRoot zeta 37 := by
                      convert IsCyclotomicExtension.zeta_spec 37 ℚ K using 1;
                    exact ⟨ h_zeta_prop, fun k hk₁ hk₂ hk₃ => by have := h_zeta_order.pow_eq_one_iff_dvd k; interval_cases k <;> simp_all +decide ⟩;
                  simp_all +decide [ ZMod.val ];
                  grind +ring;
  convert h_expand using 1;
  · congr! 2;
    · exact H_explicit ▸ rfl;
    · exact C2_explicit ▸ rfl;
  · unfold eta_1 eta_2;
    unfold eta C1 C2; simp +decide ;
    rw [ show ( Finset.image ( fun x : ZMod 37 => g ^ 2 * x ) H : Finset ( ZMod 37 ) ) = { 3, 4, 5, 7, 13, 18, 19, 24, 30, 32, 33, 34 } from ?_, show ( Finset.image ( fun x : ZMod 37 => g * x ) H : Finset ( ZMod 37 ) ) = { 2, 9, 12, 15, 16, 17, 20, 21, 22, 25, 28, 35 } from ?_ ] ; simp +decide [ Finset.sum ] ; ring!;
    · native_decide +revert;
    · native_decide +revert);

/-
The algebraic relation 11γ = -3α² - α + 74 holds.
-/
theorem relation_gamma : 11 * gamma = -3 * alpha^2 - alpha + 74 := by
  have h_gamma : 11 * gamma = 11 * (eta_1 - eta_0) := by
    rfl
  have h_alpha : 11 * alpha = 11 * (eta_2 - eta_1) := by
    rfl
  have h_beta : 11 * beta = 11 * (eta_0 - eta_2) := by
    rfl
  have h_sum : eta_0 + eta_1 + eta_2 = -1 := by
    exact?
  have h_beta_eq : 11 * beta = 3 * alpha^2 - 10 * alpha - 74 := by
    convert relation_beta using 1
  have h_gamma_eq : 11 * gamma = -3 * alpha^2 - alpha + 74 := by
    grind
  exact h_gamma_eq.symm ▸ by ring;

/-
Checking availability of necessary theorems.
-/
#check Polynomial.cyclotomic.irreducible_rat
#check IsCyclotomicExtension.autEquivPow

/-
The 37th cyclotomic polynomial is irreducible over Q.
-/
theorem h_irr : Irreducible (Polynomial.cyclotomic 37 ℚ) := Polynomial.cyclotomic.irreducible_rat (by norm_num)

/-
sigma n is the Galois automorphism mapping zeta to zeta^n.
-/
noncomputable def sigma (n : (ZMod 37)ˣ) : K ≃ₐ[ℚ] K := (IsCyclotomicExtension.autEquivPow K h_irr).symm n

/-
sigma n maps zeta to zeta^n.
-/
theorem sigma_zeta (n : (ZMod 37)ˣ) : sigma n zeta = zeta^(n : ZMod 37).val := by
  -- By definition of automorphisms in the Galois group, $\sigma_n$ maps $zeta$ to $zeta^n$.
  have h_sigma_zeta : ∀ n : (ZMod 37)ˣ, (sigma n) zeta = zeta^(n.val.val) := by
    intro n
    simp [sigma];
    erw [ PowerBasis.equivOfMinpoly_apply ];
    erw [ PowerBasis.lift_gen ];
    exact?;
  exact h_sigma_zeta n

/-
The action of sigma n on alpha is determined by the cubic character of n.
-/
theorem global_permutation (n : (ZMod 37)ˣ) :
  ((n : ZMod 37) ∈ C1 → sigma n alpha = beta) ∧
  ((n : ZMod 37) ∈ C2 → sigma n alpha = gamma) ∧
  ((n : ZMod 37) ∈ H → sigma n alpha = alpha) := by
    -- Let's simplify the goal using the definitions of $C1$, $C2$, and $H$.
    suffices h_simp : ∀ n : (ZMod 37)ˣ, (n.val ∈ C1 → sigma n eta_0 = eta_1 ∧ sigma n eta_1 = eta_2 ∧ sigma n eta_2 = eta_0) ∧ (n.val ∈ C2 → sigma n eta_0 = eta_2 ∧ sigma n eta_1 = eta_0 ∧ sigma n eta_2 = eta_1) ∧ (n.val ∈ H → sigma n eta_0 = eta_0 ∧ sigma n eta_1 = eta_1 ∧ sigma n eta_2 = eta_2) by
      unfold alpha beta gamma; aesop;
    -- By definition of $sigma$, we know that $sigma n (zeta^x) = zeta^{n.val * x}$ for any $x \in \mathbb{Z}/37\mathbb{Z}$.
    have h_sigma_exp : ∀ n : (ZMod 37)ˣ, ∀ x : ZMod 37, (sigma n) (zeta^(x.val)) = zeta^((n.val * x).val) := by
      intro n x; exact (by
      convert congr_arg ( · ^ x.val ) ( sigma_zeta n ) using 1 ; norm_num [ pow_mul ];
      rw [ ← pow_mul, ZMod.val_mul ];
      -- Since $zeta$ is a primitive $37$th root of unity, we have $zeta^{37} = 1$.
      have h_zeta_37 : zeta ^ 37 = 1 := by
        convert IsCyclotomicExtension.zeta_pow 37 ℚ K;
      rw [ ← Nat.mod_add_div ( ( n : ZMod 37 ).val * x.val ) 37, pow_add, pow_mul ] ; aesop);
    -- Apply the definition of $sigma$ to each term in the sum.
    have h_sigma_sum : ∀ n : (ZMod 37)ˣ, ∀ S : Finset (ZMod 37), (sigma n) (∑ x ∈ S, zeta^(x.val)) = ∑ x ∈ S, zeta^((n.val * x).val) := by
      exact fun n S => by rw [ map_sum, Finset.sum_congr rfl fun x hx => h_sigma_exp n x ] ;
    intro n
    simp [h_sigma_sum, eta_0, eta_1, eta_2];
    unfold eta; simp +decide [ h_sigma_sum ] ;
    -- By definition of $C1$, $C2$, and $H$, we can rewrite the sums accordingly.
    have h_cosets : ∀ n : (ZMod 37)ˣ, (n.val ∈ C1 → Finset.image (fun x => (n.val * x : ZMod 37)) H = C1 ∧ Finset.image (fun x => (n.val * x : ZMod 37)) C1 = C2 ∧ Finset.image (fun x => (n.val * x : ZMod 37)) C2 = H) ∧ (n.val ∈ C2 → Finset.image (fun x => (n.val * x : ZMod 37)) H = C2 ∧ Finset.image (fun x => (n.val * x : ZMod 37)) C1 = H ∧ Finset.image (fun x => (n.val * x : ZMod 37)) C2 = C1) ∧ (n.val ∈ H → Finset.image (fun x => (n.val * x : ZMod 37)) H = H ∧ Finset.image (fun x => (n.val * x : ZMod 37)) C1 = C1 ∧ Finset.image (fun x => (n.val * x : ZMod 37)) C2 = C2) := by
      native_decide +revert;
    refine' ⟨ fun hn => _, fun hn => _, fun hn => _ ⟩;
    · have := h_cosets n |>.1 hn;
      exact ⟨ by rw [ ← this.1, Finset.sum_image ( Finset.card_image_iff.mp <| by simp +decide [ this ] ) ], by rw [ ← this.2.1, Finset.sum_image ( Finset.card_image_iff.mp <| by simp +decide [ this ] ) ], by rw [ ← this.2.2, Finset.sum_image ( Finset.card_image_iff.mp <| by simp +decide [ this ] ) ] ⟩;
    · have := h_cosets n |>.2.1 hn;
      exact ⟨ by rw [ ← this.1, Finset.sum_image ( Finset.card_image_iff.mp <| by simp +decide [ this ] ) ], by rw [ ← this.2.1, Finset.sum_image ( Finset.card_image_iff.mp <| by simp +decide [ this ] ) ], by rw [ ← this.2.2, Finset.sum_image ( Finset.card_image_iff.mp <| by simp +decide [ this ] ) ] ⟩;
    · have := h_cosets n |>.2.2 hn; simp_all +decide [ Finset.sum_image ] ;
      refine' ⟨ _, _, _ ⟩;
      · conv_rhs => rw [ ← this.1, Finset.sum_image ( Finset.card_image_iff.mp <| by simp +decide [ this.1 ] ) ] ;
      · conv_rhs => rw [ ← this.2.1, Finset.sum_image ( Finset.card_image_iff.mp <| by simp +decide [ * ] ) ] ;
      · conv_rhs => rw [ ← this.2.2, Finset.sum_image ( Finset.card_image_iff.mp <| by simp +decide [ * ] ) ] ;

/-
Ok is the ring of integers of K.
-/
abbrev Ok := NumberField.RingOfIntegers K

/-
sigma_int n is the restriction of sigma n to the ring of integers, viewed as a Z-algebra equivalence.
-/
noncomputable def sigma_int (n : (ZMod 37)ˣ) : Ok ≃ₐ[ℤ] Ok :=
  (NumberField.RingOfIntegers.mapAlgEquiv (sigma n)).restrictScalars ℤ

/-
N_mod_37 N is the element N in (ZMod 37)ˣ.
-/
def N_mod_37 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 37) : (ZMod 37)ˣ :=
  ZMod.unitOfCoprime N (Nat.Coprime.symm ((Nat.coprime_primes (by norm_num) (Fact.out)).mpr hN.symm))

/-
zeta is an algebraic integer.
-/
theorem zeta_isIntegral : IsIntegral ℤ zeta := IsPrimitiveRoot.isIntegral (IsCyclotomicExtension.zeta_spec 37 ℚ K) (by norm_num)

/-
zeta_int is zeta viewed as an element of the ring of integers.
-/
def zeta_int : Ok := ⟨zeta, zeta_isIntegral⟩

/-
The Artin property holds for zeta.
-/
theorem artin_property_zeta (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 37) (P : Ideal Ok) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) zeta_int) = (Ideal.Quotient.mk P zeta_int)^N := by
    have h_norm : ((Ideal.Quotient.mk P) (sigma_int (N_mod_37 N hN) zeta_int)) = ((Ideal.Quotient.mk P) (zeta_int)) ^ N := by
      have h_norm_eq : (sigma_int (N_mod_37 N hN) zeta_int) = zeta_int ^ N := by
        have h_sigma_zeta : sigma (N_mod_37 N hN) zeta = zeta ^ N := by
          convert sigma_zeta ( N_mod_37 N hN ) using 1;
          -- Since $N$ is coprime to $37$, we have $N \equiv N \mod 37 \pmod{37}$.
          have h_cong : (N : ZMod 37) = (N_mod_37 N hN : ZMod 37) := by
            exact?;
          rw [ ← h_cong, ZMod.val_natCast ];
          have h_order : zeta ^ 37 = 1 := by
            convert IsCyclotomicExtension.zeta_pow 37 ℚ K;
          rw [ ← Nat.mod_add_div N 37, pow_add, pow_mul ] ; aesop;
        exact?
      aesop;
    convert h_norm using 1

/-
zeta_int is a primitive 37th root of unity in the ring of integers.
-/
theorem zeta_int_isPrimitiveRoot : IsPrimitiveRoot zeta_int 37 := by
  have h_prim : IsPrimitiveRoot (zeta : K) 37 := by
    apply_rules [ IsCyclotomicExtension.zeta_spec ];
  simp_all +decide [ IsPrimitiveRoot.iff_def ];
  apply And.intro;
  · exact Subtype.ext h_prim.1;
  · intro l hl;
    convert h_prim.2 l _;
    convert congr_arg ( fun x : Ok => x : Ok → K ) hl using 1

/-
The ring of integers is generated by zeta.
-/
theorem Ok_eq_adjoin : ⊤ = Algebra.adjoin ℤ {zeta_int} := by
  have h_cyclotomic : IsCyclotomicExtension {37} ℤ (NumberField.RingOfIntegers (CyclotomicField 37 ℚ)) := by
    have h_cyclotomic : IsCyclotomicExtension {37} ℚ (CyclotomicField 37 ℚ) := by
      infer_instance;
    convert IsPrimitiveRoot.IsCyclotomicExtension.ringOfIntegers using 1;
    rotate_left;
    exacts [ 37, 1, ⟨ by norm_num ⟩, by infer_instance, by simpa using h_cyclotomic, by norm_num ];
  have h_primitive_root : IsPrimitiveRoot (zeta_int : NumberField.RingOfIntegers (CyclotomicField 37 ℚ)) 37 := by
    convert zeta_int_isPrimitiveRoot using 1;
  rw [ eq_comm ] ; exact IsCyclotomicExtension.adjoin_primitive_root_eq_top h_primitive_root;

/-
Define the integer versions of the Gaussian periods and roots.
-/
noncomputable def eta_int (S : Finset (ZMod 37)) : Ok := ∑ x ∈ S, zeta_int^(x.val)
noncomputable def eta_0_int := eta_int H
noncomputable def eta_1_int := eta_int C1
noncomputable def eta_2_int := eta_int C2
noncomputable def alpha_int := eta_2_int - eta_1_int
noncomputable def beta_int := eta_0_int - eta_2_int
noncomputable def gamma_int := eta_1_int - eta_0_int

/-
The integer roots map to the field roots.
-/
theorem alpha_int_coe : (alpha_int : K) = alpha := by
  exact?
theorem beta_int_coe : (beta_int : K) = beta := by
  unfold beta_int beta;
  unfold eta_0_int eta_2_int eta_0 eta_2; aesop;
theorem gamma_int_coe : (gamma_int : K) = gamma := by
  exact?

/-
The cyclic relations hold in the ring of integers.
-/
theorem cyclic_relations_int :
  11 * beta_int = 3 * alpha_int^2 - 10 * alpha_int - 74 ∧
  11 * gamma_int = -3 * alpha_int^2 - alpha_int + 74 := by
    -- By definition of alpha_int, beta_int, and gamma_int, we know that their images in K satisfy the same relations as their counterparts in K.
    have alpha_int_eq : (alpha_int : K) = alpha := by
      exact?
    have beta_int_eq : (beta_int : K) = beta := by
      exact?
    have gamma_int_eq : (gamma_int : K) = gamma := by
      exact?;
    -- Since these are equalities in K, we can conclude that the relations hold in the ring of integers as well.
    have h_rel : (11 * beta_int : K) = 3 * alpha_int^2 - 10 * alpha_int - 74 ∧ (11 * gamma_int : K) = -3 * alpha_int^2 - alpha_int + 74 := by
      exact ⟨ by rw [ alpha_int_eq, beta_int_eq, relation_beta ], by rw [ alpha_int_eq, gamma_int_eq, relation_gamma ] ⟩;
    have h_inj : Function.Injective (algebraMap (NumberField.RingOfIntegers K) K) := by
      exact?;
    exact ⟨ h_inj <| by simpa using h_rel.1, h_inj <| by simpa using h_rel.2 ⟩

/-
The global permutation holds in the ring of integers.
-/
theorem global_permutation_int (n : (ZMod 37)ˣ) :
  ((n : ZMod 37) ∈ C1 → sigma_int n alpha_int = beta_int) ∧
  ((n : ZMod 37) ∈ C2 → sigma_int n alpha_int = gamma_int) ∧
  ((n : ZMod 37) ∈ H → sigma_int n alpha_int = alpha_int) := by
    have := @global_permutation n;
    refine' ⟨ _, _, _ ⟩;
    · intro hn
      have h_eq : (sigma_int n alpha_int : K) = beta := by
        convert this.1 hn using 1;
      exact ( by rw [ ← beta_int_coe ] at *; exact Subtype.ext h_eq );
    · intro hn;
      have h_sigma_int_gamma : (sigma n : K → K) alpha = gamma := by
        exact this.2.1 hn;
      exact?;
    · intro hn;
      have := this.2.2 hn;
      exact?

/-
The automorphism sigma N reduces to the Frobenius map x |-> x^N modulo P.
-/
theorem artin_property (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 37) (P : Ideal Ok) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) (x : Ok) :
  Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) x) = (Ideal.Quotient.mk P x)^N := by
    -- The set of x satisfying the property is a subalgebra of Ok.
    have h_subalgebra : ∀ x y : Ok, ((Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) x)) = (Ideal.Quotient.mk P x) ^ N) → ((Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) y)) = (Ideal.Quotient.mk P y) ^ N) → ((Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) (x + y))) = (Ideal.Quotient.mk P (x + y)) ^ N) ∧ ((Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) (x * y))) = (Ideal.Quotient.mk P (x * y)) ^ N) := by
      intro x y hx hy;
      have h_frobenius_mul : ∀ (x y : Ok ⧸ P), (x + y) ^ N = x ^ N + y ^ N ∧ (x * y) ^ N = x ^ N * y ^ N := by
        intro x y; haveI := Fact.mk ( Fact.out : Nat.Prime N ) ; simp +decide [ add_pow_char, mul_pow ] ;
        -- Since $P$ is a prime ideal lying over $N$, the quotient ring $Ok/P$ has characteristic $N$.
        have h_char : ringChar (Ok ⧸ P) = N := by
          have h_char : Ideal.Quotient.mk P (N : Ok) = 0 := by
            rw [ Ideal.Quotient.eq_zero_iff_mem ];
            have := hP.1;
            rw [ Ideal.ext_iff ] at this;
            specialize this N; simp_all +decide [ Ideal.mem_span_singleton ] ;
          rw [ ringChar.eq_iff ];
          constructor;
          intro x; rw [ ← Nat.modEq_zero_iff_dvd ] ; simp_all +decide [ ← ZMod.natCast_eq_natCast_iff ] ;
          erw [ ZMod.natCast_eq_zero_iff ];
          erw [ Ideal.Quotient.eq_zero_iff_mem ] at *;
          constructor <;> intro hx;
          · have := hP.1;
            rw [ SetLike.ext_iff ] at this;
            specialize this x;
            simp_all +decide [ Ideal.mem_span_singleton, Ideal.mem_comap ];
            exact_mod_cast this;
          · obtain ⟨ k, rfl ⟩ := hx; simp +decide [ h_char, Ideal.mul_mem_right ] ;
        haveI := ringChar.of_eq h_char; simp +decide [ add_pow_char ] ;
      have h_frobenius_mul : ∀ (x y : Ok), (Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) x)) = (Ideal.Quotient.mk P x) ^ N → (Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) y)) = (Ideal.Quotient.mk P y) ^ N → (Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) (x + y))) = (Ideal.Quotient.mk P (x + y)) ^ N ∧ (Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) (x * y))) = (Ideal.Quotient.mk P (x * y)) ^ N := by
        intros x y hx hy; exact ⟨by
        convert h_frobenius_mul ( Ideal.Quotient.mk P x ) ( Ideal.Quotient.mk P y ) |>.1 using 1;
        · convert congr_arg₂ ( · + · ) hx hy using 1;
          · exact congr_arg _ ( map_add _ _ _ );
          · exact h_frobenius_mul _ _ |>.1;
        · convert h_frobenius_mul ( Ideal.Quotient.mk P x ) ( Ideal.Quotient.mk P y ) |>.1 using 1, by
          convert h_frobenius_mul ( Ideal.Quotient.mk P x ) ( Ideal.Quotient.mk P y ) |>.2 using 1;
          · convert congr_arg₂ ( · * · ) hx hy using 1;
            · exact congr_arg _ ( map_mul _ _ _ );
            · ring;
          · rw [ ← h_frobenius_mul ( Ideal.Quotient.mk P x ) ( Ideal.Quotient.mk P y ) |>.2 ];
            exact?⟩;
      exact h_frobenius_mul x y hx hy;
    -- Since Ok is generated by zeta_int (Ok_eq_adjoin), and the property holds for zeta_int (artin_property_zeta), it holds for all x.
    have h_generate : ∀ x ∈ Algebra.adjoin ℤ {zeta_int}, ((Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) x)) = (Ideal.Quotient.mk P x) ^ N) := by
      refine' fun x hx => Algebra.adjoin_induction _ _ _ _ hx;
      · exact fun x hx => by rw [ Set.mem_singleton_iff.mp hx ] ; exact artin_property_zeta N hN P hP;
      · intro r; erw [ map_intCast ] ; simp +decide [ pow_succ ] ;
        -- Since $P$ lies over $(N)$, we have $N \in P$.
        have hN_in_P : (N : Ok) ∈ P := by
          have := hP.1;
          exact Ideal.mem_comap.mp ( this ▸ Ideal.mem_span_singleton_self _ );
        erw [ Ideal.Quotient.eq ];
        -- Since $N$ is prime, we have $r^N \equiv r \pmod{N}$.
        have h_r_pow_N : (r : Ok) ^ N - r ∈ Ideal.span {(N : Ok)} := by
          rw [ Ideal.mem_span_singleton ];
          have h_r_pow_N : (r : ℤ) ^ N ≡ r [ZMOD N] := by
            haveI := Fact.mk ( Fact.out : Nat.Prime N ) ; simp +decide [ ← ZMod.intCast_eq_intCast_iff ] ;
          obtain ⟨ k, hk ⟩ := h_r_pow_N.symm.dvd;
          exact ⟨ k, by simpa [ ← @Int.cast_inj Ok ] using hk ⟩;
        simpa using P.neg_mem ( Ideal.span_le.mpr ( Set.singleton_subset_iff.mpr hN_in_P ) h_r_pow_N );
      · exact fun x y hx hy hx' hy' => h_subalgebra x y hx' hy' |>.1;
      · exact fun x y hx hy hx' hy' => h_subalgebra x y hx' hy' |>.2;
    convert h_generate x ?_;
    convert Ok_eq_adjoin ▸ Algebra.mem_top

/-
The polynomial f(X) = X^3 - 37X - 37.
-/
def f_poly : Polynomial ℤ := Polynomial.X^3 - 37 * Polynomial.X - 37

/-
P is a maximal ideal.
-/
theorem P_is_maximal (N : ℕ) [Fact (Nat.Prime N)] (P : Ideal Ok) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) : P.IsMaximal := by
  -- Since $P$ is a prime ideal in the ring of integers $Ok$ and $Ok$ is integral over $\mathbb{Z}$, $P$ must be maximal in $Ok$.
  have h_max : P.IsPrime → P ≠ ⊥ → P.IsMaximal := by
    exact?;
  refine h_max ‹_› ?_;
  intro h; have := hP.1; simp_all +decide [ Ideal.span_singleton_eq_bot ] ;

/-
The explicit Frobenius action on alpha_bar is given by the formulas (multiplied by 11 to avoid division).
-/
theorem explicit_frobenius (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 37) (hN11 : N ≠ 11)
  (P : Ideal Ok) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  let alpha_bar := Ideal.Quotient.mk P alpha_int
  let beta_bar := Ideal.Quotient.mk P beta_int
  let gamma_bar := Ideal.Quotient.mk P gamma_int
  ((N : ZMod 37) ∈ C1 → 11 * alpha_bar ^ N = 3 * alpha_bar ^ 2 - 10 * alpha_bar - 74) ∧
  ((N : ZMod 37) ∈ C2 → 11 * alpha_bar ^ N = -3 * alpha_bar ^ 2 - alpha_bar + 74) := by
    refine' ⟨ _, _ ⟩;
    · intro hN1
      have h_beta : Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) alpha_int) = Ideal.Quotient.mk P beta_int := by
        have h_beta : sigma_int (N_mod_37 N hN) alpha_int = beta_int := by
          convert global_permutation_int ( N_mod_37 N hN ) |>.1 _;
          exact?;
        rw [h_beta];
      have h_beta_eq : 11 * Ideal.Quotient.mk P beta_int = 3 * (Ideal.Quotient.mk P alpha_int)^2 - 10 * (Ideal.Quotient.mk P alpha_int) - 74 := by
        have h_beta_eq : 11 * beta_int = 3 * alpha_int^2 - 10 * alpha_int - 74 := by
          exact cyclic_relations_int.left;
        convert congr_arg ( Ideal.Quotient.mk P ) h_beta_eq using 1;
      have h_beta_eq : Ideal.Quotient.mk P (sigma_int (N_mod_37 N hN) alpha_int) = (Ideal.Quotient.mk P alpha_int)^N := by
        convert artin_property N hN P hP alpha_int using 1;
      aesop;
    · intro hN2
      have h_gamma_bar : (Ideal.Quotient.mk P gamma_int) = (Ideal.Quotient.mk P alpha_int)^N := by
        convert artin_property N hN P hP alpha_int using 1;
        rw [ global_permutation_int ( N_mod_37 N hN ) |>.2.1 ];
        convert hN2 using 1;
      convert congr_arg ( Ideal.Quotient.mk P ) ( congr_arg ( fun x : Ok => x : Ok → Ok ) ( show 11 * gamma_int = -3 * alpha_int^2 - alpha_int + 74 from ( cyclic_relations_int ) |>.2 ) ) using 1;
      simp +decide [ ← h_gamma_bar ];
      exact Or.inl rfl

/-
Definitions of s1, s2, and c.
-/
def s1 : ZMod 37 := 10
def s2 : ZMod 37 := 26
def c (N : ℕ) : ZMod 37 := (N : ZMod 37)^12

/-
Characterization of C1 and C2 by 12th powers.
-/
lemma mem_C1_iff (x : ZMod 37) (hx : x ≠ 0) : x ∈ C1 ↔ x^12 = s2 := by
  fin_cases x <;> trivial
lemma mem_C2_iff (x : ZMod 37) (hx : x ≠ 0) : x ∈ C2 ↔ x^12 = s1 := by
  native_decide +revert

/-
The main theorem: alpha^N = gamma if c == s1, and alpha^N = beta if c == s2.
-/
theorem final_result (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 37) (hN_odd : N % 2 = 1) (hN_a : Nat.Coprime 11 N)
  (P : Ideal Ok) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  let alpha_bar := Ideal.Quotient.mk P alpha_int
  let beta_bar := Ideal.Quotient.mk P beta_int
  let gamma_bar := Ideal.Quotient.mk P gamma_int
  (c N = s1 → alpha_bar ^ N = gamma_bar) ∧
  (c N = s2 → alpha_bar ^ N = beta_bar) := by
    have := explicit_frobenius N ( by aesop ) ( by aesop ) P hP;
    -- Since $11$ is invertible in $Ok/P$, we can cancel $11$ from the equations.
    have h_cancel : ∀ (x y : Ok ⧸ P), 11 * x = 11 * y → x = y := by
      -- Since $11$ is invertible in $Ok/P$, we can cancel $11$ from the equation $11 * x = 11 * y$.
      have h_inv : ∃ (inv_11 : Ok ⧸ P), inv_11 * 11 = 1 := by
        have h_inv : (11 : Ok ⧸ P) ≠ 0 := by
          intro h; have := hP.1; simp_all +decide [ Ideal.mem_span_singleton ] ;
          -- Since $11 \in P$, we have $11 \in \text{Ideal.under } \mathbb{Z} P$, which implies $11 \in \text{Ideal.span } \{N\}$.
          have h11_in_span : (11 : ℤ) ∈ Ideal.span {(N : ℤ)} := by
            convert Ideal.Quotient.eq_zero_iff_mem.mp h using 1;
            simp +decide [ Ideal.mem_span_singleton, this ];
          rw [ Ideal.mem_span_singleton ] at h11_in_span;
          norm_cast at h11_in_span; have := Nat.le_of_dvd ( by decide ) h11_in_span; interval_cases N <;> trivial;
        have h_inv : IsUnit (11 : Ok ⧸ P) := by
          have h_inv : IsField (Ok ⧸ P) := by
            exact @Field.toIsField _ ( Ideal.Quotient.field P );
          exact isUnit_iff_exists_inv.mpr ( h_inv.mul_inv_cancel ‹_› );
        exact h_inv.exists_left_inv;
      intro x y hxy; obtain ⟨ inv_11, h_inv ⟩ := h_inv; have := congr_arg ( · * inv_11 ) hxy; norm_num [ mul_assoc, mul_comm, mul_left_comm, h_inv ] at this; aesop;
    refine' ⟨ fun h => h_cancel _ _ _, fun h => h_cancel _ _ _ ⟩;
    · convert this.2 _ using 1;
      · convert congr_arg ( Ideal.Quotient.mk P ) ( cyclic_relations_int.2 ) using 1;
      · convert mem_C2_iff _ _ |>.2 _;
        · intro h; have := hP.1; simp_all +decide [ Ideal.span_singleton_eq_bot ] ;
          erw [ ZMod.natCast_eq_zero_iff ] at h ; have := Nat.dvd_gcd ( show 37 ∣ N from h ) ( show 37 ∣ 37 from dvd_refl 37 ) ; simp_all +decide;
          simp_all +decide [ Nat.Prime.dvd_iff_eq Fact.out ];
        · convert h using 1;
    · convert this.1 _ using 1;
      · convert congr_arg ( Ideal.Quotient.mk P ) ( cyclic_relations_int.1 ) using 1;
      · convert mem_C1_iff _ _ |>.2 h;
        rw [ Ne.eq_def, ZMod.natCast_eq_zero_iff ];
        exact fun h => hN <| by have := Nat.prime_dvd_prime_iff_eq ( by decide : Nat.Prime 37 ) ( Fact.out : Nat.Prime N ) ; tauto;

/-
Define the field K_2557, zeta_2557, constants s1_2557 and s2_2557, and the cosets H_2557, C1_2557, C2_2557. Also define the cubic character c_2557.
-/
abbrev K_2557 := CyclotomicField 2557 ℚ

noncomputable def zeta_2557 : K_2557 := IsCyclotomicExtension.zeta 2557 ℚ K_2557

def s1_2557 : ZMod 2557 := 835
def s2_2557 : ZMod 2557 := 1721

def H_2557 : Finset (ZMod 2557) := ((Finset.univ : Finset (ZMod 2557)).filter (fun x => x ≠ 0)).filter (fun x => x^852 = 1)
def C1_2557 : Finset (ZMod 2557) := ((Finset.univ : Finset (ZMod 2557)).filter (fun x => x ≠ 0)).filter (fun x => x^852 = s2_2557)
def C2_2557 : Finset (ZMod 2557) := ((Finset.univ : Finset (ZMod 2557)).filter (fun x => x ≠ 0)).filter (fun x => x^852 = s1_2557)

def c_2557 (N : ℕ) : ZMod 2557 := (N : ZMod 2557)^852

/-
Define the Gaussian periods eta_0, eta_1, eta_2 and the roots alpha, beta, gamma for q=2557.
-/
open BigOperators

noncomputable def eta_2557 (S : Finset (ZMod 2557)) : K_2557 := ∑ x ∈ S, zeta_2557^(x.val)

noncomputable def eta_0_2557 := eta_2557 H_2557
noncomputable def eta_1_2557 := eta_2557 C1_2557
noncomputable def eta_2_2557 := eta_2557 C2_2557

noncomputable def alpha_2557 := eta_2_2557 - eta_1_2557
noncomputable def beta_2557 := eta_0_2557 - eta_2_2557
noncomputable def gamma_2557 := eta_1_2557 - eta_0_2557

/-
Define the ring of integers Ok_2557 and state that zeta_2557 is integral.
-/
abbrev Ok_2557 := NumberField.RingOfIntegers K_2557

theorem zeta_isIntegral_2557 : IsIntegral ℤ zeta_2557 := by
  refine' ⟨ Polynomial.X ^ 2557 - 1, _, _ ⟩;
  · exact Polynomial.monic_X_pow_sub_C _ ( by norm_num );
  · simp +zetaDelta at *;
    convert sub_eq_zero.mpr ( IsCyclotomicExtension.zeta_pow 2557 ℚ K_2557 )

/-
Define zeta_int_2557 and the integer versions of the Gaussian periods and roots.
-/
def zeta_int_2557 : Ok_2557 := ⟨zeta_2557, zeta_isIntegral_2557⟩

noncomputable def eta_int_2557 (S : Finset (ZMod 2557)) : Ok_2557 := ∑ x ∈ S, zeta_int_2557^(x.val)

noncomputable def eta_0_int_2557 := eta_int_2557 H_2557
noncomputable def eta_1_int_2557 := eta_int_2557 C1_2557
noncomputable def eta_2_int_2557 := eta_int_2557 C2_2557

noncomputable def alpha_int_2557 := eta_2_int_2557 - eta_1_int_2557
noncomputable def beta_int_2557 := eta_0_int_2557 - eta_2_int_2557
noncomputable def gamma_int_2557 := eta_1_int_2557 - eta_0_int_2557

/-
Prove that alpha_int_2557 coerces to alpha_2557.
-/
theorem alpha_int_coe_2557 : (alpha_int_2557 : K_2557) = alpha_2557 := by
  -- By definition of coercion, we have that the coercion of alpha_int_2557 is the same as the sum of the coercions of the individual elements.
  simp [alpha_int_2557, alpha_2557];
  simp +decide only [eta_2_int_2557, eta_1_int_2557];
  unfold eta_int_2557 eta_2_2557 eta_1_2557;
  unfold eta_2557; simp +decide [ zeta_int_2557 ] ;

/-
Prove that beta_int_2557 coerces to beta_2557 and gamma_int_coe_2557 coerces to gamma_2557.
-/
theorem beta_int_coe_2557 : (beta_int_2557 : K_2557) = beta_2557 := by
  simp [beta_int_2557, beta_2557];
  simp +decide only [eta_0_int_2557, eta_2_int_2557];
  unfold eta_int_2557 eta_0_2557 eta_2_2557;
  unfold eta_2557; simp +decide [ zeta_int_2557 ]

theorem gamma_int_coe_2557 : (gamma_int_2557 : K_2557) = gamma_2557 := by
  simp [gamma_int_2557, gamma_2557];
  simp +decide only [eta_1_int_2557, eta_0_int_2557];
  unfold eta_int_2557 eta_1_2557 eta_0_2557;
  unfold eta_2557; simp +decide [ zeta_int_2557 ]

/-
Define the proposition PeriodEquation_2557 representing the equation alpha^3 = 2557*alpha + 2557.
-/
def PeriodEquation_2557 : Prop := alpha_2557^3 = 2557 * alpha_2557 + 2557

/-
Define the irreducibility of the cyclotomic polynomial and the Galois automorphism sigma_2557.
-/
theorem h_irr_2557 : Irreducible (Polynomial.cyclotomic 2557 ℚ) := by
  exact Polynomial.cyclotomic.irreducible_rat <| by norm_num;

noncomputable def sigma_2557 (n : (ZMod 2557)ˣ) : K_2557 ≃ₐ[ℚ] K_2557 := (IsCyclotomicExtension.autEquivPow K_2557 h_irr_2557).symm n

/-
Prove sigma_zeta_2557 and define sigma_int_2557.
-/
theorem sigma_zeta_2557 (n : (ZMod 2557)ˣ) : sigma_2557 n zeta_2557 = zeta_2557^(n : ZMod 2557).val := by
  -- By definition of the automorphism, we have σ_n(zeta_2557) = zeta_2557^n.
  have h_sigma_def : ∀ n : (ZMod 2557)ˣ, (sigma_2557 n) zeta_2557 = zeta_2557^(n : ZMod 2557).val := by
    intro n
    simp [sigma_2557];
    rw [ PowerBasis.equivOfMinpoly_apply ];
    convert ( IsPrimitiveRoot.powerBasis ℚ ( show IsPrimitiveRoot ( IsCyclotomicExtension.zeta 2557 ℚ K_2557 ) 2557 from ?_ ) |> PowerBasis.lift_gen ) _ _;
    convert IsCyclotomicExtension.zeta_spec 2557 ℚ K_2557;
  exact h_sigma_def n

noncomputable def sigma_int_2557 (n : (ZMod 2557)ˣ) : Ok_2557 ≃ₐ[ℤ] Ok_2557 :=
  (NumberField.RingOfIntegers.mapAlgEquiv (sigma_2557 n)).restrictScalars ℤ

/-
Define N_mod_2557 and state the Artin property for zeta.
-/
def N_mod_2557 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 2557) : (ZMod 2557)ˣ :=
  ZMod.unitOfCoprime N (Nat.Coprime.symm ((Nat.coprime_primes (by norm_num) (Fact.out)).mpr hN.symm))

theorem artin_property_zeta_2557 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 2557) (P : Ideal Ok_2557) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  Ideal.Quotient.mk P (sigma_int_2557 (N_mod_2557 N hN) zeta_int_2557) = (Ideal.Quotient.mk P zeta_int_2557)^N := by
    have h_sigma_zeta : ∀ (n : (ZMod 2557)ˣ), sigma_2557 n zeta_2557 = zeta_2557^(n : ZMod 2557).val := by
      exact?;
    have h_sigma_zeta_mod : ∀ (n : (ZMod 2557)ˣ), Ideal.Quotient.mk P (sigma_int_2557 n zeta_int_2557) = (Ideal.Quotient.mk P zeta_int_2557)^(n : ZMod 2557).val := by
      intro n
      have h_sigma_zeta_mod_step : Ideal.Quotient.mk P (sigma_int_2557 n zeta_int_2557) = Ideal.Quotient.mk P (zeta_int_2557^(n : ZMod 2557).val) := by
        congr;
        exact Subtype.ext <| h_sigma_zeta n;
      exact?;
    convert h_sigma_zeta_mod ( N_mod_2557 N hN ) using 1;
    have h_sigma_zeta_mod : Ideal.Quotient.mk P (zeta_int_2557 ^ 2557) = 1 := by
      have h_sigma_zeta_mod : zeta_int_2557 ^ 2557 = 1 := by
        have h_sigma_zeta_mod : zeta_2557 ^ 2557 = 1 := by
          exact IsCyclotomicExtension.zeta_pow 2557 ℚ K_2557;
        exact Subtype.ext h_sigma_zeta_mod;
      rw [ h_sigma_zeta_mod, map_one ];
    have h_sigma_zeta_mod : (Ideal.Quotient.mk P zeta_int_2557) ^ (N % 2557) = (Ideal.Quotient.mk P zeta_int_2557) ^ N := by
      rw [ ← Nat.mod_add_div N 2557 ] ; norm_num [ pow_add, pow_mul, h_sigma_zeta_mod ] ;
      erw [ map_pow ] at * ; aesop;
    convert h_sigma_zeta_mod.symm using 1

/-
Prove that the ring of integers Ok_2557 is generated by zeta_int_2557.
-/
theorem Ok_eq_adjoin_2557 : ⊤ = Algebra.adjoin ℤ {zeta_int_2557} := by
  -- By definition of $zeta_int_2557$, we know that $zeta_int_2557$ is a root of the minimal polynomial $x^{2556} + x^{2555} + \cdots + x + 1$.
  have h_min_poly : ∀ x : K_2557, IsIntegral ℤ x → x ∈ Algebra.adjoin ℤ {zeta_2557} := by
    have h_gen : IsIntegralClosure (Algebra.adjoin ℤ {zeta_2557}) ℤ K_2557 := by
      have h_integral_closure : IsIntegralClosure (Algebra.adjoin ℤ {zeta_2557}) ℤ K_2557 := by
        have h_prime : Nat.Prime 2557 := by norm_num
        have := @IsCyclotomicExtension.Rat.isIntegralClosure_adjoin_singleton_of_prime;
        convert this ( show IsPrimitiveRoot zeta_2557 2557 from ?_ );
        · exact ⟨ h_prime ⟩;
        · convert IsCyclotomicExtension.zeta_spec 2557 ℚ K_2557;
      exact?;
    cases h_gen ; aesop;
  ext x le_antisymm _ _;
  convert h_min_poly x.1 x.2;
  simp +decide [ Algebra.adjoin_singleton_eq_range_aeval ];
  constructor <;> rintro ⟨ p, hp ⟩;
  · use p;
    convert congr_arg Subtype.val hp using 1;
    simp +decide [ Polynomial.aeval_def, Polynomial.eval₂_eq_sum_range ];
    induction ( Finset.range ( p.natDegree + 1 ) ) using Finset.induction <;> aesop;
  · use p;
    erw [ Polynomial.aeval_def, Polynomial.eval₂_eq_sum_range ] at * ; aesop

/-
If two ring homomorphisms from Ok_2557 agree on zeta_int_2557, they are equal.
-/
theorem hom_eq_of_map_zeta_2557 {R : Type*} [CommRing R] (f g : Ok_2557 →+* R) (h : f zeta_int_2557 = g zeta_int_2557) : f = g := by
  -- Since $Ok_2557$ is generated by $zeta_int_2557$, any element in $Ok_2557$ can be written as a polynomial in $zeta_int_2557$ with integer coefficients.
  have h_gen : ∀ x : Ok_2557, x ∈ Algebra.adjoin ℤ {zeta_int_2557} := by
    intro x
    have := Ok_eq_adjoin_2557
    simp_all +decide [ Algebra.adjoin_singleton_eq_range_aeval ];
    replace this := SetLike.ext_iff.mp this x; aesop;
  refine' RingHom.ext fun x => _;
  refine' Algebra.adjoin_induction _ _ _ _ ( h_gen x ) <;> aesop

/-
Prove that the ring characteristic of Ok_2557 / P is N.
-/
theorem ringChar_Ok_quot_P_2557 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 2557) (P : Ideal Ok_2557) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) : ringChar (Ok_2557 ⧸ P) = N := by
  -- Since $N$ is in $P$, we have $(N : Ok_2557 ⧸ P) = 0$.
  have hN_zero : (N : Ok_2557 ⧸ P) = 0 := by
    -- Since $P$ lies over $N$, we have $N \in P$.
    have hN_in_P : (N : Ok_2557) ∈ P := by
      have := hP.1;
      exact Ideal.mem_comap.mp ( this ▸ Ideal.mem_span_singleton_self _ );
    exact Ideal.Quotient.eq_zero_iff_mem.mpr hN_in_P;
  have h_char_div : ringChar (Ok_2557 ⧸ P) ∣ N := by
    exact?;
  rw [ Nat.dvd_prime Fact.out ] at h_char_div;
  cases h_char_div <;> simp_all +decide [ ringChar.eq_iff ];
  exact absurd ( CharP.char_is_prime_or_zero ( Ok_2557 ⧸ P ) 1 ) ( by simp +decide )

/-
Prove the general Artin property for Ok_2557.
-/
theorem artin_property_2557 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 2557) (P : Ideal Ok_2557) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) (x : Ok_2557) :
  Ideal.Quotient.mk P (sigma_int_2557 (N_mod_2557 N hN) x) = (Ideal.Quotient.mk P x)^N := by
    have h_frobenius_eq : ∀ x : Ok_2557, Ideal.Quotient.mk P (sigma_int_2557 (N_mod_2557 N hN) x) = (Ideal.Quotient.mk P x)^N := by
      have h_char : CharP (Ok_2557 ⧸ P) N := by
        have h_char : ringChar (Ok_2557 ⧸ P) = N := by
          convert ringChar_Ok_quot_P_2557 N hN P hP;
        exact h_char ▸ inferInstance;
      intro x
      set f : Ok_2557 →+* (Ok_2557 ⧸ P) := (Ideal.Quotient.mk P).comp (sigma_int_2557 (N_mod_2557 N hN))
      set g : Ok_2557 →+* (Ok_2557 ⧸ P) := (frobenius (Ok_2557 ⧸ P) N).comp (Ideal.Quotient.mk P);
      have h_frobenius_eq : f zeta_int_2557 = g zeta_int_2557 := by
        convert artin_property_zeta_2557 N hN P hP using 1;
      convert hom_eq_of_map_zeta_2557 f g h_frobenius_eq |> fun h => congr_arg ( fun f => f x ) h using 1;
    exact h_frobenius_eq x

/-
Define the polynomial f_poly_2557 and prove that P is maximal.
-/
def f_poly_2557 : Polynomial ℤ := Polynomial.X^3 - 2557 * Polynomial.X - 2557

theorem P_is_maximal_2557 (N : ℕ) [Fact (Nat.Prime N)] (P : Ideal Ok_2557) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) : P.IsMaximal := by
  have h_comap : (P.comap (algebraMap ℤ Ok_2557)) = Ideal.span {↑N} := by
    have := hP.1;
    convert this.symm using 1;
  have h_comap_max : (Ideal.span {↑N} : Ideal ℤ).IsMaximal := by
    have h_comap_max : Ideal.IsMaximal (Ideal.span {↑N} : Ideal ℤ) := by
      have h_prime : Ideal.IsPrime (Ideal.span {↑N} : Ideal ℤ) := by
        rw [ Ideal.span_singleton_prime ] <;> norm_cast;
        · exact Nat.prime_iff_prime_int.mp ( Fact.out : Nat.Prime N );
        · exact Nat.Prime.ne_zero Fact.out
      convert h_prime.isMaximal using 1;
      simp +decide [ Ideal.span_singleton_eq_bot ];
      exact Or.inl <| Nat.Prime.ne_zero Fact.out;
    exact h_comap_max;
  convert Ideal.isMaximal_of_isIntegral_of_isMaximal_comap _ _;
  exact ℤ;
  all_goals try infer_instance;
  exact h_comap.symm ▸ h_comap_max

/-
Define the algebraic relations for beta and gamma as propositions.
-/
def RelationBeta_2557 : Prop := 101 * beta_2557 = 3 * alpha_2557^2 - 55 * alpha_2557 - 5114
def RelationGamma_2557 : Prop := 101 * gamma_2557 = -3 * alpha_2557^2 + 46 * alpha_2557 + 5114

/-
Define the integer versions of the cyclic relations.
-/
def CyclicRelationsInt_2557 : Prop :=
  101 * beta_int_2557 = 3 * alpha_int_2557^2 - 55 * alpha_int_2557 - 5114 ∧
  101 * gamma_int_2557 = -3 * alpha_int_2557^2 + 46 * alpha_int_2557 + 5114

/-
Prove that multiplication by an element of C1 permutes the cosets cyclically: H -> C1 -> C2 -> H.
-/
lemma permute_cosets_2557 (n : (ZMod 2557)ˣ) :
  ((n : ZMod 2557) ∈ C1_2557 → Finset.image (fun x => (n : ZMod 2557) * x) H_2557 = C1_2557) ∧
  ((n : ZMod 2557) ∈ C1_2557 → Finset.image (fun x => (n : ZMod 2557) * x) C1_2557 = C2_2557) ∧
  ((n : ZMod 2557) ∈ C1_2557 → Finset.image (fun x => (n : ZMod 2557) * x) C2_2557 = H_2557) := by
    refine' ⟨ _, _, _ ⟩ <;> intro hn <;> rw [ Finset.ext_iff ] <;> intro x <;> simp +decide [ hn, C1_2557, C2_2557, H_2557 ] at *;
    · constructor <;> intro hx;
      · rcases hx with ⟨ a, ⟨ ha₁, ha₂ ⟩, rfl ⟩ ; simp +decide [ *, mul_pow ];
      · refine' ⟨ n⁻¹ * x, _, _ ⟩ <;> simp_all +decide [ mul_pow, Units.mul_inv_cancel_left ];
        native_decide +revert;
    · constructor;
      · rintro ⟨ a, ⟨ ha₁, ha₂ ⟩, rfl ⟩;
        norm_num +zetaDelta at *;
        exact ⟨ ha₁, by rw [ mul_pow, hn.2, ha₂ ] ; native_decide ⟩;
      · intro hx
        use n⁻¹.val * x;
        native_decide +revert;
    · constructor <;> intro hx;
      · rcases hx with ⟨ a, ⟨ ha₁, ha₂ ⟩, rfl ⟩;
        simp +decide [ *, mul_pow ];
      · -- Let $a = n^{-1} * x$. We need to show that $a \in C2_2557$ and $n * a = x$.
        use n⁻¹ * x;
        native_decide +revert

/-
Prove the global permutation properties of sigma_n on alpha.
-/
theorem global_permutation_2557 (n : (ZMod 2557)ˣ) :
  ((n : ZMod 2557) ∈ C1_2557 → sigma_2557 n alpha_2557 = beta_2557) ∧
  ((n : ZMod 2557) ∈ C2_2557 → sigma_2557 n alpha_2557 = gamma_2557) ∧
  ((n : ZMod 2557) ∈ H_2557 → sigma_2557 n alpha_2557 = alpha_2557) := by
    refine' ⟨ _, _, _ ⟩;
    · intro hn;
      have h_perm : Finset.image (fun x => (n : ZMod 2557) * x) H_2557 = C1_2557 ∧ Finset.image (fun x => (n : ZMod 2557) * x) C1_2557 = C2_2557 ∧ Finset.image (fun x => (n : ZMod 2557) * x) C2_2557 = H_2557 := by
        exact ⟨ by simpa [ ← ZMod.natCast_eq_zero_iff ] using permute_cosets_2557 n |>.1 hn, by simpa [ ← ZMod.natCast_eq_zero_iff ] using permute_cosets_2557 n |>.2.1 hn, by simpa [ ← ZMod.natCast_eq_zero_iff ] using permute_cosets_2557 n |>.2.2 hn ⟩;
      -- By definition of $\sigma_n$, we have $\sigma_n(\eta_S) = \sum_{x \in S} \zeta^{nx}$.
      have h_sigma_eta : ∀ S : Finset (ZMod 2557), (sigma_2557 n) (eta_2557 S) = eta_2557 (Finset.image (fun x => (n : ZMod 2557) * x) S) := by
        intro S
        simp [eta_2557, sigma_2557];
        refine' Finset.sum_congr rfl fun x hx => _;
        have h_sigma_zeta : ∀ x : ZMod 2557, sigma_2557 n (zeta_2557 ^ x.val) = zeta_2557 ^ ((n : ZMod 2557) * x).val := by
          intro x
          have h_sigma_zeta : sigma_2557 n (zeta_2557 ^ x.val) = (sigma_2557 n zeta_2557) ^ x.val := by
            exact map_pow _ _ _;
          rw [ h_sigma_zeta, sigma_zeta_2557 ];
          rw [ ← pow_mul, ZMod.val_mul ];
          rw [ ← Nat.mod_add_div ( ( n : ZMod 2557 ).val * x.val ) 2557, pow_add, pow_mul ] ; norm_num [ zeta_2557 ];
          have h_zeta_pow : IsCyclotomicExtension.zeta 2557 ℚ K_2557 ^ 2557 = 1 := by
            exact IsCyclotomicExtension.zeta_pow _ _ _;
          rw [ h_zeta_pow, one_pow, mul_one ];
        convert h_sigma_zeta x using 1;
        unfold sigma_2557; aesop;
      simp +decide only [alpha_2557, beta_2557];
      simp +decide only [map_sub];
      rw [ show eta_2_2557 = eta_2557 C2_2557 from rfl, show eta_1_2557 = eta_2557 C1_2557 from rfl, h_sigma_eta, h_sigma_eta, h_perm.2.2, h_perm.2.1 ];
      rfl;
    · intro hn
      have h_perm : Finset.image (fun x => (n : ZMod 2557) * x) H_2557 = C2_2557 ∧ Finset.image (fun x => (n : ZMod 2557) * x) C1_2557 = H_2557 ∧ Finset.image (fun x => (n : ZMod 2557) * x) C2_2557 = C1_2557 := by
        have h_perm : ∀ x : ZMod 2557, x ∈ H_2557 → (n : ZMod 2557) * x ∈ C2_2557 := by
          intro x hx
          have hnx : (n * x : ZMod 2557)^852 = s1_2557 := by
            simp_all +decide [ mul_pow, Finset.mem_filter ];
            unfold C2_2557 at hn; unfold H_2557 at hx; aesop;
          exact Finset.mem_filter.mpr ⟨ Finset.mem_filter.mpr ⟨ Finset.mem_univ _, by
            intro h; simp +decide [ h ] at hnx; ⟩, hnx ⟩;
        have h_perm_C1 : ∀ x : ZMod 2557, x ∈ C1_2557 → (n : ZMod 2557) * x ∈ H_2557 := by
          intro x hx
          have h_perm_C1 : (n : ZMod 2557) ^ 852 * x ^ 852 = 1 := by
            have h_perm_C1 : (n : ZMod 2557) ^ 852 = s1_2557 := by
              exact Finset.mem_filter.mp hn |>.2
            have h_perm_C1' : x ^ 852 = s2_2557 := by
              exact Finset.mem_filter.mp hx |>.2 |> fun h => by simp [ h ];
            rw [h_perm_C1, h_perm_C1']
            skip;
            native_decide +revert;
          have h_perm_C1 : ((n : ZMod 2557) * x) ^ 852 = 1 := by
            rw [ mul_pow, h_perm_C1 ];
          exact Finset.mem_filter.mpr ⟨ Finset.mem_filter.mpr ⟨ Finset.mem_univ _, by
            grind ⟩, h_perm_C1 ⟩;
        have h_perm_C2 : ∀ x : ZMod 2557, x ∈ C2_2557 → (n : ZMod 2557) * x ∈ C1_2557 := by
          intro x hx
          have h_perm_C2 : (n : ZMod 2557) * x ∈ C1_2557 := by
            have h_perm_C2 : (n : ZMod 2557) ^ 852 = s1_2557 ∧ x ^ 852 = s1_2557 := by
              exact ⟨ Finset.mem_filter.mp hn |>.2, Finset.mem_filter.mp hx |>.2 ⟩;
            have h_perm_C2 : ((n : ZMod 2557) * x) ^ 852 = s2_2557 := by
              rw [ mul_pow, h_perm_C2.1, h_perm_C2.2 ];
              native_decide +revert;
            exact Finset.mem_filter.mpr ⟨ Finset.mem_filter.mpr ⟨ Finset.mem_univ _, by
              intro h; simp +decide [ h ] at h_perm_C2; ⟩, h_perm_C2 ⟩
          exact h_perm_C2;
        have h_perm_card : Finset.card (Finset.image (fun x => (n : ZMod 2557) * x) H_2557) = Finset.card C2_2557 ∧ Finset.card (Finset.image (fun x => (n : ZMod 2557) * x) C1_2557) = Finset.card H_2557 ∧ Finset.card (Finset.image (fun x => (n : ZMod 2557) * x) C2_2557) = Finset.card C1_2557 := by
          have h_perm_card : Finset.card (Finset.image (fun x => (n : ZMod 2557) * x) H_2557) = Finset.card H_2557 ∧ Finset.card (Finset.image (fun x => (n : ZMod 2557) * x) C1_2557) = Finset.card C1_2557 ∧ Finset.card (Finset.image (fun x => (n : ZMod 2557) * x) C2_2557) = Finset.card C2_2557 := by
            exact ⟨ Finset.card_image_of_injective _ fun x y hxy => by simpa using hxy, Finset.card_image_of_injective _ fun x y hxy => by simpa using hxy, Finset.card_image_of_injective _ fun x y hxy => by simpa using hxy ⟩;
          exact ⟨ by rw [ h_perm_card.1 ] ; native_decide, by rw [ h_perm_card.2.1 ] ; native_decide, by rw [ h_perm_card.2.2 ] ; native_decide ⟩;
        exact ⟨ Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr h_perm ) ( by rw [ h_perm_card.1 ] ), Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr h_perm_C1 ) ( by rw [ h_perm_card.2.1 ] ), Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr h_perm_C2 ) ( by rw [ h_perm_card.2.2 ] ) ⟩;
      -- By definition of $sigma_2557$, we know that $sigma_2557(n)(\eta_k) = \eta_{k+1}$ for $k = 0, 1, 2$.
      have h_sigma_eta : sigma_2557 n (eta_2557 H_2557) = eta_2557 (Finset.image (fun x => (n : ZMod 2557) * x) H_2557) ∧ sigma_2557 n (eta_2557 C1_2557) = eta_2557 (Finset.image (fun x => (n : ZMod 2557) * x) C1_2557) ∧ sigma_2557 n (eta_2557 C2_2557) = eta_2557 (Finset.image (fun x => (n : ZMod 2557) * x) C2_2557) := by
        have h_sigma_eta : ∀ S : Finset (ZMod 2557), sigma_2557 n (eta_2557 S) = eta_2557 (Finset.image (fun x => (n : ZMod 2557) * x) S) := by
          intro S
          simp [eta_2557, sigma_zeta_2557];
          refine' Finset.sum_congr rfl fun x hx => _;
          rw [ ← pow_mul, ZMod.val_mul ];
          rw [ ← Nat.mod_add_div ( ( n : ZMod 2557 ).val * x.val ) 2557, pow_add, pow_mul ] ; norm_num [ zeta_2557 ];
          rw [ show ( IsCyclotomicExtension.zeta 2557 ℚ K_2557 : K_2557 ) ^ 2557 = 1 from ?_, one_pow, mul_one ];
          exact IsCyclotomicExtension.zeta_pow _ _ _;
        exact ⟨ h_sigma_eta _, h_sigma_eta _, h_sigma_eta _ ⟩;
      simp_all +decide only [alpha_2557, gamma_2557];
      convert congr_arg₂ ( · - · ) h_sigma_eta.2.2 h_sigma_eta.2.1 using 1;
      exact map_sub _ _ _;
    · unfold alpha_2557;
      unfold eta_2_2557 eta_1_2557;
      unfold eta_2557 C1_2557 H_2557 at *;
      unfold C2_2557 at *;
      simp +contextual [ Finset.sum_filter, Finset.sum_sub_distrib ];
      rw [ ← Finset.sum_sub_distrib, ← Finset.sum_sub_distrib ];
      intro hn hn';
      refine' Finset.sum_bij ( fun x hx => ( n : ZMod 2557 ) * x ) _ _ _ _ <;> simp +contextual [ hn, hn' ];
      · exact fun b => ⟨ n⁻¹ * b, by simp +decide [ hn ] ⟩;
      · intro a; split_ifs <;> simp +decide [ *, mul_pow ] ;
        all_goals simp_all +decide [ mul_pow, ZMod.val_mul ];
        · rw [ sigma_zeta_2557 ];
          rw [ ← pow_mul, ← Nat.mod_add_div ( ( n : ZMod 2557 ).val * a.val ) 2557, pow_add, pow_mul ] ; norm_num [ zeta_2557 ];
          have h_zeta_pow : IsCyclotomicExtension.zeta 2557 ℚ K_2557 ^ 2557 = 1 := by
            exact IsCyclotomicExtension.zeta_pow _ _ _;
          rw [ h_zeta_pow, one_pow, mul_one ];
        · rw [ sigma_zeta_2557 ];
          rw [ ← pow_mul, ← Nat.mod_add_div ( ( n : ZMod 2557 ).val * a.val ) 2557, pow_add, pow_mul ];
          have h_zeta_pow : zeta_2557 ^ 2557 = 1 := by
            exact IsCyclotomicExtension.zeta_pow _ _ _;
          norm_num [ h_zeta_pow ]

/-
Prove the action of sigma_n on the Gaussian periods eta_0, eta_1, eta_2.
-/
lemma sigma_eta_2557 (n : (ZMod 2557)ˣ) :
  ((n : ZMod 2557) ∈ C1_2557 → sigma_2557 n eta_0_2557 = eta_1_2557 ∧ sigma_2557 n eta_1_2557 = eta_2_2557 ∧ sigma_2557 n eta_2_2557 = eta_0_2557) ∧
  ((n : ZMod 2557) ∈ C2_2557 → sigma_2557 n eta_0_2557 = eta_2_2557 ∧ sigma_2557 n eta_1_2557 = eta_0_2557 ∧ sigma_2557 n eta_2_2557 = eta_1_2557) ∧
  ((n : ZMod 2557) ∈ H_2557 → sigma_2557 n eta_0_2557 = eta_0_2557 ∧ sigma_2557 n eta_1_2557 = eta_1_2557 ∧ sigma_2557 n eta_2_2557 = eta_2_2557) := by
    refine' ⟨ _, _, _ ⟩;
    · intro hn
      have h_perm : Finset.image (fun x => (n : ZMod 2557) * x) H_2557 = C1_2557 ∧ Finset.image (fun x => (n : ZMod 2557) * x) C1_2557 = C2_2557 ∧ Finset.image (fun x => (n : ZMod 2557) * x) C2_2557 = H_2557 := by
        have := permute_cosets_2557 n;
        exact ⟨ this.1 hn, this.2.1 hn, this.2.2 hn ⟩;
      -- By definition of $sigma_2557$, we know that $sigma_2557(n)(zeta_2557) = zeta_2557^n$.
      have h_sigma_zeta : ∀ x : ZMod 2557, sigma_2557 n (zeta_2557^x.val) = zeta_2557^(n * x).val := by
        intro x
        have h_sigma_zeta : sigma_2557 n (zeta_2557^x.val) = (sigma_2557 n zeta_2557)^x.val := by
          exact map_pow _ _ _;
        rw [ h_sigma_zeta, sigma_zeta_2557 ];
        rw [ ← pow_mul, ZMod.val_mul ];
        rw [ ← Nat.mod_add_div ( ( n : ZMod 2557 ).val * x.val ) 2557, pow_add, pow_mul ] ; norm_num [ zeta_2557 ];
        have h_zeta_pow : IsCyclotomicExtension.zeta 2557 ℚ K_2557 ^ 2557 = 1 := by
          exact IsCyclotomicExtension.zeta_pow _ _ _;
        rw [ h_zeta_pow, one_pow, mul_one ];
      -- By definition of $eta$, we can rewrite the sums using the permutation properties.
      have h_eta_perm : ∀ S : Finset (ZMod 2557), (∑ x ∈ S, (sigma_2557 n) (zeta_2557^x.val)) = ∑ x ∈ Finset.image (fun x => (n : ZMod 2557) * x) S, zeta_2557^(x.val) := by
        exact fun S => by rw [ Finset.sum_image ( by intros x hx y hy hxy; simpa using hxy ) ] ; exact Finset.sum_congr rfl fun x hx => h_sigma_zeta x;
      simp +contextual only [eta_0_2557, eta_1_2557, eta_2_2557];
      simp +contextual only [eta_2557, map_sum, h_eta_perm, h_perm];
      norm_num;
    · intro hn2
      have h_perm : Finset.image (fun x => (n : ZMod 2557) * x) H_2557 = C2_2557 ∧ Finset.image (fun x => (n : ZMod 2557) * x) C1_2557 = H_2557 ∧ Finset.image (fun x => (n : ZMod 2557) * x) C2_2557 = C1_2557 := by
        have h_perm : ∀ x ∈ H_2557, (n : ZMod 2557) * x ∈ C2_2557 := by
          unfold C2_2557 at *; simp_all +contextual [ Finset.mem_filter, Finset.mem_univ ] ;
          unfold H_2557; simp +contextual [ hn2, mul_pow ] ;
        have h_perm_C1 : ∀ x ∈ C1_2557, (n : ZMod 2557) * x ∈ H_2557 := by
          intro x hx
          have h_perm_C1 : (n : ZMod 2557) * x ∈ H_2557 := by
            have h_perm_C1 : (n : ZMod 2557) ^ 852 = s1_2557 := by
              exact Finset.mem_filter.mp hn2 |>.2
            have h_perm_C1' : x ^ 852 = s2_2557 := by
              native_decide +revert
            have h_perm_C1'' : ((n : ZMod 2557) * x) ^ 852 = 1 := by
              rw [ mul_pow, h_perm_C1, h_perm_C1' ] ; native_decide;
            exact Finset.mem_filter.mpr ⟨ Finset.mem_filter.mpr ⟨ Finset.mem_univ _, by
              intro h; simp +decide [ h ] at h_perm_C1''; ⟩, h_perm_C1'' ⟩;
          exact h_perm_C1;
        have h_perm_C2 : ∀ x ∈ C2_2557, (n : ZMod 2557) * x ∈ C1_2557 := by
          intro x hx
          have h_perm_C2_step : (n : ZMod 2557) * x ∈ C1_2557 := by
            have h_perm_C2_step : (n : ZMod 2557) * x ∈ ((Finset.univ : Finset (ZMod 2557)).filter (fun x => x ≠ 0)).filter (fun x => x^852 = s1_2557 * s1_2557) := by
              simp_all +decide [ Finset.mem_filter, Finset.mem_univ ];
              exact ⟨ by rintro rfl; exact absurd hx ( by native_decide ), by rw [ mul_pow ] ; exact by rw [ show ( n : ZMod 2557 ) ^ 852 = s1_2557 from by exact Finset.mem_filter.mp hn2 |>.2 ] ; exact by rw [ show x ^ 852 = s1_2557 from by exact Finset.mem_filter.mp hx |>.2 ] ⟩;
            exact h_perm_C2_step |> fun h => by rw [ show s1_2557 * s1_2557 = s2_2557 by native_decide ] at h; exact h;
          exact h_perm_C2_step;
        refine' ⟨ Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr h_perm ) _, Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr h_perm_C1 ) _, Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr h_perm_C2 ) _ ⟩;
        · rw [ Finset.card_image_of_injective _ fun x y hxy => by simpa using hxy ];
          native_decide;
        · rw [ Finset.card_image_of_injective _ fun x y hxy => by simpa using hxy ] ; native_decide;
        · rw [ Finset.card_image_of_injective _ fun x y hxy => by simpa using hxy ];
          native_decide;
      -- By definition of $sigma_2557$, we know that $sigma_2557(n)(zeta_2557) = zeta_2557^n$.
      have h_sigma_zeta : ∀ x : ZMod 2557, sigma_2557 n (zeta_2557^x.val) = zeta_2557^(n * x).val := by
        intro x
        have h_sigma_zeta_pow : sigma_2557 n (zeta_2557^x.val) = (sigma_2557 n zeta_2557)^x.val := by
          exact map_pow _ _ _;
        rw [ h_sigma_zeta_pow, sigma_zeta_2557 ];
        rw [ ← pow_mul, ZMod.val_mul ];
        rw [ ← Nat.mod_add_div ( ( n : ZMod 2557 ).val * x.val ) 2557, pow_add, pow_mul ] ; norm_num [ zeta_2557 ];
        erw [ IsCyclotomicExtension.zeta_pow ] ; norm_num;
      -- Applying the permutation property of $n$ to the Gaussian periods.
      have h_eta_perm : ∀ S : Finset (ZMod 2557), (sigma_2557 n) (∑ x ∈ S, zeta_2557^(x.val)) = ∑ x ∈ Finset.image (fun x => (n : ZMod 2557) * x) S, zeta_2557^(x.val) := by
        simp +decide [ Finset.sum_image, h_sigma_zeta ];
      exact ⟨ by rw [ show eta_0_2557 = ∑ x ∈ H_2557, zeta_2557 ^ x.val from rfl, show eta_2_2557 = ∑ x ∈ C2_2557, zeta_2557 ^ x.val from rfl, h_eta_perm, h_perm.1 ], by rw [ show eta_1_2557 = ∑ x ∈ C1_2557, zeta_2557 ^ x.val from rfl, show eta_0_2557 = ∑ x ∈ H_2557, zeta_2557 ^ x.val from rfl, h_eta_perm, h_perm.2.1 ], by rw [ show eta_2_2557 = ∑ x ∈ C2_2557, zeta_2557 ^ x.val from rfl, show eta_1_2557 = ∑ x ∈ C1_2557, zeta_2557 ^ x.val from rfl, h_eta_perm, h_perm.2.2 ] ⟩;
    · intro hn;
      -- By definition of $H_{2557}$, we know that $n^{852} = 1$.
      have hn_pow : (n : ZMod 2557)^852 = 1 := by
        exact Finset.mem_filter.mp hn |>.2;
      -- Since $n^{852} = 1$, multiplication by $n$ permutes the elements of $H_{2557}$, $C1_{2557}$, and $C2_{2557}$.
      have h_perm : Finset.image (fun x => (n : ZMod 2557) * x) H_2557 = H_2557 ∧ Finset.image (fun x => (n : ZMod 2557) * x) C1_2557 = C1_2557 ∧ Finset.image (fun x => (n : ZMod 2557) * x) C2_2557 = C2_2557 := by
        have h_perm : ∀ x ∈ H_2557, (n : ZMod 2557) * x ∈ H_2557 ∧ ∀ x ∈ C1_2557, (n : ZMod 2557) * x ∈ C1_2557 ∧ ∀ x ∈ C2_2557, (n : ZMod 2557) * x ∈ C2_2557 := by
          -- Since $n^{852} = 1$, multiplying any element of $H_{2557}$, $C1_{2557}$, or $C2_{2557}$ by $n$ will result in an element of the same set.
          intros x hx
          simp [H_2557, C1_2557, C2_2557, hn_pow] at hx ⊢;
          grind;
        refine' ⟨ Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr fun x hx => h_perm x hx |>.1 ) _, Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr fun x hx => h_perm _ hn |>.2 x hx |>.1 ) _, Finset.eq_of_subset_of_card_le ( Finset.image_subset_iff.mpr fun x hx => h_perm _ hn |>.2 _ ( Classical.choose_spec ( Finset.nonempty_of_ne_empty ( by native_decide ) ) ) |>.2 x hx ) _ ⟩;
        · rw [ Finset.card_image_of_injective _ fun x y hxy => by simpa using hxy ];
        · rw [ Finset.card_image_of_injective _ fun x y hxy => by simpa using hxy ];
        · rw [ Finset.card_image_of_injective _ fun x y hxy => by simpa using hxy ];
      -- Since multiplication by $n$ permutes the elements of $H_{2557}$, $C1_{2557}$, and $C2_{2557}$, we have:
      have h_sum_perm : ∀ S : Finset (ZMod 2557), Finset.image (fun x => (n : ZMod 2557) * x) S = S → ∑ x ∈ S, zeta_2557^(x.val) = ∑ x ∈ S, zeta_2557^((n : ZMod 2557) * x).val := by
        intros S hS_perm
        have h_sum_eq : ∑ x ∈ S, zeta_2557^(x.val) = ∑ x ∈ Finset.image (fun x => (n : ZMod 2557) * x) S, zeta_2557^(x.val) := by
          rw [hS_perm];
        rw [ h_sum_eq, Finset.sum_image ];
        exact fun x hx y hy hxy => by simpa using congr_arg ( fun x : ZMod 2557 => ( n⁻¹ : ZMod 2557 ) * x ) hxy;
      -- Apply the permutation property to each of the sums to conclude the proof.
      have h_sigma_perm : ∀ S : Finset (ZMod 2557), ∑ x ∈ S, zeta_2557^((n : ZMod 2557) * x).val = ∑ x ∈ S, (sigma_2557 n) (zeta_2557^(x.val)) := by
        intro S; refine' Finset.sum_congr rfl fun x hx => _; rw [ map_pow ] ; rw [ sigma_zeta_2557 ] ;
        rw [ ← pow_mul, ZMod.val_mul ];
        rw [ ← Nat.mod_add_div ( ( n : ZMod 2557 ).val * x.val ) 2557, pow_add, pow_mul ] ; norm_num;
        have h_zeta_pow : zeta_2557 ^ 2557 = 1 := by
          exact IsCyclotomicExtension.zeta_pow _ _ _;
        rw [ h_zeta_pow, one_pow, mul_one ];
      simp_all +contextual only [eta_0_2557, eta_1_2557, eta_2_2557];
      exact ⟨ by simpa only [ ← map_sum ] using h_sum_perm H_2557 h_perm.1 |> Eq.symm, by simpa only [ ← map_sum ] using h_sum_perm C1_2557 h_perm.2.1 |> Eq.symm, by simpa only [ ← map_sum ] using h_sum_perm C2_2557 h_perm.2.2 |> Eq.symm ⟩

/-
Prove the global permutation properties of sigma_n on alpha (renamed to v2 to avoid name collision).
-/
theorem global_permutation_2557_v2 (n : (ZMod 2557)ˣ) :
  ((n : ZMod 2557) ∈ C1_2557 → sigma_2557 n alpha_2557 = beta_2557) ∧
  ((n : ZMod 2557) ∈ C2_2557 → sigma_2557 n alpha_2557 = gamma_2557) ∧
  ((n : ZMod 2557) ∈ H_2557 → sigma_2557 n alpha_2557 = alpha_2557) := by
    convert global_permutation_2557 n using 80001

/-
Prove the global permutation properties for the integer roots.
-/
theorem global_permutation_int_2557 (n : (ZMod 2557)ˣ) :
  ((n : ZMod 2557) ∈ C1_2557 → sigma_int_2557 n alpha_int_2557 = beta_int_2557) ∧
  ((n : ZMod 2557) ∈ C2_2557 → sigma_int_2557 n alpha_int_2557 = gamma_int_2557) ∧
  ((n : ZMod 2557) ∈ H_2557 → sigma_int_2557 n alpha_int_2557 = alpha_int_2557) := by
    refine' ⟨ _, _, _ ⟩ <;> intros hn <;> have := global_permutation_2557_v2 n <;> simp_all +decide [ ← eq_sub_iff_add_eq' ];
    · convert this.1 using 1;
      constructor <;> intro h <;> apply_fun ( fun x => x : Ok_2557 → K_2557 ) at * <;> simp_all +decide [ alpha_int_coe_2557, beta_int_coe_2557, gamma_int_coe_2557 ];
      · unfold sigma_int_2557; simp_all +decide [ ← alpha_int_coe_2557, ← beta_int_coe_2557, ← gamma_int_coe_2557 ] ;
        convert h using 1;
        constructor <;> intro h <;> apply_fun ( fun x => x : Ok_2557 → K_2557 ) at * <;> simp_all +decide [ NumberField.RingOfIntegers.mapAlgEquiv ] ;
        · convert h using 1;
          constructor <;> intro h <;> apply_fun ( fun x => x : Ok_2557 → K_2557 ) at * <;> simp_all +decide [ NumberField.RingOfIntegers.mapAlgHom ];
          exact Subtype.coe_injective;
        · exact Subtype.coe_injective;
      · exact Subtype.coe_injective;
    · convert this.2.1 using 1;
      rw [ ← alpha_int_coe_2557, ← gamma_int_coe_2557 ];
      constructor <;> intro h <;> rcases h' : alpha_int_2557 with ⟨ x, hx ⟩ <;> rcases h'' : gamma_int_2557 with ⟨ y, hy ⟩ <;> simp_all +decide [ Subtype.ext_iff ] ;
      · convert congr_arg Subtype.val h using 1;
      · exact Subtype.ext h;
    · convert this.2.2 using 1;
      have h_sigma_int_eq : ∀ x y : Ok_2557, (sigma_int_2557 n) x = y ↔ (sigma_2557 n) (x : K_2557) = (y : K_2557) := by
        intro x y; exact ⟨ fun h => by
          convert congr_arg Subtype.val h using 1, fun h => by
          refine' Subtype.ext _;
          convert h using 1 ⟩ ;
      rw [ h_sigma_int_eq, alpha_int_coe_2557 ]

/-
The automorphism sigma_N reduces to the Frobenius map x |-> x^N modulo P.
-/
theorem artin_property_2557_thm (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 2557) (P : Ideal Ok_2557) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) (x : Ok_2557) :
  Ideal.Quotient.mk P (sigma_int_2557 (N_mod_2557 N hN) x) = (Ideal.Quotient.mk P x)^N := by
    -- Apply the Artin property theorem from exercise 19 to conclude the proof.
    apply artin_property_2557 N hN P hP x

/-
The Dream Theorem for q=2557.
-/
theorem final_result_2557 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 2557) (hN_odd : N % 2 = 1) (hN_a : Nat.Coprime 101 N)
  (P : Ideal Ok_2557) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  let alpha_bar := Ideal.Quotient.mk P alpha_int_2557
  let beta_bar := Ideal.Quotient.mk P beta_int_2557
  let gamma_bar := Ideal.Quotient.mk P gamma_int_2557
  (c_2557 N = s1_2557 → alpha_bar ^ N = gamma_bar) ∧
  (c_2557 N = s2_2557 → alpha_bar ^ N = beta_bar) := by
    constructor;
    · intro h₁
      have h₂ : (N : ZMod 2557) ∈ C2_2557 := by
        unfold c_2557 s1_2557 C2_2557 at *;
        simp_all +decide [ Finset.mem_filter, Finset.mem_univ ];
        intro h; simp_all +decide ;
      have h₃ : sigma_int_2557 (N_mod_2557 N hN) alpha_int_2557 = gamma_int_2557 := by
        convert global_permutation_int_2557 ( N_mod_2557 N hN ) |>.2.1 _;
        exact?;
      rw [ ← h₃, ← artin_property_2557_thm ];
      assumption;
    · -- Assume $c_2557 N = s2_2557$. Then $N^{852} \equiv s2_2557 \pmod{2557}$.
      intro hc
      have hN_in_C1 : (N : ZMod 2557) ∈ C1_2557 := by
        have hN_in_C1 : (N : ZMod 2557) ^ 852 = s2_2557 := by
          exact hc;
        have hN_nonzero : (N : ZMod 2557) ≠ 0 := by
          intro h; simp_all +decide [ ZMod.natCast_eq_zero_iff ] ;
        exact Finset.mem_filter.mpr ⟨ Finset.mem_filter.mpr ⟨ Finset.mem_univ _, hN_nonzero ⟩, hN_in_C1 ⟩;
      -- By the Artin property, we have $(\sigma_N(\alpha)) \equiv \alpha^N \pmod{P}$.
      have h_artin : Ideal.Quotient.mk P (sigma_int_2557 (N_mod_2557 N hN) alpha_int_2557) = (Ideal.Quotient.mk P alpha_int_2557)^N := by
        convert artin_property_2557_thm N hN P hP alpha_int_2557 using 1;
      rw [ ← h_artin, global_permutation_int_2557 _ |>.1 hN_in_C1 ]

/-
Properties of the cubic residues s1 and s2.
-/
lemma s1_s2_props :
  s1_2557 ^ 3 = 1 ∧ s2_2557 ^ 3 = 1 ∧ s1_2557 ≠ 1 ∧ s2_2557 ≠ 1 ∧ s1_2557 * s2_2557 = 1 ∧ s2_2557 = s1_2557^2 := by
    native_decide +revert

/-
Multiplication by an element of C1 permutes the cosets cyclically.
-/
lemma permute_cosets_2557_thm (n : (ZMod 2557)ˣ) :
  ((n : ZMod 2557) ∈ C1_2557 → Finset.image (fun x => (n : ZMod 2557) * x) H_2557 = C1_2557) ∧
  ((n : ZMod 2557) ∈ C1_2557 → Finset.image (fun x => (n : ZMod 2557) * x) C1_2557 = C2_2557) ∧
  ((n : ZMod 2557) ∈ C1_2557 → Finset.image (fun x => (n : ZMod 2557) * x) C2_2557 = H_2557) := by
    convert permute_cosets_2557 n using 1

/-
The automorphism sigma maps zeta to zeta^n.
-/
theorem sigma_zeta_2557_proven (n : (ZMod 2557)ˣ) : sigma_2557 n zeta_2557 = zeta_2557^(n : ZMod 2557).val := by
  exact?

/-
Action of sigma on the Gaussian periods.
-/
lemma sigma_eta_2557_proven (n : (ZMod 2557)ˣ) :
  ((n : ZMod 2557) ∈ C1_2557 → sigma_2557 n eta_0_2557 = eta_1_2557 ∧ sigma_2557 n eta_1_2557 = eta_2_2557 ∧ sigma_2557 n eta_2_2557 = eta_0_2557) ∧
  ((n : ZMod 2557) ∈ C2_2557 → sigma_2557 n eta_0_2557 = eta_2_2557 ∧ sigma_2557 n eta_1_2557 = eta_0_2557 ∧ sigma_2557 n eta_2_2557 = eta_1_2557) ∧
  ((n : ZMod 2557) ∈ H_2557 → sigma_2557 n eta_0_2557 = eta_0_2557 ∧ sigma_2557 n eta_1_2557 = eta_1_2557 ∧ sigma_2557 n eta_2_2557 = eta_2_2557) := by
    -- Apply the permutation properties to each case.
    apply sigma_eta_2557

/-
Multiplication by an element of C1 permutes the cosets cyclically.
-/
lemma permute_cosets_2557_proof (n : (ZMod 2557)ˣ) :
  ((n : ZMod 2557) ∈ C1_2557 → Finset.image (fun x => (n : ZMod 2557) * x) H_2557 = C1_2557) ∧
  ((n : ZMod 2557) ∈ C1_2557 → Finset.image (fun x => (n : ZMod 2557) * x) C1_2557 = C2_2557) ∧
  ((n : ZMod 2557) ∈ C1_2557 → Finset.image (fun x => (n : ZMod 2557) * x) C2_2557 = H_2557) := by
    convert permute_cosets_2557 n using 1

/-
Action of sigma on the Gaussian periods.
-/
lemma sigma_eta_2557_proof (n : (ZMod 2557)ˣ) :
  ((n : ZMod 2557) ∈ C1_2557 → sigma_2557 n eta_0_2557 = eta_1_2557 ∧ sigma_2557 n eta_1_2557 = eta_2_2557 ∧ sigma_2557 n eta_2_2557 = eta_0_2557) ∧
  ((n : ZMod 2557) ∈ C2_2557 → sigma_2557 n eta_0_2557 = eta_2_2557 ∧ sigma_2557 n eta_1_2557 = eta_0_2557 ∧ sigma_2557 n eta_2_2557 = eta_1_2557) ∧
  ((n : ZMod 2557) ∈ H_2557 → sigma_2557 n eta_0_2557 = eta_0_2557 ∧ sigma_2557 n eta_1_2557 = eta_1_2557 ∧ sigma_2557 n eta_2_2557 = eta_2_2557) := by
    convert sigma_eta_2557 n using 1

/-
Global permutation of alpha.
-/
lemma global_permutation_2557_proof (n : (ZMod 2557)ˣ) :
  ((n : ZMod 2557) ∈ C1_2557 → sigma_2557 n alpha_2557 = beta_2557) ∧
  ((n : ZMod 2557) ∈ C2_2557 → sigma_2557 n alpha_2557 = gamma_2557) ∧
  ((n : ZMod 2557) ∈ H_2557 → sigma_2557 n alpha_2557 = alpha_2557) := by
    convert global_permutation_2557_v2 n using 1

/-
Verify the polynomial relations for beta and gamma with corrected sign.
-/
lemma check_polynomial_identity_2557_corrected :
  let alpha : Polynomial ℚ := Polynomial.X
  let beta : Polynomial ℚ := (3 * alpha^2 - 55 * alpha - 5114) * Polynomial.C (101 : ℚ)⁻¹
  let gamma : Polynomial ℚ := (-3 * alpha^2 - 46 * alpha + 5114) * Polynomial.C (101 : ℚ)⁻¹
  let modulus : Polynomial ℚ := alpha^3 - 2557 * alpha - 2557
  (beta^2 + alpha * beta + (alpha^2 - 2557)) % modulus = 0 ∧
  (gamma^2 + alpha * gamma + (alpha^2 - 2557)) % modulus = 0 ∧
  (beta + gamma + alpha) % modulus = 0 := by
    -- By definition of polynomial remainder, we know that if the remainder is zero, then the polynomial is divisible by the divisor.
    simp [Polynomial.mod_def];
    erw [ Polynomial.leadingCoeff, Polynomial.natDegree_sub_C ] ; norm_num [ Polynomial.natDegree_sub_eq_left_of_natDegree_lt ] ; ring_nf ; norm_num [ Polynomial.coeff_one, Polynomial.coeff_X ] ;
    erw [ show ( - ( Polynomial.X * 2557 ) + ( Polynomial.X ^ 3 - 2557 ) : Polynomial ℚ ) = ( Polynomial.X ^ 3 - 2557 * Polynomial.X - 2557 ) by ring ];
    erw [ Polynomial.modByMonic_eq_zero_iff_dvd ];
    · erw [ Polynomial.modByMonic_eq_zero_iff_dvd ];
      · exact ⟨ by exact ⟨ Polynomial.C ( 1 / 101 ) * 3 - Polynomial.C ( 1 / 10201 ) * 330 + Polynomial.C ( 1 / 10201 ) * 9 * Polynomial.X, by exact Polynomial.funext fun x => by norm_num; ring ⟩, by exact ⟨ Polynomial.C ( 1 / 101 ) * -3 + Polynomial.C ( 1 / 10201 ) * 276 + Polynomial.C ( 1 / 10201 ) * 9 * Polynomial.X, by exact Polynomial.funext fun x => by norm_num; ring ⟩, by erw [ show ( Polynomial.X - Polynomial.C ( 1 / 101 ) * Polynomial.X * 101 : Polynomial ℚ ) = 0 by exact Polynomial.funext fun x => by norm_num; ring ] ; norm_num ⟩;
      · rw [ Polynomial.Monic, Polynomial.leadingCoeff ];
        erw [ Polynomial.natDegree_sub_C, Polynomial.natDegree_sub_eq_left_of_natDegree_lt ] <;> norm_num [ Polynomial.coeff_X ];
    · rw [ Polynomial.Monic, Polynomial.leadingCoeff ];
      erw [ Polynomial.natDegree_sub_C, Polynomial.natDegree_sub_eq_left_of_natDegree_lt ] <;> norm_num [ Polynomial.coeff_X ]

/-
Check constants.
-/
#eval (835 * 835) % 2557
#eval 1721
#eval (835 * 1721) % 2557
#eval (835 * 835 * 835) % 2557

/-
Coercion of integer roots to field roots.
-/
theorem alpha_int_coe_2557_proof : (alpha_int_2557 : K_2557) = alpha_2557 := by
  simp [alpha_int_2557, alpha_2557, eta_2_int_2557, eta_1_int_2557, eta_2_2557, eta_1_2557, eta_int_2557, eta_2557, zeta_int_2557]

theorem beta_int_coe_2557_proof : (beta_int_2557 : K_2557) = beta_2557 := by
  simp [beta_int_2557, beta_2557, eta_0_int_2557, eta_2_int_2557, eta_0_2557, eta_2_2557, eta_int_2557, eta_2557, zeta_int_2557]

theorem gamma_int_coe_2557_proof : (gamma_int_2557 : K_2557) = gamma_2557 := by
  simp [gamma_int_2557, gamma_2557, eta_1_int_2557, eta_0_int_2557, eta_1_2557, eta_0_2557, eta_int_2557, eta_2557, zeta_int_2557]

/-
Global permutation of integer roots.
-/
theorem global_permutation_int_2557_proof (n : (ZMod 2557)ˣ) :
  ((n : ZMod 2557) ∈ C1_2557 → sigma_int_2557 n alpha_int_2557 = beta_int_2557) ∧
  ((n : ZMod 2557) ∈ C2_2557 → sigma_int_2557 n alpha_int_2557 = gamma_int_2557) ∧
  ((n : ZMod 2557) ∈ H_2557 → sigma_int_2557 n alpha_int_2557 = alpha_int_2557) := by
    exact?

/-
Artin property for zeta.
-/
theorem artin_property_zeta_2557_proof (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 2557) (P : Ideal Ok_2557) [P.IsPrime] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  Ideal.Quotient.mk P (sigma_int_2557 (N_mod_2557 N hN) zeta_int_2557) = (Ideal.Quotient.mk P zeta_int_2557)^N := by
    convert artin_property_2557 N hN P hP zeta_int_2557 using 1

/-
Definitions of cyclotomic numbers and period constants.
-/
def cyclotomic_num_2557 (i j : Fin 3) : ℕ :=
  let Ci := if i = 0 then H_2557 else if i = 1 then C1_2557 else C2_2557
  let Cj := if j = 0 then H_2557 else if j = 1 then C1_2557 else C2_2557
  (Ci.product Cj).filter (fun x : ZMod 2557 × ZMod 2557 => x.1 + x.2 ∈ H_2557) |>.card

def period_const_2557 (i j : Fin 3) : ℤ :=
  let Ci := if i = 0 then H_2557 else if i = 1 then C1_2557 else C2_2557
  let Cj := if j = 0 then H_2557 else if j = 1 then C1_2557 else C2_2557
  (Ci.product Cj).filter (fun x : ZMod 2557 × ZMod 2557 => x.1 + x.2 = 0) |>.card

/-
Compute cyclotomic numbers and period constants.
-/
#eval cyclotomic_num_2557 0 0
#eval cyclotomic_num_2557 0 1
#eval cyclotomic_num_2557 0 2
#eval cyclotomic_num_2557 1 0
#eval cyclotomic_num_2557 1 1
#eval cyclotomic_num_2557 1 2
#eval cyclotomic_num_2557 2 0
#eval cyclotomic_num_2557 2 1
#eval cyclotomic_num_2557 2 2

#eval period_const_2557 0 0
#eval period_const_2557 0 1
#eval period_const_2557 0 2
#eval period_const_2557 1 0
#eval period_const_2557 1 1
#eval period_const_2557 1 2
#eval period_const_2557 2 0
#eval period_const_2557 2 1
#eval period_const_2557 2 2

/-
Verify the cyclotomic numbers.
-/
def cyc_num_2557 (i j : Fin 3) : ℕ :=
  let Ci := if i = 0 then H_2557 else if i = 1 then C1_2557 else C2_2557
  let Cj := if j = 0 then H_2557 else if j = 1 then C1_2557 else C2_2557
  (Ci.product Cj).filter (fun x : ZMod 2557 × ZMod 2557 => x.1 + x.2 = 1) |>.card

lemma check_cyc_00 : cyc_num_2557 0 0 = 272 := by native_decide
lemma check_cyc_01 : cyc_num_2557 0 1 = 290 := by native_decide
lemma check_cyc_02 : cyc_num_2557 0 2 = 289 := by native_decide
lemma check_cyc_10 : cyc_num_2557 1 0 = 290 := by native_decide
lemma check_cyc_11 : cyc_num_2557 1 1 = 289 := by native_decide
lemma check_cyc_12 : cyc_num_2557 1 2 = 273 := by native_decide
lemma check_cyc_20 : cyc_num_2557 2 0 = 289 := by native_decide
lemma check_cyc_21 : cyc_num_2557 2 1 = 273 := by native_decide
lemma check_cyc_22 : cyc_num_2557 2 2 = 290 := by native_decide

/-
Compute the correct cyclotomic numbers.
-/
#eval cyc_num_2557 0 0
#eval cyc_num_2557 0 1
#eval cyc_num_2557 0 2
#eval cyc_num_2557 1 0
#eval cyc_num_2557 1 1
#eval cyc_num_2557 1 2
#eval cyc_num_2557 2 0
#eval cyc_num_2557 2 1
#eval cyc_num_2557 2 2

/-
The roots of x^3=1 in ZMod 2557.
-/
lemma roots_of_unity_props :
  {x : ZMod 2557 | x^3 = 1} = {1, s1_2557, s2_2557} := by
  ext x
  simp
  constructor
  · intro h
    -- This direction is hard for ATP without calculation.
    -- But we know there are at most 3 roots.
    -- And we know 1, s1, s2 are roots.
    -- So if they are distinct, they are all the roots.
    native_decide +revert
  · rintro (rfl|rfl|rfl)
    · norm_num
    · exact s1_s2_props.1
    · exact s1_s2_props.2.1

/-
The cosets partition the units.
-/
lemma units_partition :
  let units := Finset.univ.filter (fun x : ZMod 2557 => x ≠ 0)
  units = H_2557 ∪ C1_2557 ∪ C2_2557 ∧
  Disjoint H_2557 C1_2557 ∧ Disjoint H_2557 C2_2557 ∧ Disjoint C1_2557 C2_2557 := by
    native_decide +revert

/-
The sum of the Gaussian periods is -1.
-/
lemma sum_eta_eq_minus_one_2557 : eta_0_2557 + eta_1_2557 + eta_2_2557 = -1 := by
  -- The sum of all zeta^x over the units is zero because it's a geometric series with sum zero.
  have h_sum_units : ∑ x ∈ Finset.univ.filter (fun x : ZMod 2557 => x ≠ 0), zeta_2557^(x.val) = -1 := by
    -- The sum of all powers of zeta_2557 is zero because it forms a geometric series with ratio zeta_2557.
    have h_sum_all : ∑ x ∈ Finset.range 2557, zeta_2557^x = 0 := by
      rw [ geom_sum_eq ];
      · have h_zeta_pow : zeta_2557 ^ 2557 = 1 := by
          exact IsCyclotomicExtension.zeta_pow 2557 ℚ K_2557
        rw [h_zeta_pow]
        simp;
      · -- By definition of $zeta_2557$, we know that $zeta_2557$ is a primitive 2557th root of unity.
        have h_primitive : IsPrimitiveRoot zeta_2557 2557 := by
          convert IsCyclotomicExtension.zeta_spec 2557 ℚ K_2557;
        exact h_primitive.ne_one ( by decide );
    rw [ Finset.sum_eq_add_sum_diff_singleton ( Finset.mem_range.mpr ( Nat.succ_pos _ ) ) ] at h_sum_all;
    rw [ show ( Finset.range ( Nat.succ 2556 ) \ { 0 } : Finset ℕ ) = Finset.image ( fun x : ZMod 2557 => x.val ) ( Finset.univ.filter ( fun x : ZMod 2557 => x ≠ 0 ) ) from by native_decide, Finset.sum_image ] at h_sum_all;
    · linear_combination' h_sum_all;
    · native_decide +revert;
  rw [ ← h_sum_units, show ( Finset.univ.filter fun x : ZMod 2557 => ¬x = 0 ) = H_2557 ∪ C1_2557 ∪ C2_2557 from ?_, Finset.sum_union, Finset.sum_union ];
  · rfl;
  · native_decide +revert;
  · native_decide +revert;
  · native_decide +revert

/-
Definition of C_func.
-/
def C_func (i : Fin 3) : Finset (ZMod 2557) :=
  if i = 0 then H_2557 else if i = 1 then C1_2557 else C2_2557

/-
Definition of eta_func.
-/
noncomputable def eta_func (i : Fin 3) : K_2557 :=
  ∑ x ∈ C_func i, zeta_2557^(x.val)

/-
Link eta_func to eta_0, eta_1, eta_2.
-/
lemma eta_eq_eta_func :
  eta_0_2557 = eta_func 0 ∧ eta_1_2557 = eta_func 1 ∧ eta_2_2557 = eta_func 2 := by
    exact ⟨ rfl, rfl, rfl ⟩

/-
-1 is in H.
-/
lemma neg_one_in_H : (-1 : ZMod 2557) ∈ H_2557 := by
  native_decide +revert

/-
Negation preserves coset membership.
-/
lemma neg_mem_C_func_iff (i : Fin 3) (x : ZMod 2557) : -x ∈ C_func i ↔ x ∈ C_func i := by
  native_decide +revert

/-
Constant term of the product expansion.
-/
lemma constant_term_lemma (i j : Fin 3) :
  (Finset.filter (fun p : ZMod 2557 × ZMod 2557 => p.1 + p.2 = 0) (C_func i ×ˢ C_func j)).card = if i = j then 852 else 0 := by
    native_decide +revert

/-
The number of solutions to x+y=z depends only on the coset of z.
-/
lemma coeff_lemma (i j k : Fin 3) (z : ZMod 2557) (hz : z ∈ C_func k) :
  (Finset.filter (fun p : ZMod 2557 × ZMod 2557 => p.1 + p.2 = z) (C_func i ×ˢ C_func j)).card = cyc_num_2557 (i - k) (j - k) := by
    -- By definition of $C_func$, we know that $z^{-1} \in C_func (-k)$.
    have hz_inv : z⁻¹ ∈ C_func (-k) := by
      native_decide +revert;
    -- We'll use the fact that multiplication by a unit preserves the cardinality of sets.
    have h_bij : Finset.filter (fun p : ZMod 2557 × ZMod 2557 => p.1 + p.2 = z) (C_func i ×ˢ C_func j) = Finset.image (fun p => (p.1 * z, p.2 * z)) (Finset.filter (fun p : ZMod 2557 × ZMod 2557 => p.1 + p.2 = 1) (C_func (i - k) ×ˢ C_func (j - k))) := by
      ext ⟨x, y⟩; simp [hz, hz_inv];
      constructor <;> intro hxy
      all_goals generalize_proofs at *;
      · use x * z⁻¹, y * z⁻¹;
        have h_mul : ∀ (i : Fin 3) (x : ZMod 2557), x ∈ C_func i → x * z⁻¹ ∈ C_func (i - k) := by
          intro i x hxop;
          fin_cases i <;> fin_cases k <;> simp +decide [ *, C_func ] at hxop ⊢;
          all_goals unfold C_func at *; simp +decide [ *, H_2557, C1_2557, C2_2557 ] at *;
          all_goals simp +decide [ *, mul_pow ] ;
          all_goals intro H; have := congr_arg ( · ^ 852 ) H; norm_num [ hxop, hz_inv ] at this;
          all_goals haveI := Fact.mk ( by norm_num : Nat.Prime 2557 ) ; simp_all +decide [ mul_eq_zero ] ;
        have h_mul : x * z⁻¹ + y * z⁻¹ = 1 := by
          rw [ ← add_mul, hxy.2 ];
          have h_mul : z ≠ 0 := by
            fin_cases k <;> simp +decide [ C_func ] at hz ⊢ <;> simp_all +decide [ Finset.mem_filter ];
            · exact Finset.mem_filter.mp hz |>.2 |> fun h => by simp_all +decide [ H_2557 ] ;
            · exact fun h => by rw [ h ] at hz; exact absurd hz ( by native_decide ) ;
            · exact fun h => by rw [ h ] at hz; exact absurd hz ( by native_decide ) ;
          generalize_proofs at *; (
          haveI := Fact.mk ( by native_decide : Nat.Prime 2557 ) ; exact mul_inv_cancel₀ h_mul;);
        grind;
      · rcases hxy with ⟨ a, b, ⟨ ⟨ ha, hb ⟩, hab ⟩, rfl, rfl ⟩ ; simp_all +decide [ ← eq_sub_iff_add_eq' ] ;
        -- By definition of $C_func$, we know that $a * z \in C_func i$ and $(1 - a) * z \in C_func j$.
        have h_mul : ∀ i : Fin 3, ∀ x : ZMod 2557, x ∈ C_func i → x * z ∈ C_func (i + k) := by
          unfold C_func at *; simp +decide [ Finset.mem_filter, Finset.mem_product ] at *;
          fin_cases k <;> simp +decide [ H_2557, C1_2557, C2_2557 ] at hz ⊢;
          · grind;
          · intro i x hx; fin_cases i <;> simp +decide [ *, Finset.mem_filter, Finset.mem_product ] at hx ⊢;
            · grind;
            · native_decide +revert;
            · simp +decide [ *, mul_pow ];
              haveI := Fact.mk ( by norm_num : Nat.Prime 2557 ) ; exact mul_ne_zero hx.1 hz.1;
          · intro i x hx; fin_cases i <;> simp +decide [ *, Finset.mem_filter, Finset.mem_univ ] at hx ⊢;
            · grind;
            · simp +decide [ *, mul_pow ];
              haveI := Fact.mk ( by norm_num : Nat.Prime 2557 ) ; exact mul_ne_zero hx.1 hz.1;
            · native_decide +revert
        generalize_proofs at *;
        exact ⟨ ⟨ by simpa using h_mul ( i - k ) a ha, by simpa using h_mul ( j - k ) ( 1 - a ) hb ⟩, by ring ⟩;
    rw [ h_bij, Finset.card_image_of_injOn ];
    · rfl;
    · intro p hp q hq h_eq; simp_all +decide [ Prod.ext_iff ] ;
      have hz_ne_zero : z ≠ 0 := by
        intro h; simp_all +decide [ C_func ] ;
        fin_cases k <;> exact absurd hz ( by native_decide );
      haveI := Fact.mk ( by native_decide : Nat.Prime 2557 ) ; exact ⟨ mul_right_cancel₀ hz_ne_zero h_eq.1, mul_right_cancel₀ hz_ne_zero h_eq.2 ⟩ ;

/-
Expansion of the non-constant part of the product of periods.
-/
lemma sum_non_zero_terms (i j : Fin 3) :
  ∑ x ∈ C_func i, ∑ y ∈ C_func j, (if x + y ≠ 0 then zeta_2557^(x.val + y.val) else 0) =
  ∑ k : Fin 3, (cyc_num_2557 (i - k) (j - k)) • eta_func k := by
    -- By Fubini's theorem, we can interchange the order of summation.
    have h_fubini : ∑ x ∈ C_func i, ∑ y ∈ C_func j, (if x + y ≠ 0 then zeta_2557 ^ (x.val + y.val) else 0) = ∑ z ∈ Finset.univ.filter (fun x => x ≠ 0), (∑ x ∈ C_func i, ∑ y ∈ C_func j, (if x + y = z then zeta_2557 ^ (x.val + y.val) else 0)) := by
      rw [ Finset.sum_comm, Finset.sum_congr rfl ];
      exact?;
      intro x hx; rw [ Finset.sum_comm ] ; simp +decide [ Finset.sum_ite ] ;
    -- For each $z \in C_k$, the inner sum $\sum_{x \in C_i, y \in C_j} \zeta^{x+y}$ is equal to $\text{cyc\_num}(i-k, j-k) \cdot \zeta^z$.
    have h_inner_sum : ∀ k : Fin 3, ∀ z ∈ C_func k, ∑ x ∈ C_func i, ∑ y ∈ C_func j, (if x + y = z then zeta_2557 ^ (x.val + y.val) else 0) = cyc_num_2557 (i - k) (j - k) * zeta_2557 ^ (z.val) := by
      intros k z hz
      have h_inner_sum_eq : ∑ x ∈ C_func i, ∑ y ∈ C_func j, (if x + y = z then zeta_2557 ^ (x.val + y.val) else 0) = (∑ x ∈ C_func i, ∑ y ∈ C_func j, (if x + y = z then 1 else 0)) * zeta_2557 ^ (z.val) := by
        simp +contextual only [Finset.sum_mul _ _ _];
        refine' Finset.sum_congr rfl fun x hx => Finset.sum_congr rfl fun y hy => _;
        split_ifs <;> simp_all +decide [ ← ZMod.natCast_eq_zero_iff ];
        rw [ ← ‹x + y = z›, ZMod.val_add ];
        rw [ ← Nat.mod_add_div ( x.val + y.val ) 2557, pow_add, pow_mul ] ; norm_num [ zeta_2557 ];
        rw [ show IsCyclotomicExtension.zeta 2557 ℚ K_2557 ^ 2557 = 1 from by exact? ] ; norm_num;
      have := coeff_lemma i j k z hz; simp_all +decide [ Finset.sum_ite ] ;
      rw [ ← this, Finset.card_filter ];
      rw [ Finset.sum_product ] ; simp +contextual [ Finset.sum_ite ] ;
    -- By grouping the terms based on the coset $k$ that $z$ belongs to, we can rewrite the outer sum.
    have h_group : ∑ z ∈ Finset.univ.filter (fun x => x ≠ 0), (∑ x ∈ C_func i, ∑ y ∈ C_func j, (if x + y = z then zeta_2557 ^ (x.val + y.val) else 0)) = ∑ k : Fin 3, ∑ z ∈ C_func k, (∑ x ∈ C_func i, ∑ y ∈ C_func j, (if x + y = z then zeta_2557 ^ (x.val + y.val) else 0)) := by
      rw [ ← Finset.sum_biUnion ];
      · rw [ show ( Finset.univ.biUnion C_func : Finset ( ZMod 2557 ) ) = Finset.univ.filter ( fun x : ZMod 2557 => x ≠ 0 ) from ?_ ];
        native_decide +revert;
      · intro i hi j hj hij; simp_all +decide [ Finset.disjoint_left, Set.PairwiseDisjoint ] ;
        native_decide +revert;
    rw [ h_fubini, h_group, Finset.sum_congr rfl fun k hk => Finset.sum_congr rfl fun z hz => h_inner_sum k z hz ] ; simp +decide [ Finset.mul_sum _ _ _, mul_assoc, mul_left_comm, Finset.sum_mul ] ; ring;
    exact Finset.sum_congr rfl fun _ _ => by rw [ ← Finset.mul_sum _ _ _ ] ; rfl;

/-
General multiplication formula for Gaussian periods.
-/
lemma mul_eta_expansion_lemma (i j : Fin 3) :
  eta_func i * eta_func j =
  (∑ k : Fin 3, (cyc_num_2557 (i - k) (j - k)) • eta_func k) +
  if i = j then 852 else 0 := by
    -- Let's split the sum into zero and non-zero parts.
    have h_split : ∑ x ∈ C_func i, ∑ y ∈ C_func j, zeta_2557^(x.val + y.val) = (∑ x ∈ C_func i, ∑ y ∈ C_func j, (if x + y ≠ 0 then zeta_2557^(x.val + y.val) else 0)) + (∑ x ∈ C_func i, ∑ y ∈ C_func j, (if x + y = 0 then zeta_2557^(x.val + y.val) else 0)) := by
      simpa only [ ← Finset.sum_add_distrib ] using Finset.sum_congr rfl fun x hx => Finset.sum_congr rfl fun y hy => by aesop;
    -- Apply the lemmas to compute the constant and non-constant parts.
    have h_const : ∑ x ∈ C_func i, ∑ y ∈ C_func j, (if x + y = 0 then zeta_2557^(x.val + y.val) else 0) = if i = j then 852 else 0 := by
      have h_const : ∑ x ∈ C_func i, ∑ y ∈ C_func j, (if x + y = 0 then zeta_2557^(x.val + y.val) else 0) = ∑ x ∈ C_func i, ∑ y ∈ C_func j, (if x + y = 0 then 1 else 0) := by
        refine' Finset.sum_congr rfl fun x hx => Finset.sum_congr rfl fun y hy => _;
        split_ifs <;> simp_all +decide [ add_eq_zero_iff_eq_neg ];
        have h_exp : (-y).val + y.val ≡ 0 [MOD 2557] := by
          have h_exp : (-y).val + y.val ≡ 0 [ZMOD 2557] := by
            erw [ ← ZMod.intCast_eq_intCast_iff ] ; norm_num;
          exact Int.natCast_modEq_iff.mp h_exp;
        rw [ ← Nat.mod_add_div ( ( -y |> ZMod.val ) + y.val ) 2557, h_exp ] ; norm_num [ pow_add, pow_mul, zeta_2557 ] ;
        rw [ IsCyclotomicExtension.zeta_pow ] ; norm_num;
      rw [h_const];
      convert constant_term_lemma i j using 1;
      simp +decide only [Finset.card_filter, Finset.sum_product];
      norm_cast;
    convert h_split.trans ( congr_arg₂ ( · + · ) ( sum_non_zero_terms i j ) h_const ) using 1;
    simp +decide only [eta_func, Finset.sum_mul _ _ _, pow_add];
    simp +decide only [Finset.mul_sum _ _ _]

/-
Values of cyclotomic numbers.
-/
lemma cyc_num_simp (i j : Fin 3) :
  cyc_num_2557 i j =
  if i = 0 then
    if j = 0 then 272 else if j = 1 then 290 else 289
  else if i = 1 then
    if j = 0 then 290 else if j = 1 then 289 else 273
  else
    if j = 0 then 289 else if j = 1 then 273 else 290 := by
  fin_cases i <;> fin_cases j <;> native_decide

/-
Prove the period equation.
-/
theorem period_equation_proven : PeriodEquation_2557 := by
  have h_sum_eta : eta_0_2557 + eta_1_2557 + eta_2_2557 = -1 := by
    convert sum_eta_eq_minus_one_2557 using 1;
  -- By definition of $C_func$, we know that $mul_eta_expansion_lemma$ holds.
  have h_mul_eta_expansion : ∀ i j : Fin 3, eta_func i * eta_func j = (∑ k : Fin 3, (cyc_num_2557 (i - k) (j - k)) • eta_func k) + (if i = j then 852 else 0) := by
    intros i j; exact mul_eta_expansion_lemma i j;
  generalize_proofs at *; (
  -- By definition of $eta_func$, we know that $eta_func i = eta_i$.
  have h_eta_func_eq : eta_func 0 = eta_0_2557 ∧ eta_func 1 = eta_1_2557 ∧ eta_func 2 = eta_2_2557 := by
    exact ⟨ rfl, rfl, rfl ⟩
  generalize_proofs at *; (
  simp_all +decide [ Fin.sum_univ_three, cyc_num_simp ];
  exact mul_left_cancel₀ ( show ( eta_2_2557 - eta_1_2557 ) ≠ 0 from sub_ne_zero_of_ne <| by
                            grind ) <| by
                            unfold alpha_2557; ring;
                            grind;))

/-
Prove the algebraic relation for beta.
-/
theorem relation_beta_2557_proven : 101 * beta_2557 = 3 * alpha_2557^2 - 55 * alpha_2557 - 5114 := by
  -- Apply the lemma_period老手帮助
  have := @mul_eta_expansion_lemma; (
  have h_beta : alpha_2557^3 = 2557 * alpha_2557 + 2557 := by
    convert period_equation_proven;
  have h_beta : beta_2557 = eta_func 0 - eta_func 2 ∧ alpha_2557 = eta_func 2 - eta_func 1 := by
    exact ⟨ rfl, rfl ⟩;
  simp_all +decide [ Fin.sum_univ_three ];
  simp_all +decide [ Fin.forall_fin_succ, cyc_num_simp ];
  grind +ring)

/-
Multiplication formula for Gaussian periods.
-/
lemma mul_eta_expansion_2557 (i j : Fin 3) :
  eta_func i * eta_func j =
  (∑ k : Fin 3, (cyc_num_2557 (i - k) (j - k)) • eta_func k) +
  if i = j then 852 else 0 := by
    convert mul_eta_expansion_lemma i j using 1

/-
Prove the corrected algebraic relation for gamma.
-/
theorem relation_gamma_2557_corrected : 101 * gamma_2557 = -3 * alpha_2557^2 - 46 * alpha_2557 + 5114 := by
  -- Using the relation for beta, we can derive the relation for gamma.
  have h_gamma : 101 * gamma_2557 = 101 * (eta_1_2557 - eta_0_2557) := by
    rfl;
  have h_gamma_sub : 101 * (eta_1_2557 - eta_0_2557) = -3 * (eta_2_2557 - eta_1_2557)^2 - 46 * (eta_2_2557 - eta_1_2557) + 5114 := by
    have h_beta : 101 * (eta_0_2557 - eta_2_2557) = 3 * (eta_2_2557 - eta_1_2557)^2 - 55 * (eta_2_2557 - eta_1_2557) - 5114 := by
      have h_beta : 101 * beta_2557 = 3 * alpha_2557^2 - 55 * alpha_2557 - 5114 := by
        convert relation_beta_2557_proven using 1;
      exact h_beta
    grind;
  exact h_gamma.trans h_gamma_sub

/-
Expansion of alpha^2.
-/
lemma alpha_sq_expansion : alpha_2557^2 = 33 * eta_0_2557 - 19 * eta_1_2557 - 16 * eta_2_2557 + 1704 := by
  -- Substitute the expressions for alpha, beta, and gamma into the equation.
  have h_sub : (eta_2_2557 - eta_1_2557)^2 = 33 * eta_0_2557 - 19 * eta_1_2557 - 16 * eta_2_2557 + 1704 := by
    have h_beta : 101 * (eta_0_2557 - eta_2_2557) = 3 * (eta_2_2557 - eta_1_2557)^2 - 55 * (eta_2_2557 - eta_1_2557) - 5114 := by
      convert relation_beta_2557_proven using 1
    have h_gamma : 101 * (eta_1_2557 - eta_0_2557) = -3 * (eta_2_2557 - eta_1_2557)^2 - 46 * (eta_2_2557 - eta_1_2557) + 5114 := by
      grind
    have h_sum : eta_0_2557 + eta_1_2557 + eta_2_2557 = -1 := by
      convert sum_eta_eq_minus_one_2557 using 1;
    grind +ring;
  exact h_sub

/-
Prove the algebraic relation for beta.
-/
theorem relation_beta_2557_proven_final : 101 * beta_2557 = 3 * alpha_2557^2 - 55 * alpha_2557 - 5114 := by
  rw [alpha_sq_expansion]
  unfold alpha_2557 beta_2557
  have h_sum : eta_0_2557 + eta_1_2557 + eta_2_2557 = -1 := sum_eta_eq_minus_one_2557
  linear_combination 2 * h_sum

/-
Prove the algebraic relation for gamma.
-/
theorem relation_gamma_2557_proven_final : 101 * gamma_2557 = -3 * alpha_2557^2 - 46 * alpha_2557 + 5114 := by
  rw [alpha_sq_expansion]
  unfold alpha_2557 gamma_2557
  have h_sum : eta_0_2557 + eta_1_2557 + eta_2_2557 = -1 := sum_eta_eq_minus_one_2557
  linear_combination -2 * h_sum

/-
Corrected cyclic relations in Ok (retry).
-/
def CyclicRelationsInt_2557_Corrected : Prop :=
  101 * beta_int_2557 = 3 * alpha_int_2557^2 - 55 * alpha_int_2557 - 5114 ∧
  101 * gamma_int_2557 = -3 * alpha_int_2557^2 - 46 * alpha_int_2557 + 5114

theorem cyclic_relations_int_2557_proof_corrected : CyclicRelationsInt_2557_Corrected := by
  -- By definition of $alpha_int_2557$, $beta_int_2557$, and $gamma_int_2557$, we have:
  have h_alpha_int_coe : (alpha_int_2557 : K_2557) = alpha_2557 := by
    convert alpha_int_coe_2557
  have h_beta_int_coe : (beta_int_2557 : K_2557) = beta_2557 := by
    convert beta_int_coe_2557
  have h_gamma_int_coe : (gamma_int_2557 : K_2557) = gamma_2557 := by
    convert gamma_int_coe_2557;
  -- Substitute the integer roots with their field counterparts using the equalities h_alpha_int_coe, h_beta_int_coe, and h_gamma_int_coe.
  have h_subst : (101 * beta_int_2557 : K_2557) = (3 * alpha_int_2557^2 - 55 * alpha_int_2557 - 5114 : K_2557) ∧ (101 * gamma_int_2557 : K_2557) = (-3 * alpha_int_2557^2 - 46 * alpha_int_2557 + 5114 : K_2557) := by
    -- Substitute the integer roots with their field counterparts using the equalities h_alpha_int_coe, h_beta_int_coe, and h_gamma_int_coe, and then apply the relations relation_beta_2557_proven_final and relation_gamma_2557_proven_final.
    simp [h_alpha_int_coe, h_beta_int_coe, h_gamma_int_coe, relation_beta_2557_proven_final, relation_gamma_2557_proven_final];
  -- Since the embedding of Ok_2557 into K_2557 is injective, the equality in the field K_2557 implies the equality in the ring of integers Ok_2557.
  have h_inj : Function.Injective (algebraMap Ok_2557 K_2557) := by
    exact Subtype.coe_injective;
  exact ⟨ h_inj <| by simpa using h_subst.1, h_inj <| by simpa using h_subst.2 ⟩

/-
Multiplication by C1 permutes cosets (proven).
-/
lemma permute_cosets_2557_proven (n : (ZMod 2557)ˣ) :
  ((n : ZMod 2557) ∈ C1_2557 → Finset.image (fun x => (n : ZMod 2557) * x) H_2557 = C1_2557) ∧
  ((n : ZMod 2557) ∈ C1_2557 → Finset.image (fun x => (n : ZMod 2557) * x) C1_2557 = C2_2557) ∧
  ((n : ZMod 2557) ∈ C1_2557 → Finset.image (fun x => (n : ZMod 2557) * x) C2_2557 = H_2557) := by
    convert permute_cosets_2557 n using 1

/-
Explicit Frobenius action on alpha_bar.
-/
theorem explicit_frobenius_2557 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 2557) (hN_a : Nat.Coprime 101 N)
  (P : Ideal Ok_2557) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  let alpha_bar := Ideal.Quotient.mk P alpha_int_2557
  ((N : ZMod 2557) ∈ C1_2557 → 101 * alpha_bar ^ N = 3 * alpha_bar ^ 2 - 55 * alpha_bar - 5114) ∧
  ((N : ZMod 2557) ∈ C2_2557 → 101 * alpha_bar ^ N = -3 * alpha_bar ^ 2 - 46 * alpha_bar + 5114) := by
    refine' ⟨ _, _ ⟩ <;> intro h <;> have := @cyclic_relations_int_2557_proof_corrected <;> simp_all +decide [ ← mul_assoc, ← map_mul, ← map_pow ];
    · -- Apply the artin property to relate `alpha_bar^N` to `sigma_int N alpha_int`.
      have h_artin : (Ideal.Quotient.mk P) (sigma_int_2557 (N_mod_2557 N hN) alpha_int_2557) = (Ideal.Quotient.mk P) (alpha_int_2557)^N := by
        convert artin_property_2557_thm N hN P hP alpha_int_2557 using 1;
      -- Apply the global permutation property to relate `sigma_int N alpha_int` to `beta_int`.
      have h_global_perm : (sigma_int_2557 (N_mod_2557 N hN) alpha_int_2557) = beta_int_2557 := by
        convert global_permutation_int_2557_proof ( N_mod_2557 N hN ) |> And.left <| ?_ using 1
        generalize_proofs at *; (
        unfold N_mod_2557; aesop;);
      simp_all +decide [ ← h_artin ];
      convert congr_arg ( Ideal.Quotient.mk P ) this.1 using 1;
    · -- Apply the Artin property to relate `alpha_bar^N` to `sigma_int N alpha_int`.
      have h_artin : (Ideal.Quotient.mk P) (sigma_int_2557 (N_mod_2557 N hN) alpha_int_2557) = (Ideal.Quotient.mk P alpha_int_2557)^N := by
        convert artin_property_2557_thm N hN P hP alpha_int_2557 using 1;
      -- Apply the global permutation property to relate `sigma_int N alpha_int` to `gamma_int`.
      have h_global : sigma_int_2557 (N_mod_2557 N hN) alpha_int_2557 = gamma_int_2557 := by
        convert global_permutation_int_2557_proof (N_mod_2557 N hN) |>.2.1 _;
        unfold N_mod_2557; aesop;
      have := this.2; simp_all +decide [ ← map_mul, ← map_pow ] ;
      simpa only [ ← h_artin ] using congr_arg ( Ideal.Quotient.mk P ) this

/-
The Dream Theorem for q = 2557. If c(N) = s1, then alpha^N = gamma. If c(N) = s2, then alpha^N = beta.
-/
theorem dream_theorem_2557 (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 2557) (hN_odd : N % 2 = 1) (hN_a : Nat.Coprime 101 N)
  (P : Ideal Ok_2557) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  let alpha_bar := Ideal.Quotient.mk P alpha_int_2557
  let beta_bar := Ideal.Quotient.mk P beta_int_2557
  let gamma_bar := Ideal.Quotient.mk P gamma_int_2557
  (c_2557 N = s1_2557 → alpha_bar ^ N = gamma_bar) ∧
  (c_2557 N = s2_2557 → alpha_bar ^ N = beta_bar) := by
    convert final_result_2557 N hN hN_odd hN_a P hP using 1

/-
The Dream Theorem for q = 2557. If c(N) = s1, then alpha^N = gamma. If c(N) = s2, then alpha^N = beta.
-/
theorem final_result_2557_proven (N : ℕ) [Fact (Nat.Prime N)] (hN : N ≠ 2557) (hN_odd : N % 2 = 1) (hN_a : Nat.Coprime 101 N)
  (P : Ideal Ok_2557) [P.IsMaximal] (hP : P.LiesOver (Ideal.span {(N : ℤ)})) :
  let alpha_bar := Ideal.Quotient.mk P alpha_int_2557
  let beta_bar := Ideal.Quotient.mk P beta_int_2557
  let gamma_bar := Ideal.Quotient.mk P gamma_int_2557
  (c_2557 N = s1_2557 → alpha_bar ^ N = gamma_bar) ∧
  (c_2557 N = s2_2557 → alpha_bar ^ N = beta_bar) := by
    -- Apply the Dream Theorem for q = 2557 with the given hypotheses.
    apply dream_theorem_2557 N hN hN_odd hN_a P hP

/-
Verification of the polynomial identities relating alpha, beta, and gamma for q=2557.
-/
lemma check_polynomial_identity_2557_corrected_proven :
  let alpha : Polynomial ℚ := Polynomial.X
  let beta : Polynomial ℚ := (3 * alpha^2 - 55 * alpha - 5114) * Polynomial.C (101 : ℚ)⁻¹
  let gamma : Polynomial ℚ := (-3 * alpha^2 - 46 * alpha + 5114) * Polynomial.C (101 : ℚ)⁻¹
  let modulus : Polynomial ℚ := alpha^3 - 2557 * alpha - 2557
  (beta^2 + alpha * beta + (alpha^2 - 2557)) % modulus = 0 ∧
  (gamma^2 + alpha * gamma + (alpha^2 - 2557)) % modulus = 0 ∧
  (beta + gamma + alpha) % modulus = 0 := by
    convert check_polynomial_identity_2557_corrected using 1